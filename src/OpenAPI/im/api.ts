const BASE_PATH = "https://api.chatdaddy.tech/im".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Instant Messaging Service
 * Complete instant messaging API for WhatsApp Multi-Device & Business API. 
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from '../base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof Account
     */
    'accountId': string;
    /**
     * The user ID of the user on ChatDaddy
     * @type {string}
     * @memberof Account
     */
    'ownerId': string;
    /**
     * Assignees who can access this account.
     * @type {Array<string>}
     * @memberof Account
     */
    'assignees'?: Array<string>;
    /**
     * User facing nickname of the account
     * @type {string}
     * @memberof Account
     */
    'nickname': string;
    /**
     * 
     * @type {AccountTier}
     * @memberof Account
     */
    'tier'?: AccountTier;
    /**
     * 
     * @type {AccountType}
     * @memberof Account
     */
    'type': AccountType;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    'createdAt': string;
    /**
     * The user ID of the user on ChatDaddy
     * @type {string}
     * @memberof Account
     */
    'createdBy'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    'updatedAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    'deletedAt'?: string | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    'lastLoginAt'?: string | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    'lastLogoutAt'?: string | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    'lastClosedAt'?: string | null;
    /**
     * 
     * @type {AccountState}
     * @memberof Account
     */
    'state': AccountState;
    /**
     * Last known connection error this account encountered. The presence of this field does not imply that the account is in an error state, only that this was the last error encountered. 
     * @type {AppError}
     * @memberof Account
     */
    'error'?: AppError | null;
    /**
     * Additional information about the current state of the account. This can be used to provide more context about the state of the account. Eg. has history sync completed, what type of  
     * @type {{ [key: string]: any; }}
     * @memberof Account
     */
    'stateInfo': { [key: string]: any; };
    /**
     * If true, you can call the \"accountsOpen\" endpoint and the account will be connected without any additional steps or user interaction. False means some additional steps are required to connect the account. 
     * @type {boolean}
     * @memberof Account
     */
    'canLogin': boolean;
    /**
     * The ID of the user who is currently logged in to this account. Eg. the phone number of the user who is currently logged in in a WhatsApp account. 
     * @type {string}
     * @memberof Account
     */
    'userId'?: string | null;
    /**
     * 
     * @type {Contact}
     * @memberof Account
     */
    'user'?: Contact;
    /**
     * 
     * @type {AccountSettings}
     * @memberof Account
     */
    'settings': AccountSettings;
    /**
     * 
     * @type {ArchiveState}
     * @memberof Account
     */
    'archiveState'?: ArchiveState;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AccountAssignType = {
    SmartAssign: 'smart-assign',
    RoundRobin: 'round-robin'
} as const;

export type AccountAssignType = typeof AccountAssignType[keyof typeof AccountAssignType];


/**
 * @type AccountCredentialsAlibaba
 * @export
 */
export type AccountCredentialsAlibaba = AccountCredentialsAlibabaOneOf | AccountCredentialsAlibabaV2 | AccountCredentialsWaba;

/**
 * 
 * @export
 * @interface AccountCredentialsAlibabaOneOf
 */
export interface AccountCredentialsAlibabaOneOf {
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsAlibabaOneOf
     */
    'type': AccountCredentialsAlibabaOneOfTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsAlibabaOneOf
     */
    'accessKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsAlibabaOneOf
     */
    'accessKeySecret': string;
    /**
     * Secret for WebHook
     * @type {string}
     * @memberof AccountCredentialsAlibabaOneOf
     */
    'secret': string;
}

export const AccountCredentialsAlibabaOneOfTypeEnum = {
    AlibabaCams: 'alibaba-cams'
} as const;

export type AccountCredentialsAlibabaOneOfTypeEnum = typeof AccountCredentialsAlibabaOneOfTypeEnum[keyof typeof AccountCredentialsAlibabaOneOfTypeEnum];

/**
 * 
 * @export
 * @interface AccountCredentialsAlibabaV2
 */
export interface AccountCredentialsAlibabaV2 {
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsAlibabaV2
     */
    'type': AccountCredentialsAlibabaV2TypeEnum;
    /**
     * The initial access token used to authenticate with Alibaba CAMS service
     * @type {string}
     * @memberof AccountCredentialsAlibabaV2
     */
    'initialAccessToken'?: string;
    /**
     * The WABA ID of the business account. This is the same as the business account\'s JID
     * @type {string}
     * @memberof AccountCredentialsAlibabaV2
     */
    'wabaId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsAlibabaV2
     */
    'templateNamespace'?: string;
    /**
     * The customer space ID of the business account. Used internally
     * @type {string}
     * @memberof AccountCredentialsAlibabaV2
     */
    'custSpaceId'?: string;
    /**
     * Secret for WebHook
     * @type {string}
     * @memberof AccountCredentialsAlibabaV2
     */
    'secret': string;
}

export const AccountCredentialsAlibabaV2TypeEnum = {
    AlibabaCamsV2: 'alibaba-cams-v2'
} as const;

export type AccountCredentialsAlibabaV2TypeEnum = typeof AccountCredentialsAlibabaV2TypeEnum[keyof typeof AccountCredentialsAlibabaV2TypeEnum];

/**
 * 
 * @export
 * @interface AccountCredentialsMail
 */
export interface AccountCredentialsMail {
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsMail
     */
    'type': AccountCredentialsMailTypeEnum;
    /**
     * Email address of the account
     * @type {string}
     * @memberof AccountCredentialsMail
     */
    'emailAddress': string;
    /**
     * Unique Id of the sender
     * @type {number}
     * @memberof AccountCredentialsMail
     */
    'senderId': number;
}

export const AccountCredentialsMailTypeEnum = {
    Mail: 'mail'
} as const;

export type AccountCredentialsMailTypeEnum = typeof AccountCredentialsMailTypeEnum[keyof typeof AccountCredentialsMailTypeEnum];

/**
 * 
 * @export
 * @interface AccountCredentialsMeta
 */
export interface AccountCredentialsMeta {
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsMeta
     */
    'type': AccountCredentialsMetaTypeEnum;
    /**
     * Page ID of the Facebook page
     * @type {string}
     * @memberof AccountCredentialsMeta
     */
    'pageId': string;
    /**
     * Page access token of the Facebook page
     * @type {string}
     * @memberof AccountCredentialsMeta
     */
    'pageAccessToken': string;
}

export const AccountCredentialsMetaTypeEnum = {
    Messenger: 'messenger'
} as const;

export type AccountCredentialsMetaTypeEnum = typeof AccountCredentialsMetaTypeEnum[keyof typeof AccountCredentialsMetaTypeEnum];

/**
 * 
 * @export
 * @interface AccountCredentialsSms
 */
export interface AccountCredentialsSms {
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsSms
     */
    'type': AccountCredentialsSmsTypeEnum;
    /**
     * Sender Id to be displayed
     * @type {string}
     * @memberof AccountCredentialsSms
     */
    'senderId': string;
}

export const AccountCredentialsSmsTypeEnum = {
    Sms: 'sms'
} as const;

export type AccountCredentialsSmsTypeEnum = typeof AccountCredentialsSmsTypeEnum[keyof typeof AccountCredentialsSmsTypeEnum];

/**
 * 
 * @export
 * @interface AccountCredentialsTikTok
 */
export interface AccountCredentialsTikTok {
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsTikTok
     */
    'type': AccountCredentialsTikTokTypeEnum;
    /**
     * Cookies for TikTok. This must be a serialised `tough-cookie` cookiejar
     * @type {{ [key: string]: any; }}
     * @memberof AccountCredentialsTikTok
     */
    'cookies': { [key: string]: any; };
}

export const AccountCredentialsTikTokTypeEnum = {
    Tiktok: 'tiktok'
} as const;

export type AccountCredentialsTikTokTypeEnum = typeof AccountCredentialsTikTokTypeEnum[keyof typeof AccountCredentialsTikTokTypeEnum];

/**
 * 
 * @export
 * @interface AccountCredentialsWaba
 */
export interface AccountCredentialsWaba {
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsWaba
     */
    'type': AccountCredentialsWabaTypeEnum;
    /**
     * The WABA ID of the business account.
     * @type {string}
     * @memberof AccountCredentialsWaba
     */
    'phoneNumberId': string;
    /**
     * ID of the business
     * @type {string}
     * @memberof AccountCredentialsWaba
     */
    'waBusinessId': string;
    /**
     * Version of the WABA build
     * @type {string}
     * @memberof AccountCredentialsWaba
     */
    'version'?: string;
}

export const AccountCredentialsWabaTypeEnum = {
    Waba: 'waba'
} as const;

export type AccountCredentialsWabaTypeEnum = typeof AccountCredentialsWabaTypeEnum[keyof typeof AccountCredentialsWabaTypeEnum];

/**
 * 
 * @export
 * @interface AccountSettings
 */
export interface AccountSettings {
    /**
     * Supply a list of user IDs to notify when a new message arrives
     * @type {Array<string>}
     * @memberof AccountSettings
     */
    'notifyUsers'?: Array<string>;
    /**
     * Should chat history be synced with the database
     * @type {boolean}
     * @memberof AccountSettings
     */
    'enableHistorySync'?: boolean;
    /**
     * Maximum number of messages that would be synced to the database
     * @type {number}
     * @memberof AccountSettings
     */
    'maxMessageSync'?: number;
    /**
     * Will doing a chat action (like archive, mark unread) actually sync it back with the primary device
     * @type {boolean}
     * @memberof AccountSettings
     */
    'nativeChatActionSync'?: boolean;
    /**
     * Should unarchived chats be archived again when a new message arrives
     * @type {boolean}
     * @memberof AccountSettings
     */
    'unArchiveOnNewMessage'?: boolean;
    /**
     * 
     * @type {AccountSettingsNewChatsAssignee}
     * @memberof AccountSettings
     * @deprecated
     */
    'newChatsAssignee'?: AccountSettingsNewChatsAssignee;
    /**
     * Should polls be sent as buttons instead of a message, to avoid unreliable button msg delivery for some recipients. This is for the regular WhatsApp API only.
     * @type {boolean}
     * @memberof AccountSettings
     */
    'sendButtonsAsPoll'?: boolean;
    /**
     * Should story receiving/sending be enabled for the account. Only applicable for regular WhatsApp accounts.
     * @type {boolean}
     * @memberof AccountSettings
     */
    'enableStories'?: boolean;
    /**
     * Should products be synced to WhatsApp automatically.
     * @type {boolean}
     * @memberof AccountSettings
     */
    'autoSyncProductsToPlatform'?: boolean;
    /**
     * 
     * @type {KeepDeletedMessagesSettings}
     * @memberof AccountSettings
     */
    'keepDeletedMessages'?: KeepDeletedMessagesSettings;
    /**
     * Provide a geo location from where all traffic will be routed. Only relevant for non-webhook account types. Leave undefined to use the default geo location.
     * @type {string}
     * @memberof AccountSettings
     */
    'geoLocation'?: string;
    /**
     * Should voice messages received be automatically transcribed to text
     * @type {boolean}
     * @memberof AccountSettings
     */
    'autoTranscribeVoiceMessages'?: boolean;
    /**
     * Should calls received be automatically transcribed to text?
     * @type {boolean}
     * @memberof AccountSettings
     */
    'autoTranscribeCalls'?: boolean;
    /**
     * 
     * @type {CommentsSilenceConfig}
     * @memberof AccountSettings
     */
    'commentsSilence'?: CommentsSilenceConfig;
}
/**
 * Allow assignment of new chats to a specific assignee. All new chats will be auto asssigned if one of the option is enabled and select any assignee. Deprecated: use a message flow to do this automation
 * @export
 * @interface AccountSettingsNewChatsAssignee
 */
export interface AccountSettingsNewChatsAssignee {
    /**
     * 
     * @type {ChatAssignment}
     * @memberof AccountSettingsNewChatsAssignee
     */
    'incoming'?: ChatAssignment;
    /**
     * 
     * @type {ChatAssignment}
     * @memberof AccountSettingsNewChatsAssignee
     */
    'outgoing'?: ChatAssignment;
}
/**
 * Describes the current state of an account. 1. open => logged in & connected to WhatsApp. Can send & receive messages now 2. connecting => establishing connection to WhatsApp. QR code is available during this state 3. close => connection to WhatsApp is closed, account is inactive at the moment
 * @export
 * @enum {string}
 */

export const AccountState = {
    Open: 'open',
    Connecting: 'connecting',
    Close: 'close'
} as const;

export type AccountState = typeof AccountState[keyof typeof AccountState];


/**
 * Describes the tier of the account, and which features it\'ll have
 * @export
 * @enum {string}
 */

export const AccountTier = {
    LimitedMsgNoChatHistory: 'limited_msg_no_chat_history',
    UnlimitedMsgChatHistory: 'unlimited_msg_chat_history'
} as const;

export type AccountTier = typeof AccountTier[keyof typeof AccountTier];


/**
 * 
 * @export
 * @enum {string}
 */

export const AccountType = {
    Wa: 'wa',
    WaBusinessApi: 'wa-business-api',
    Mock: 'mock',
    Tiktok: 'tiktok',
    Messenger: 'messenger',
    Mail: 'mail',
    Sms: 'sms',
    Instagram: 'instagram'
} as const;

export type AccountType = typeof AccountType[keyof typeof AccountType];


/**
 * @type AccountWaChangeLoginMode
 * @export
 */
export type AccountWaChangeLoginMode = AccountWaChangeLoginModeOneOf | AccountWaChangeLoginModeOneOf1;

/**
 * 
 * @export
 * @interface AccountWaChangeLoginModeOneOf
 */
export interface AccountWaChangeLoginModeOneOf {
    /**
     * 
     * @type {string}
     * @memberof AccountWaChangeLoginModeOneOf
     */
    'type': AccountWaChangeLoginModeOneOfTypeEnum;
}

export const AccountWaChangeLoginModeOneOfTypeEnum = {
    Qr: 'qr'
} as const;

export type AccountWaChangeLoginModeOneOfTypeEnum = typeof AccountWaChangeLoginModeOneOfTypeEnum[keyof typeof AccountWaChangeLoginModeOneOfTypeEnum];

/**
 * 
 * @export
 * @interface AccountWaChangeLoginModeOneOf1
 */
export interface AccountWaChangeLoginModeOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof AccountWaChangeLoginModeOneOf1
     */
    'type': AccountWaChangeLoginModeOneOf1TypeEnum;
    /**
     * Phone number to generate PIN for
     * @type {string}
     * @memberof AccountWaChangeLoginModeOneOf1
     */
    'phoneNumber': string;
}

export const AccountWaChangeLoginModeOneOf1TypeEnum = {
    PhoneNumber: 'phoneNumber'
} as const;

export type AccountWaChangeLoginModeOneOf1TypeEnum = typeof AccountWaChangeLoginModeOneOf1TypeEnum[keyof typeof AccountWaChangeLoginModeOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface AccountsDelete200Response
 */
export interface AccountsDelete200Response {
    /**
     * 
     * @type {boolean}
     * @memberof AccountsDelete200Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface AccountsGet200Response
 */
export interface AccountsGet200Response {
    /**
     * 
     * @type {Array<Account>}
     * @memberof AccountsGet200Response
     */
    'accounts': Array<Account>;
    /**
     * 
     * @type {number}
     * @memberof AccountsGet200Response
     */
    'total'?: number;
}
/**
 * Update an account. Specifying account updates the type
 * @export
 * @interface AccountsPatchRequest
 */
export interface AccountsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountsPatchRequest
     */
    'nickname'?: string;
    /**
     * 
     * @type {AccountTier}
     * @memberof AccountsPatchRequest
     */
    'tier'?: AccountTier;
    /**
     * 
     * @type {AccountSettings}
     * @memberof AccountsPatchRequest
     */
    'settings'?: AccountSettings;
    /**
     * 
     * @type {AccountsPatchRequestCredentials}
     * @memberof AccountsPatchRequest
     */
    'credentials'?: AccountsPatchRequestCredentials;
    /**
     * Assignees who can access this account.
     * @type {Array<string>}
     * @memberof AccountsPatchRequest
     */
    'assignees'?: Array<string>;
}


/**
 * @type AccountsPatchRequestCredentials
 * @export
 */
export type AccountsPatchRequestCredentials = AccountCredentialsAlibaba | AccountCredentialsAlibabaV2 | AccountCredentialsMail | AccountCredentialsMeta | AccountCredentialsSms | AccountCredentialsTikTok;

/**
 * 
 * @export
 * @interface AccountsPostRequest
 */
export interface AccountsPostRequest {
    /**
     * 
     * @type {AccountType}
     * @memberof AccountsPostRequest
     */
    'type': AccountType;
    /**
     * 
     * @type {AccountTier}
     * @memberof AccountsPostRequest
     */
    'tier'?: AccountTier;
    /**
     * 
     * @type {string}
     * @memberof AccountsPostRequest
     */
    'nickname'?: string;
    /**
     * 
     * @type {AccountSettings}
     * @memberof AccountsPostRequest
     */
    'settings'?: AccountSettings;
}


/**
 * 
 * @export
 * @enum {string}
 */

const ActorAutomationType = {
    KeywordReply: 'keyword-reply',
    DefaultReply: 'default-reply',
    Campaigns: 'campaigns',
    Notifications: 'notifications',
    Bot: 'bot',
    AiChatbot: 'ai-chatbot',
    Trigger: 'trigger'
} as const;

type ActorAutomationType = typeof ActorAutomationType[keyof typeof ActorAutomationType];


/**
 * Context about the actor of a particular action
 * @export
 * @interface ActorMetadata
 */
interface ActorMetadata {
    /**
     * 
     * @type {ActorAutomationType}
     * @memberof ActorMetadata
     */
    'type': ActorAutomationType;
    /**
     * ID of the object that sent the message. For example, the campaign ID or keyword reply ID. Separate sub-objects with a `/`. For example, to specify the action of a bot -- use `bot_id/action_id`
     * @type {string}
     * @memberof ActorMetadata
     */
    'objectId': string;
    /**
     * Name of the object that sent the message. For example, the campaign name or keyword reply name
     * @type {string}
     * @memberof ActorMetadata
     */
    'objectName'?: string;
}


/**
 * 
 * @export
 * @interface AggregateDataPost200Response
 */
export interface AggregateDataPost200Response {
    /**
     * Aggregated data for the phone number
     * @type {{ [key: string]: any; }}
     * @memberof AggregateDataPost200Response
     */
    'data': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface AlibabCAMSQuotedContext
 */
export interface AlibabCAMSQuotedContext {
    /**
     * The user ID of the person that sent it
     * @type {string}
     * @memberof AlibabCAMSQuotedContext
     */
    'from': string;
    /**
     * The ID of the message that was replied to
     * @type {string}
     * @memberof AlibabCAMSQuotedContext
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface AlibabaCAMSForwardedContext
 */
export interface AlibabaCAMSForwardedContext {
    /**
     * 
     * @type {boolean}
     * @memberof AlibabaCAMSForwardedContext
     */
    'forwarded': boolean;
}
/**
 * 
 * @export
 * @interface AlibabaCAMSISVTerms
 */
export interface AlibabaCAMSISVTerms {
    /**
     * Name of the company
     * @type {string}
     * @memberof AlibabaCAMSISVTerms
     */
    'name': string;
    /**
     * Office address of the company
     * @type {string}
     * @memberof AlibabaCAMSISVTerms
     */
    'officeAddress': string;
    /**
     * Email address of the company
     * @type {string}
     * @memberof AlibabaCAMSISVTerms
     */
    'emailAddress': string;
    /**
     * ISO Country code of the company
     * @type {string}
     * @memberof AlibabaCAMSISVTerms
     */
    'countryCode': string;
    /**
     * Description of the company
     * @type {string}
     * @memberof AlibabaCAMSISVTerms
     */
    'description': string;
    /**
     * URL for uploaded pdf of ISV terms
     * @type {string}
     * @memberof AlibabaCAMSISVTerms
     */
    'isvTerms': string;
}
/**
 * 
 * @export
 * @interface AlibabaCAMSStateInfo
 */
export interface AlibabaCAMSStateInfo {
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSStateInfo
     */
    'version'?: AlibabaCAMSStateInfoVersionEnum;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSStateInfo
     */
    'status'?: AlibabaCAMSStateInfoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSStateInfo
     */
    'qualityRating'?: AlibabaCAMSStateInfoQualityRatingEnum;
    /**
     * Status of the company name approval from WABA
     * @type {string}
     * @memberof AlibabaCAMSStateInfo
     */
    'nameStatus'?: string;
    /**
     * Whether the business account is blocked from using Alibaba CAMS by WhatsApp
     * @type {boolean}
     * @memberof AlibabaCAMSStateInfo
     */
    'isBlocked'?: boolean;
    /**
     * 
     * @type {AlibabaCAMSISVTerms}
     * @memberof AlibabaCAMSStateInfo
     */
    'isvTerms'?: AlibabaCAMSISVTerms;
    /**
     * Description of the business account visible to others on WA
     * @type {string}
     * @memberof AlibabaCAMSStateInfo
     */
    'profileDescription'?: string;
    /**
     * Whether the business account has enabled the welcome message feature
     * @type {boolean}
     * @memberof AlibabaCAMSStateInfo
     */
    'enabledWelcomeMessage'?: boolean;
}

export const AlibabaCAMSStateInfoVersionEnum = {
    Waba: 'waba',
    AlibabaCamsV2: 'alibaba-cams-v2'
} as const;

export type AlibabaCAMSStateInfoVersionEnum = typeof AlibabaCAMSStateInfoVersionEnum[keyof typeof AlibabaCAMSStateInfoVersionEnum];
export const AlibabaCAMSStateInfoStatusEnum = {
    PendingApproval: 'pending-approval',
    Approved: 'approved',
    Rejected: 'rejected'
} as const;

export type AlibabaCAMSStateInfoStatusEnum = typeof AlibabaCAMSStateInfoStatusEnum[keyof typeof AlibabaCAMSStateInfoStatusEnum];
export const AlibabaCAMSStateInfoQualityRatingEnum = {
    Red: 'RED',
    Yellow: 'YELLOW',
    Green: 'GREEN',
    Na: 'NA',
    Unknown: 'UNKNOWN'
} as const;

export type AlibabaCAMSStateInfoQualityRatingEnum = typeof AlibabaCAMSStateInfoQualityRatingEnum[keyof typeof AlibabaCAMSStateInfoQualityRatingEnum];

/**
 * @type AlibabaCAMSWebhookItem
 * @export
 */
export type AlibabaCAMSWebhookItem = AlibabaCAMSWebhookMessageItem | AlibabaCAMSWebhookTemplateItem;

/**
 * 
 * @export
 * @interface AlibabaCAMSWebhookMessageItem
 */
export interface AlibabaCAMSWebhookMessageItem {
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'Type': AlibabaCAMSWebhookMessageItemTypeEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'referral'?: { [key: string]: any; };
    /**
     * Reason for rejection of template
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'Reason'?: string;
    /**
     * Status of the template
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'AuditStatus'?: AlibabaCAMSWebhookMessageItemAuditStatusEnum;
    /**
     * Code of the template
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'TemplateCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'Status'?: AlibabaCAMSWebhookMessageItemStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'ConversationId'?: string;
    /**
     * Raw text if type=TEXT, otherwise JSON stringified content
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'Message'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'From': string;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'To': string;
    /**
     * Unix timestamp in MS
     * @type {number}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'Timestamp': number;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'MessageId': string;
    /**
     * 
     * @type {AlibabaCAMSWebhookMessageItemContext}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'Context'?: AlibabaCAMSWebhookMessageItemContext;
    /**
     * Name of the user that sent the message
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'ConversationType'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'ErrorDescription'?: string;
    /**
     * 
     * @type {AlibabaCAMSWebhookMessageItemErrorCode}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'ErrorCode'?: AlibabaCAMSWebhookMessageItemErrorCode;
    /**
     * Unix timestamp in MS
     * @type {number}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'ConversionExpirationTime'?: number;
}

export const AlibabaCAMSWebhookMessageItemTypeEnum = {
    Text: 'TEXT',
    Template: 'TEMPLATE',
    Image: 'IMAGE',
    Video: 'VIDEO',
    Audio: 'AUDIO',
    Document: 'DOCUMENT',
    Unknown: 'UNKNOWN',
    Location: 'LOCATION',
    Interactive: 'INTERACTIVE',
    Reply: 'REPLY',
    Reaction: 'REACTION',
    Contacts: 'CONTACTS'
} as const;

export type AlibabaCAMSWebhookMessageItemTypeEnum = typeof AlibabaCAMSWebhookMessageItemTypeEnum[keyof typeof AlibabaCAMSWebhookMessageItemTypeEnum];
export const AlibabaCAMSWebhookMessageItemAuditStatusEnum = {
    Fail: 'fail',
    Pass: 'pass'
} as const;

export type AlibabaCAMSWebhookMessageItemAuditStatusEnum = typeof AlibabaCAMSWebhookMessageItemAuditStatusEnum[keyof typeof AlibabaCAMSWebhookMessageItemAuditStatusEnum];
export const AlibabaCAMSWebhookMessageItemStatusEnum = {
    Sent: 'Sent',
    Delivered: 'Delivered',
    Read: 'Read',
    Failed: 'Failed'
} as const;

export type AlibabaCAMSWebhookMessageItemStatusEnum = typeof AlibabaCAMSWebhookMessageItemStatusEnum[keyof typeof AlibabaCAMSWebhookMessageItemStatusEnum];

/**
 * @type AlibabaCAMSWebhookMessageItemContext
 * @export
 */
export type AlibabaCAMSWebhookMessageItemContext = AlibabCAMSQuotedContext | AlibabaCAMSForwardedContext;

/**
 * @type AlibabaCAMSWebhookMessageItemErrorCode
 * @export
 */
export type AlibabaCAMSWebhookMessageItemErrorCode = number | string;

/**
 * 
 * @export
 * @interface AlibabaCAMSWebhookTemplateItem
 */
export interface AlibabaCAMSWebhookTemplateItem {
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookTemplateItem
     */
    'Type': AlibabaCAMSWebhookTemplateItemTypeEnum;
    /**
     * Code of the template
     * @type {string}
     * @memberof AlibabaCAMSWebhookTemplateItem
     */
    'TemplateCode': string;
    /**
     * Status of the template
     * @type {string}
     * @memberof AlibabaCAMSWebhookTemplateItem
     */
    'AuditStatus': AlibabaCAMSWebhookTemplateItemAuditStatusEnum;
    /**
     * Language of the template
     * @type {string}
     * @memberof AlibabaCAMSWebhookTemplateItem
     */
    'Language': string;
    /**
     * Waba ID of the template
     * @type {string}
     * @memberof AlibabaCAMSWebhookTemplateItem
     */
    'WabaId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookTemplateItem
     */
    'Reason'?: string;
}

export const AlibabaCAMSWebhookTemplateItemTypeEnum = {
    Template: 'template'
} as const;

export type AlibabaCAMSWebhookTemplateItemTypeEnum = typeof AlibabaCAMSWebhookTemplateItemTypeEnum[keyof typeof AlibabaCAMSWebhookTemplateItemTypeEnum];
export const AlibabaCAMSWebhookTemplateItemAuditStatusEnum = {
    Fail: 'fail',
    Pass: 'pass'
} as const;

export type AlibabaCAMSWebhookTemplateItemAuditStatusEnum = typeof AlibabaCAMSWebhookTemplateItemAuditStatusEnum[keyof typeof AlibabaCAMSWebhookTemplateItemAuditStatusEnum];

/**
 * 
 * @export
 * @interface AlibabaCamsMetadata200Response
 */
export interface AlibabaCamsMetadata200Response {
    /**
     * Meta app ID for embedded sign up
     * @type {string}
     * @memberof AlibabaCamsMetadata200Response
     */
    'appId': string;
    /**
     * Meta terms pdf template for embedded sign up
     * @type {string}
     * @memberof AlibabaCamsMetadata200Response
     */
    'isvTermsTemplate': string;
}
/**
 * 
 * @export
 * @interface AlibabaCamsProfileUpdateRequest
 */
export interface AlibabaCamsProfileUpdateRequest {
    /**
     * Business profile picture URL
     * @type {string}
     * @memberof AlibabaCamsProfileUpdateRequest
     */
    'profilePictureUrl'?: string;
    /**
     * Business description
     * @type {string}
     * @memberof AlibabaCamsProfileUpdateRequest
     */
    'description'?: string;
    /**
     * Enable welcome message
     * @type {boolean}
     * @memberof AlibabaCamsProfileUpdateRequest
     */
    'enabledWelcomeMessage'?: boolean;
}
/**
 * 
 * @export
 * @interface AlibabaCamsRegister200Response
 */
export interface AlibabaCamsRegister200Response {
    /**
     * User ID for the account
     * @type {string}
     * @memberof AlibabaCamsRegister200Response
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface AlibabaCamsRegisterRequest
 */
export interface AlibabaCamsRegisterRequest {
    /**
     * Version of the integration
     * @type {string}
     * @memberof AlibabaCamsRegisterRequest
     */
    'version'?: AlibabaCamsRegisterRequestVersionEnum;
    /**
     * Id of the latest whatsapp business account
     * @type {string}
     * @memberof AlibabaCamsRegisterRequest
     */
    'wabaId': string;
    /**
     * Phone number to connect to the account. No formatting, just digits with country code. If not provided, the first phone number will be used.
     * @type {string}
     * @memberof AlibabaCamsRegisterRequest
     */
    'selectedPhoneNumber': string;
    /**
     * Id of the phone number to connect to the account
     * @type {string}
     * @memberof AlibabaCamsRegisterRequest
     */
    'phoneNumberId'?: string;
    /**
     * Token from embedded sign up
     * @type {string}
     * @memberof AlibabaCamsRegisterRequest
     * @deprecated
     */
    'token'?: string;
}

export const AlibabaCamsRegisterRequestVersionEnum = {
    Waba: 'waba',
    AlibabaCamsV2: 'alibaba-cams-v2'
} as const;

export type AlibabaCamsRegisterRequestVersionEnum = typeof AlibabaCamsRegisterRequestVersionEnum[keyof typeof AlibabaCamsRegisterRequestVersionEnum];

/**
 * 
 * @export
 * @interface AlibabaCamsSync200Response
 */
export interface AlibabaCamsSync200Response {
    /**
     * 
     * @type {Account}
     * @memberof AlibabaCamsSync200Response
     */
    'account': Account;
}
/**
 * Override with new cust space ID & phone number
 * @export
 * @interface AlibabaCamsSyncRequest
 */
export interface AlibabaCamsSyncRequest {
    /**
     * WABA customer space ID
     * @type {string}
     * @memberof AlibabaCamsSyncRequest
     */
    'custSpaceId'?: string;
    /**
     * Phone number to connect to the account. No formatting, just digits with country code.
     * @type {string}
     * @memberof AlibabaCamsSyncRequest
     */
    'phoneNumber'?: string;
}
/**
 * @type AnyContactID
 * @export
 */
export type AnyContactID = UniqueContactID | string;

/**
 * 
 * @export
 * @interface AppError
 */
interface AppError {
    /**
     * 
     * @type {number}
     * @memberof AppError
     */
    'statusCode': number;
    /**
     * What the error was
     * @type {string}
     * @memberof AppError
     */
    'message': string;
    /**
     * 
     * @type {AppErrorData}
     * @memberof AppError
     */
    'data'?: AppErrorData;
}
/**
 * Some extra information about the error
 * @export
 * @interface AppErrorData
 */
interface AppErrorData {
    [key: string]: any;

    /**
     * 
     * @type {AppErrorDataHelpLink}
     * @memberof AppErrorData
     */
    'helpLink'?: AppErrorDataHelpLink;
}
/**
 * @type AppErrorDataHelpLink
 * @export
 */
type AppErrorDataHelpLink = AppErrorDataHelpLinkOneOf | AppErrorDataHelpLinkOneOf1;

/**
 * 
 * @export
 * @interface AppErrorDataHelpLinkOneOf
 */
interface AppErrorDataHelpLinkOneOf {
    /**
     * 
     * @type {string}
     * @memberof AppErrorDataHelpLinkOneOf
     */
    'docId': string;
}
/**
 * 
 * @export
 * @interface AppErrorDataHelpLinkOneOf1
 */
interface AppErrorDataHelpLinkOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof AppErrorDataHelpLinkOneOf1
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ArchiveState
 */
export interface ArchiveState {
    /**
     * 
     * @type {string}
     * @memberof ArchiveState
     */
    'type': ArchiveStateTypeEnum;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ArchiveState
     */
    'doneAt': string;
    /**
     * 
     * @type {AppError}
     * @memberof ArchiveState
     */
    'error'?: AppError;
}

export const ArchiveStateTypeEnum = {
    Archiving: 'archiving',
    Error: 'error',
    Done: 'done'
} as const;

export type ArchiveStateTypeEnum = typeof ArchiveStateTypeEnum[keyof typeof ArchiveStateTypeEnum];

/**
 * 
 * @export
 * @interface AssigneeFilter
 */
export interface AssigneeFilter {
    /**
     * ID of the assignee
     * @type {string}
     * @memberof AssigneeFilter
     */
    'id': string;
    /**
     * 
     * @type {MetadataQuery}
     * @memberof AssigneeFilter
     */
    'assigned'?: MetadataQuery;
}
/**
 * @type BulkMessageAction
 * @export
 */
export type BulkMessageAction = BulkMessageActionOneOf | BulkMessageActionOneOf1;

/**
 * 
 * @export
 * @interface BulkMessageActionOneOf
 */
export interface BulkMessageActionOneOf {
    /**
     * 
     * @type {string}
     * @memberof BulkMessageActionOneOf
     */
    'type': BulkMessageActionOneOfTypeEnum;
}

export const BulkMessageActionOneOfTypeEnum = {
    Delete: 'delete'
} as const;

export type BulkMessageActionOneOfTypeEnum = typeof BulkMessageActionOneOfTypeEnum[keyof typeof BulkMessageActionOneOfTypeEnum];

/**
 * 
 * @export
 * @interface BulkMessageActionOneOf1
 */
export interface BulkMessageActionOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof BulkMessageActionOneOf1
     */
    'type': BulkMessageActionOneOf1TypeEnum;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BulkMessageActionOneOf1
     */
    'timestamp'?: string;
    /**
     * If multiple messages are being retried, add an interval between each message, starting from the timestamp
     * @type {number}
     * @memberof BulkMessageActionOneOf1
     */
    'intervalS'?: number;
}

export const BulkMessageActionOneOf1TypeEnum = {
    Retry: 'retry'
} as const;

export type BulkMessageActionOneOf1TypeEnum = typeof BulkMessageActionOneOf1TypeEnum[keyof typeof BulkMessageActionOneOf1TypeEnum];

/**
 * Comparison data for channel counts between two dates
 * @export
 * @interface ChannelCountComparison
 */
export interface ChannelCountComparison {
    /**
     * Current live channel count
     * @type {number}
     * @memberof ChannelCountComparison
     */
    'currentCount'?: number;
    /**
     * Channel count from the comparison date
     * @type {number}
     * @memberof ChannelCountComparison
     */
    'compareCount'?: number;
    /**
     * Absolute difference (current - compare)
     * @type {number}
     * @memberof ChannelCountComparison
     */
    'difference'?: number;
    /**
     * Percentage change from compare date to current
     * @type {number}
     * @memberof ChannelCountComparison
     */
    'percentageChange'?: number;
}
/**
 * 
 * @export
 * @interface Chat
 */
export interface Chat {
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof Chat
     */
    'accountId': string;
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof Chat
     */
    'id': string;
    /**
     * Alternate ID (LID) for the chat when phone number is hidden
     * @type {string}
     * @memberof Chat
     */
    'altId'?: string | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Chat
     */
    'lastMessage': string;
    /**
     * Number of unread messages
     * @type {number}
     * @memberof Chat
     */
    'unread': number;
    /**
     * 
     * @type {boolean}
     * @memberof Chat
     */
    'spam'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Chat
     */
    'archive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Chat
     */
    'readOnly': boolean;
    /**
     * Timestamp of when the chat was muted
     * @type {number}
     * @memberof Chat
     */
    'mute'?: number | null;
    /**
     * Timestamp of when the chat was pinned
     * @type {number}
     * @memberof Chat
     */
    'pin'?: number | null;
    /**
     * did the user create this contact
     * @type {boolean}
     * @memberof Chat
     */
    'isUserGenerated': boolean;
    /**
     * does this chat have any pending messages
     * @type {boolean}
     * @memberof Chat
     */
    'hasPendingMessage'?: boolean;
    /**
     * does this chat have any unsolved notes
     * @type {boolean}
     * @memberof Chat
     */
    'hasUnsolvedNote'?: boolean;
    /**
     * does this chat have any failed messages
     * @type {boolean}
     * @memberof Chat
     */
    'hasFailedMessage'?: boolean;
    /**
     * the user IDs mentioned in the chat
     * @type {Array<string>}
     * @memberof Chat
     */
    'mentions'?: Array<string>;
    /**
     * if disappearing messages is on, and for how long
     * @type {number}
     * @memberof Chat
     */
    'disappearingMessages'?: number | null;
    /**
     * If the chat has all the message history from the primary source
     * @type {boolean}
     * @memberof Chat
     */
    'hasEntireMessageHistory': boolean;
    /**
     * 
     * @type {Contact}
     * @memberof Chat
     */
    'contact': Contact;
    /**
     * 
     * @type {Array<Message>}
     * @memberof Chat
     */
    'messages'?: Array<Message>;
    /**
     * 
     * @type {Array<ChatPresence>}
     * @memberof Chat
     */
    'presences'?: Array<ChatPresence>;
    /**
     * Globally unique cursor to sort chats by. It\'s a simple concatenation of: - pinned status (0 or 1) - archived status (0 or 1) - last message timestamp (in hex) - partial chat ID - last 4 chars of the account ID 
     * @type {string}
     * @memberof Chat
     */
    'cursor': string;
}
/**
 * 
 * @export
 * @interface ChatAction
 */
export interface ChatAction {
    /**
     * 
     * @type {string}
     * @memberof ChatAction
     */
    'action': ChatActionActionEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ChatAction
     */
    'value': boolean;
}

export const ChatActionActionEnum = {
    Archive: 'archive',
    Pin: 'pin',
    Mute: 'mute',
    Read: 'read',
    Delete: 'delete'
} as const;

export type ChatActionActionEnum = typeof ChatActionActionEnum[keyof typeof ChatActionActionEnum];

/**
 * 
 * @export
 * @interface ChatAssignment
 */
export interface ChatAssignment {
    /**
     * This flag will define if option should enabled/disabled
     * @type {boolean}
     * @memberof ChatAssignment
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {AccountAssignType}
     * @memberof ChatAssignment
     */
    'assignType'?: AccountAssignType;
    /**
     * If round-robin assign is enabled, which member will be assigned next
     * @type {string}
     * @memberof ChatAssignment
     */
    'nextAssignee'?: string;
    /**
     * Auto assigned will work for the selected teammates
     * @type {Array<string>}
     * @memberof ChatAssignment
     */
    'assignees'?: Array<string>;
}


/**
 * 
 * @export
 * @interface ChatPresence
 */
export interface ChatPresence {
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof ChatPresence
     */
    'accountId': string;
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof ChatPresence
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ChatPresence
     */
    'contactId': string;
    /**
     * if a known team member has this presence
     * @type {string}
     * @memberof ChatPresence
     */
    'userId'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ChatPresence
     */
    'updatedAt': string;
    /**
     * 
     * @type {PresenceType}
     * @memberof ChatPresence
     */
    'type': PresenceType;
}


/**
 * 
 * @export
 * @interface ChatsGet200Response
 */
export interface ChatsGet200Response {
    /**
     * next page cursor, if it exists
     * @type {string}
     * @memberof ChatsGet200Response
     */
    'nextPage'?: string;
    /**
     * number of total unread chats given the filter
     * @type {number}
     * @memberof ChatsGet200Response
     */
    'unreadChatCount'?: number;
    /**
     * total number of chats given the filter
     * @type {number}
     * @memberof ChatsGet200Response
     */
    'totalDataCount'?: number;
    /**
     * the API counts at most N unread chats, if there are more unread chats that were not fetched, this flag is true
     * @type {boolean}
     * @memberof ChatsGet200Response
     */
    'hasMoreUnread'?: boolean;
    /**
     * 
     * @type {Array<Chat>}
     * @memberof ChatsGet200Response
     */
    'chats': Array<Chat>;
}
/**
 * @type ChatsGetAssigneeParameter
 * @export
 */
export type ChatsGetAssigneeParameter = Array<ChatsGetAssigneeParameterOneOf> | ChatsGetAssigneeParameterOneOf;

/**
 * @type ChatsGetAssigneeParameterOneOf
 * @export
 */
export type ChatsGetAssigneeParameterOneOf = AssigneeFilter | string;

/**
 * @type ChatsGetContactsParameter
 * @export
 */
export type ChatsGetContactsParameter = AnyContactID | Array<AnyContactID>;

/**
 * @type ChatsGetTagsParameter
 * @export
 */
export type ChatsGetTagsParameter = Array<ChatsGetTagsParameterOneOf> | ChatsGetTagsParameterOneOf;

/**
 * @type ChatsGetTagsParameterOneOf
 * @export
 */
export type ChatsGetTagsParameterOneOf = TagFilter | string;

/**
 * 
 * @export
 * @interface ChatsGetTicketParameter
 */
export interface ChatsGetTicketParameter {
    /**
     * ID of a CRM board
     * @type {string}
     * @memberof ChatsGetTicketParameter
     */
    'boardId': string;
    /**
     * ID of a stage
     * @type {string}
     * @memberof ChatsGetTicketParameter
     */
    'stageId'?: string;
}
/**
 * 
 * @export
 * @interface CommentsSilenceConfig
 */
export interface CommentsSilenceConfig {
    /**
     * Settings for which comments should be silenced. When silenced, the comment will not the chat\'s lastMessage or unread count.
     * @type {string}
     * @memberof CommentsSilenceConfig
     */
    'category'?: CommentsSilenceConfigCategoryEnum;
}

export const CommentsSilenceConfigCategoryEnum = {
    OngoingLive: 'ongoing-live',
    AllLive: 'all-live',
    All: 'all'
} as const;

export type CommentsSilenceConfigCategoryEnum = typeof CommentsSilenceConfigCategoryEnum[keyof typeof CommentsSilenceConfigCategoryEnum];

/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof Contact
     */
    'id': string;
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof Contact
     */
    'accountId': string;
    /**
     * Alternate ID (LID) for the contact when phone number is hidden
     * @type {string}
     * @memberof Contact
     */
    'altId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'cursor': string;
    /**
     * 
     * @type {ContactType}
     * @memberof Contact
     */
    'type': ContactType;
    /**
     * name of the contact as set on ChatDaddy
     * @type {string}
     * @memberof Contact
     */
    'name': string | null;
    /**
     * name of the contact, as set on the platform
     * @type {Array<string>}
     * @memberof Contact
     */
    'platformNames': Array<string>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Contact
     */
    'createdAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Contact
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'phoneNumber': string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'email'?: string | null;
    /**
     * 
     * @type {ContactImg}
     * @memberof Contact
     */
    'img'?: ContactImg | null;
    /**
     * Tags associated with this contact
     * @type {Array<ContactTag>}
     * @memberof Contact
     */
    'tags': Array<ContactTag>;
    /**
     * CRM Board Tickets associated with this contact
     * @type {Array<ContactTicket>}
     * @memberof Contact
     */
    'tickets'?: Array<ContactTicket>;
    /**
     * The assignee of the contact
     * @type {string}
     * @memberof Contact
     */
    'assignee'?: string | null;
    /**
     * The person who assigned this contact
     * @type {string}
     * @memberof Contact
     */
    'assigner'?: string | null;
    /**
     * Timestamp of when the contact was last assigned
     * @type {string}
     * @memberof Contact
     */
    'assignedAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Contact
     */
    'firstAssignedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    'messagesSent': number;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    'messagesReceived': number;
    /**
     * 
     * @type {ContactChat}
     * @memberof Contact
     */
    'chat'?: ContactChat;
}


/**
 * 
 * @export
 * @interface ContactChat
 */
export interface ContactChat {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ContactChat
     */
    'lastMessage': string;
    /**
     * 
     * @type {number}
     * @memberof ContactChat
     */
    'unread'?: number;
}
/**
 * @type ContactCrmTicketPatch
 * @export
 */
export type ContactCrmTicketPatch = ContactCrmTicketPatchOneOf | ContactCrmTicketPatchOneOf1;

/**
 * 
 * @export
 * @interface ContactCrmTicketPatchOneOf
 */
export interface ContactCrmTicketPatchOneOf {
    /**
     * ID of a CRM board
     * @type {string}
     * @memberof ContactCrmTicketPatchOneOf
     */
    'boardId': string;
    /**
     * remove this contact from the CRM board
     * @type {boolean}
     * @memberof ContactCrmTicketPatchOneOf
     */
    'remove': boolean;
}
/**
 * 
 * @export
 * @interface ContactCrmTicketPatchOneOf1
 */
export interface ContactCrmTicketPatchOneOf1 {
    /**
     * ID of a CRM board
     * @type {string}
     * @memberof ContactCrmTicketPatchOneOf1
     */
    'boardId': string;
    /**
     * ID of a stage
     * @type {string}
     * @memberof ContactCrmTicketPatchOneOf1
     */
    'stageId': string;
    /**
     * Order of a ticket
     * @type {number}
     * @memberof ContactCrmTicketPatchOneOf1
     */
    'order'?: number;
}
/**
 * 
 * @export
 * @interface ContactImg
 */
export interface ContactImg {
    /**
     * 
     * @type {string}
     * @memberof ContactImg
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactImg
     */
    'fullUrl'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ContactImg
     */
    'fetchedAt'?: string;
    /**
     * Timestamp of when the full image was fetched
     * @type {string}
     * @memberof ContactImg
     */
    'fullFetchedAt'?: string;
}
/**
 * 
 * @export
 * @interface ContactTag
 */
export interface ContactTag {
    /**
     * 
     * @type {string}
     * @memberof ContactTag
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTag
     */
    'value'?: string | null;
    /**
     * used in events to denote that the tag has been removed
     * @type {boolean}
     * @memberof ContactTag
     */
    'remove'?: boolean;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof ContactTag
     */
    'addedMetadata': UpsertMetadata;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof ContactTag
     */
    'updatedMetadata'?: UpsertMetadata;
}
/**
 * 
 * @export
 * @interface ContactTagInsert
 */
export interface ContactTagInsert {
    /**
     * 
     * @type {string}
     * @memberof ContactTagInsert
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTagInsert
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface ContactTagUpdate
 */
export interface ContactTagUpdate {
    /**
     * 
     * @type {string}
     * @memberof ContactTagUpdate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTagUpdate
     */
    'value'?: string | null;
    /**
     * used in events to denote that the tag has been removed
     * @type {boolean}
     * @memberof ContactTagUpdate
     */
    'remove'?: boolean;
}
/**
 * Metadata about a ticket in the contact
 * @export
 * @interface ContactTicket
 */
export interface ContactTicket {
    /**
     * ID of a CRM board
     * @type {string}
     * @memberof ContactTicket
     */
    'boardId': string;
    /**
     * ID of a stage
     * @type {string}
     * @memberof ContactTicket
     */
    'stageId': string;
    /**
     * ID of a ticket
     * @type {string}
     * @memberof ContactTicket
     */
    'id': string;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof ContactTicket
     */
    'createMetadata'?: UpsertMetadata;
    /**
     * 
     * @type {ContactTicketTimer}
     * @memberof ContactTicket
     */
    'timer'?: ContactTicketTimer;
}
/**
 * 
 * @export
 * @interface ContactTicketTimer
 */
export interface ContactTicketTimer {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ContactTicketTimer
     */
    'endsAt': string;
    /**
     * 
     * @type {TicketTimerStatus}
     * @memberof ContactTicketTimer
     */
    'status': TicketTimerStatus;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ContactType = {
    Individual: 'individual',
    Group: 'group',
    Channel: 'channel',
    Broadcast: 'broadcast',
    Post: 'post'
} as const;

export type ContactType = typeof ContactType[keyof typeof ContactType];


/**
 * 
 * @export
 * @interface ContactsCheckExists200Response
 */
export interface ContactsCheckExists200Response {
    /**
     * Whether the user exists
     * @type {boolean}
     * @memberof ContactsCheckExists200Response
     */
    'exists': boolean;
    /**
     * True ID of the user on the platform
     * @type {string}
     * @memberof ContactsCheckExists200Response
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ContactsGet200Response
 */
export interface ContactsGet200Response {
    /**
     * total contacts present with these filters. Only returned if returnTotalCount is true
     * @type {number}
     * @memberof ContactsGet200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {Array<Contact>}
     * @memberof ContactsGet200Response
     */
    'contacts': Array<Contact>;
    /**
     * 
     * @type {string}
     * @memberof ContactsGet200Response
     */
    'nextPage': string | null;
}
/**
 * 
 * @export
 * @interface ContactsImageGet200Response
 */
export interface ContactsImageGet200Response {
    /**
     * 
     * @type {string}
     * @memberof ContactsImageGet200Response
     */
    'url': string | null;
}
/**
 * 
 * @export
 * @interface ContactsPatch
 */
export interface ContactsPatch {
    /**
     * 
     * @type {ContactsPatchPatch}
     * @memberof ContactsPatch
     */
    'patch': ContactsPatchPatch;
}
/**
 * 
 * @export
 * @interface ContactsPatch200Response
 */
export interface ContactsPatch200Response {
    /**
     * 
     * @type {number}
     * @memberof ContactsPatch200Response
     */
    'updated': number;
}
/**
 * 
 * @export
 * @interface ContactsPatchPatch
 */
export interface ContactsPatchPatch {
    /**
     * 
     * @type {string}
     * @memberof ContactsPatchPatch
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactsPatchPatch
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactsPatchPatch
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactsPatchPatch
     */
    'assignee'?: string | null;
    /**
     * 
     * @type {Array<ContactTagUpdate>}
     * @memberof ContactsPatchPatch
     */
    'tags'?: Array<ContactTagUpdate>;
}
/**
 * 
 * @export
 * @interface ContactsPost
 */
export interface ContactsPost {
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof ContactsPost
     */
    'accountId'?: string;
    /**
     * 
     * @type {Array<ContactsPostContactsInner>}
     * @memberof ContactsPost
     */
    'contacts': Array<ContactsPostContactsInner>;
}
/**
 * 
 * @export
 * @interface ContactsPostContactsInner
 */
export interface ContactsPostContactsInner {
    /**
     * 
     * @type {string}
     * @memberof ContactsPostContactsInner
     */
    'name': string | null;
    /**
     * The phone number of the contact
     * @type {string}
     * @memberof ContactsPostContactsInner
     */
    'phoneNumber': string;
    /**
     * The email of the contact
     * @type {string}
     * @memberof ContactsPostContactsInner
     */
    'email'?: string;
    /**
     * 
     * @type {Array<ContactTagUpdate>}
     * @memberof ContactsPostContactsInner
     */
    'tags'?: Array<ContactTagUpdate> | null;
    /**
     * 
     * @type {string}
     * @memberof ContactsPostContactsInner
     */
    'assignee'?: string | null;
}
/**
 * 
 * @export
 * @interface CrmBoard
 */
export interface CrmBoard {
    /**
     * ID of a CRM board
     * @type {string}
     * @memberof CrmBoard
     */
    'id': string;
    /**
     * Name of the CRM board
     * @type {string}
     * @memberof CrmBoard
     */
    'name': string;
    /**
     * The team ID of the team on ChatDaddy
     * @type {string}
     * @memberof CrmBoard
     */
    'ownerId': string;
    /**
     * 
     * @type {Array<CrmBoardStage>}
     * @memberof CrmBoard
     */
    'stages': Array<CrmBoardStage>;
    /**
     * 
     * @type {Array<CrmBoardCustomField>}
     * @memberof CrmBoard
     */
    'customFields'?: Array<CrmBoardCustomField>;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof CrmBoard
     */
    'addedMetadata'?: UpsertMetadata;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof CrmBoard
     */
    'updatedMetadata'?: UpsertMetadata;
    /**
     * 
     * @type {boolean}
     * @memberof CrmBoard
     */
    'pinned'?: boolean;
}
/**
 * 
 * @export
 * @interface CrmBoardCustomField
 */
export interface CrmBoardCustomField {
    /**
     * 
     * @type {string}
     * @memberof CrmBoardCustomField
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof CrmBoardCustomField
     */
    'show': boolean;
}
/**
 * 
 * @export
 * @interface CrmBoardGet200Response
 */
export interface CrmBoardGet200Response {
    /**
     * 
     * @type {Array<CrmBoard>}
     * @memberof CrmBoardGet200Response
     */
    'items': Array<CrmBoard>;
}
/**
 * 
 * @export
 * @interface CrmBoardPatch
 */
export interface CrmBoardPatch {
    /**
     * Name of the CRM board
     * @type {string}
     * @memberof CrmBoardPatch
     */
    'name'?: string;
    /**
     * Minimum response time after the ticket was created, in seconds
     * @type {number}
     * @memberof CrmBoardPatch
     */
    'minResponseTime'?: number;
    /**
     * After the ticket created, within this time, the ticket should be closed, in seconds
     * @type {number}
     * @memberof CrmBoardPatch
     */
    'minCloseTime'?: number;
    /**
     * 
     * @type {Array<CrmBoardStagePatch>}
     * @memberof CrmBoardPatch
     */
    'stages'?: Array<CrmBoardStagePatch>;
    /**
     * 
     * @type {CrmBoardPatchCustomFields}
     * @memberof CrmBoardPatch
     */
    'customFields'?: CrmBoardPatchCustomFields;
    /**
     * 
     * @type {boolean}
     * @memberof CrmBoardPatch
     */
    'pinned'?: boolean;
}
/**
 * @type CrmBoardPatchCustomFields
 * @export
 */
export type CrmBoardPatchCustomFields = Array<CrmBoardCustomField>;

/**
 * 
 * @export
 * @interface CrmBoardPost
 */
export interface CrmBoardPost {
    /**
     * Name of the CRM board
     * @type {string}
     * @memberof CrmBoardPost
     */
    'name': string;
    /**
     * Minimum response time after the ticket was created, in seconds
     * @type {number}
     * @memberof CrmBoardPost
     */
    'minResponseTime'?: number;
    /**
     * After the ticket created, within this time, the ticket should be closed, in seconds
     * @type {number}
     * @memberof CrmBoardPost
     */
    'minCloseTime'?: number;
    /**
     * 
     * @type {Array<CrmBoardStagePost>}
     * @memberof CrmBoardPost
     */
    'stages': Array<CrmBoardStagePost>;
    /**
     * 
     * @type {Array<CrmBoardCustomField>}
     * @memberof CrmBoardPost
     */
    'customFields'?: Array<CrmBoardCustomField>;
}
/**
 * 
 * @export
 * @interface CrmBoardStage
 */
export interface CrmBoardStage {
    /**
     * ID of a stage
     * @type {string}
     * @memberof CrmBoardStage
     */
    'id': string;
    /**
     * Name of the stage
     * @type {string}
     * @memberof CrmBoardStage
     */
    'name': string;
    /**
     * Hex color code
     * @type {string}
     * @memberof CrmBoardStage
     */
    'color': string;
}
/**
 * 
 * @export
 * @interface CrmBoardStageDelete
 */
export interface CrmBoardStageDelete {
    /**
     * ID of a stage
     * @type {string}
     * @memberof CrmBoardStageDelete
     */
    'id': string;
    /**
     * True if the stage should be removed from the board
     * @type {boolean}
     * @memberof CrmBoardStageDelete
     */
    'remove': boolean;
    /**
     * ID of the stage to move all the contact\'s to when this stage removed
     * @type {string}
     * @memberof CrmBoardStageDelete
     */
    'moveTo'?: string;
}
/**
 * @type CrmBoardStagePatch
 * @export
 */
export type CrmBoardStagePatch = CrmBoardStageDelete | CrmBoardStagePatchData | CrmBoardStagePost;

/**
 * 
 * @export
 * @interface CrmBoardStagePatchData
 */
export interface CrmBoardStagePatchData {
    /**
     * ID of a stage
     * @type {string}
     * @memberof CrmBoardStagePatchData
     */
    'id': string;
    /**
     * Name of the stage
     * @type {string}
     * @memberof CrmBoardStagePatchData
     */
    'name'?: string;
    /**
     * Hex color code
     * @type {string}
     * @memberof CrmBoardStagePatchData
     */
    'color'?: string;
    /**
     * Order of a ticket
     * @type {number}
     * @memberof CrmBoardStagePatchData
     */
    'index'?: number;
}
/**
 * 
 * @export
 * @interface CrmBoardStagePost
 */
export interface CrmBoardStagePost {
    /**
     * Name of the stage
     * @type {string}
     * @memberof CrmBoardStagePost
     */
    'name': string;
    /**
     * Hex color code
     * @type {string}
     * @memberof CrmBoardStagePost
     */
    'color': string;
    /**
     * Order of a ticket
     * @type {number}
     * @memberof CrmBoardStagePost
     */
    'index'?: number;
}
/**
 * 
 * @export
 * @interface CrmTicket
 */
export interface CrmTicket {
    /**
     * ID of a ticket
     * @type {string}
     * @memberof CrmTicket
     */
    'id': string;
    /**
     * ID of a CRM board
     * @type {string}
     * @memberof CrmTicket
     */
    'boardId': string;
    /**
     * ID of a stage
     * @type {string}
     * @memberof CrmTicket
     */
    'stageId': string;
    /**
     * ID of a stage
     * @type {string}
     * @memberof CrmTicket
     */
    'prevStageId'?: string;
    /**
     * Order of a ticket
     * @type {number}
     * @memberof CrmTicket
     */
    'order': number;
    /**
     * Title of the ticket
     * @type {string}
     * @memberof CrmTicket
     */
    'title': string;
    /**
     * 
     * @type {UniqueContactID}
     * @memberof CrmTicket
     */
    'contactId': UniqueContactID;
    /**
     * 
     * @type {Contact}
     * @memberof CrmTicket
     */
    'contact'?: Contact;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof CrmTicket
     */
    'createMetadata': UpsertMetadata;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof CrmTicket
     */
    'updateMetadata': UpsertMetadata;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof CrmTicket
     */
    'resolvedMetadata'?: UpsertMetadata;
    /**
     * 
     * @type {TicketTimer}
     * @memberof CrmTicket
     */
    'timer'?: TicketTimer;
    /**
     * Calculated Lifetime Value of the contact based on revenue tags
     * @type {number}
     * @memberof CrmTicket
     */
    'ltv'?: number | null;
}
/**
 * 
 * @export
 * @interface CrmTicketBulkPost
 */
export interface CrmTicketBulkPost {
    /**
     * ID of a CRM board
     * @type {string}
     * @memberof CrmTicketBulkPost
     */
    'boardId': string;
    /**
     * 
     * @type {Array<CrmTicketBulkPostItemsInner>}
     * @memberof CrmTicketBulkPost
     */
    'items': Array<CrmTicketBulkPostItemsInner>;
}
/**
 * 
 * @export
 * @interface CrmTicketBulkPostItemsInner
 */
export interface CrmTicketBulkPostItemsInner {
    /**
     * ID of a stage
     * @type {string}
     * @memberof CrmTicketBulkPostItemsInner
     */
    'stageId'?: string;
    /**
     * Title of the ticket
     * @type {string}
     * @memberof CrmTicketBulkPostItemsInner
     */
    'title': string;
    /**
     * 
     * @type {UniqueContactID}
     * @memberof CrmTicketBulkPostItemsInner
     */
    'contactId': UniqueContactID;
    /**
     * Order of a ticket
     * @type {number}
     * @memberof CrmTicketBulkPostItemsInner
     */
    'order'?: number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CrmTicketBulkPostItemsInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {TicketTimerCreate}
     * @memberof CrmTicketBulkPostItemsInner
     */
    'timer'?: TicketTimerCreate;
}
/**
 * 
 * @export
 * @interface CrmTicketPatch
 */
export interface CrmTicketPatch {
    /**
     * ID of a CRM board
     * @type {string}
     * @memberof CrmTicketPatch
     */
    'boardId'?: string;
    /**
     * ID of a stage
     * @type {string}
     * @memberof CrmTicketPatch
     */
    'stageId'?: string;
    /**
     * Title of the ticket
     * @type {string}
     * @memberof CrmTicketPatch
     */
    'title'?: string;
    /**
     * Order of a ticket
     * @type {number}
     * @memberof CrmTicketPatch
     */
    'order'?: number;
}
/**
 * 
 * @export
 * @interface CrmTicketPost
 */
export interface CrmTicketPost {
    /**
     * ID of a CRM board
     * @type {string}
     * @memberof CrmTicketPost
     */
    'boardId': string;
    /**
     * ID of a stage
     * @type {string}
     * @memberof CrmTicketPost
     */
    'stageId'?: string;
    /**
     * Title of the ticket
     * @type {string}
     * @memberof CrmTicketPost
     */
    'title': string;
    /**
     * 
     * @type {UniqueContactID}
     * @memberof CrmTicketPost
     */
    'contactId': UniqueContactID;
    /**
     * Order of a ticket
     * @type {number}
     * @memberof CrmTicketPost
     */
    'order'?: number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CrmTicketPost
     */
    'createdAt'?: string;
    /**
     * 
     * @type {TicketTimerCreate}
     * @memberof CrmTicketPost
     */
    'timer'?: TicketTimerCreate;
}
/**
 * 
 * @export
 * @interface CrmTicketsPage
 */
export interface CrmTicketsPage {
    /**
     * 
     * @type {Array<CrmTicket>}
     * @memberof CrmTicketsPage
     */
    'items': Array<CrmTicket>;
    /**
     * 
     * @type {string}
     * @memberof CrmTicketsPage
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {number}
     * @memberof CrmTicketsPage
     */
    'totalCount'?: number;
}
/**
 * Daily snapshot of connected channel counts
 * @export
 * @interface DailyChannelSnapshot
 */
export interface DailyChannelSnapshot {
    /**
     * Snapshot date (YYYY-MM-DD)
     * @type {string}
     * @memberof DailyChannelSnapshot
     */
    'date'?: string;
    /**
     * Total connected channels
     * @type {number}
     * @memberof DailyChannelSnapshot
     */
    'totalChannels'?: number;
    /**
     * WhatsApp channels
     * @type {number}
     * @memberof DailyChannelSnapshot
     */
    'whatsapp'?: number;
    /**
     * WhatsApp Business API channels
     * @type {number}
     * @memberof DailyChannelSnapshot
     */
    'waba'?: number;
    /**
     * Instagram channels
     * @type {number}
     * @memberof DailyChannelSnapshot
     */
    'instagram'?: number;
    /**
     * Messenger channels
     * @type {number}
     * @memberof DailyChannelSnapshot
     */
    'messenger'?: number;
    /**
     * When this snapshot was created
     * @type {string}
     * @memberof DailyChannelSnapshot
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface EntryItems
 */
export interface EntryItems {
    /**
     * 
     * @type {string}
     * @memberof EntryItems
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof EntryItems
     */
    'time'?: number;
    /**
     * 
     * @type {Array<MessagingItems>}
     * @memberof EntryItems
     */
    'messaging'?: Array<MessagingItems>;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof EntryItems
     */
    'changes'?: Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface GetChannelCount200Response
 */
export interface GetChannelCount200Response {
    /**
     * 
     * @type {number}
     * @memberof GetChannelCount200Response
     */
    'count'?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetChannelCount200Response
     */
    'countByType'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface GetChannelCountComparison200Response
 */
export interface GetChannelCountComparison200Response {
    /**
     * The date being compared against
     * @type {string}
     * @memberof GetChannelCountComparison200Response
     */
    'compareDate'?: string;
    /**
     * 
     * @type {ChannelCountComparison}
     * @memberof GetChannelCountComparison200Response
     */
    'total'?: ChannelCountComparison;
    /**
     * 
     * @type {ChannelCountComparison}
     * @memberof GetChannelCountComparison200Response
     */
    'whatsapp'?: ChannelCountComparison;
    /**
     * 
     * @type {ChannelCountComparison}
     * @memberof GetChannelCountComparison200Response
     */
    'waba'?: ChannelCountComparison;
    /**
     * 
     * @type {ChannelCountComparison}
     * @memberof GetChannelCountComparison200Response
     */
    'instagram'?: ChannelCountComparison;
    /**
     * 
     * @type {ChannelCountComparison}
     * @memberof GetChannelCountComparison200Response
     */
    'messenger'?: ChannelCountComparison;
}
/**
 * 
 * @export
 * @interface GetDailyChannelSnapshots200Response
 */
export interface GetDailyChannelSnapshots200Response {
    /**
     * 
     * @type {Array<DailyChannelSnapshot>}
     * @memberof GetDailyChannelSnapshots200Response
     */
    'snapshots'?: Array<DailyChannelSnapshot>;
}
/**
 * 
 * @export
 * @interface GetLatestTicket200Response
 */
export interface GetLatestTicket200Response {
    /**
     * 
     * @type {CrmTicket}
     * @memberof GetLatestTicket200Response
     */
    'ticket'?: CrmTicket;
}
/**
 * 
 * @export
 * @interface GetPosts200Response
 */
export interface GetPosts200Response {
    /**
     * 
     * @type {Array<ReferencedPost>}
     * @memberof GetPosts200Response
     */
    'items': Array<ReferencedPost>;
    /**
     * next page cursor, if it exists
     * @type {string}
     * @memberof GetPosts200Response
     */
    'nextPageCursor'?: string;
}
/**
 * 
 * @export
 * @interface GetTicketsByStage200Response
 */
export interface GetTicketsByStage200Response {
    /**
     * 
     * @type {{ [key: string]: CrmTicketsPage; }}
     * @memberof GetTicketsByStage200Response
     */
    'ticketsByStage': { [key: string]: CrmTicketsPage; };
}
/**
 * @type GroupAction
 * @export
 */
export type GroupAction = GroupMetadataAction | GroupParticipantsAction;

/**
 * 
 * @export
 * @enum {string}
 */

export const GroupActionType = {
    Add: 'add',
    Remove: 'remove',
    Demote: 'demote',
    Promote: 'promote'
} as const;

export type GroupActionType = typeof GroupActionType[keyof typeof GroupActionType];


/**
 * 
 * @export
 * @interface GroupCreate
 */
export interface GroupCreate {
    /**
     * 
     * @type {string}
     * @memberof GroupCreate
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupCreate
     */
    'participants': Array<string>;
}
/**
 * 
 * @export
 * @interface GroupMetadata
 */
export interface GroupMetadata {
    /**
     * 
     * @type {string}
     * @memberof GroupMetadata
     */
    'id': string;
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof GroupMetadata
     */
    'accountId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof GroupMetadata
     */
    'createdAt': string;
    /**
     * ID of the group owner
     * @type {string}
     * @memberof GroupMetadata
     */
    'ownerId'?: string | null;
    /**
     * 
     * @type {Contact}
     * @memberof GroupMetadata
     */
    'owner'?: Contact;
    /**
     * 
     * @type {string}
     * @memberof GroupMetadata
     */
    'description': string | null;
    /**
     * is set when the group only allows admins to change group settings
     * @type {boolean}
     * @memberof GroupMetadata
     */
    'restrict': boolean;
    /**
     * is set when the group only allows admins to write messages
     * @type {boolean}
     * @memberof GroupMetadata
     */
    'announce': boolean;
    /**
     * 
     * @type {Array<GroupParticipant>}
     * @memberof GroupMetadata
     */
    'participants': Array<GroupParticipant>;
}
/**
 * 
 * @export
 * @interface GroupMetadataAction
 */
export interface GroupMetadataAction {
    /**
     * 
     * @type {string}
     * @memberof GroupMetadataAction
     */
    'action': GroupMetadataActionActionEnum;
    /**
     * 
     * @type {string}
     * @memberof GroupMetadataAction
     */
    'value': string;
}

export const GroupMetadataActionActionEnum = {
    UpdateDescription: 'update_description'
} as const;

export type GroupMetadataActionActionEnum = typeof GroupMetadataActionActionEnum[keyof typeof GroupMetadataActionActionEnum];

/**
 * 
 * @export
 * @interface GroupParticipant
 */
export interface GroupParticipant {
    /**
     * 
     * @type {Contact}
     * @memberof GroupParticipant
     */
    'contact': Contact;
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof GroupParticipant
     */
    'contactId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupParticipant
     */
    'admin'?: GroupParticipantAdminEnum | null;
}

export const GroupParticipantAdminEnum = {
    Admin: 'admin',
    SuperAdmin: 'super-admin'
} as const;

export type GroupParticipantAdminEnum = typeof GroupParticipantAdminEnum[keyof typeof GroupParticipantAdminEnum];

/**
 * 
 * @export
 * @interface GroupParticipantsAction
 */
export interface GroupParticipantsAction {
    /**
     * 
     * @type {GroupActionType}
     * @memberof GroupParticipantsAction
     */
    'action': GroupActionType;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupParticipantsAction
     */
    'participants': Array<string>;
}


/**
 * 
 * @export
 * @interface GroupsInviteCode200Response
 */
export interface GroupsInviteCode200Response {
    /**
     * 
     * @type {string}
     * @memberof GroupsInviteCode200Response
     */
    'inviteCode': string;
}
/**
 * 
 * @export
 * @interface KeepDeletedMessagesSettings
 */
export interface KeepDeletedMessagesSettings {
    /**
     * Should messages sent by the account be kept.
     * @type {boolean}
     * @memberof KeepDeletedMessagesSettings
     */
    'fromMe': boolean;
}
/**
 * 
 * @export
 * @interface ListMessage
 */
export interface ListMessage {
    /**
     * The title of the list
     * @type {string}
     * @memberof ListMessage
     */
    'title'?: string;
    /**
     * 
     * @type {Array<ListMessageSection>}
     * @memberof ListMessage
     */
    'sections': Array<ListMessageSection>;
    /**
     * The maximum number of options that can be selected
     * @type {number}
     * @memberof ListMessage
     */
    'maxSelections'?: number;
}
/**
 * 
 * @export
 * @interface ListMessageOption
 */
export interface ListMessageOption {
    /**
     * 
     * @type {string}
     * @memberof ListMessageOption
     */
    'id': string;
    /**
     * The text of the option
     * @type {string}
     * @memberof ListMessageOption
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface ListMessageSection
 */
export interface ListMessageSection {
    /**
     * The title of the section
     * @type {string}
     * @memberof ListMessageSection
     */
    'title': string;
    /**
     * 
     * @type {Array<ListMessageOption>}
     * @memberof ListMessageSection
     */
    'options': Array<ListMessageOption>;
    /**
     * The maximum number of options that can be selected
     * @type {number}
     * @memberof ListMessageSection
     */
    'maxSelections'?: number;
}
/**
 * 
 * @export
 * @interface MailRegisterPostRequest
 */
export interface MailRegisterPostRequest {
    /**
     * 
     * @type {string}
     * @memberof MailRegisterPostRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface MailStateInfo
 */
export interface MailStateInfo {
    /**
     * 
     * @type {boolean}
     * @memberof MailStateInfo
     */
    'senderVerified'?: boolean;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {Array<string>}
     * @memberof Message
     */
    'mentions'?: Array<string>;
    /**
     * The subject of the message
     * @type {string}
     * @memberof Message
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'text'?: string | null;
    /**
     * 
     * @type {QuotedMessage}
     * @memberof Message
     */
    'quoted'?: QuotedMessage | null;
    /**
     * True, if the message was deleted
     * @type {boolean}
     * @memberof Message
     */
    'deleted'?: boolean;
    /**
     * True, if the message failed to decrypt
     * @type {boolean}
     * @memberof Message
     */
    'failDecryption'?: boolean;
    /**
     * True, if the message is a comment
     * @type {boolean}
     * @memberof Message
     */
    'isComment'?: boolean;
    /**
     * 
     * @type {MessageContentAction}
     * @memberof Message
     */
    'action'?: MessageContentAction | null;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof Message
     */
    'attachments'?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<MessageButton>}
     * @memberof Message
     */
    'buttons'?: Array<MessageButton> | null;
    /**
     * 
     * @type {Poll}
     * @memberof Message
     */
    'poll'?: Poll;
    /**
     * 
     * @type {ListMessage}
     * @memberof Message
     */
    'list'?: ListMessage;
    /**
     * 
     * @type {Array<MessageProduct>}
     * @memberof Message
     */
    'products'?: Array<MessageProduct> | null;
    /**
     * 
     * @type {MessageContentOrder}
     * @memberof Message
     */
    'order'?: MessageContentOrder | null;
    /**
     * 
     * @type {MessageLinkPreview}
     * @memberof Message
     */
    'linkPreview'?: MessageLinkPreview;
    /**
     * 
     * @type {Array<MessageReaction>}
     * @memberof Message
     */
    'reactions'?: Array<MessageReaction> | null;
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof Message
     */
    'chatId': string;
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof Message
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'fromMe': boolean;
    /**
     * The contact that sent the message (applicable for groups)
     * @type {string}
     * @memberof Message
     */
    'senderContactId'?: string | null;
    /**
     * 
     * @type {MessageAllOfSender}
     * @memberof Message
     */
    'sender'?: MessageAllOfSender | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Message
     */
    'timestamp': string;
    /**
     * 
     * @type {MessageStatus}
     * @memberof Message
     */
    'status'?: MessageStatus;
    /**
     * 
     * @type {MessageAllOfError}
     * @memberof Message
     */
    'error'?: MessageAllOfError;
    /**
     * Only for notes, user ID of the person who resolved the note
     * @type {string}
     * @memberof Message
     */
    'resolvedBy'?: string | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Message
     */
    'resolvedAt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'hidden'?: boolean;
    /**
     * If the message has been revised, i.e. edited, fixed or had its status updated, this will be incremented. This number is managed by CD, and will not reflect correctly for messages newly synced from the platform
     * @type {number}
     * @memberof Message
     */
    'revision'?: number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Message
     */
    'editedAt'?: string | null;
    /**
     * 
     * @type {MiscOptions}
     * @memberof Message
     */
    'miscOptions'?: MiscOptions;
    /**
     * 
     * @type {WABAConversationMetadata}
     * @memberof Message
     */
    'conversationMetadata'?: WABAConversationMetadata;
    /**
     * 
     * @type {NLPTranscriptionJob}
     * @memberof Message
     */
    'transcription'?: NLPTranscriptionJob;
    /**
     * 
     * @type {MessageAllOfReactionAction}
     * @memberof Message
     */
    'reactionAction'?: MessageAllOfReactionAction;
    /**
     * 
     * @type {ReferencedPost}
     * @memberof Message
     */
    'referencedPost'?: ReferencedPost;
}


/**
 * @type MessageAllOfError
 * @export
 */
export type MessageAllOfError = MessageError | object;

/**
 * Message describes a reaction to another message
 * @export
 * @interface MessageAllOfReactionAction
 */
export interface MessageAllOfReactionAction {
    /**
     * Describes a reaction on a message
     * @type {string}
     * @memberof MessageAllOfReactionAction
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof MessageAllOfReactionAction
     */
    'id': string;
}
/**
 * The user ID of the person that sent it
 * @export
 * @interface MessageAllOfSender
 */
export interface MessageAllOfSender {
    /**
     * 
     * @type {string}
     * @memberof MessageAllOfSender
     */
    'userId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageAllOfSender
     */
    'createdAt'?: string;
    /**
     * 
     * @type {MessageSenderContext}
     * @memberof MessageAllOfSender
     */
    'context'?: MessageSenderContext;
}
/**
 * 
 * @export
 * @interface MessageAttachment
 */
export interface MessageAttachment {
    /**
     * 
     * @type {MessageAttachmentType}
     * @memberof MessageAttachment
     */
    'type': MessageAttachmentType;
    /**
     * 
     * @type {string}
     * @memberof MessageAttachment
     */
    'mimetype': string;
    /**
     * 1. can be publicly hosted url, 2. or can be base64 encoded buffer. But make sure it starts with `data:;base64,` -- can be at most 1KB in size Note: the `contact` type only supports base64 encoded data. Must be a serialised vcard 
     * @type {string}
     * @memberof MessageAttachment
     */
    'url': string;
    /**
     * 
     * @type {MessageLocation}
     * @memberof MessageAttachment
     */
    'location'?: MessageLocation;
    /**
     * thumbnail of sticker/video/image
     * @type {string}
     * @memberof MessageAttachment
     */
    'jpegThumbnail'?: string | null;
    /**
     * duration of audio/video message
     * @type {number}
     * @memberof MessageAttachment
     */
    'seconds'?: number;
    /**
     * Show as PTT (voice note) -- only for audio messages
     * @type {boolean}
     * @memberof MessageAttachment
     */
    'pttAudio'?: boolean;
    /**
     * name of the doc message
     * @type {string}
     * @memberof MessageAttachment
     */
    'filename'?: string;
    /**
     * is this a gif -- only for video messages
     * @type {boolean}
     * @memberof MessageAttachment
     */
    'isGif'?: boolean;
    /**
     * 
     * @type {MessageAttachmentDecryption}
     * @memberof MessageAttachment
     */
    'decryption'?: MessageAttachmentDecryption;
}


/**
 * 
 * @export
 * @interface MessageAttachmentDecryption
 */
export interface MessageAttachmentDecryption {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MessageAttachmentDecryption
     */
    'keys'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentDecryption
     */
    'algorithm': MessageAttachmentDecryptionAlgorithmEnum;
}

export const MessageAttachmentDecryptionAlgorithmEnum = {
    Aes256Cbc: 'aes-256-cbc'
} as const;

export type MessageAttachmentDecryptionAlgorithmEnum = typeof MessageAttachmentDecryptionAlgorithmEnum[keyof typeof MessageAttachmentDecryptionAlgorithmEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const MessageAttachmentType = {
    Image: 'image',
    Video: 'video',
    Contact: 'contact',
    Sticker: 'sticker',
    Audio: 'audio',
    Document: 'document',
    Location: 'location'
} as const;

export type MessageAttachmentType = typeof MessageAttachmentType[keyof typeof MessageAttachmentType];


/**
 * 
 * @export
 * @interface MessageButton
 */
export interface MessageButton {
    /**
     * 
     * @type {string}
     * @memberof MessageButton
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MessageButton
     */
    'text': string;
    /**
     * Make a button with a link
     * @type {string}
     * @memberof MessageButton
     */
    'url'?: string;
    /**
     * Make a button with a phone number
     * @type {string}
     * @memberof MessageButton
     */
    'phoneNumber'?: string;
}
/**
 * 
 * @export
 * @interface MessageCompose
 */
export interface MessageCompose {
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageCompose
     */
    'mentions'?: Array<string>;
    /**
     * The subject of the message
     * @type {string}
     * @memberof MessageCompose
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageCompose
     */
    'text'?: string | null;
    /**
     * 
     * @type {QuotedMessage}
     * @memberof MessageCompose
     */
    'quoted'?: QuotedMessage | null;
    /**
     * True, if the message was deleted
     * @type {boolean}
     * @memberof MessageCompose
     */
    'deleted'?: boolean;
    /**
     * True, if the message failed to decrypt
     * @type {boolean}
     * @memberof MessageCompose
     */
    'failDecryption'?: boolean;
    /**
     * True, if the message is a comment
     * @type {boolean}
     * @memberof MessageCompose
     */
    'isComment'?: boolean;
    /**
     * 
     * @type {MessageContentAction}
     * @memberof MessageCompose
     */
    'action'?: MessageContentAction | null;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof MessageCompose
     */
    'attachments'?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<MessageButton>}
     * @memberof MessageCompose
     */
    'buttons'?: Array<MessageButton> | null;
    /**
     * 
     * @type {Poll}
     * @memberof MessageCompose
     */
    'poll'?: Poll;
    /**
     * 
     * @type {ListMessage}
     * @memberof MessageCompose
     */
    'list'?: ListMessage;
    /**
     * 
     * @type {Array<MessageProduct>}
     * @memberof MessageCompose
     */
    'products'?: Array<MessageProduct> | null;
    /**
     * 
     * @type {MessageContentOrder}
     * @memberof MessageCompose
     */
    'order'?: MessageContentOrder | null;
    /**
     * 
     * @type {MessageLinkPreview}
     * @memberof MessageCompose
     */
    'linkPreview'?: MessageLinkPreview;
    /**
     * 
     * @type {Array<MessageReaction>}
     * @memberof MessageCompose
     */
    'reactions'?: Array<MessageReaction> | null;
    /**
     * Specify the message Id -- can be used as an idempotency key. Ensures, that two messages with the same ID will never be sent twice 
     * @type {string}
     * @memberof MessageCompose
     */
    'id'?: string;
    /**
     * Set the status of the message, use to create notes
     * @type {string}
     * @memberof MessageCompose
     */
    'status'?: MessageComposeStatusEnum;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageCompose
     */
    'timestamp'?: string;
    /**
     * 
     * @type {MiscOptions}
     * @memberof MessageCompose
     */
    'miscOptions'?: MiscOptions;
    /**
     * parameters to replace in text
     * @type {{ [key: string]: any; }}
     * @memberof MessageCompose
     */
    'parameters'?: { [key: string]: any; };
    /**
     * 
     * @type {MessageComposeAllOfSender}
     * @memberof MessageCompose
     * @deprecated
     */
    'sender'?: MessageComposeAllOfSender;
}

export const MessageComposeStatusEnum = {
    Note: 'note',
    Pending: 'pending'
} as const;

export type MessageComposeStatusEnum = typeof MessageComposeStatusEnum[keyof typeof MessageComposeStatusEnum];

/**
 * 
 * @export
 * @interface MessageComposeAllOfSender
 */
export interface MessageComposeAllOfSender {
    /**
     * 
     * @type {MessageSenderContext}
     * @memberof MessageComposeAllOfSender
     */
    'context': MessageSenderContext;
}
/**
 * 
 * @export
 * @interface MessageComposeWChatID
 */
export interface MessageComposeWChatID {
    /**
     * Specify the message Id -- can be used as an idempotency key. Ensures, that two messages with the same ID will never be sent twice 
     * @type {string}
     * @memberof MessageComposeWChatID
     */
    'id'?: string;
    /**
     * Set the status of the message, use to create notes
     * @type {string}
     * @memberof MessageComposeWChatID
     */
    'status'?: MessageComposeWChatIDStatusEnum;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageComposeWChatID
     */
    'timestamp'?: string;
    /**
     * 
     * @type {MiscOptions}
     * @memberof MessageComposeWChatID
     */
    'miscOptions'?: MiscOptions;
    /**
     * parameters to replace in text
     * @type {{ [key: string]: object; }}
     * @memberof MessageComposeWChatID
     */
    'parameters'?: { [key: string]: object; };
    /**
     * 
     * @type {MessageComposeAllOfSender}
     * @memberof MessageComposeWChatID
     * @deprecated
     */
    'sender'?: MessageComposeAllOfSender;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageComposeWChatID
     */
    'mentions'?: Array<string>;
    /**
     * The subject of the message
     * @type {string}
     * @memberof MessageComposeWChatID
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageComposeWChatID
     */
    'text'?: string | null;
    /**
     * 
     * @type {QuotedMessage}
     * @memberof MessageComposeWChatID
     */
    'quoted'?: QuotedMessage | null;
    /**
     * True, if the message was deleted
     * @type {boolean}
     * @memberof MessageComposeWChatID
     */
    'deleted'?: boolean;
    /**
     * True, if the message failed to decrypt
     * @type {boolean}
     * @memberof MessageComposeWChatID
     */
    'failDecryption'?: boolean;
    /**
     * True, if the message is a comment
     * @type {boolean}
     * @memberof MessageComposeWChatID
     */
    'isComment'?: boolean;
    /**
     * 
     * @type {MessageContentAction}
     * @memberof MessageComposeWChatID
     */
    'action'?: MessageContentAction | null;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof MessageComposeWChatID
     */
    'attachments'?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<MessageButton>}
     * @memberof MessageComposeWChatID
     */
    'buttons'?: Array<MessageButton> | null;
    /**
     * 
     * @type {Poll}
     * @memberof MessageComposeWChatID
     */
    'poll'?: Poll;
    /**
     * 
     * @type {ListMessage}
     * @memberof MessageComposeWChatID
     */
    'list'?: ListMessage;
    /**
     * 
     * @type {Array<MessageProduct>}
     * @memberof MessageComposeWChatID
     */
    'products'?: Array<MessageProduct> | null;
    /**
     * 
     * @type {MessageContentOrder}
     * @memberof MessageComposeWChatID
     */
    'order'?: MessageContentOrder | null;
    /**
     * 
     * @type {MessageLinkPreview}
     * @memberof MessageComposeWChatID
     */
    'linkPreview'?: MessageLinkPreview;
    /**
     * 
     * @type {Array<MessageReaction>}
     * @memberof MessageComposeWChatID
     */
    'reactions'?: Array<MessageReaction> | null;
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof MessageComposeWChatID
     */
    'chatId': string;
}

export const MessageComposeWChatIDStatusEnum = {
    Note: 'note',
    Pending: 'pending'
} as const;

export type MessageComposeWChatIDStatusEnum = typeof MessageComposeWChatIDStatusEnum[keyof typeof MessageComposeWChatIDStatusEnum];

/**
 * 
 * @export
 * @interface MessageContent
 */
export interface MessageContent {
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageContent
     */
    'mentions'?: Array<string>;
    /**
     * The subject of the message
     * @type {string}
     * @memberof MessageContent
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageContent
     */
    'text'?: string | null;
    /**
     * 
     * @type {QuotedMessage}
     * @memberof MessageContent
     */
    'quoted'?: QuotedMessage | null;
    /**
     * True, if the message was deleted
     * @type {boolean}
     * @memberof MessageContent
     */
    'deleted'?: boolean;
    /**
     * True, if the message failed to decrypt
     * @type {boolean}
     * @memberof MessageContent
     */
    'failDecryption'?: boolean;
    /**
     * True, if the message is a comment
     * @type {boolean}
     * @memberof MessageContent
     */
    'isComment'?: boolean;
    /**
     * 
     * @type {MessageContentAction}
     * @memberof MessageContent
     */
    'action'?: MessageContentAction | null;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof MessageContent
     */
    'attachments'?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<MessageButton>}
     * @memberof MessageContent
     */
    'buttons'?: Array<MessageButton> | null;
    /**
     * 
     * @type {Poll}
     * @memberof MessageContent
     */
    'poll'?: Poll;
    /**
     * 
     * @type {ListMessage}
     * @memberof MessageContent
     */
    'list'?: ListMessage;
    /**
     * 
     * @type {Array<MessageProduct>}
     * @memberof MessageContent
     */
    'products'?: Array<MessageProduct> | null;
    /**
     * 
     * @type {MessageContentOrder}
     * @memberof MessageContent
     */
    'order'?: MessageContentOrder | null;
    /**
     * 
     * @type {MessageLinkPreview}
     * @memberof MessageContent
     */
    'linkPreview'?: MessageLinkPreview;
    /**
     * 
     * @type {Array<MessageReaction>}
     * @memberof MessageContent
     */
    'reactions'?: Array<MessageReaction> | null;
}
/**
 * 
 * @export
 * @interface MessageContentAction
 */
export interface MessageContentAction {
    /**
     * 
     * @type {string}
     * @memberof MessageContentAction
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageContentAction
     */
    'parameters'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MessageContentOrder
 */
export interface MessageContentOrder {
    /**
     * 
     * @type {string}
     * @memberof MessageContentOrder
     */
    'orderId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageContentOrder
     */
    'jpegThumbnail'?: string;
    /**
     * 
     * @type {number}
     * @memberof MessageContentOrder
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof MessageContentOrder
     */
    'sellerId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageContentOrder
     */
    'token': string;
    /**
     * 
     * @type {Price}
     * @memberof MessageContentOrder
     */
    'total': Price;
}
/**
 * 
 * @export
 * @interface MessageError
 */
export interface MessageError {
    /**
     * 
     * @type {number}
     * @memberof MessageError
     */
    'statusCode': number;
    /**
     * What the error was
     * @type {string}
     * @memberof MessageError
     */
    'message': string;
    /**
     * 
     * @type {AppErrorData}
     * @memberof MessageError
     */
    'data'?: AppErrorData;
    /**
     * Number of retries that have been attempted
     * @type {number}
     * @memberof MessageError
     */
    'retries': number;
}
/**
 * 
 * @export
 * @interface MessageID
 */
export interface MessageID {
    /**
     * 
     * @type {string}
     * @memberof MessageID
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MessageID
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageID
     */
    'chatId': string;
}
/**
 * 
 * @export
 * @interface MessageLinkPreview
 */
export interface MessageLinkPreview {
    /**
     * 
     * @type {string}
     * @memberof MessageLinkPreview
     */
    'jpegThumbnail'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageLinkPreview
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof MessageLinkPreview
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof MessageLinkPreview
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof MessageLinkPreview
     */
    'matchedText'?: string;
}
/**
 * 
 * @export
 * @interface MessageLocation
 */
export interface MessageLocation {
    /**
     * 
     * @type {number}
     * @memberof MessageLocation
     */
    'latitude': number;
    /**
     * 
     * @type {number}
     * @memberof MessageLocation
     */
    'longitude': number;
}
/**
 * 
 * @export
 * @interface MessageProduct
 */
export interface MessageProduct {
    /**
     * 
     * @type {string}
     * @memberof MessageProduct
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MessageProduct
     */
    'accountId'?: string;
    /**
     * 
     * @type {MessageProductDetails}
     * @memberof MessageProduct
     */
    'details'?: MessageProductDetails;
}
/**
 * 
 * @export
 * @interface MessageProductDetails
 */
export interface MessageProductDetails {
    /**
     * 3-letter ISO currency code
     * @type {string}
     * @memberof MessageProductDetails
     */
    'currencyCode': string;
    /**
     * the actual price * 1000
     * @type {number}
     * @memberof MessageProductDetails
     */
    'price1000': number;
    /**
     * 
     * @type {string}
     * @memberof MessageProductDetails
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof MessageProductDetails
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageProductDetails
     */
    'url'?: string;
    /**
     * 
     * @type {MessageAttachment}
     * @memberof MessageProductDetails
     */
    'image': MessageAttachment;
    /**
     * The user ID of the business that owns this product
     * @type {string}
     * @memberof MessageProductDetails
     */
    'businessOwnerId'?: string;
}
/**
 * 
 * @export
 * @interface MessageReaction
 */
export interface MessageReaction {
    /**
     * Describes a reaction on a message
     * @type {string}
     * @memberof MessageReaction
     */
    'reaction': string;
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof MessageReaction
     */
    'fromId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageReaction
     */
    'id': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageReaction
     */
    'timestamp'?: string;
}
/**
 * Context about the actor of a particular action
 * @export
 * @interface MessageSenderContext
 */
export interface MessageSenderContext {
    /**
     * 
     * @type {ActorAutomationType}
     * @memberof MessageSenderContext
     */
    'type': ActorAutomationType;
    /**
     * ID of the object that sent the message. For example, the campaign ID or keyword reply ID. Separate sub-objects with a `/`. For example, to specify the action of a bot -- use `bot_id/action_id`
     * @type {string}
     * @memberof MessageSenderContext
     */
    'objectId': string;
    /**
     * Name of the object that sent the message. For example, the campaign name or keyword reply name
     * @type {string}
     * @memberof MessageSenderContext
     */
    'objectName'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const MessageStatus = {
    Error: 'error',
    Pending: 'pending',
    Note: 'note',
    Sent: 'sent',
    Delivered: 'delivered',
    Read: 'read',
    Cancelled: 'cancelled'
} as const;

export type MessageStatus = typeof MessageStatus[keyof typeof MessageStatus];


/**
 * 
 * @export
 * @interface MessagesBulkActionRequest
 */
export interface MessagesBulkActionRequest {
    /**
     * 
     * @type {BulkMessageAction}
     * @memberof MessagesBulkActionRequest
     */
    'action': BulkMessageAction;
}
/**
 * @type MessagesForwardToChatIdParameter
 * @export
 */
export type MessagesForwardToChatIdParameter = AnyContactID | Array<AnyContactID>;

/**
 * 
 * @export
 * @interface MessagesGet200Response
 */
export interface MessagesGet200Response {
    /**
     * 
     * @type {string}
     * @memberof MessagesGet200Response
     */
    'nextPage'?: string;
    /**
     * 
     * @type {Array<Message>}
     * @memberof MessagesGet200Response
     */
    'messages': Array<Message>;
}
/**
 * 
 * @export
 * @interface MessagesGetRangeParameter
 */
export interface MessagesGetRangeParameter {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessagesGetRangeParameter
     */
    'start': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessagesGetRangeParameter
     */
    'end': string;
}
/**
 * 
 * @export
 * @interface MessagesPatchPendingRequest
 */
export interface MessagesPatchPendingRequest {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessagesPatchPendingRequest
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface MessagesPatchRequest
 */
export interface MessagesPatchRequest {
    /**
     * 
     * @type {boolean}
     * @memberof MessagesPatchRequest
     */
    'resolved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MessagesPatchRequest
     */
    'text'?: string;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof MessagesPatchRequest
     */
    'attachments'?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessagesPatchRequest
     */
    'mentions'?: Array<string>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessagesPatchRequest
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface MessagesSearch200Response
 */
export interface MessagesSearch200Response {
    /**
     * 
     * @type {string}
     * @memberof MessagesSearch200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {Array<Message>}
     * @memberof MessagesSearch200Response
     */
    'messages': Array<Message>;
    /**
     * 
     * @type {Array<Chat>}
     * @memberof MessagesSearch200Response
     */
    'chats'?: Array<Chat>;
}
/**
 * 
 * @export
 * @interface MessagingItems
 */
export interface MessagingItems {
    /**
     * 
     * @type {MessagingItemsSender}
     * @memberof MessagingItems
     */
    'sender'?: MessagingItemsSender;
    /**
     * 
     * @type {MessagingItemsSender}
     * @memberof MessagingItems
     */
    'recipient'?: MessagingItemsSender;
    /**
     * 
     * @type {number}
     * @memberof MessagingItems
     */
    'timestamp'?: number;
    /**
     * 
     * @type {MessagingItemsMessage}
     * @memberof MessagingItems
     */
    'message'?: MessagingItemsMessage;
    /**
     * 
     * @type {MessagingItemsDelivery}
     * @memberof MessagingItems
     */
    'delivery'?: MessagingItemsDelivery;
    /**
     * 
     * @type {MessagingItemsRead}
     * @memberof MessagingItems
     */
    'read'?: MessagingItemsRead;
    /**
     * 
     * @type {MessagingItemsPostback}
     * @memberof MessagingItems
     */
    'postback'?: MessagingItemsPostback;
}
/**
 * 
 * @export
 * @interface MessagingItemsDelivery
 */
export interface MessagingItemsDelivery {
    [key: string]: any;

    /**
     * 
     * @type {Array<string>}
     * @memberof MessagingItemsDelivery
     */
    'mids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MessagingItemsMessage
 */
export interface MessagingItemsMessage {
    /**
     * 
     * @type {string}
     * @memberof MessagingItemsMessage
     */
    'mid'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessagingItemsMessage
     */
    'text'?: string;
    /**
     * 
     * @type {MessagingItemsMessageReplyTo}
     * @memberof MessagingItemsMessage
     */
    'reply_to'?: MessagingItemsMessageReplyTo;
    /**
     * 
     * @type {Array<MessengerAttachmentItems>}
     * @memberof MessagingItemsMessage
     */
    'attachments'?: Array<MessengerAttachmentItems>;
}
/**
 * 
 * @export
 * @interface MessagingItemsMessageReplyTo
 */
export interface MessagingItemsMessageReplyTo {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof MessagingItemsMessageReplyTo
     */
    'mid'?: string;
}
/**
 * 
 * @export
 * @interface MessagingItemsPostback
 */
export interface MessagingItemsPostback {
    /**
     * 
     * @type {string}
     * @memberof MessagingItemsPostback
     */
    'mid'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessagingItemsPostback
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessagingItemsPostback
     */
    'payload'?: string;
}
/**
 * 
 * @export
 * @interface MessagingItemsRead
 */
export interface MessagingItemsRead {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof MessagingItemsRead
     */
    'mid'?: string;
    /**
     * 
     * @type {number}
     * @memberof MessagingItemsRead
     */
    'watermark'?: number;
}
/**
 * 
 * @export
 * @interface MessagingItemsSender
 */
export interface MessagingItemsSender {
    /**
     * 
     * @type {string}
     * @memberof MessagingItemsSender
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface MessengerAttachmentItems
 */
export interface MessengerAttachmentItems {
    /**
     * 
     * @type {string}
     * @memberof MessengerAttachmentItems
     */
    'type'?: string;
    /**
     * 
     * @type {MessengerAttachmentItemsPayload}
     * @memberof MessengerAttachmentItems
     */
    'payload'?: MessengerAttachmentItemsPayload;
}
/**
 * 
 * @export
 * @interface MessengerAttachmentItemsPayload
 */
export interface MessengerAttachmentItemsPayload {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof MessengerAttachmentItemsPayload
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface MetaStateInfo
 */
export interface MetaStateInfo {
    /**
     * 
     * @type {string}
     * @memberof MetaStateInfo
     */
    'role'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MetaStateInfo
     */
    'businessVerified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MetaStateInfo
     */
    'businessName'?: string;
}
/**
 * 
 * @export
 * @interface MetaUser
 */
export interface MetaUser {
    /**
     * Page scoped ID of the user
     * @type {string}
     * @memberof MetaUser
     */
    'psid': string;
    /**
     * First name of the user
     * @type {string}
     * @memberof MetaUser
     */
    'firstName': string;
    /**
     * Last name of the user
     * @type {string}
     * @memberof MetaUser
     */
    'lastName'?: string;
    /**
     * Locale of the user
     * @type {string}
     * @memberof MetaUser
     */
    'locale'?: string;
    /**
     * Timezone of the user
     * @type {string}
     * @memberof MetaUser
     */
    'timezone'?: string;
    /**
     * Gender of the user
     * @type {string}
     * @memberof MetaUser
     */
    'gender'?: string;
}
/**
 * 
 * @export
 * @interface MetadataQuery
 */
export interface MetadataQuery {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MetadataQuery
     */
    'doneFrom'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MetadataQuery
     */
    'doneTo'?: string;
    /**
     * The user ID of the user on ChatDaddy
     * @type {string}
     * @memberof MetadataQuery
     */
    'doneBy'?: string;
}
/**
 * 
 * @export
 * @interface MiscOptions
 */
export interface MiscOptions {
    /**
     * Original ID from the provider
     * @type {string}
     * @memberof MiscOptions
     */
    'originalId'?: string;
    /**
     * WA Business template
     * @type {string}
     * @memberof MiscOptions
     */
    'templateId'?: string;
    /**
     * WA Business template params -- do not need to populate
     * @type {{ [key: string]: string; }}
     * @memberof MiscOptions
     */
    'templateParams'?: { [key: string]: string; };
    /**
     * Emulate typing behaviour before send
     * @type {boolean}
     * @memberof MiscOptions
     */
    'withTyping'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MiscOptions
     */
    'forwardCount'?: number;
    /**
     * 
     * @type {MiscOptionsForwarded}
     * @memberof MiscOptions
     */
    'forwarded'?: MiscOptionsForwarded;
    /**
     * Adds random whitespace to produce a distinct message
     * @type {boolean}
     * @memberof MiscOptions
     */
    'randomizeMessage'?: boolean;
    /**
     * the ID of the button clicked
     * @type {string}
     * @memberof MiscOptions
     */
    'buttonReplyId'?: string;
    /**
     * the ID of the list item clicked
     * @type {string}
     * @memberof MiscOptions
     */
    'listReplyId'?: string;
    /**
     * the option of the poll that was clicked
     * @type {Array<string>}
     * @memberof MiscOptions
     */
    'pollReplyOptions'?: Array<string>;
    /**
     * If true, the message will be cancelled if a reply is received
     * @type {boolean}
     * @memberof MiscOptions
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * FEP (Future Expiration Point) expiry timestamp in milliseconds
     * @type {number}
     * @memberof MiscOptions
     */
    'fepExpiryTime'?: number;
}
/**
 * the message being forwarded
 * @export
 * @interface MiscOptionsForwarded
 */
export interface MiscOptionsForwarded {
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof MiscOptionsForwarded
     */
    'accountId'?: string;
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof MiscOptionsForwarded
     */
    'chatId': string;
    /**
     * 
     * @type {string}
     * @memberof MiscOptionsForwarded
     */
    'id': string;
}
/**
 * Use to send 1 or more messages in a single request. You can override the default compose options for each message by passing in the compose options in the recipient object
 * @export
 * @interface MultiMessageCompose
 */
export interface MultiMessageCompose {
    /**
     * 
     * @type {MessageCompose}
     * @memberof MultiMessageCompose
     */
    'compose'?: MessageCompose;
    /**
     * 
     * @type {Array<MessageComposeWChatID>}
     * @memberof MultiMessageCompose
     */
    'recipients': Array<MessageComposeWChatID>;
}
/**
 * 
 * @export
 * @interface NLPTranscriptionJob
 */
export interface NLPTranscriptionJob {
    /**
     * 
     * @type {string}
     * @memberof NLPTranscriptionJob
     */
    'status': NLPTranscriptionJobStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof NLPTranscriptionJob
     */
    'error'?: string;
}

export const NLPTranscriptionJobStatusEnum = {
    InProgress: 'in-progress',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type NLPTranscriptionJobStatusEnum = typeof NLPTranscriptionJobStatusEnum[keyof typeof NLPTranscriptionJobStatusEnum];

/**
 * 
 * @export
 * @interface OrderDetails
 */
export interface OrderDetails {
    /**
     * 
     * @type {OrderPrice}
     * @memberof OrderDetails
     */
    'price'?: OrderPrice;
    /**
     * 
     * @type {Array<OrderProduct>}
     * @memberof OrderDetails
     */
    'products'?: Array<OrderProduct>;
}
/**
 * 
 * @export
 * @interface OrderPrice
 */
export interface OrderPrice {
    /**
     * actual price * 1000
     * @type {number}
     * @memberof OrderPrice
     */
    'total1000'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderPrice
     */
    'subtotal1000'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderPrice
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface OrderProduct
 */
export interface OrderProduct {
    /**
     * 
     * @type {MessageProduct}
     * @memberof OrderProduct
     */
    'product': MessageProduct;
    /**
     * 
     * @type {number}
     * @memberof OrderProduct
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface PermanentlyStoreAttachments200Response
 */
export interface PermanentlyStoreAttachments200Response {
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof PermanentlyStoreAttachments200Response
     */
    'attachments': Array<MessageAttachment>;
}
/**
 * Model for a product on an external platform (eg. WhatsApp)
 * @export
 * @interface PlatformProduct
 */
export interface PlatformProduct {
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'retailerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'url'?: string;
    /**
     * 
     * @type {Array<ProductCategory>}
     * @memberof PlatformProduct
     */
    'categories'?: Array<ProductCategory>;
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof PlatformProduct
     */
    'price': number | null;
    /**
     * 
     * @type {number}
     * @memberof PlatformProduct
     */
    'stock'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlatformProduct
     */
    'totalStockSold'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'currency': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PlatformProduct
     */
    'isHidden': boolean;
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'id': string;
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof PlatformProduct
     */
    'accountId': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PlatformProduct
     */
    'imageUrls': { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PlatformProduct
     */
    'reviewStatus': { [key: string]: string; };
    /**
     * 
     * @type {ProductAvailability}
     * @memberof PlatformProduct
     */
    'availability'?: ProductAvailability;
    /**
     * 
     * @type {ProductSyncStatus}
     * @memberof PlatformProduct
     */
    'syncStatus': ProductSyncStatus;
    /**
     * True if sync is underway right now
     * @type {boolean}
     * @memberof PlatformProduct
     */
    'isSyncing'?: boolean;
    /**
     * 
     * @type {AppError}
     * @memberof PlatformProduct
     */
    'error'?: AppError;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PlatformProduct
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PlatformProduct
     */
    'updatedAt': string;
    /**
     * Cursor to sort products by
     * @type {string}
     * @memberof PlatformProduct
     */
    'cursor'?: string;
}


/**
 * 
 * @export
 * @interface PlatformProductCategoriesGet200Response
 */
export interface PlatformProductCategoriesGet200Response {
    /**
     * 
     * @type {Array<ProductCategory>}
     * @memberof PlatformProductCategoriesGet200Response
     */
    'categories': Array<ProductCategory>;
}
/**
 * 
 * @export
 * @interface PlatformProductCategoriesPostRequest
 */
export interface PlatformProductCategoriesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCategoriesPostRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface PlatformProductCreate
 */
export interface PlatformProductCreate {
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'retailerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof PlatformProductCreate
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'currency': string;
    /**
     * 
     * @type {number}
     * @memberof PlatformProductCreate
     */
    'stock'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PlatformProductCreate
     */
    'isHidden': boolean;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'category'?: string;
    /**
     * List of URLs for images of the product
     * @type {Array<string>}
     * @memberof PlatformProductCreate
     */
    'imageUrls'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PlatformProductUpdate
 */
export interface PlatformProductUpdate {
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'retailerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PlatformProductUpdate
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'currency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PlatformProductUpdate
     */
    'isHidden'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'category'?: string;
    /**
     * List of URLs for images of the product
     * @type {Array<string>}
     * @memberof PlatformProductUpdate
     */
    'imageUrls'?: Array<string>;
    /**
     * 
     * @type {PlatformProductUpdateStock}
     * @memberof PlatformProductUpdate
     */
    'stock'?: PlatformProductUpdateStock;
    /**
     * 
     * @type {number}
     * @memberof PlatformProductUpdate
     */
    'totalStockSold'?: number;
}
/**
 * 
 * @export
 * @interface PlatformProductUpdateStock
 */
export interface PlatformProductUpdateStock {
    /**
     * The new stock quantity
     * @type {number}
     * @memberof PlatformProductUpdateStock
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdateStock
     */
    'action'?: PlatformProductUpdateStockActionEnum;
}

export const PlatformProductUpdateStockActionEnum = {
    Set: 'set',
    Increment: 'increment',
    Decrement: 'decrement'
} as const;

export type PlatformProductUpdateStockActionEnum = typeof PlatformProductUpdateStockActionEnum[keyof typeof PlatformProductUpdateStockActionEnum];

/**
 * 
 * @export
 * @interface PlatformProductsGet200Response
 */
export interface PlatformProductsGet200Response {
    /**
     * total products present with these filters. Only returned if returnTotalCount is true
     * @type {number}
     * @memberof PlatformProductsGet200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {Array<PlatformProduct>}
     * @memberof PlatformProductsGet200Response
     */
    'products': Array<PlatformProduct>;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductsGet200Response
     */
    'nextPage'?: string;
}
/**
 * 
 * @export
 * @interface PlatformProductsPost200Response
 */
export interface PlatformProductsPost200Response {
    /**
     * 
     * @type {Array<PlatformProduct>}
     * @memberof PlatformProductsPost200Response
     */
    'products': Array<PlatformProduct>;
}
/**
 * 
 * @export
 * @interface PlatformProductsPostRequest
 */
export interface PlatformProductsPostRequest {
    /**
     * 
     * @type {Array<PlatformProductCreate>}
     * @memberof PlatformProductsPostRequest
     */
    'products': Array<PlatformProductCreate>;
}
/**
 * 
 * @export
 * @interface Poll
 */
export interface Poll {
    /**
     * 
     * @type {Array<PollOption>}
     * @memberof Poll
     */
    'options': Array<PollOption>;
    /**
     * The maximum number of options that can be selected
     * @type {number}
     * @memberof Poll
     */
    'maxSelections'?: number;
}
/**
 * 
 * @export
 * @interface PollOption
 */
export interface PollOption {
    /**
     * The text of the option
     * @type {string}
     * @memberof PollOption
     */
    'text': string;
    /**
     * The IDs of the contacts that selected this option
     * @type {Array<string>}
     * @memberof PollOption
     */
    'voters'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PresenceType = {
    Available: 'available',
    Unavailable: 'unavailable',
    Typing: 'typing',
    StoppedTyping: 'stoppedTyping'
} as const;

export type PresenceType = typeof PresenceType[keyof typeof PresenceType];


/**
 * 
 * @export
 * @interface Price
 */
export interface Price {
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'currency': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ProductAvailability = {
    InStock: 'in-stock'
} as const;

export type ProductAvailability = typeof ProductAvailability[keyof typeof ProductAvailability];


/**
 * 
 * @export
 * @interface ProductCategory
 */
export interface ProductCategory {
    /**
     * 
     * @type {string}
     * @memberof ProductCategory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductCategory
     */
    'name': string;
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof ProductCategory
     */
    'accountId': string;
    /**
     * 
     * @type {number}
     * @memberof ProductCategory
     */
    'productCount': number;
}
/**
 * Update a product category
 * @export
 * @interface ProductCategoryPatchRequest
 */
export interface ProductCategoryPatchRequest {
    /**
     * New name of the category
     * @type {string}
     * @memberof ProductCategoryPatchRequest
     */
    'name'?: string;
    /**
     * 
     * @type {Array<ProductCategoryPatchRequestProductsInner>}
     * @memberof ProductCategoryPatchRequest
     */
    'products'?: Array<ProductCategoryPatchRequestProductsInner>;
}
/**
 * 
 * @export
 * @interface ProductCategoryPatchRequestProductsInner
 */
export interface ProductCategoryPatchRequestProductsInner {
    /**
     * 
     * @type {string}
     * @memberof ProductCategoryPatchRequestProductsInner
     */
    'productId': string;
    /**
     * 
     * @type {string}
     * @memberof ProductCategoryPatchRequestProductsInner
     */
    'type': ProductCategoryPatchRequestProductsInnerTypeEnum;
}

export const ProductCategoryPatchRequestProductsInnerTypeEnum = {
    Add: 'add',
    Remove: 'remove'
} as const;

export type ProductCategoryPatchRequestProductsInnerTypeEnum = typeof ProductCategoryPatchRequestProductsInnerTypeEnum[keyof typeof ProductCategoryPatchRequestProductsInnerTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

const ProductSyncStatus = {
    Synced: 'synced',
    PendingCreate: 'pendingCreate',
    PendingUpdate: 'pendingUpdate',
    PendingDelete: 'pendingDelete'
} as const;

type ProductSyncStatus = typeof ProductSyncStatus[keyof typeof ProductSyncStatus];


/**
 * 
 * @export
 * @interface ProfileMessengerPostRequest
 */
export interface ProfileMessengerPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileMessengerPostRequest
     */
    'pageId': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileMessengerPostRequest
     */
    'pageAccessToken': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileMessengerPostRequest
     */
    'userAccessToken': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileMessengerPostRequest
     */
    'fbPageId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProfileMessengerPostRequest
     */
    'type'?: ProfileMessengerPostRequestTypeEnum;
}

export const ProfileMessengerPostRequestTypeEnum = {
    Messenger: 'messenger',
    Instagram: 'instagram'
} as const;

export type ProfileMessengerPostRequestTypeEnum = typeof ProfileMessengerPostRequestTypeEnum[keyof typeof ProfileMessengerPostRequestTypeEnum];

/**
 * 
 * @export
 * @interface QuotedMessage
 */
export interface QuotedMessage {
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof QuotedMessage
     */
    'chatId': string;
    /**
     * 
     * @type {string}
     * @memberof QuotedMessage
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof QuotedMessage
     */
    'senderContactId'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuotedMessage
     */
    'text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof QuotedMessage
     */
    'jpegThumbnail'?: string | null;
}
/**
 * 
 * @export
 * @interface ReferencedPost
 */
export interface ReferencedPost {
    /**
     * ID of the post
     * @type {string}
     * @memberof ReferencedPost
     */
    'id': string;
    /**
     * URL of the post
     * @type {string}
     * @memberof ReferencedPost
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ReferencedPost
     */
    'type': ReferencedPostTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ReferencedPost
     */
    'caption': string;
    /**
     * 
     * @type {string}
     * @memberof ReferencedPost
     */
    'liveStatus'?: ReferencedPostLiveStatusEnum;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ReferencedPost
     */
    'createdAt': string;
    /**
     * URL of the preview image
     * @type {string}
     * @memberof ReferencedPost
     */
    'previewUrl'?: string;
}

export const ReferencedPostTypeEnum = {
    LiveVideo: 'live_video',
    Post: 'post',
    Reel: 'reel'
} as const;

export type ReferencedPostTypeEnum = typeof ReferencedPostTypeEnum[keyof typeof ReferencedPostTypeEnum];
export const ReferencedPostLiveStatusEnum = {
    Ongoing: 'ongoing',
    Ended: 'ended'
} as const;

export type ReferencedPostLiveStatusEnum = typeof ReferencedPostLiveStatusEnum[keyof typeof ReferencedPostLiveStatusEnum];

/**
 * 
 * @export
 * @interface SaveDailyChannelSnapshot200Response
 */
export interface SaveDailyChannelSnapshot200Response {
    /**
     * 
     * @type {boolean}
     * @memberof SaveDailyChannelSnapshot200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SaveDailyChannelSnapshot200Response
     */
    'date'?: string;
    /**
     * 
     * @type {number}
     * @memberof SaveDailyChannelSnapshot200Response
     */
    'totalChannels'?: number;
}
/**
 * 
 * @export
 * @interface SaveDailyChannelSnapshotRequest
 */
export interface SaveDailyChannelSnapshotRequest {
    /**
     * Date for the snapshot (YYYY-MM-DD). Defaults to today if not provided.
     * @type {string}
     * @memberof SaveDailyChannelSnapshotRequest
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface SmsSenderIdPostRequest
 */
export interface SmsSenderIdPostRequest {
    /**
     * 
     * @type {string}
     * @memberof SmsSenderIdPostRequest
     */
    'senderId': string;
}
/**
 * 
 * @export
 * @interface SmsStateInfo
 */
export interface SmsStateInfo {
    /**
     * 
     * @type {boolean}
     * @memberof SmsStateInfo
     */
    'senderVerified'?: boolean;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'name': string;
    /**
     * The filters for a dynamic tag
     * @type {object}
     * @memberof Tag
     */
    'filters'?: object | null;
    /**
     * Hex color code
     * @type {string}
     * @memberof Tag
     */
    'color'?: string;
    /**
     * 
     * @type {TagFieldValidation}
     * @memberof Tag
     */
    'validation'?: TagFieldValidation;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Tag
     */
    'createdAt': string;
    /**
     * The user ID of the user on ChatDaddy
     * @type {string}
     * @memberof Tag
     */
    'createdBy': string;
}
/**
 * @type TagFieldValidation
 * @export
 */
export type TagFieldValidation = TagFieldValidationOneOf | TagFieldValidationOneOf1;

/**
 * 
 * @export
 * @interface TagFieldValidationOneOf
 */
export interface TagFieldValidationOneOf {
    /**
     * 
     * @type {string}
     * @memberof TagFieldValidationOneOf
     */
    'type'?: TagFieldValidationOneOfTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TagFieldValidationOneOf
     */
    'format'?: TagFieldValidationOneOfFormatEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof TagFieldValidationOneOf
     */
    'enum'?: Array<string>;
}

export const TagFieldValidationOneOfTypeEnum = {
    String: 'string'
} as const;

export type TagFieldValidationOneOfTypeEnum = typeof TagFieldValidationOneOfTypeEnum[keyof typeof TagFieldValidationOneOfTypeEnum];
export const TagFieldValidationOneOfFormatEnum = {
    Email: 'email',
    Phone: 'phone',
    Uri: 'uri',
    Attachment: 'attachment',
    TeamMember: 'team-member',
    DateTime: 'date-time'
} as const;

export type TagFieldValidationOneOfFormatEnum = typeof TagFieldValidationOneOfFormatEnum[keyof typeof TagFieldValidationOneOfFormatEnum];

/**
 * 
 * @export
 * @interface TagFieldValidationOneOf1
 */
export interface TagFieldValidationOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof TagFieldValidationOneOf1
     */
    'type'?: TagFieldValidationOneOf1TypeEnum;
}

export const TagFieldValidationOneOf1TypeEnum = {
    Number: 'number',
    Integer: 'integer',
    Boolean: 'boolean'
} as const;

export type TagFieldValidationOneOf1TypeEnum = typeof TagFieldValidationOneOf1TypeEnum[keyof typeof TagFieldValidationOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface TagFilter
 */
export interface TagFilter {
    /**
     * 
     * @type {string}
     * @memberof TagFilter
     */
    'name': string;
    /**
     * Filter by value of the tag
     * @type {string}
     * @memberof TagFilter
     */
    'value'?: string | null;
    /**
     * The operator to use for the value
     * @type {string}
     * @memberof TagFilter
     */
    'operator'?: TagFilterOperatorEnum;
    /**
     * 
     * @type {MetadataQuery}
     * @memberof TagFilter
     */
    'added'?: MetadataQuery;
}

export const TagFilterOperatorEnum = {
    Equals: 'equals',
    NotEquals: 'notEquals'
} as const;

export type TagFilterOperatorEnum = typeof TagFilterOperatorEnum[keyof typeof TagFilterOperatorEnum];

/**
 * 
 * @export
 * @interface TagsGet200Response
 */
export interface TagsGet200Response {
    /**
     * 
     * @type {Array<Tag>}
     * @memberof TagsGet200Response
     */
    'tags': Array<Tag>;
    /**
     * total tags present
     * @type {number}
     * @memberof TagsGet200Response
     */
    'total'?: number;
    /**
     * next page cursor, if it exists
     * @type {string}
     * @memberof TagsGet200Response
     */
    'nextPageCursor'?: string;
}
/**
 * 
 * @export
 * @interface TagsPostRequest
 */
export interface TagsPostRequest {
    /**
     * 
     * @type {TagFieldValidation}
     * @memberof TagsPostRequest
     */
    'validation'?: TagFieldValidation;
    /**
     * Hex color code
     * @type {string}
     * @memberof TagsPostRequest
     */
    'color'?: string;
}
/**
 * Description of the category of the template
 * @export
 * @enum {string}
 */

export const TemplateCategory = {
    Transactional: 'transactional',
    Marketing: 'marketing',
    Otp: 'otp'
} as const;

export type TemplateCategory = typeof TemplateCategory[keyof typeof TemplateCategory];


/**
 * 
 * @export
 * @interface TemplateCreate
 */
export interface TemplateCreate {
    /**
     * 
     * @type {string}
     * @memberof TemplateCreate
     */
    'text': string | null;
    /**
     * Optional header text for the WABA message template
     * @type {string}
     * @memberof TemplateCreate
     */
    'header'?: string;
    /**
     * Optional footer text for the WABA message template
     * @type {string}
     * @memberof TemplateCreate
     */
    'footer'?: string;
    /**
     * 
     * @type {Array<MessageButton>}
     * @memberof TemplateCreate
     */
    'buttons'?: Array<MessageButton>;
    /**
     * 
     * @type {ListMessage}
     * @memberof TemplateCreate
     */
    'list'?: ListMessage;
    /**
     * 
     * @type {Array<TemplateCreateAttachmentsInner>}
     * @memberof TemplateCreate
     */
    'attachments'?: Array<TemplateCreateAttachmentsInner>;
}
/**
 * 
 * @export
 * @interface TemplateCreateAttachmentsInner
 */
export interface TemplateCreateAttachmentsInner {
    /**
     * 
     * @type {MessageAttachmentType}
     * @memberof TemplateCreateAttachmentsInner
     */
    'type': MessageAttachmentType;
    /**
     * 
     * @type {string}
     * @memberof TemplateCreateAttachmentsInner
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateCreateAttachmentsInner
     */
    'filename'?: string;
}


/**
 * 
 * @export
 * @interface TemplateParams
 */
export interface TemplateParams {
    /**
     * 
     * @type {string}
     * @memberof TemplateParams
     */
    'name': string;
    /**
     * ISO language code
     * @type {string}
     * @memberof TemplateParams
     */
    'language': string;
    /**
     * 
     * @type {TemplateCategory}
     * @memberof TemplateParams
     */
    'category': TemplateCategory;
}


/**
 * 
 * @export
 * @interface TemplatesSubmitForReview200Response
 */
export interface TemplatesSubmitForReview200Response {
    /**
     * ID of the template submitted for review
     * @type {string}
     * @memberof TemplatesSubmitForReview200Response
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface TemplatesSubmitForReviewRequest
 */
export interface TemplatesSubmitForReviewRequest {
    /**
     * 
     * @type {TemplateParams}
     * @memberof TemplatesSubmitForReviewRequest
     */
    'params': TemplateParams;
    /**
     * 
     * @type {TemplateCreate}
     * @memberof TemplatesSubmitForReviewRequest
     */
    'message': TemplateCreate;
}
/**
 * 
 * @export
 * @interface TicketTimer
 */
export interface TicketTimer {
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof TicketTimer
     */
    'startMetadata': UpsertMetadata;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof TicketTimer
     */
    'stopMetadata'?: UpsertMetadata;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TicketTimer
     */
    'endsAt': string;
    /**
     * 
     * @type {TicketTimerStatus}
     * @memberof TicketTimer
     */
    'status': TicketTimerStatus;
}


/**
 * 
 * @export
 * @interface TicketTimerCreate
 */
export interface TicketTimerCreate {
    /**
     * Duration of the timer in seconds
     * @type {number}
     * @memberof TicketTimerCreate
     */
    'durationS': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TicketTimerStatus = {
    Running: 'running',
    Stopped: 'stopped',
    Ended: 'ended'
} as const;

export type TicketTimerStatus = typeof TicketTimerStatus[keyof typeof TicketTimerStatus];


/**
 * 
 * @export
 * @interface TikTokChatState
 */
export interface TikTokChatState {
    /**
     * Whether the chat is synced. If false, the chat will not be available
     * @type {number}
     * @memberof TikTokChatState
     */
    'synced': number;
    /**
     * Cursor to sync from. If null, the chat will be synced from the beginning
     * @type {string}
     * @memberof TikTokChatState
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface TikTokStateInfo
 */
export interface TikTokStateInfo {
    /**
     * 
     * @type {boolean}
     * @memberof TikTokStateInfo
     */
    'isSyncing'?: boolean;
    /**
     * 
     * @type {TikTokChatState}
     * @memberof TikTokStateInfo
     */
    'strangerChats'?: TikTokChatState;
    /**
     * 
     * @type {TikTokChatState}
     * @memberof TikTokStateInfo
     */
    'normalChats'?: TikTokChatState;
    /**
     * 
     * @type {string}
     * @memberof TikTokStateInfo
     */
    'lastSyncCursor'?: string;
    /**
     * 
     * @type {string}
     * @memberof TikTokStateInfo
     */
    'latestNotificationCursor'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TikTokStateInfo
     */
    'syncCompletedAt'?: string;
}
/**
 * 
 * @export
 * @interface UniqueContactID
 */
export interface UniqueContactID {
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof UniqueContactID
     */
    'id': string;
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof UniqueContactID
     */
    'accountId': string;
}
/**
 * 
 * @export
 * @interface UpsertMetadata
 */
export interface UpsertMetadata {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof UpsertMetadata
     */
    'doneAt': string;
    /**
     * The user ID of the user on ChatDaddy
     * @type {string}
     * @memberof UpsertMetadata
     */
    'doneBy': string;
    /**
     * 
     * @type {ActorMetadata}
     * @memberof UpsertMetadata
     */
    'actor'?: ActorMetadata;
}
/**
 * Metadata about a WABA conversation. This is set on the message when a new conversation is created.
 * @export
 * @interface WABAConversationMetadata
 */
export interface WABAConversationMetadata {
    /**
     * ID of the conversation
     * @type {string}
     * @memberof WABAConversationMetadata
     */
    'id': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof WABAConversationMetadata
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WABAConversationMetadata
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface WAPhonePairingState
 */
export interface WAPhonePairingState {
    /**
     * The WA ID of the phone
     * @type {string}
     * @memberof WAPhonePairingState
     */
    'jid': string;
    /**
     * The code to enter on the phone
     * @type {string}
     * @memberof WAPhonePairingState
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface WAStateInfo
 */
export interface WAStateInfo {
    /**
     * The QR to scan to log into the account
     * @type {string}
     * @memberof WAStateInfo
     */
    'qr'?: string;
    /**
     * 
     * @type {WAPhonePairingState}
     * @memberof WAStateInfo
     */
    'phonePairingState'?: WAPhonePairingState;
    /**
     * Whether the client has received all pending/offline notifications
     * @type {boolean}
     * @memberof WAStateInfo
     */
    'receivedPendingNotifications'?: boolean;
    /**
     * If the user logged in with a WA business account. Product APIs would be available now
     * @type {boolean}
     * @memberof WAStateInfo
     */
    'isBusiness'?: boolean;
    /**
     * If syncing history right now. If such is the case, regular event processing will be queued till the sync is complete
     * @type {boolean}
     * @memberof WAStateInfo
     */
    'isSyncingHistory'?: boolean;
    /**
     * 
     * @type {WASyncStateInfo}
     * @memberof WAStateInfo
     */
    'sync'?: WASyncStateInfo;
}
/**
 * @type WASyncData
 * @export
 */
export type WASyncData = WASyncDataOneOf | WASyncDataOneOf1;

/**
 * 
 * @export
 * @interface WASyncDataOneOf
 */
export interface WASyncDataOneOf {
    /**
     * Total number of objects received
     * @type {number}
     * @memberof WASyncDataOneOf
     */
    'total': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof WASyncDataOneOf
     */
    'lastRecvAt': string;
}
/**
 * 
 * @export
 * @interface WASyncDataOneOf1
 */
export interface WASyncDataOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof WASyncDataOneOf1
     */
    'error': string;
}
/**
 * State of how many chats, messages, contacts are synced, and if there was an error
 * @export
 * @interface WASyncStateInfo
 */
export interface WASyncStateInfo {
    /**
     * 
     * @type {WASyncData}
     * @memberof WASyncStateInfo
     */
    'chats'?: WASyncData;
    /**
     * 
     * @type {WASyncData}
     * @memberof WASyncStateInfo
     */
    'contacts'?: WASyncData;
    /**
     * 
     * @type {WASyncData}
     * @memberof WASyncStateInfo
     */
    'messages'?: WASyncData;
}
/**
 * 
 * @export
 * @interface WebhookMailPostRequest
 */
export interface WebhookMailPostRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhookMailPostRequest
     */
    'MessageID': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookMailPostRequest
     */
    'Recipient': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookMailPostRequest
     */
    'RecordType'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookMailPostRequest
     */
    'DeliveredAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookMailPostRequest
     */
    'Tag': string;
    /**
     * Extra information about the request
     * @type {object}
     * @memberof WebhookMailPostRequest
     */
    'Metadata'?: object;
}
/**
 * 
 * @export
 * @interface WebhookMessengerPostRequest
 */
export interface WebhookMessengerPostRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhookMessengerPostRequest
     */
    'object'?: string;
    /**
     * 
     * @type {Array<EntryItems>}
     * @memberof WebhookMessengerPostRequest
     */
    'entry'?: Array<EntryItems>;
}
/**
 * 
 * @export
 * @interface WebhookSmsLimitPostRequest
 */
export interface WebhookSmsLimitPostRequest {
    /**
     * Account SID
     * @type {string}
     * @memberof WebhookSmsLimitPostRequest
     */
    'AccountSid'?: string;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Logs out of the account & removes all synced chats, messages. Keeps contacts, and notes.
         * @summary Archive an account\'s resyncable data.
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsArchive: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsArchive', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/archive`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Close connection to the account
         * @param {string} accountId 
         * @param {boolean} [logout] Closes the account and logs out from the accounts. Will require user interaction (eg. scan QR) to open it again 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClose: async (accountId: string, logout?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsClose', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/close`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)

            if (logout !== undefined) {
                localVarQueryParameter['logout'] = logout;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can continue to poll this route to check if it has been deleted. When deleted, the route will return a 404.
         * @summary Enqueues a task to delete the account
         * @param {string} accountId 
         * @param {boolean} [deleteNow] Delete the account immediately. Otherwise, the account will be completely removed after 24 hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsDelete: async (accountId: string, deleteNow?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsDelete', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_DELETE"], configuration)

            if (deleteNow !== undefined) {
                localVarQueryParameter['deleteNow'] = deleteNow;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of all accounts
         * @param {string} [q] Search items by this string
         * @param {number} [page] Page number to paginate through results
         * @param {number} [count] Number of items to return
         * @param {AccountType} [type] 
         * @param {boolean} [all] 
         * @param {AccountState} [state] only fetch accounts with a state
         * @param {boolean} [returnCount] return total count of accounts
         * @param {string} [teamId] If specified, only fetches accounts that are part of the given team. If not specified, fetches all accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsGet: async (q?: string, page?: number, count?: number, type?: AccountType, all?: boolean, state?: AccountState, returnCount?: boolean, teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (returnCount !== undefined) {
                localVarQueryParameter['returnCount'] = returnCount;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Open connection to the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsOpen: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsOpen', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/open`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update name of the account or its settings
         * @summary Update an account
         * @param {string} accountId 
         * @param {AccountsPatchRequest} [accountsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPatch: async (accountId: string, accountsPatchRequest?: AccountsPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsPatch', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountsPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new account
         * @param {AccountsPostRequest} [accountsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPost: async (accountsPostRequest?: AccountsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route simulates creating a new account with the same ID. All data associated with the account is thus retained.
         * @summary Recreate a deleted account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRecreatePost: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsRecreatePost', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/recreate`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_CREATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * WA supports login either by QR code or by OTP. This API allows changing the login mode. 
         * @summary Change login mode of a WhatsApp account
         * @param {string} accountId 
         * @param {AccountWaChangeLoginMode} [accountWaChangeLoginMode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waChangeLoginMode: async (accountId: string, accountWaChangeLoginMode?: AccountWaChangeLoginMode, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('waChangeLoginMode', 'accountId', accountId)
            const localVarPath = `/accounts/wa/{accountId}/change-login-mode`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountWaChangeLoginMode, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * Logs out of the account & removes all synced chats, messages. Keeps contacts, and notes.
         * @summary Archive an account\'s resyncable data.
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsArchive(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsArchive(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountsArchive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Close connection to the account
         * @param {string} accountId 
         * @param {boolean} [logout] Closes the account and logs out from the accounts. Will require user interaction (eg. scan QR) to open it again 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsClose(accountId: string, logout?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsClose(accountId, logout, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountsClose']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You can continue to poll this route to check if it has been deleted. When deleted, the route will return a 404.
         * @summary Enqueues a task to delete the account
         * @param {string} accountId 
         * @param {boolean} [deleteNow] Delete the account immediately. Otherwise, the account will be completely removed after 24 hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsDelete(accountId: string, deleteNow?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsDelete(accountId, deleteNow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the list of all accounts
         * @param {string} [q] Search items by this string
         * @param {number} [page] Page number to paginate through results
         * @param {number} [count] Number of items to return
         * @param {AccountType} [type] 
         * @param {boolean} [all] 
         * @param {AccountState} [state] only fetch accounts with a state
         * @param {boolean} [returnCount] return total count of accounts
         * @param {string} [teamId] If specified, only fetches accounts that are part of the given team. If not specified, fetches all accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsGet(q?: string, page?: number, count?: number, type?: AccountType, all?: boolean, state?: AccountState, returnCount?: boolean, teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsGet(q, page, count, type, all, state, returnCount, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Open connection to the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsOpen(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsOpen(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountsOpen']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update name of the account or its settings
         * @summary Update an account
         * @param {string} accountId 
         * @param {AccountsPatchRequest} [accountsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPatch(accountId: string, accountsPatchRequest?: AccountsPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPatch(accountId, accountsPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountsPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a new account
         * @param {AccountsPostRequest} [accountsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPost(accountsPostRequest?: AccountsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPost(accountsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This route simulates creating a new account with the same ID. All data associated with the account is thus retained.
         * @summary Recreate a deleted account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsRecreatePost(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsRecreatePost(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountsRecreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * WA supports login either by QR code or by OTP. This API allows changing the login mode. 
         * @summary Change login mode of a WhatsApp account
         * @param {string} accountId 
         * @param {AccountWaChangeLoginMode} [accountWaChangeLoginMode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waChangeLoginMode(accountId: string, accountWaChangeLoginMode?: AccountWaChangeLoginMode, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.waChangeLoginMode(accountId, accountWaChangeLoginMode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.waChangeLoginMode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * Logs out of the account & removes all synced chats, messages. Keeps contacts, and notes.
         * @summary Archive an account\'s resyncable data.
         * @param {AccountApiAccountsArchiveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsArchive(requestParameters: AccountApiAccountsArchiveRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.accountsArchive(requestParameters.accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Close connection to the account
         * @param {AccountApiAccountsCloseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClose(requestParameters: AccountApiAccountsCloseRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountsClose(requestParameters.accountId, requestParameters.logout, options).then((request) => request(axios, basePath));
        },
        /**
         * You can continue to poll this route to check if it has been deleted. When deleted, the route will return a 404.
         * @summary Enqueues a task to delete the account
         * @param {AccountApiAccountsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsDelete(requestParameters: AccountApiAccountsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.accountsDelete(requestParameters.accountId, requestParameters.deleteNow, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of all accounts
         * @param {AccountApiAccountsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsGet(requestParameters: AccountApiAccountsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AccountsGet200Response> {
            return localVarFp.accountsGet(requestParameters.q, requestParameters.page, requestParameters.count, requestParameters.type, requestParameters.all, requestParameters.state, requestParameters.returnCount, requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Open connection to the account
         * @param {AccountApiAccountsOpenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsOpen(requestParameters: AccountApiAccountsOpenRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountsOpen(requestParameters.accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update name of the account or its settings
         * @summary Update an account
         * @param {AccountApiAccountsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPatch(requestParameters: AccountApiAccountsPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.accountsPatch(requestParameters.accountId, requestParameters.accountsPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new account
         * @param {AccountApiAccountsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPost(requestParameters: AccountApiAccountsPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.accountsPost(requestParameters.accountsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This route simulates creating a new account with the same ID. All data associated with the account is thus retained.
         * @summary Recreate a deleted account
         * @param {AccountApiAccountsRecreatePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRecreatePost(requestParameters: AccountApiAccountsRecreatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.accountsRecreatePost(requestParameters.accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * WA supports login either by QR code or by OTP. This API allows changing the login mode. 
         * @summary Change login mode of a WhatsApp account
         * @param {AccountApiWaChangeLoginModeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waChangeLoginMode(requestParameters: AccountApiWaChangeLoginModeRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.waChangeLoginMode(requestParameters.accountId, requestParameters.accountWaChangeLoginMode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for accountsArchive operation in AccountApi.
 * @export
 * @interface AccountApiAccountsArchiveRequest
 */
export interface AccountApiAccountsArchiveRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsArchive
     */
    readonly accountId: string
}

/**
 * Request parameters for accountsClose operation in AccountApi.
 * @export
 * @interface AccountApiAccountsCloseRequest
 */
export interface AccountApiAccountsCloseRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsClose
     */
    readonly accountId: string

    /**
     * Closes the account and logs out from the accounts. Will require user interaction (eg. scan QR) to open it again 
     * @type {boolean}
     * @memberof AccountApiAccountsClose
     */
    readonly logout?: boolean
}

/**
 * Request parameters for accountsDelete operation in AccountApi.
 * @export
 * @interface AccountApiAccountsDeleteRequest
 */
export interface AccountApiAccountsDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsDelete
     */
    readonly accountId: string

    /**
     * Delete the account immediately. Otherwise, the account will be completely removed after 24 hours
     * @type {boolean}
     * @memberof AccountApiAccountsDelete
     */
    readonly deleteNow?: boolean
}

/**
 * Request parameters for accountsGet operation in AccountApi.
 * @export
 * @interface AccountApiAccountsGetRequest
 */
export interface AccountApiAccountsGetRequest {
    /**
     * Search items by this string
     * @type {string}
     * @memberof AccountApiAccountsGet
     */
    readonly q?: string

    /**
     * Page number to paginate through results
     * @type {number}
     * @memberof AccountApiAccountsGet
     */
    readonly page?: number

    /**
     * Number of items to return
     * @type {number}
     * @memberof AccountApiAccountsGet
     */
    readonly count?: number

    /**
     * 
     * @type {AccountType}
     * @memberof AccountApiAccountsGet
     */
    readonly type?: AccountType

    /**
     * 
     * @type {boolean}
     * @memberof AccountApiAccountsGet
     */
    readonly all?: boolean

    /**
     * only fetch accounts with a state
     * @type {AccountState}
     * @memberof AccountApiAccountsGet
     */
    readonly state?: AccountState

    /**
     * return total count of accounts
     * @type {boolean}
     * @memberof AccountApiAccountsGet
     */
    readonly returnCount?: boolean

    /**
     * If specified, only fetches accounts that are part of the given team. If not specified, fetches all accounts
     * @type {string}
     * @memberof AccountApiAccountsGet
     */
    readonly teamId?: string
}

/**
 * Request parameters for accountsOpen operation in AccountApi.
 * @export
 * @interface AccountApiAccountsOpenRequest
 */
export interface AccountApiAccountsOpenRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsOpen
     */
    readonly accountId: string
}

/**
 * Request parameters for accountsPatch operation in AccountApi.
 * @export
 * @interface AccountApiAccountsPatchRequest
 */
export interface AccountApiAccountsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {AccountsPatchRequest}
     * @memberof AccountApiAccountsPatch
     */
    readonly accountsPatchRequest?: AccountsPatchRequest
}

/**
 * Request parameters for accountsPost operation in AccountApi.
 * @export
 * @interface AccountApiAccountsPostRequest
 */
export interface AccountApiAccountsPostRequest {
    /**
     * 
     * @type {AccountsPostRequest}
     * @memberof AccountApiAccountsPost
     */
    readonly accountsPostRequest?: AccountsPostRequest
}

/**
 * Request parameters for accountsRecreatePost operation in AccountApi.
 * @export
 * @interface AccountApiAccountsRecreatePostRequest
 */
export interface AccountApiAccountsRecreatePostRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsRecreatePost
     */
    readonly accountId: string
}

/**
 * Request parameters for waChangeLoginMode operation in AccountApi.
 * @export
 * @interface AccountApiWaChangeLoginModeRequest
 */
export interface AccountApiWaChangeLoginModeRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiWaChangeLoginMode
     */
    readonly accountId: string

    /**
     * 
     * @type {AccountWaChangeLoginMode}
     * @memberof AccountApiWaChangeLoginMode
     */
    readonly accountWaChangeLoginMode?: AccountWaChangeLoginMode
}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * Logs out of the account & removes all synced chats, messages. Keeps contacts, and notes.
     * @summary Archive an account\'s resyncable data.
     * @param {AccountApiAccountsArchiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsArchive(requestParameters: AccountApiAccountsArchiveRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsArchive(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Close connection to the account
     * @param {AccountApiAccountsCloseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsClose(requestParameters: AccountApiAccountsCloseRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsClose(requestParameters.accountId, requestParameters.logout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can continue to poll this route to check if it has been deleted. When deleted, the route will return a 404.
     * @summary Enqueues a task to delete the account
     * @param {AccountApiAccountsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsDelete(requestParameters: AccountApiAccountsDeleteRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsDelete(requestParameters.accountId, requestParameters.deleteNow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of all accounts
     * @param {AccountApiAccountsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsGet(requestParameters: AccountApiAccountsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsGet(requestParameters.q, requestParameters.page, requestParameters.count, requestParameters.type, requestParameters.all, requestParameters.state, requestParameters.returnCount, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Open connection to the account
     * @param {AccountApiAccountsOpenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsOpen(requestParameters: AccountApiAccountsOpenRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsOpen(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update name of the account or its settings
     * @summary Update an account
     * @param {AccountApiAccountsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsPatch(requestParameters: AccountApiAccountsPatchRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsPatch(requestParameters.accountId, requestParameters.accountsPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new account
     * @param {AccountApiAccountsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsPost(requestParameters: AccountApiAccountsPostRequest = {}, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsPost(requestParameters.accountsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route simulates creating a new account with the same ID. All data associated with the account is thus retained.
     * @summary Recreate a deleted account
     * @param {AccountApiAccountsRecreatePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsRecreatePost(requestParameters: AccountApiAccountsRecreatePostRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsRecreatePost(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * WA supports login either by QR code or by OTP. This API allows changing the login mode. 
     * @summary Change login mode of a WhatsApp account
     * @param {AccountApiWaChangeLoginModeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public waChangeLoginMode(requestParameters: AccountApiWaChangeLoginModeRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).waChangeLoginMode(requestParameters.accountId, requestParameters.accountWaChangeLoginMode, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AggregateDataApi - axios parameter creator
 * @export
 */
export const AggregateDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Aggregate data for a phone number
         * @param {string} phoneNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateDataPost: async (phoneNumber: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'phoneNumber' is not null or undefined
            assertParamExists('aggregateDataPost', 'phoneNumber', phoneNumber)
            const localVarPath = `/aggregate-data/{phoneNumber}`
                .replace(`{${"phoneNumber"}}`, encodeURIComponent(String(phoneNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AggregateDataApi - functional programming interface
 * @export
 */
export const AggregateDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AggregateDataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Aggregate data for a phone number
         * @param {string} phoneNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aggregateDataPost(phoneNumber: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AggregateDataPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aggregateDataPost(phoneNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AggregateDataApi.aggregateDataPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AggregateDataApi - factory interface
 * @export
 */
export const AggregateDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AggregateDataApiFp(configuration)
    return {
        /**
         * 
         * @summary Aggregate data for a phone number
         * @param {AggregateDataApiAggregateDataPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregateDataPost(requestParameters: AggregateDataApiAggregateDataPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AggregateDataPost200Response> {
            return localVarFp.aggregateDataPost(requestParameters.phoneNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for aggregateDataPost operation in AggregateDataApi.
 * @export
 * @interface AggregateDataApiAggregateDataPostRequest
 */
export interface AggregateDataApiAggregateDataPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AggregateDataApiAggregateDataPost
     */
    readonly phoneNumber: string
}

/**
 * AggregateDataApi - object-oriented interface
 * @export
 * @class AggregateDataApi
 * @extends {BaseAPI}
 */
export class AggregateDataApi extends BaseAPI {
    /**
     * 
     * @summary Aggregate data for a phone number
     * @param {AggregateDataApiAggregateDataPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregateDataApi
     */
    public aggregateDataPost(requestParameters: AggregateDataApiAggregateDataPostRequest, options?: RawAxiosRequestConfig) {
        return AggregateDataApiFp(this.configuration).aggregateDataPost(requestParameters.phoneNumber, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AlibabaCamsApi - axios parameter creator
 * @export
 */
export const AlibabaCamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Submit ISV terms to Alibaba CAMS API
         * @param {string} accountId 
         * @param {AlibabaCAMSISVTerms} [alibabaCAMSISVTerms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsIsvTerms: async (accountId: string, alibabaCAMSISVTerms?: AlibabaCAMSISVTerms, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('alibabaCamsIsvTerms', 'accountId', accountId)
            const localVarPath = `/alibaba-cams/isv-terms/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alibabaCAMSISVTerms, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query metadata for Alibaba CAMS API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsMetadata: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/alibaba-cams/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update business info for Alibaba CAMS API
         * @param {string} accountId 
         * @param {AlibabaCamsProfileUpdateRequest} [alibabaCamsProfileUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsProfileUpdate: async (accountId: string, alibabaCamsProfileUpdateRequest?: AlibabaCamsProfileUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('alibabaCamsProfileUpdate', 'accountId', accountId)
            const localVarPath = `/alibaba-cams/profile/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alibabaCamsProfileUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register an account with a token from embedded sign up
         * @param {string} accountId 
         * @param {AlibabaCamsRegisterRequest} [alibabaCamsRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsRegister: async (accountId: string, alibabaCamsRegisterRequest?: AlibabaCamsRegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('alibabaCamsRegister', 'accountId', accountId)
            const localVarPath = `/alibaba-cams/register/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alibabaCamsRegisterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sync the account state with Alibaba CAMS
         * @param {string} accountId 
         * @param {AlibabaCamsSyncRequest} [alibabaCamsSyncRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsSync: async (accountId: string, alibabaCamsSyncRequest?: AlibabaCamsSyncRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('alibabaCamsSync', 'accountId', accountId)
            const localVarPath = `/alibaba-cams/sync/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alibabaCamsSyncRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Receive a message from Alibaba CAMS API
         * @param {string} accountId 
         * @param {string} secret 
         * @param {Array<AlibabaCAMSWebhookItem>} [alibabaCAMSWebhookItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookAlibabaCamsPost: async (accountId: string, secret: string, alibabaCAMSWebhookItem?: Array<AlibabaCAMSWebhookItem>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('webhookAlibabaCamsPost', 'accountId', accountId)
            // verify required parameter 'secret' is not null or undefined
            assertParamExists('webhookAlibabaCamsPost', 'secret', secret)
            const localVarPath = `/webhook/{accountId}/{secret}/alibaba-cams`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"secret"}}`, encodeURIComponent(String(secret)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alibabaCAMSWebhookItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlibabaCamsApi - functional programming interface
 * @export
 */
export const AlibabaCamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlibabaCamsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Submit ISV terms to Alibaba CAMS API
         * @param {string} accountId 
         * @param {AlibabaCAMSISVTerms} [alibabaCAMSISVTerms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alibabaCamsIsvTerms(accountId: string, alibabaCAMSISVTerms?: AlibabaCAMSISVTerms, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alibabaCamsIsvTerms(accountId, alibabaCAMSISVTerms, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlibabaCamsApi.alibabaCamsIsvTerms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Query metadata for Alibaba CAMS API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alibabaCamsMetadata(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlibabaCamsMetadata200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alibabaCamsMetadata(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlibabaCamsApi.alibabaCamsMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update business info for Alibaba CAMS API
         * @param {string} accountId 
         * @param {AlibabaCamsProfileUpdateRequest} [alibabaCamsProfileUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alibabaCamsProfileUpdate(accountId: string, alibabaCamsProfileUpdateRequest?: AlibabaCamsProfileUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alibabaCamsProfileUpdate(accountId, alibabaCamsProfileUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlibabaCamsApi.alibabaCamsProfileUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register an account with a token from embedded sign up
         * @param {string} accountId 
         * @param {AlibabaCamsRegisterRequest} [alibabaCamsRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alibabaCamsRegister(accountId: string, alibabaCamsRegisterRequest?: AlibabaCamsRegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlibabaCamsRegister200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alibabaCamsRegister(accountId, alibabaCamsRegisterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlibabaCamsApi.alibabaCamsRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sync the account state with Alibaba CAMS
         * @param {string} accountId 
         * @param {AlibabaCamsSyncRequest} [alibabaCamsSyncRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alibabaCamsSync(accountId: string, alibabaCamsSyncRequest?: AlibabaCamsSyncRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlibabaCamsSync200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alibabaCamsSync(accountId, alibabaCamsSyncRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlibabaCamsApi.alibabaCamsSync']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Receive a message from Alibaba CAMS API
         * @param {string} accountId 
         * @param {string} secret 
         * @param {Array<AlibabaCAMSWebhookItem>} [alibabaCAMSWebhookItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookAlibabaCamsPost(accountId: string, secret: string, alibabaCAMSWebhookItem?: Array<AlibabaCAMSWebhookItem>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookAlibabaCamsPost(accountId, secret, alibabaCAMSWebhookItem, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlibabaCamsApi.webhookAlibabaCamsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AlibabaCamsApi - factory interface
 * @export
 */
export const AlibabaCamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlibabaCamsApiFp(configuration)
    return {
        /**
         * 
         * @summary Submit ISV terms to Alibaba CAMS API
         * @param {AlibabaCamsApiAlibabaCamsIsvTermsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsIsvTerms(requestParameters: AlibabaCamsApiAlibabaCamsIsvTermsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.alibabaCamsIsvTerms(requestParameters.accountId, requestParameters.alibabaCAMSISVTerms, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query metadata for Alibaba CAMS API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsMetadata(options?: RawAxiosRequestConfig): AxiosPromise<AlibabaCamsMetadata200Response> {
            return localVarFp.alibabaCamsMetadata(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update business info for Alibaba CAMS API
         * @param {AlibabaCamsApiAlibabaCamsProfileUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsProfileUpdate(requestParameters: AlibabaCamsApiAlibabaCamsProfileUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.alibabaCamsProfileUpdate(requestParameters.accountId, requestParameters.alibabaCamsProfileUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register an account with a token from embedded sign up
         * @param {AlibabaCamsApiAlibabaCamsRegisterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsRegister(requestParameters: AlibabaCamsApiAlibabaCamsRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<AlibabaCamsRegister200Response> {
            return localVarFp.alibabaCamsRegister(requestParameters.accountId, requestParameters.alibabaCamsRegisterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sync the account state with Alibaba CAMS
         * @param {AlibabaCamsApiAlibabaCamsSyncRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsSync(requestParameters: AlibabaCamsApiAlibabaCamsSyncRequest, options?: RawAxiosRequestConfig): AxiosPromise<AlibabaCamsSync200Response> {
            return localVarFp.alibabaCamsSync(requestParameters.accountId, requestParameters.alibabaCamsSyncRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Receive a message from Alibaba CAMS API
         * @param {AlibabaCamsApiWebhookAlibabaCamsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookAlibabaCamsPost(requestParameters: AlibabaCamsApiWebhookAlibabaCamsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.webhookAlibabaCamsPost(requestParameters.accountId, requestParameters.secret, requestParameters.alibabaCAMSWebhookItem, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for alibabaCamsIsvTerms operation in AlibabaCamsApi.
 * @export
 * @interface AlibabaCamsApiAlibabaCamsIsvTermsRequest
 */
export interface AlibabaCamsApiAlibabaCamsIsvTermsRequest {
    /**
     * 
     * @type {string}
     * @memberof AlibabaCamsApiAlibabaCamsIsvTerms
     */
    readonly accountId: string

    /**
     * 
     * @type {AlibabaCAMSISVTerms}
     * @memberof AlibabaCamsApiAlibabaCamsIsvTerms
     */
    readonly alibabaCAMSISVTerms?: AlibabaCAMSISVTerms
}

/**
 * Request parameters for alibabaCamsProfileUpdate operation in AlibabaCamsApi.
 * @export
 * @interface AlibabaCamsApiAlibabaCamsProfileUpdateRequest
 */
export interface AlibabaCamsApiAlibabaCamsProfileUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AlibabaCamsApiAlibabaCamsProfileUpdate
     */
    readonly accountId: string

    /**
     * 
     * @type {AlibabaCamsProfileUpdateRequest}
     * @memberof AlibabaCamsApiAlibabaCamsProfileUpdate
     */
    readonly alibabaCamsProfileUpdateRequest?: AlibabaCamsProfileUpdateRequest
}

/**
 * Request parameters for alibabaCamsRegister operation in AlibabaCamsApi.
 * @export
 * @interface AlibabaCamsApiAlibabaCamsRegisterRequest
 */
export interface AlibabaCamsApiAlibabaCamsRegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof AlibabaCamsApiAlibabaCamsRegister
     */
    readonly accountId: string

    /**
     * 
     * @type {AlibabaCamsRegisterRequest}
     * @memberof AlibabaCamsApiAlibabaCamsRegister
     */
    readonly alibabaCamsRegisterRequest?: AlibabaCamsRegisterRequest
}

/**
 * Request parameters for alibabaCamsSync operation in AlibabaCamsApi.
 * @export
 * @interface AlibabaCamsApiAlibabaCamsSyncRequest
 */
export interface AlibabaCamsApiAlibabaCamsSyncRequest {
    /**
     * 
     * @type {string}
     * @memberof AlibabaCamsApiAlibabaCamsSync
     */
    readonly accountId: string

    /**
     * 
     * @type {AlibabaCamsSyncRequest}
     * @memberof AlibabaCamsApiAlibabaCamsSync
     */
    readonly alibabaCamsSyncRequest?: AlibabaCamsSyncRequest
}

/**
 * Request parameters for webhookAlibabaCamsPost operation in AlibabaCamsApi.
 * @export
 * @interface AlibabaCamsApiWebhookAlibabaCamsPostRequest
 */
export interface AlibabaCamsApiWebhookAlibabaCamsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AlibabaCamsApiWebhookAlibabaCamsPost
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof AlibabaCamsApiWebhookAlibabaCamsPost
     */
    readonly secret: string

    /**
     * 
     * @type {Array<AlibabaCAMSWebhookItem>}
     * @memberof AlibabaCamsApiWebhookAlibabaCamsPost
     */
    readonly alibabaCAMSWebhookItem?: Array<AlibabaCAMSWebhookItem>
}

/**
 * AlibabaCamsApi - object-oriented interface
 * @export
 * @class AlibabaCamsApi
 * @extends {BaseAPI}
 */
export class AlibabaCamsApi extends BaseAPI {
    /**
     * 
     * @summary Submit ISV terms to Alibaba CAMS API
     * @param {AlibabaCamsApiAlibabaCamsIsvTermsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlibabaCamsApi
     */
    public alibabaCamsIsvTerms(requestParameters: AlibabaCamsApiAlibabaCamsIsvTermsRequest, options?: RawAxiosRequestConfig) {
        return AlibabaCamsApiFp(this.configuration).alibabaCamsIsvTerms(requestParameters.accountId, requestParameters.alibabaCAMSISVTerms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query metadata for Alibaba CAMS API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlibabaCamsApi
     */
    public alibabaCamsMetadata(options?: RawAxiosRequestConfig) {
        return AlibabaCamsApiFp(this.configuration).alibabaCamsMetadata(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update business info for Alibaba CAMS API
     * @param {AlibabaCamsApiAlibabaCamsProfileUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlibabaCamsApi
     */
    public alibabaCamsProfileUpdate(requestParameters: AlibabaCamsApiAlibabaCamsProfileUpdateRequest, options?: RawAxiosRequestConfig) {
        return AlibabaCamsApiFp(this.configuration).alibabaCamsProfileUpdate(requestParameters.accountId, requestParameters.alibabaCamsProfileUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register an account with a token from embedded sign up
     * @param {AlibabaCamsApiAlibabaCamsRegisterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlibabaCamsApi
     */
    public alibabaCamsRegister(requestParameters: AlibabaCamsApiAlibabaCamsRegisterRequest, options?: RawAxiosRequestConfig) {
        return AlibabaCamsApiFp(this.configuration).alibabaCamsRegister(requestParameters.accountId, requestParameters.alibabaCamsRegisterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sync the account state with Alibaba CAMS
     * @param {AlibabaCamsApiAlibabaCamsSyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlibabaCamsApi
     */
    public alibabaCamsSync(requestParameters: AlibabaCamsApiAlibabaCamsSyncRequest, options?: RawAxiosRequestConfig) {
        return AlibabaCamsApiFp(this.configuration).alibabaCamsSync(requestParameters.accountId, requestParameters.alibabaCamsSyncRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Receive a message from Alibaba CAMS API
     * @param {AlibabaCamsApiWebhookAlibabaCamsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlibabaCamsApi
     */
    public webhookAlibabaCamsPost(requestParameters: AlibabaCamsApiWebhookAlibabaCamsPostRequest, options?: RawAxiosRequestConfig) {
        return AlibabaCamsApiFp(this.configuration).webhookAlibabaCamsPost(requestParameters.accountId, requestParameters.secret, requestParameters.alibabaCAMSWebhookItem, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CRMApi - axios parameter creator
 * @export
 */
export const CRMApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new CRM ticket
         * @param {CrmTicketBulkPost} [crmTicketBulkPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateTickets: async (crmTicketBulkPost?: CrmTicketBulkPost, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/crm/bulk/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(crmTicketBulkPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete multiple CRM tickets
         * @param {Array<string>} ids Ticket IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteTickets: async (ids: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('bulkDeleteTickets', 'ids', ids)
            const localVarPath = `/crm/bulk/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new CRM ticket
         * @param {CrmTicketPost} [crmTicketPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket: async (crmTicketPost?: CrmTicketPost, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/crm/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(crmTicketPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a CRM board
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmBoardDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('crmBoardDelete', 'id', id)
            const localVarPath = `/crm/boards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All CRM Boards for the Team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmBoardGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/crm/boards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a CRM board
         * @param {string} id 
         * @param {CrmBoardPatch} [crmBoardPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmBoardPatch: async (id: string, crmBoardPatch?: CrmBoardPatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('crmBoardPatch', 'id', id)
            const localVarPath = `/crm/boards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(crmBoardPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new CRM board
         * @param {CrmBoardPost} [crmBoardPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmBoardPost: async (crmBoardPost?: CrmBoardPost, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/crm/boards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(crmBoardPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a CRM ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicket: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTicket', 'id', id)
            const localVarPath = `/crm/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest ticket for a CRM board
         * @param {string} boardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestTicket: async (boardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('getLatestTicket', 'boardId', boardId)
            const localVarPath = `/crm/getLatestTicket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (boardId !== undefined) {
                localVarQueryParameter['boardId'] = boardId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get CRM tickets
         * @param {number} [count] Number of items to return
         * @param {string} [page] 
         * @param {string} [boardId] 
         * @param {string} [stageId] 
         * @param {UniqueContactID} [contactId] 
         * @param {Array<string>} [id] 
         * @param {boolean} [returnTotalCount] 
         * @param {string} [q] Search items by this string
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickets: async (count?: number, page?: string, boardId?: string, stageId?: string, contactId?: UniqueContactID, id?: Array<string>, returnTotalCount?: boolean, q?: string, tags?: ChatsGetTagsParameter, assignee?: ChatsGetAssigneeParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/crm/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (boardId !== undefined) {
                localVarQueryParameter['boardId'] = boardId;
            }

            if (stageId !== undefined) {
                localVarQueryParameter['stageId'] = stageId;
            }

            if (contactId !== undefined) {
                localVarQueryParameter['contactId'] = contactId;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get CRM tickets grouped by stage
         * @param {number} [count] Number of items to return
         * @param {string} [page] 
         * @param {string} [boardId] 
         * @param {string} [stageId] 
         * @param {UniqueContactID} [contactId] 
         * @param {boolean} [returnTotalCount] 
         * @param {string} [q] Search items by this string
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketsByStage: async (count?: number, page?: string, boardId?: string, stageId?: string, contactId?: UniqueContactID, returnTotalCount?: boolean, q?: string, tags?: ChatsGetTagsParameter, assignee?: ChatsGetAssigneeParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/crm/tickets/by-stage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (boardId !== undefined) {
                localVarQueryParameter['boardId'] = boardId;
            }

            if (stageId !== undefined) {
                localVarQueryParameter['stageId'] = stageId;
            }

            if (contactId !== undefined) {
                localVarQueryParameter['contactId'] = contactId;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start a timer for a CRM ticket
         * @param {string} id 
         * @param {TicketTimerCreate} [ticketTimerCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTicketTimer: async (id: string, ticketTimerCreate?: TicketTimerCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startTicketTimer', 'id', id)
            const localVarPath = `/crm/tickets/{id}/timer/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketTimerCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If no timer is running, this will return the ticket as is.
         * @summary Stop a timer for a CRM ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTicketTimer: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stopTicketTimer', 'id', id)
            const localVarPath = `/crm/tickets/{id}/timer/stop`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a CRM ticket
         * @param {string} id 
         * @param {CrmTicketPatch} [crmTicketPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicket: async (id: string, crmTicketPatch?: CrmTicketPatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTicket', 'id', id)
            const localVarPath = `/crm/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(crmTicketPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CRMApi - functional programming interface
 * @export
 */
export const CRMApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CRMApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new CRM ticket
         * @param {CrmTicketBulkPost} [crmTicketBulkPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkCreateTickets(crmTicketBulkPost?: CrmTicketBulkPost, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CrmTicket>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreateTickets(crmTicketBulkPost, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CRMApi.bulkCreateTickets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete multiple CRM tickets
         * @param {Array<string>} ids Ticket IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkDeleteTickets(ids: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteTickets(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CRMApi.bulkDeleteTickets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new CRM ticket
         * @param {CrmTicketPost} [crmTicketPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTicket(crmTicketPost?: CrmTicketPost, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrmTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTicket(crmTicketPost, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CRMApi.createTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a CRM board
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crmBoardDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crmBoardDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CRMApi.crmBoardDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get All CRM Boards for the Team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crmBoardGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrmBoardGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crmBoardGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CRMApi.crmBoardGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a CRM board
         * @param {string} id 
         * @param {CrmBoardPatch} [crmBoardPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crmBoardPatch(id: string, crmBoardPatch?: CrmBoardPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrmBoard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crmBoardPatch(id, crmBoardPatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CRMApi.crmBoardPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new CRM board
         * @param {CrmBoardPost} [crmBoardPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crmBoardPost(crmBoardPost?: CrmBoardPost, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrmBoard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crmBoardPost(crmBoardPost, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CRMApi.crmBoardPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a CRM ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTicket(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTicket(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CRMApi.deleteTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the latest ticket for a CRM board
         * @param {string} boardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestTicket(boardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLatestTicket200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestTicket(boardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CRMApi.getLatestTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get CRM tickets
         * @param {number} [count] Number of items to return
         * @param {string} [page] 
         * @param {string} [boardId] 
         * @param {string} [stageId] 
         * @param {UniqueContactID} [contactId] 
         * @param {Array<string>} [id] 
         * @param {boolean} [returnTotalCount] 
         * @param {string} [q] Search items by this string
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickets(count?: number, page?: string, boardId?: string, stageId?: string, contactId?: UniqueContactID, id?: Array<string>, returnTotalCount?: boolean, q?: string, tags?: ChatsGetTagsParameter, assignee?: ChatsGetAssigneeParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrmTicketsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickets(count, page, boardId, stageId, contactId, id, returnTotalCount, q, tags, assignee, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CRMApi.getTickets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get CRM tickets grouped by stage
         * @param {number} [count] Number of items to return
         * @param {string} [page] 
         * @param {string} [boardId] 
         * @param {string} [stageId] 
         * @param {UniqueContactID} [contactId] 
         * @param {boolean} [returnTotalCount] 
         * @param {string} [q] Search items by this string
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicketsByStage(count?: number, page?: string, boardId?: string, stageId?: string, contactId?: UniqueContactID, returnTotalCount?: boolean, q?: string, tags?: ChatsGetTagsParameter, assignee?: ChatsGetAssigneeParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTicketsByStage200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketsByStage(count, page, boardId, stageId, contactId, returnTotalCount, q, tags, assignee, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CRMApi.getTicketsByStage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Start a timer for a CRM ticket
         * @param {string} id 
         * @param {TicketTimerCreate} [ticketTimerCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startTicketTimer(id: string, ticketTimerCreate?: TicketTimerCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrmTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startTicketTimer(id, ticketTimerCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CRMApi.startTicketTimer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If no timer is running, this will return the ticket as is.
         * @summary Stop a timer for a CRM ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopTicketTimer(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrmTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopTicketTimer(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CRMApi.stopTicketTimer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a CRM ticket
         * @param {string} id 
         * @param {CrmTicketPatch} [crmTicketPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTicket(id: string, crmTicketPatch?: CrmTicketPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrmTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTicket(id, crmTicketPatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CRMApi.updateTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CRMApi - factory interface
 * @export
 */
export const CRMApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CRMApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new CRM ticket
         * @param {CRMApiBulkCreateTicketsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateTickets(requestParameters: CRMApiBulkCreateTicketsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<CrmTicket>> {
            return localVarFp.bulkCreateTickets(requestParameters.crmTicketBulkPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete multiple CRM tickets
         * @param {CRMApiBulkDeleteTicketsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteTickets(requestParameters: CRMApiBulkDeleteTicketsRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.bulkDeleteTickets(requestParameters.ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new CRM ticket
         * @param {CRMApiCreateTicketRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket(requestParameters: CRMApiCreateTicketRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CrmTicket> {
            return localVarFp.createTicket(requestParameters.crmTicketPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a CRM board
         * @param {CRMApiCrmBoardDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmBoardDelete(requestParameters: CRMApiCrmBoardDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.crmBoardDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All CRM Boards for the Team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmBoardGet(options?: RawAxiosRequestConfig): AxiosPromise<CrmBoardGet200Response> {
            return localVarFp.crmBoardGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a CRM board
         * @param {CRMApiCrmBoardPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmBoardPatch(requestParameters: CRMApiCrmBoardPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<CrmBoard> {
            return localVarFp.crmBoardPatch(requestParameters.id, requestParameters.crmBoardPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new CRM board
         * @param {CRMApiCrmBoardPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmBoardPost(requestParameters: CRMApiCrmBoardPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CrmBoard> {
            return localVarFp.crmBoardPost(requestParameters.crmBoardPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a CRM ticket
         * @param {CRMApiDeleteTicketRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicket(requestParameters: CRMApiDeleteTicketRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.deleteTicket(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest ticket for a CRM board
         * @param {CRMApiGetLatestTicketRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestTicket(requestParameters: CRMApiGetLatestTicketRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetLatestTicket200Response> {
            return localVarFp.getLatestTicket(requestParameters.boardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get CRM tickets
         * @param {CRMApiGetTicketsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickets(requestParameters: CRMApiGetTicketsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CrmTicketsPage> {
            return localVarFp.getTickets(requestParameters.count, requestParameters.page, requestParameters.boardId, requestParameters.stageId, requestParameters.contactId, requestParameters.id, requestParameters.returnTotalCount, requestParameters.q, requestParameters.tags, requestParameters.assignee, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get CRM tickets grouped by stage
         * @param {CRMApiGetTicketsByStageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketsByStage(requestParameters: CRMApiGetTicketsByStageRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetTicketsByStage200Response> {
            return localVarFp.getTicketsByStage(requestParameters.count, requestParameters.page, requestParameters.boardId, requestParameters.stageId, requestParameters.contactId, requestParameters.returnTotalCount, requestParameters.q, requestParameters.tags, requestParameters.assignee, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start a timer for a CRM ticket
         * @param {CRMApiStartTicketTimerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTicketTimer(requestParameters: CRMApiStartTicketTimerRequest, options?: RawAxiosRequestConfig): AxiosPromise<CrmTicket> {
            return localVarFp.startTicketTimer(requestParameters.id, requestParameters.ticketTimerCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * If no timer is running, this will return the ticket as is.
         * @summary Stop a timer for a CRM ticket
         * @param {CRMApiStopTicketTimerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTicketTimer(requestParameters: CRMApiStopTicketTimerRequest, options?: RawAxiosRequestConfig): AxiosPromise<CrmTicket> {
            return localVarFp.stopTicketTimer(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a CRM ticket
         * @param {CRMApiUpdateTicketRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicket(requestParameters: CRMApiUpdateTicketRequest, options?: RawAxiosRequestConfig): AxiosPromise<CrmTicket> {
            return localVarFp.updateTicket(requestParameters.id, requestParameters.crmTicketPatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for bulkCreateTickets operation in CRMApi.
 * @export
 * @interface CRMApiBulkCreateTicketsRequest
 */
export interface CRMApiBulkCreateTicketsRequest {
    /**
     * 
     * @type {CrmTicketBulkPost}
     * @memberof CRMApiBulkCreateTickets
     */
    readonly crmTicketBulkPost?: CrmTicketBulkPost
}

/**
 * Request parameters for bulkDeleteTickets operation in CRMApi.
 * @export
 * @interface CRMApiBulkDeleteTicketsRequest
 */
export interface CRMApiBulkDeleteTicketsRequest {
    /**
     * Ticket IDs to delete
     * @type {Array<string>}
     * @memberof CRMApiBulkDeleteTickets
     */
    readonly ids: Array<string>
}

/**
 * Request parameters for createTicket operation in CRMApi.
 * @export
 * @interface CRMApiCreateTicketRequest
 */
export interface CRMApiCreateTicketRequest {
    /**
     * 
     * @type {CrmTicketPost}
     * @memberof CRMApiCreateTicket
     */
    readonly crmTicketPost?: CrmTicketPost
}

/**
 * Request parameters for crmBoardDelete operation in CRMApi.
 * @export
 * @interface CRMApiCrmBoardDeleteRequest
 */
export interface CRMApiCrmBoardDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof CRMApiCrmBoardDelete
     */
    readonly id: string
}

/**
 * Request parameters for crmBoardPatch operation in CRMApi.
 * @export
 * @interface CRMApiCrmBoardPatchRequest
 */
export interface CRMApiCrmBoardPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof CRMApiCrmBoardPatch
     */
    readonly id: string

    /**
     * 
     * @type {CrmBoardPatch}
     * @memberof CRMApiCrmBoardPatch
     */
    readonly crmBoardPatch?: CrmBoardPatch
}

/**
 * Request parameters for crmBoardPost operation in CRMApi.
 * @export
 * @interface CRMApiCrmBoardPostRequest
 */
export interface CRMApiCrmBoardPostRequest {
    /**
     * 
     * @type {CrmBoardPost}
     * @memberof CRMApiCrmBoardPost
     */
    readonly crmBoardPost?: CrmBoardPost
}

/**
 * Request parameters for deleteTicket operation in CRMApi.
 * @export
 * @interface CRMApiDeleteTicketRequest
 */
export interface CRMApiDeleteTicketRequest {
    /**
     * 
     * @type {string}
     * @memberof CRMApiDeleteTicket
     */
    readonly id: string
}

/**
 * Request parameters for getLatestTicket operation in CRMApi.
 * @export
 * @interface CRMApiGetLatestTicketRequest
 */
export interface CRMApiGetLatestTicketRequest {
    /**
     * 
     * @type {string}
     * @memberof CRMApiGetLatestTicket
     */
    readonly boardId: string
}

/**
 * Request parameters for getTickets operation in CRMApi.
 * @export
 * @interface CRMApiGetTicketsRequest
 */
export interface CRMApiGetTicketsRequest {
    /**
     * Number of items to return
     * @type {number}
     * @memberof CRMApiGetTickets
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof CRMApiGetTickets
     */
    readonly page?: string

    /**
     * 
     * @type {string}
     * @memberof CRMApiGetTickets
     */
    readonly boardId?: string

    /**
     * 
     * @type {string}
     * @memberof CRMApiGetTickets
     */
    readonly stageId?: string

    /**
     * 
     * @type {UniqueContactID}
     * @memberof CRMApiGetTickets
     */
    readonly contactId?: UniqueContactID

    /**
     * 
     * @type {Array<string>}
     * @memberof CRMApiGetTickets
     */
    readonly id?: Array<string>

    /**
     * 
     * @type {boolean}
     * @memberof CRMApiGetTickets
     */
    readonly returnTotalCount?: boolean

    /**
     * Search items by this string
     * @type {string}
     * @memberof CRMApiGetTickets
     */
    readonly q?: string

    /**
     * Get contacts who fall in either of these tags
     * @type {ChatsGetTagsParameter}
     * @memberof CRMApiGetTickets
     */
    readonly tags?: ChatsGetTagsParameter

    /**
     * Get contacts assigned to the specified users
     * @type {ChatsGetAssigneeParameter}
     * @memberof CRMApiGetTickets
     */
    readonly assignee?: ChatsGetAssigneeParameter
}

/**
 * Request parameters for getTicketsByStage operation in CRMApi.
 * @export
 * @interface CRMApiGetTicketsByStageRequest
 */
export interface CRMApiGetTicketsByStageRequest {
    /**
     * Number of items to return
     * @type {number}
     * @memberof CRMApiGetTicketsByStage
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof CRMApiGetTicketsByStage
     */
    readonly page?: string

    /**
     * 
     * @type {string}
     * @memberof CRMApiGetTicketsByStage
     */
    readonly boardId?: string

    /**
     * 
     * @type {string}
     * @memberof CRMApiGetTicketsByStage
     */
    readonly stageId?: string

    /**
     * 
     * @type {UniqueContactID}
     * @memberof CRMApiGetTicketsByStage
     */
    readonly contactId?: UniqueContactID

    /**
     * 
     * @type {boolean}
     * @memberof CRMApiGetTicketsByStage
     */
    readonly returnTotalCount?: boolean

    /**
     * Search items by this string
     * @type {string}
     * @memberof CRMApiGetTicketsByStage
     */
    readonly q?: string

    /**
     * Get contacts who fall in either of these tags
     * @type {ChatsGetTagsParameter}
     * @memberof CRMApiGetTicketsByStage
     */
    readonly tags?: ChatsGetTagsParameter

    /**
     * Get contacts assigned to the specified users
     * @type {ChatsGetAssigneeParameter}
     * @memberof CRMApiGetTicketsByStage
     */
    readonly assignee?: ChatsGetAssigneeParameter
}

/**
 * Request parameters for startTicketTimer operation in CRMApi.
 * @export
 * @interface CRMApiStartTicketTimerRequest
 */
export interface CRMApiStartTicketTimerRequest {
    /**
     * 
     * @type {string}
     * @memberof CRMApiStartTicketTimer
     */
    readonly id: string

    /**
     * 
     * @type {TicketTimerCreate}
     * @memberof CRMApiStartTicketTimer
     */
    readonly ticketTimerCreate?: TicketTimerCreate
}

/**
 * Request parameters for stopTicketTimer operation in CRMApi.
 * @export
 * @interface CRMApiStopTicketTimerRequest
 */
export interface CRMApiStopTicketTimerRequest {
    /**
     * 
     * @type {string}
     * @memberof CRMApiStopTicketTimer
     */
    readonly id: string
}

/**
 * Request parameters for updateTicket operation in CRMApi.
 * @export
 * @interface CRMApiUpdateTicketRequest
 */
export interface CRMApiUpdateTicketRequest {
    /**
     * 
     * @type {string}
     * @memberof CRMApiUpdateTicket
     */
    readonly id: string

    /**
     * 
     * @type {CrmTicketPatch}
     * @memberof CRMApiUpdateTicket
     */
    readonly crmTicketPatch?: CrmTicketPatch
}

/**
 * CRMApi - object-oriented interface
 * @export
 * @class CRMApi
 * @extends {BaseAPI}
 */
export class CRMApi extends BaseAPI {
    /**
     * 
     * @summary Create a new CRM ticket
     * @param {CRMApiBulkCreateTicketsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public bulkCreateTickets(requestParameters: CRMApiBulkCreateTicketsRequest = {}, options?: RawAxiosRequestConfig) {
        return CRMApiFp(this.configuration).bulkCreateTickets(requestParameters.crmTicketBulkPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete multiple CRM tickets
     * @param {CRMApiBulkDeleteTicketsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public bulkDeleteTickets(requestParameters: CRMApiBulkDeleteTicketsRequest, options?: RawAxiosRequestConfig) {
        return CRMApiFp(this.configuration).bulkDeleteTickets(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new CRM ticket
     * @param {CRMApiCreateTicketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public createTicket(requestParameters: CRMApiCreateTicketRequest = {}, options?: RawAxiosRequestConfig) {
        return CRMApiFp(this.configuration).createTicket(requestParameters.crmTicketPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a CRM board
     * @param {CRMApiCrmBoardDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public crmBoardDelete(requestParameters: CRMApiCrmBoardDeleteRequest, options?: RawAxiosRequestConfig) {
        return CRMApiFp(this.configuration).crmBoardDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get All CRM Boards for the Team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public crmBoardGet(options?: RawAxiosRequestConfig) {
        return CRMApiFp(this.configuration).crmBoardGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a CRM board
     * @param {CRMApiCrmBoardPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public crmBoardPatch(requestParameters: CRMApiCrmBoardPatchRequest, options?: RawAxiosRequestConfig) {
        return CRMApiFp(this.configuration).crmBoardPatch(requestParameters.id, requestParameters.crmBoardPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new CRM board
     * @param {CRMApiCrmBoardPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public crmBoardPost(requestParameters: CRMApiCrmBoardPostRequest = {}, options?: RawAxiosRequestConfig) {
        return CRMApiFp(this.configuration).crmBoardPost(requestParameters.crmBoardPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a CRM ticket
     * @param {CRMApiDeleteTicketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public deleteTicket(requestParameters: CRMApiDeleteTicketRequest, options?: RawAxiosRequestConfig) {
        return CRMApiFp(this.configuration).deleteTicket(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest ticket for a CRM board
     * @param {CRMApiGetLatestTicketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public getLatestTicket(requestParameters: CRMApiGetLatestTicketRequest, options?: RawAxiosRequestConfig) {
        return CRMApiFp(this.configuration).getLatestTicket(requestParameters.boardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get CRM tickets
     * @param {CRMApiGetTicketsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public getTickets(requestParameters: CRMApiGetTicketsRequest = {}, options?: RawAxiosRequestConfig) {
        return CRMApiFp(this.configuration).getTickets(requestParameters.count, requestParameters.page, requestParameters.boardId, requestParameters.stageId, requestParameters.contactId, requestParameters.id, requestParameters.returnTotalCount, requestParameters.q, requestParameters.tags, requestParameters.assignee, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get CRM tickets grouped by stage
     * @param {CRMApiGetTicketsByStageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public getTicketsByStage(requestParameters: CRMApiGetTicketsByStageRequest = {}, options?: RawAxiosRequestConfig) {
        return CRMApiFp(this.configuration).getTicketsByStage(requestParameters.count, requestParameters.page, requestParameters.boardId, requestParameters.stageId, requestParameters.contactId, requestParameters.returnTotalCount, requestParameters.q, requestParameters.tags, requestParameters.assignee, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start a timer for a CRM ticket
     * @param {CRMApiStartTicketTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public startTicketTimer(requestParameters: CRMApiStartTicketTimerRequest, options?: RawAxiosRequestConfig) {
        return CRMApiFp(this.configuration).startTicketTimer(requestParameters.id, requestParameters.ticketTimerCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If no timer is running, this will return the ticket as is.
     * @summary Stop a timer for a CRM ticket
     * @param {CRMApiStopTicketTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public stopTicketTimer(requestParameters: CRMApiStopTicketTimerRequest, options?: RawAxiosRequestConfig) {
        return CRMApiFp(this.configuration).stopTicketTimer(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a CRM ticket
     * @param {CRMApiUpdateTicketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public updateTicket(requestParameters: CRMApiUpdateTicketRequest, options?: RawAxiosRequestConfig) {
        return CRMApiFp(this.configuration).updateTicket(requestParameters.id, requestParameters.crmTicketPatch, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChatsApi - axios parameter creator
 * @export
 */
export const ChatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get chats
         * @param {number} [count] Number of items to return
         * @param {string} [page] 
         * @param {boolean} [archive] 
         * @param {boolean} [unread] Only get chats with unread/read messages
         * @param {boolean} [returnTotalCount] 
         * @param {boolean} [hasPendingMessage] 
         * @param {string} [mentioned] 
         * @param {boolean} [hasUnsolvedNote] 
         * @param {boolean} [hasFailedMessage] 
         * @param {boolean} [lastMessageFromMe] Only get chats where the last message was sent by me/not me
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {ChatsGetContactsParameter} [contacts] Get these specific contact ids
         * @param {string} [q] Search items by this string
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {ContactType} [type] only get contacts of type
         * @param {ChatsGetTicketParameter} [ticket] Query the status of a ticket
         * @param {Array<string>} [notAssignee] Exclude contacts assigned to the specified users
         * @param {boolean} [returnUnreadChatCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsGet: async (count?: number, page?: string, archive?: boolean, unread?: boolean, returnTotalCount?: boolean, hasPendingMessage?: boolean, mentioned?: string, hasUnsolvedNote?: boolean, hasFailedMessage?: boolean, lastMessageFromMe?: boolean, tags?: ChatsGetTagsParameter, notTags?: Array<string>, contacts?: ChatsGetContactsParameter, q?: string, assignee?: ChatsGetAssigneeParameter, accountId?: Array<string>, type?: ContactType, ticket?: ChatsGetTicketParameter, notAssignee?: Array<string>, returnUnreadChatCount?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL", "CHATS_ACCESS_ASSIGNED"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (archive !== undefined) {
                localVarQueryParameter['archive'] = archive;
            }

            if (unread !== undefined) {
                localVarQueryParameter['unread'] = unread;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }

            if (hasPendingMessage !== undefined) {
                localVarQueryParameter['hasPendingMessage'] = hasPendingMessage;
            }

            if (mentioned !== undefined) {
                localVarQueryParameter['mentioned'] = mentioned;
            }

            if (hasUnsolvedNote !== undefined) {
                localVarQueryParameter['hasUnsolvedNote'] = hasUnsolvedNote;
            }

            if (hasFailedMessage !== undefined) {
                localVarQueryParameter['hasFailedMessage'] = hasFailedMessage;
            }

            if (lastMessageFromMe !== undefined) {
                localVarQueryParameter['lastMessageFromMe'] = lastMessageFromMe;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (notTags) {
                localVarQueryParameter['notTags'] = notTags;
            }

            if (contacts !== undefined) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (ticket !== undefined) {
                localVarQueryParameter['ticket'] = ticket;
            }

            if (notAssignee) {
                localVarQueryParameter['notAssignee'] = notAssignee;
            }

            if (returnUnreadChatCount !== undefined) {
                localVarQueryParameter['returnUnreadChatCount'] = returnUnreadChatCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a chat -- read, unread, archive, pin etc.
         * @param {string} accountId 
         * @param {string} id 
         * @param {ChatAction} [chatAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPatch: async (accountId: string, id: string, chatAction?: ChatAction, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('chatsPatch', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsPatch', 'id', id)
            const localVarPath = `/chats/{accountId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL", "CHATS_ACCESS_ASSIGNED"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: Sending an \"available\" presence, will also subscribe you to events from the other party
         * @summary Update a chat\'s presence.
         * @param {string} accountId 
         * @param {string} id 
         * @param {PresenceType} presence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPresencePost: async (accountId: string, id: string, presence: PresenceType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('chatsPresencePost', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsPresencePost', 'id', id)
            // verify required parameter 'presence' is not null or undefined
            assertParamExists('chatsPresencePost', 'presence', presence)
            const localVarPath = `/chats/{accountId}/{id}/presence`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ASSIGNED", "CHATS_ACCESS_ALL"], configuration)

            if (presence !== undefined) {
                localVarQueryParameter['presence'] = presence;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the total count of channels. Can be filtered by account type and creation date range. Supports preset filters (daily, weekly, monthly) or custom date ranges. 
         * @summary Get channel count
         * @param {AccountType} [type] Filter by account type
         * @param {string} [createdAfter] Filter channels created after this timestamp (inclusive). Can be used with createdBefore to create a custom date range. 
         * @param {string} [createdBefore] Filter channels created before this timestamp (exclusive). Can be used with createdAfter to create a custom date range. 
         * @param {GetChannelCountPresetEnum} [preset] Preset time range filter. Calculates channel count for the specified period from the current time. Overrides createdAfter/createdBefore if provided. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelCount: async (type?: AccountType, createdAfter?: string, createdBefore?: string, preset?: GetChannelCountPresetEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/channel-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['createdAfter'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['createdBefore'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (preset !== undefined) {
                localVarQueryParameter['preset'] = preset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Compares the current live channel counts with snapshots from a specific date. Returns comparison for total channels and each channel type (WhatsApp, WABA, Instagram, Messenger). 
         * @summary Compare channel counts between two dates
         * @param {string} compareDate Date to compare against (YYYY-MM-DD). Compares current counts vs this date\&#39;s snapshot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelCountComparison: async (compareDate: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compareDate' is not null or undefined
            assertParamExists('getChannelCountComparison', 'compareDate', compareDate)
            const localVarPath = `/channel-count-comparison`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (compareDate !== undefined) {
                localVarQueryParameter['compareDate'] = (compareDate as any instanceof Date) ?
                    (compareDate as any).toISOString().substring(0,10) :
                    compareDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves historical daily channel count snapshots. Returns pre-calculated channel counts for each day, useful for displaying historical trends. 
         * @summary Get daily channel snapshots
         * @param {string} [startDate] Start date for snapshot range (YYYY-MM-DD)
         * @param {string} [endDate] End date for snapshot range (YYYY-MM-DD)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDailyChannelSnapshots: async (startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/channel-snapshots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves a snapshot of connected channel counts for a specific date. This endpoint is typically called by a cron job at the end of each day. 
         * @summary Save daily channel snapshot
         * @param {SaveDailyChannelSnapshotRequest} [saveDailyChannelSnapshotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDailyChannelSnapshot: async (saveDailyChannelSnapshotRequest?: SaveDailyChannelSnapshotRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/channel-snapshots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveDailyChannelSnapshotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatsApi - functional programming interface
 * @export
 */
export const ChatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get chats
         * @param {number} [count] Number of items to return
         * @param {string} [page] 
         * @param {boolean} [archive] 
         * @param {boolean} [unread] Only get chats with unread/read messages
         * @param {boolean} [returnTotalCount] 
         * @param {boolean} [hasPendingMessage] 
         * @param {string} [mentioned] 
         * @param {boolean} [hasUnsolvedNote] 
         * @param {boolean} [hasFailedMessage] 
         * @param {boolean} [lastMessageFromMe] Only get chats where the last message was sent by me/not me
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {ChatsGetContactsParameter} [contacts] Get these specific contact ids
         * @param {string} [q] Search items by this string
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {ContactType} [type] only get contacts of type
         * @param {ChatsGetTicketParameter} [ticket] Query the status of a ticket
         * @param {Array<string>} [notAssignee] Exclude contacts assigned to the specified users
         * @param {boolean} [returnUnreadChatCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsGet(count?: number, page?: string, archive?: boolean, unread?: boolean, returnTotalCount?: boolean, hasPendingMessage?: boolean, mentioned?: string, hasUnsolvedNote?: boolean, hasFailedMessage?: boolean, lastMessageFromMe?: boolean, tags?: ChatsGetTagsParameter, notTags?: Array<string>, contacts?: ChatsGetContactsParameter, q?: string, assignee?: ChatsGetAssigneeParameter, accountId?: Array<string>, type?: ContactType, ticket?: ChatsGetTicketParameter, notAssignee?: Array<string>, returnUnreadChatCount?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsGet(count, page, archive, unread, returnTotalCount, hasPendingMessage, mentioned, hasUnsolvedNote, hasFailedMessage, lastMessageFromMe, tags, notTags, contacts, q, assignee, accountId, type, ticket, notAssignee, returnUnreadChatCount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatsApi.chatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a chat -- read, unread, archive, pin etc.
         * @param {string} accountId 
         * @param {string} id 
         * @param {ChatAction} [chatAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsPatch(accountId: string, id: string, chatAction?: ChatAction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsPatch(accountId, id, chatAction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatsApi.chatsPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Note: Sending an \"available\" presence, will also subscribe you to events from the other party
         * @summary Update a chat\'s presence.
         * @param {string} accountId 
         * @param {string} id 
         * @param {PresenceType} presence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsPresencePost(accountId: string, id: string, presence: PresenceType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsPresencePost(accountId, id, presence, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatsApi.chatsPresencePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the total count of channels. Can be filtered by account type and creation date range. Supports preset filters (daily, weekly, monthly) or custom date ranges. 
         * @summary Get channel count
         * @param {AccountType} [type] Filter by account type
         * @param {string} [createdAfter] Filter channels created after this timestamp (inclusive). Can be used with createdBefore to create a custom date range. 
         * @param {string} [createdBefore] Filter channels created before this timestamp (exclusive). Can be used with createdAfter to create a custom date range. 
         * @param {GetChannelCountPresetEnum} [preset] Preset time range filter. Calculates channel count for the specified period from the current time. Overrides createdAfter/createdBefore if provided. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelCount(type?: AccountType, createdAfter?: string, createdBefore?: string, preset?: GetChannelCountPresetEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChannelCount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChannelCount(type, createdAfter, createdBefore, preset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatsApi.getChannelCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Compares the current live channel counts with snapshots from a specific date. Returns comparison for total channels and each channel type (WhatsApp, WABA, Instagram, Messenger). 
         * @summary Compare channel counts between two dates
         * @param {string} compareDate Date to compare against (YYYY-MM-DD). Compares current counts vs this date\&#39;s snapshot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelCountComparison(compareDate: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChannelCountComparison200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChannelCountComparison(compareDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatsApi.getChannelCountComparison']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves historical daily channel count snapshots. Returns pre-calculated channel counts for each day, useful for displaying historical trends. 
         * @summary Get daily channel snapshots
         * @param {string} [startDate] Start date for snapshot range (YYYY-MM-DD)
         * @param {string} [endDate] End date for snapshot range (YYYY-MM-DD)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDailyChannelSnapshots(startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDailyChannelSnapshots200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDailyChannelSnapshots(startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatsApi.getDailyChannelSnapshots']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves a snapshot of connected channel counts for a specific date. This endpoint is typically called by a cron job at the end of each day. 
         * @summary Save daily channel snapshot
         * @param {SaveDailyChannelSnapshotRequest} [saveDailyChannelSnapshotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveDailyChannelSnapshot(saveDailyChannelSnapshotRequest?: SaveDailyChannelSnapshotRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveDailyChannelSnapshot200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveDailyChannelSnapshot(saveDailyChannelSnapshotRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatsApi.saveDailyChannelSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatsApi - factory interface
 * @export
 */
export const ChatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get chats
         * @param {ChatsApiChatsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsGet(requestParameters: ChatsApiChatsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ChatsGet200Response> {
            return localVarFp.chatsGet(requestParameters.count, requestParameters.page, requestParameters.archive, requestParameters.unread, requestParameters.returnTotalCount, requestParameters.hasPendingMessage, requestParameters.mentioned, requestParameters.hasUnsolvedNote, requestParameters.hasFailedMessage, requestParameters.lastMessageFromMe, requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.q, requestParameters.assignee, requestParameters.accountId, requestParameters.type, requestParameters.ticket, requestParameters.notAssignee, requestParameters.returnUnreadChatCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a chat -- read, unread, archive, pin etc.
         * @param {ChatsApiChatsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPatch(requestParameters: ChatsApiChatsPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Chat> {
            return localVarFp.chatsPatch(requestParameters.accountId, requestParameters.id, requestParameters.chatAction, options).then((request) => request(axios, basePath));
        },
        /**
         * Note: Sending an \"available\" presence, will also subscribe you to events from the other party
         * @summary Update a chat\'s presence.
         * @param {ChatsApiChatsPresencePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPresencePost(requestParameters: ChatsApiChatsPresencePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.chatsPresencePost(requestParameters.accountId, requestParameters.id, requestParameters.presence, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the total count of channels. Can be filtered by account type and creation date range. Supports preset filters (daily, weekly, monthly) or custom date ranges. 
         * @summary Get channel count
         * @param {ChatsApiGetChannelCountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelCount(requestParameters: ChatsApiGetChannelCountRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetChannelCount200Response> {
            return localVarFp.getChannelCount(requestParameters.type, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.preset, options).then((request) => request(axios, basePath));
        },
        /**
         * Compares the current live channel counts with snapshots from a specific date. Returns comparison for total channels and each channel type (WhatsApp, WABA, Instagram, Messenger). 
         * @summary Compare channel counts between two dates
         * @param {ChatsApiGetChannelCountComparisonRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelCountComparison(requestParameters: ChatsApiGetChannelCountComparisonRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetChannelCountComparison200Response> {
            return localVarFp.getChannelCountComparison(requestParameters.compareDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves historical daily channel count snapshots. Returns pre-calculated channel counts for each day, useful for displaying historical trends. 
         * @summary Get daily channel snapshots
         * @param {ChatsApiGetDailyChannelSnapshotsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDailyChannelSnapshots(requestParameters: ChatsApiGetDailyChannelSnapshotsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetDailyChannelSnapshots200Response> {
            return localVarFp.getDailyChannelSnapshots(requestParameters.startDate, requestParameters.endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves a snapshot of connected channel counts for a specific date. This endpoint is typically called by a cron job at the end of each day. 
         * @summary Save daily channel snapshot
         * @param {ChatsApiSaveDailyChannelSnapshotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDailyChannelSnapshot(requestParameters: ChatsApiSaveDailyChannelSnapshotRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<SaveDailyChannelSnapshot200Response> {
            return localVarFp.saveDailyChannelSnapshot(requestParameters.saveDailyChannelSnapshotRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for chatsGet operation in ChatsApi.
 * @export
 * @interface ChatsApiChatsGetRequest
 */
export interface ChatsApiChatsGetRequest {
    /**
     * Number of items to return
     * @type {number}
     * @memberof ChatsApiChatsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsGet
     */
    readonly page?: string

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly archive?: boolean

    /**
     * Only get chats with unread/read messages
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly unread?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly returnTotalCount?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly hasPendingMessage?: boolean

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsGet
     */
    readonly mentioned?: string

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly hasUnsolvedNote?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly hasFailedMessage?: boolean

    /**
     * Only get chats where the last message was sent by me/not me
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly lastMessageFromMe?: boolean

    /**
     * Get contacts who fall in either of these tags
     * @type {ChatsGetTagsParameter}
     * @memberof ChatsApiChatsGet
     */
    readonly tags?: ChatsGetTagsParameter

    /**
     * Get contacts who are not in any of these tags
     * @type {Array<string>}
     * @memberof ChatsApiChatsGet
     */
    readonly notTags?: Array<string>

    /**
     * Get these specific contact ids
     * @type {ChatsGetContactsParameter}
     * @memberof ChatsApiChatsGet
     */
    readonly contacts?: ChatsGetContactsParameter

    /**
     * Search items by this string
     * @type {string}
     * @memberof ChatsApiChatsGet
     */
    readonly q?: string

    /**
     * Get contacts assigned to the specified users
     * @type {ChatsGetAssigneeParameter}
     * @memberof ChatsApiChatsGet
     */
    readonly assignee?: ChatsGetAssigneeParameter

    /**
     * Get contacts only belonging to this account
     * @type {Array<string>}
     * @memberof ChatsApiChatsGet
     */
    readonly accountId?: Array<string>

    /**
     * only get contacts of type
     * @type {ContactType}
     * @memberof ChatsApiChatsGet
     */
    readonly type?: ContactType

    /**
     * Query the status of a ticket
     * @type {ChatsGetTicketParameter}
     * @memberof ChatsApiChatsGet
     */
    readonly ticket?: ChatsGetTicketParameter

    /**
     * Exclude contacts assigned to the specified users
     * @type {Array<string>}
     * @memberof ChatsApiChatsGet
     */
    readonly notAssignee?: Array<string>

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly returnUnreadChatCount?: boolean
}

/**
 * Request parameters for chatsPatch operation in ChatsApi.
 * @export
 * @interface ChatsApiChatsPatchRequest
 */
export interface ChatsApiChatsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsPatch
     */
    readonly id: string

    /**
     * 
     * @type {ChatAction}
     * @memberof ChatsApiChatsPatch
     */
    readonly chatAction?: ChatAction
}

/**
 * Request parameters for chatsPresencePost operation in ChatsApi.
 * @export
 * @interface ChatsApiChatsPresencePostRequest
 */
export interface ChatsApiChatsPresencePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsPresencePost
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsPresencePost
     */
    readonly id: string

    /**
     * 
     * @type {PresenceType}
     * @memberof ChatsApiChatsPresencePost
     */
    readonly presence: PresenceType
}

/**
 * Request parameters for getChannelCount operation in ChatsApi.
 * @export
 * @interface ChatsApiGetChannelCountRequest
 */
export interface ChatsApiGetChannelCountRequest {
    /**
     * Filter by account type
     * @type {AccountType}
     * @memberof ChatsApiGetChannelCount
     */
    readonly type?: AccountType

    /**
     * Filter channels created after this timestamp (inclusive). Can be used with createdBefore to create a custom date range. 
     * @type {string}
     * @memberof ChatsApiGetChannelCount
     */
    readonly createdAfter?: string

    /**
     * Filter channels created before this timestamp (exclusive). Can be used with createdAfter to create a custom date range. 
     * @type {string}
     * @memberof ChatsApiGetChannelCount
     */
    readonly createdBefore?: string

    /**
     * Preset time range filter. Calculates channel count for the specified period from the current time. Overrides createdAfter/createdBefore if provided. 
     * @type {'daily' | 'weekly' | 'monthly'}
     * @memberof ChatsApiGetChannelCount
     */
    readonly preset?: GetChannelCountPresetEnum
}

/**
 * Request parameters for getChannelCountComparison operation in ChatsApi.
 * @export
 * @interface ChatsApiGetChannelCountComparisonRequest
 */
export interface ChatsApiGetChannelCountComparisonRequest {
    /**
     * Date to compare against (YYYY-MM-DD). Compares current counts vs this date\&#39;s snapshot.
     * @type {string}
     * @memberof ChatsApiGetChannelCountComparison
     */
    readonly compareDate: string
}

/**
 * Request parameters for getDailyChannelSnapshots operation in ChatsApi.
 * @export
 * @interface ChatsApiGetDailyChannelSnapshotsRequest
 */
export interface ChatsApiGetDailyChannelSnapshotsRequest {
    /**
     * Start date for snapshot range (YYYY-MM-DD)
     * @type {string}
     * @memberof ChatsApiGetDailyChannelSnapshots
     */
    readonly startDate?: string

    /**
     * End date for snapshot range (YYYY-MM-DD)
     * @type {string}
     * @memberof ChatsApiGetDailyChannelSnapshots
     */
    readonly endDate?: string
}

/**
 * Request parameters for saveDailyChannelSnapshot operation in ChatsApi.
 * @export
 * @interface ChatsApiSaveDailyChannelSnapshotRequest
 */
export interface ChatsApiSaveDailyChannelSnapshotRequest {
    /**
     * 
     * @type {SaveDailyChannelSnapshotRequest}
     * @memberof ChatsApiSaveDailyChannelSnapshot
     */
    readonly saveDailyChannelSnapshotRequest?: SaveDailyChannelSnapshotRequest
}

/**
 * ChatsApi - object-oriented interface
 * @export
 * @class ChatsApi
 * @extends {BaseAPI}
 */
export class ChatsApi extends BaseAPI {
    /**
     * 
     * @summary Get chats
     * @param {ChatsApiChatsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatsGet(requestParameters: ChatsApiChatsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatsGet(requestParameters.count, requestParameters.page, requestParameters.archive, requestParameters.unread, requestParameters.returnTotalCount, requestParameters.hasPendingMessage, requestParameters.mentioned, requestParameters.hasUnsolvedNote, requestParameters.hasFailedMessage, requestParameters.lastMessageFromMe, requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.q, requestParameters.assignee, requestParameters.accountId, requestParameters.type, requestParameters.ticket, requestParameters.notAssignee, requestParameters.returnUnreadChatCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a chat -- read, unread, archive, pin etc.
     * @param {ChatsApiChatsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatsPatch(requestParameters: ChatsApiChatsPatchRequest, options?: RawAxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatsPatch(requestParameters.accountId, requestParameters.id, requestParameters.chatAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: Sending an \"available\" presence, will also subscribe you to events from the other party
     * @summary Update a chat\'s presence.
     * @param {ChatsApiChatsPresencePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatsPresencePost(requestParameters: ChatsApiChatsPresencePostRequest, options?: RawAxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatsPresencePost(requestParameters.accountId, requestParameters.id, requestParameters.presence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the total count of channels. Can be filtered by account type and creation date range. Supports preset filters (daily, weekly, monthly) or custom date ranges. 
     * @summary Get channel count
     * @param {ChatsApiGetChannelCountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public getChannelCount(requestParameters: ChatsApiGetChannelCountRequest = {}, options?: RawAxiosRequestConfig) {
        return ChatsApiFp(this.configuration).getChannelCount(requestParameters.type, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.preset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Compares the current live channel counts with snapshots from a specific date. Returns comparison for total channels and each channel type (WhatsApp, WABA, Instagram, Messenger). 
     * @summary Compare channel counts between two dates
     * @param {ChatsApiGetChannelCountComparisonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public getChannelCountComparison(requestParameters: ChatsApiGetChannelCountComparisonRequest, options?: RawAxiosRequestConfig) {
        return ChatsApiFp(this.configuration).getChannelCountComparison(requestParameters.compareDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves historical daily channel count snapshots. Returns pre-calculated channel counts for each day, useful for displaying historical trends. 
     * @summary Get daily channel snapshots
     * @param {ChatsApiGetDailyChannelSnapshotsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public getDailyChannelSnapshots(requestParameters: ChatsApiGetDailyChannelSnapshotsRequest = {}, options?: RawAxiosRequestConfig) {
        return ChatsApiFp(this.configuration).getDailyChannelSnapshots(requestParameters.startDate, requestParameters.endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves a snapshot of connected channel counts for a specific date. This endpoint is typically called by a cron job at the end of each day. 
     * @summary Save daily channel snapshot
     * @param {ChatsApiSaveDailyChannelSnapshotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public saveDailyChannelSnapshot(requestParameters: ChatsApiSaveDailyChannelSnapshotRequest = {}, options?: RawAxiosRequestConfig) {
        return ChatsApiFp(this.configuration).saveDailyChannelSnapshot(requestParameters.saveDailyChannelSnapshotRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetChannelCountPresetEnum = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;
export type GetChannelCountPresetEnum = typeof GetChannelCountPresetEnum[keyof typeof GetChannelCountPresetEnum];


/**
 * ContactsApi - axios parameter creator
 * @export
 */
export const ContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Eg. provide a phone number to check whether the user is registered on WhatsApp
         * @summary Check a given user exists on the IM platform
         * @param {ContactsCheckExistsTypeEnum} type which account type to check from
         * @param {string} [phoneNumber] Phone number to check
         * @param {string} [username] Username to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsCheckExists: async (type: ContactsCheckExistsTypeEnum, phoneNumber?: string, username?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('contactsCheckExists', 'type', type)
            const localVarPath = `/contacts/exists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_READ_ALL"], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (phoneNumber !== undefined) {
                localVarQueryParameter['phoneNumber'] = phoneNumber;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete contacts
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {ChatsGetContactsParameter} [contacts] Get these specific contact ids
         * @param {ChatsGetContactsParameter} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search items by this string
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [notAssignee] Exclude contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {ContactType} [type] only get contacts of type
         * @param {string} [chatLastMessageFrom] 
         * @param {string} [chatLastMessageTo] 
         * @param {boolean} [lastMessageFromMe] Only get chats where the last message was sent by me/not me
         * @param {boolean} [unread] Only get chats with unread/read messages
         * @param {ChatsGetTicketParameter} [ticket] Query the status of a ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDelete: async (tags?: ChatsGetTagsParameter, notTags?: Array<string>, contacts?: ChatsGetContactsParameter, notContacts?: ChatsGetContactsParameter, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: ChatsGetAssigneeParameter, notAssignee?: Array<string>, accountId?: Array<string>, type?: ContactType, chatLastMessageFrom?: string, chatLastMessageTo?: string, lastMessageFromMe?: boolean, unread?: boolean, ticket?: ChatsGetTicketParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_DELETE"], configuration)

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (notTags) {
                localVarQueryParameter['notTags'] = notTags;
            }

            if (contacts !== undefined) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (notContacts !== undefined) {
                localVarQueryParameter['notContacts'] = notContacts;
            }

            if (minMessagesSent !== undefined) {
                localVarQueryParameter['minMessagesSent'] = minMessagesSent;
            }

            if (minMessagesRecv !== undefined) {
                localVarQueryParameter['minMessagesRecv'] = minMessagesRecv;
            }

            if (maxMessagesSent !== undefined) {
                localVarQueryParameter['maxMessagesSent'] = maxMessagesSent;
            }

            if (maxMessagesRecv !== undefined) {
                localVarQueryParameter['maxMessagesRecv'] = maxMessagesRecv;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (notAssignee) {
                localVarQueryParameter['notAssignee'] = notAssignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (chatLastMessageFrom !== undefined) {
                localVarQueryParameter['chatLastMessageFrom'] = (chatLastMessageFrom as any instanceof Date) ?
                    (chatLastMessageFrom as any).toISOString() :
                    chatLastMessageFrom;
            }

            if (chatLastMessageTo !== undefined) {
                localVarQueryParameter['chatLastMessageTo'] = (chatLastMessageTo as any instanceof Date) ?
                    (chatLastMessageTo as any).toISOString() :
                    chatLastMessageTo;
            }

            if (lastMessageFromMe !== undefined) {
                localVarQueryParameter['lastMessageFromMe'] = lastMessageFromMe;
            }

            if (unread !== undefined) {
                localVarQueryParameter['unread'] = unread;
            }

            if (ticket !== undefined) {
                localVarQueryParameter['ticket'] = ticket;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get contacts
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {ChatsGetContactsParameter} [contacts] Get these specific contact ids
         * @param {ChatsGetContactsParameter} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search items by this string
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [notAssignee] Exclude contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {ContactType} [type] only get contacts of type
         * @param {string} [chatLastMessageFrom] 
         * @param {string} [chatLastMessageTo] 
         * @param {boolean} [lastMessageFromMe] Only get chats where the last message was sent by me/not me
         * @param {boolean} [unread] Only get chats with unread/read messages
         * @param {ChatsGetTicketParameter} [ticket] Query the status of a ticket
         * @param {boolean} [orderByTicketOrder] 
         * @param {boolean} [returnTotalCount] 
         * @param {boolean} [returnLastMessage] 
         * @param {string} [page] 
         * @param {number} [count] Number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGet: async (tags?: ChatsGetTagsParameter, notTags?: Array<string>, contacts?: ChatsGetContactsParameter, notContacts?: ChatsGetContactsParameter, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: ChatsGetAssigneeParameter, notAssignee?: Array<string>, accountId?: Array<string>, type?: ContactType, chatLastMessageFrom?: string, chatLastMessageTo?: string, lastMessageFromMe?: boolean, unread?: boolean, ticket?: ChatsGetTicketParameter, orderByTicketOrder?: boolean, returnTotalCount?: boolean, returnLastMessage?: boolean, page?: string, count?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_READ_ALL", "CONTACTS_READ_ASSIGNED"], configuration)

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (notTags) {
                localVarQueryParameter['notTags'] = notTags;
            }

            if (contacts !== undefined) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (notContacts !== undefined) {
                localVarQueryParameter['notContacts'] = notContacts;
            }

            if (minMessagesSent !== undefined) {
                localVarQueryParameter['minMessagesSent'] = minMessagesSent;
            }

            if (minMessagesRecv !== undefined) {
                localVarQueryParameter['minMessagesRecv'] = minMessagesRecv;
            }

            if (maxMessagesSent !== undefined) {
                localVarQueryParameter['maxMessagesSent'] = maxMessagesSent;
            }

            if (maxMessagesRecv !== undefined) {
                localVarQueryParameter['maxMessagesRecv'] = maxMessagesRecv;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (notAssignee) {
                localVarQueryParameter['notAssignee'] = notAssignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (chatLastMessageFrom !== undefined) {
                localVarQueryParameter['chatLastMessageFrom'] = (chatLastMessageFrom as any instanceof Date) ?
                    (chatLastMessageFrom as any).toISOString() :
                    chatLastMessageFrom;
            }

            if (chatLastMessageTo !== undefined) {
                localVarQueryParameter['chatLastMessageTo'] = (chatLastMessageTo as any instanceof Date) ?
                    (chatLastMessageTo as any).toISOString() :
                    chatLastMessageTo;
            }

            if (lastMessageFromMe !== undefined) {
                localVarQueryParameter['lastMessageFromMe'] = lastMessageFromMe;
            }

            if (unread !== undefined) {
                localVarQueryParameter['unread'] = unread;
            }

            if (ticket !== undefined) {
                localVarQueryParameter['ticket'] = ticket;
            }

            if (orderByTicketOrder !== undefined) {
                localVarQueryParameter['orderByTicketOrder'] = orderByTicketOrder;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }

            if (returnLastMessage !== undefined) {
                localVarQueryParameter['returnLastMessage'] = returnLastMessage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the display image of a contact
         * @param {string} id 
         * @param {string} accountId 
         * @param {ContactsImageGetTypeEnum} [type] Whether to fetch preview sized image or the full image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsImageGet: async (id: string, accountId: string, type?: ContactsImageGetTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contactsImageGet', 'id', id)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('contactsImageGet', 'accountId', accountId)
            const localVarPath = `/contacts/{accountId}/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update contacts
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {ChatsGetContactsParameter} [contacts] Get these specific contact ids
         * @param {ChatsGetContactsParameter} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search items by this string
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [notAssignee] Exclude contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {ContactType} [type] only get contacts of type
         * @param {string} [chatLastMessageFrom] 
         * @param {string} [chatLastMessageTo] 
         * @param {boolean} [lastMessageFromMe] Only get chats where the last message was sent by me/not me
         * @param {boolean} [unread] Only get chats with unread/read messages
         * @param {ChatsGetTicketParameter} [ticket] Query the status of a ticket
         * @param {ContactsPatch} [contactsPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPatch: async (tags?: ChatsGetTagsParameter, notTags?: Array<string>, contacts?: ChatsGetContactsParameter, notContacts?: ChatsGetContactsParameter, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: ChatsGetAssigneeParameter, notAssignee?: Array<string>, accountId?: Array<string>, type?: ContactType, chatLastMessageFrom?: string, chatLastMessageTo?: string, lastMessageFromMe?: boolean, unread?: boolean, ticket?: ChatsGetTicketParameter, contactsPatch?: ContactsPatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_UPDATE"], configuration)

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (notTags) {
                localVarQueryParameter['notTags'] = notTags;
            }

            if (contacts !== undefined) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (notContacts !== undefined) {
                localVarQueryParameter['notContacts'] = notContacts;
            }

            if (minMessagesSent !== undefined) {
                localVarQueryParameter['minMessagesSent'] = minMessagesSent;
            }

            if (minMessagesRecv !== undefined) {
                localVarQueryParameter['minMessagesRecv'] = minMessagesRecv;
            }

            if (maxMessagesSent !== undefined) {
                localVarQueryParameter['maxMessagesSent'] = maxMessagesSent;
            }

            if (maxMessagesRecv !== undefined) {
                localVarQueryParameter['maxMessagesRecv'] = maxMessagesRecv;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (notAssignee) {
                localVarQueryParameter['notAssignee'] = notAssignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (chatLastMessageFrom !== undefined) {
                localVarQueryParameter['chatLastMessageFrom'] = (chatLastMessageFrom as any instanceof Date) ?
                    (chatLastMessageFrom as any).toISOString() :
                    chatLastMessageFrom;
            }

            if (chatLastMessageTo !== undefined) {
                localVarQueryParameter['chatLastMessageTo'] = (chatLastMessageTo as any instanceof Date) ?
                    (chatLastMessageTo as any).toISOString() :
                    chatLastMessageTo;
            }

            if (lastMessageFromMe !== undefined) {
                localVarQueryParameter['lastMessageFromMe'] = lastMessageFromMe;
            }

            if (unread !== undefined) {
                localVarQueryParameter['unread'] = unread;
            }

            if (ticket !== undefined) {
                localVarQueryParameter['ticket'] = ticket;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactsPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create contacts
         * @param {ContactsPost} [contactsPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPost: async (contactsPost?: ContactsPost, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts/upsert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactsPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsApi - functional programming interface
 * @export
 */
export const ContactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactsApiAxiosParamCreator(configuration)
    return {
        /**
         * Eg. provide a phone number to check whether the user is registered on WhatsApp
         * @summary Check a given user exists on the IM platform
         * @param {ContactsCheckExistsTypeEnum} type which account type to check from
         * @param {string} [phoneNumber] Phone number to check
         * @param {string} [username] Username to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsCheckExists(type: ContactsCheckExistsTypeEnum, phoneNumber?: string, username?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsCheckExists200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsCheckExists(type, phoneNumber, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsCheckExists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete contacts
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {ChatsGetContactsParameter} [contacts] Get these specific contact ids
         * @param {ChatsGetContactsParameter} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search items by this string
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [notAssignee] Exclude contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {ContactType} [type] only get contacts of type
         * @param {string} [chatLastMessageFrom] 
         * @param {string} [chatLastMessageTo] 
         * @param {boolean} [lastMessageFromMe] Only get chats where the last message was sent by me/not me
         * @param {boolean} [unread] Only get chats with unread/read messages
         * @param {ChatsGetTicketParameter} [ticket] Query the status of a ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsDelete(tags?: ChatsGetTagsParameter, notTags?: Array<string>, contacts?: ChatsGetContactsParameter, notContacts?: ChatsGetContactsParameter, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: ChatsGetAssigneeParameter, notAssignee?: Array<string>, accountId?: Array<string>, type?: ContactType, chatLastMessageFrom?: string, chatLastMessageTo?: string, lastMessageFromMe?: boolean, unread?: boolean, ticket?: ChatsGetTicketParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsDelete(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, notAssignee, accountId, type, chatLastMessageFrom, chatLastMessageTo, lastMessageFromMe, unread, ticket, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get contacts
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {ChatsGetContactsParameter} [contacts] Get these specific contact ids
         * @param {ChatsGetContactsParameter} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search items by this string
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [notAssignee] Exclude contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {ContactType} [type] only get contacts of type
         * @param {string} [chatLastMessageFrom] 
         * @param {string} [chatLastMessageTo] 
         * @param {boolean} [lastMessageFromMe] Only get chats where the last message was sent by me/not me
         * @param {boolean} [unread] Only get chats with unread/read messages
         * @param {ChatsGetTicketParameter} [ticket] Query the status of a ticket
         * @param {boolean} [orderByTicketOrder] 
         * @param {boolean} [returnTotalCount] 
         * @param {boolean} [returnLastMessage] 
         * @param {string} [page] 
         * @param {number} [count] Number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsGet(tags?: ChatsGetTagsParameter, notTags?: Array<string>, contacts?: ChatsGetContactsParameter, notContacts?: ChatsGetContactsParameter, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: ChatsGetAssigneeParameter, notAssignee?: Array<string>, accountId?: Array<string>, type?: ContactType, chatLastMessageFrom?: string, chatLastMessageTo?: string, lastMessageFromMe?: boolean, unread?: boolean, ticket?: ChatsGetTicketParameter, orderByTicketOrder?: boolean, returnTotalCount?: boolean, returnLastMessage?: boolean, page?: string, count?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsGet(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, notAssignee, accountId, type, chatLastMessageFrom, chatLastMessageTo, lastMessageFromMe, unread, ticket, orderByTicketOrder, returnTotalCount, returnLastMessage, page, count, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the display image of a contact
         * @param {string} id 
         * @param {string} accountId 
         * @param {ContactsImageGetTypeEnum} [type] Whether to fetch preview sized image or the full image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsImageGet(id: string, accountId: string, type?: ContactsImageGetTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsImageGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsImageGet(id, accountId, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsImageGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update contacts
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {ChatsGetContactsParameter} [contacts] Get these specific contact ids
         * @param {ChatsGetContactsParameter} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search items by this string
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [notAssignee] Exclude contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {ContactType} [type] only get contacts of type
         * @param {string} [chatLastMessageFrom] 
         * @param {string} [chatLastMessageTo] 
         * @param {boolean} [lastMessageFromMe] Only get chats where the last message was sent by me/not me
         * @param {boolean} [unread] Only get chats with unread/read messages
         * @param {ChatsGetTicketParameter} [ticket] Query the status of a ticket
         * @param {ContactsPatch} [contactsPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPatch(tags?: ChatsGetTagsParameter, notTags?: Array<string>, contacts?: ChatsGetContactsParameter, notContacts?: ChatsGetContactsParameter, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: ChatsGetAssigneeParameter, notAssignee?: Array<string>, accountId?: Array<string>, type?: ContactType, chatLastMessageFrom?: string, chatLastMessageTo?: string, lastMessageFromMe?: boolean, unread?: boolean, ticket?: ChatsGetTicketParameter, contactsPatch?: ContactsPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPatch(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, notAssignee, accountId, type, chatLastMessageFrom, chatLastMessageTo, lastMessageFromMe, unread, ticket, contactsPatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create contacts
         * @param {ContactsPost} [contactsPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPost(contactsPost?: ContactsPost, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPost(contactsPost, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsApi.contactsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactsApi - factory interface
 * @export
 */
export const ContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactsApiFp(configuration)
    return {
        /**
         * Eg. provide a phone number to check whether the user is registered on WhatsApp
         * @summary Check a given user exists on the IM platform
         * @param {ContactsApiContactsCheckExistsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsCheckExists(requestParameters: ContactsApiContactsCheckExistsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactsCheckExists200Response> {
            return localVarFp.contactsCheckExists(requestParameters.type, requestParameters.phoneNumber, requestParameters.username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete contacts
         * @param {ContactsApiContactsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDelete(requestParameters: ContactsApiContactsDeleteRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.contactsDelete(requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.notContacts, requestParameters.minMessagesSent, requestParameters.minMessagesRecv, requestParameters.maxMessagesSent, requestParameters.maxMessagesRecv, requestParameters.q, requestParameters.assignee, requestParameters.notAssignee, requestParameters.accountId, requestParameters.type, requestParameters.chatLastMessageFrom, requestParameters.chatLastMessageTo, requestParameters.lastMessageFromMe, requestParameters.unread, requestParameters.ticket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get contacts
         * @param {ContactsApiContactsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGet(requestParameters: ContactsApiContactsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ContactsGet200Response> {
            return localVarFp.contactsGet(requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.notContacts, requestParameters.minMessagesSent, requestParameters.minMessagesRecv, requestParameters.maxMessagesSent, requestParameters.maxMessagesRecv, requestParameters.q, requestParameters.assignee, requestParameters.notAssignee, requestParameters.accountId, requestParameters.type, requestParameters.chatLastMessageFrom, requestParameters.chatLastMessageTo, requestParameters.lastMessageFromMe, requestParameters.unread, requestParameters.ticket, requestParameters.orderByTicketOrder, requestParameters.returnTotalCount, requestParameters.returnLastMessage, requestParameters.page, requestParameters.count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the display image of a contact
         * @param {ContactsApiContactsImageGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsImageGet(requestParameters: ContactsApiContactsImageGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContactsImageGet200Response> {
            return localVarFp.contactsImageGet(requestParameters.id, requestParameters.accountId, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update contacts
         * @param {ContactsApiContactsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPatch(requestParameters: ContactsApiContactsPatchRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ContactsPatch200Response> {
            return localVarFp.contactsPatch(requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.notContacts, requestParameters.minMessagesSent, requestParameters.minMessagesRecv, requestParameters.maxMessagesSent, requestParameters.maxMessagesRecv, requestParameters.q, requestParameters.assignee, requestParameters.notAssignee, requestParameters.accountId, requestParameters.type, requestParameters.chatLastMessageFrom, requestParameters.chatLastMessageTo, requestParameters.lastMessageFromMe, requestParameters.unread, requestParameters.ticket, requestParameters.contactsPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create contacts
         * @param {ContactsApiContactsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPost(requestParameters: ContactsApiContactsPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.contactsPost(requestParameters.contactsPost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for contactsCheckExists operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsCheckExistsRequest
 */
export interface ContactsApiContactsCheckExistsRequest {
    /**
     * which account type to check from
     * @type {'whatsapp' | 'tiktok'}
     * @memberof ContactsApiContactsCheckExists
     */
    readonly type: ContactsCheckExistsTypeEnum

    /**
     * Phone number to check
     * @type {string}
     * @memberof ContactsApiContactsCheckExists
     */
    readonly phoneNumber?: string

    /**
     * Username to check
     * @type {string}
     * @memberof ContactsApiContactsCheckExists
     */
    readonly username?: string
}

/**
 * Request parameters for contactsDelete operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsDeleteRequest
 */
export interface ContactsApiContactsDeleteRequest {
    /**
     * Get contacts who fall in either of these tags
     * @type {ChatsGetTagsParameter}
     * @memberof ContactsApiContactsDelete
     */
    readonly tags?: ChatsGetTagsParameter

    /**
     * Get contacts who are not in any of these tags
     * @type {Array<string>}
     * @memberof ContactsApiContactsDelete
     */
    readonly notTags?: Array<string>

    /**
     * Get these specific contact ids
     * @type {ChatsGetContactsParameter}
     * @memberof ContactsApiContactsDelete
     */
    readonly contacts?: ChatsGetContactsParameter

    /**
     * Do not get these specific contacts
     * @type {ChatsGetContactsParameter}
     * @memberof ContactsApiContactsDelete
     */
    readonly notContacts?: ChatsGetContactsParameter

    /**
     * Minimum messages sent
     * @type {number}
     * @memberof ContactsApiContactsDelete
     */
    readonly minMessagesSent?: number

    /**
     * Minimum messages received
     * @type {number}
     * @memberof ContactsApiContactsDelete
     */
    readonly minMessagesRecv?: number

    /**
     * Maximum messages sent
     * @type {number}
     * @memberof ContactsApiContactsDelete
     */
    readonly maxMessagesSent?: number

    /**
     * Maximum messages received
     * @type {number}
     * @memberof ContactsApiContactsDelete
     */
    readonly maxMessagesRecv?: number

    /**
     * Search items by this string
     * @type {string}
     * @memberof ContactsApiContactsDelete
     */
    readonly q?: string

    /**
     * Get contacts assigned to the specified users
     * @type {ChatsGetAssigneeParameter}
     * @memberof ContactsApiContactsDelete
     */
    readonly assignee?: ChatsGetAssigneeParameter

    /**
     * Exclude contacts assigned to the specified users
     * @type {Array<string>}
     * @memberof ContactsApiContactsDelete
     */
    readonly notAssignee?: Array<string>

    /**
     * Get contacts only belonging to this account
     * @type {Array<string>}
     * @memberof ContactsApiContactsDelete
     */
    readonly accountId?: Array<string>

    /**
     * only get contacts of type
     * @type {ContactType}
     * @memberof ContactsApiContactsDelete
     */
    readonly type?: ContactType

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsDelete
     */
    readonly chatLastMessageFrom?: string

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsDelete
     */
    readonly chatLastMessageTo?: string

    /**
     * Only get chats where the last message was sent by me/not me
     * @type {boolean}
     * @memberof ContactsApiContactsDelete
     */
    readonly lastMessageFromMe?: boolean

    /**
     * Only get chats with unread/read messages
     * @type {boolean}
     * @memberof ContactsApiContactsDelete
     */
    readonly unread?: boolean

    /**
     * Query the status of a ticket
     * @type {ChatsGetTicketParameter}
     * @memberof ContactsApiContactsDelete
     */
    readonly ticket?: ChatsGetTicketParameter
}

/**
 * Request parameters for contactsGet operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsGetRequest
 */
export interface ContactsApiContactsGetRequest {
    /**
     * Get contacts who fall in either of these tags
     * @type {ChatsGetTagsParameter}
     * @memberof ContactsApiContactsGet
     */
    readonly tags?: ChatsGetTagsParameter

    /**
     * Get contacts who are not in any of these tags
     * @type {Array<string>}
     * @memberof ContactsApiContactsGet
     */
    readonly notTags?: Array<string>

    /**
     * Get these specific contact ids
     * @type {ChatsGetContactsParameter}
     * @memberof ContactsApiContactsGet
     */
    readonly contacts?: ChatsGetContactsParameter

    /**
     * Do not get these specific contacts
     * @type {ChatsGetContactsParameter}
     * @memberof ContactsApiContactsGet
     */
    readonly notContacts?: ChatsGetContactsParameter

    /**
     * Minimum messages sent
     * @type {number}
     * @memberof ContactsApiContactsGet
     */
    readonly minMessagesSent?: number

    /**
     * Minimum messages received
     * @type {number}
     * @memberof ContactsApiContactsGet
     */
    readonly minMessagesRecv?: number

    /**
     * Maximum messages sent
     * @type {number}
     * @memberof ContactsApiContactsGet
     */
    readonly maxMessagesSent?: number

    /**
     * Maximum messages received
     * @type {number}
     * @memberof ContactsApiContactsGet
     */
    readonly maxMessagesRecv?: number

    /**
     * Search items by this string
     * @type {string}
     * @memberof ContactsApiContactsGet
     */
    readonly q?: string

    /**
     * Get contacts assigned to the specified users
     * @type {ChatsGetAssigneeParameter}
     * @memberof ContactsApiContactsGet
     */
    readonly assignee?: ChatsGetAssigneeParameter

    /**
     * Exclude contacts assigned to the specified users
     * @type {Array<string>}
     * @memberof ContactsApiContactsGet
     */
    readonly notAssignee?: Array<string>

    /**
     * Get contacts only belonging to this account
     * @type {Array<string>}
     * @memberof ContactsApiContactsGet
     */
    readonly accountId?: Array<string>

    /**
     * only get contacts of type
     * @type {ContactType}
     * @memberof ContactsApiContactsGet
     */
    readonly type?: ContactType

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsGet
     */
    readonly chatLastMessageFrom?: string

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsGet
     */
    readonly chatLastMessageTo?: string

    /**
     * Only get chats where the last message was sent by me/not me
     * @type {boolean}
     * @memberof ContactsApiContactsGet
     */
    readonly lastMessageFromMe?: boolean

    /**
     * Only get chats with unread/read messages
     * @type {boolean}
     * @memberof ContactsApiContactsGet
     */
    readonly unread?: boolean

    /**
     * Query the status of a ticket
     * @type {ChatsGetTicketParameter}
     * @memberof ContactsApiContactsGet
     */
    readonly ticket?: ChatsGetTicketParameter

    /**
     * 
     * @type {boolean}
     * @memberof ContactsApiContactsGet
     */
    readonly orderByTicketOrder?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ContactsApiContactsGet
     */
    readonly returnTotalCount?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ContactsApiContactsGet
     */
    readonly returnLastMessage?: boolean

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsGet
     */
    readonly page?: string

    /**
     * Number of items to return
     * @type {number}
     * @memberof ContactsApiContactsGet
     */
    readonly count?: number
}

/**
 * Request parameters for contactsImageGet operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsImageGetRequest
 */
export interface ContactsApiContactsImageGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsImageGet
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsImageGet
     */
    readonly accountId: string

    /**
     * Whether to fetch preview sized image or the full image
     * @type {'preview' | 'full'}
     * @memberof ContactsApiContactsImageGet
     */
    readonly type?: ContactsImageGetTypeEnum
}

/**
 * Request parameters for contactsPatch operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsPatchRequest
 */
export interface ContactsApiContactsPatchRequest {
    /**
     * Get contacts who fall in either of these tags
     * @type {ChatsGetTagsParameter}
     * @memberof ContactsApiContactsPatch
     */
    readonly tags?: ChatsGetTagsParameter

    /**
     * Get contacts who are not in any of these tags
     * @type {Array<string>}
     * @memberof ContactsApiContactsPatch
     */
    readonly notTags?: Array<string>

    /**
     * Get these specific contact ids
     * @type {ChatsGetContactsParameter}
     * @memberof ContactsApiContactsPatch
     */
    readonly contacts?: ChatsGetContactsParameter

    /**
     * Do not get these specific contacts
     * @type {ChatsGetContactsParameter}
     * @memberof ContactsApiContactsPatch
     */
    readonly notContacts?: ChatsGetContactsParameter

    /**
     * Minimum messages sent
     * @type {number}
     * @memberof ContactsApiContactsPatch
     */
    readonly minMessagesSent?: number

    /**
     * Minimum messages received
     * @type {number}
     * @memberof ContactsApiContactsPatch
     */
    readonly minMessagesRecv?: number

    /**
     * Maximum messages sent
     * @type {number}
     * @memberof ContactsApiContactsPatch
     */
    readonly maxMessagesSent?: number

    /**
     * Maximum messages received
     * @type {number}
     * @memberof ContactsApiContactsPatch
     */
    readonly maxMessagesRecv?: number

    /**
     * Search items by this string
     * @type {string}
     * @memberof ContactsApiContactsPatch
     */
    readonly q?: string

    /**
     * Get contacts assigned to the specified users
     * @type {ChatsGetAssigneeParameter}
     * @memberof ContactsApiContactsPatch
     */
    readonly assignee?: ChatsGetAssigneeParameter

    /**
     * Exclude contacts assigned to the specified users
     * @type {Array<string>}
     * @memberof ContactsApiContactsPatch
     */
    readonly notAssignee?: Array<string>

    /**
     * Get contacts only belonging to this account
     * @type {Array<string>}
     * @memberof ContactsApiContactsPatch
     */
    readonly accountId?: Array<string>

    /**
     * only get contacts of type
     * @type {ContactType}
     * @memberof ContactsApiContactsPatch
     */
    readonly type?: ContactType

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsPatch
     */
    readonly chatLastMessageFrom?: string

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsPatch
     */
    readonly chatLastMessageTo?: string

    /**
     * Only get chats where the last message was sent by me/not me
     * @type {boolean}
     * @memberof ContactsApiContactsPatch
     */
    readonly lastMessageFromMe?: boolean

    /**
     * Only get chats with unread/read messages
     * @type {boolean}
     * @memberof ContactsApiContactsPatch
     */
    readonly unread?: boolean

    /**
     * Query the status of a ticket
     * @type {ChatsGetTicketParameter}
     * @memberof ContactsApiContactsPatch
     */
    readonly ticket?: ChatsGetTicketParameter

    /**
     * 
     * @type {ContactsPatch}
     * @memberof ContactsApiContactsPatch
     */
    readonly contactsPatch?: ContactsPatch
}

/**
 * Request parameters for contactsPost operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsPostRequest
 */
export interface ContactsApiContactsPostRequest {
    /**
     * 
     * @type {ContactsPost}
     * @memberof ContactsApiContactsPost
     */
    readonly contactsPost?: ContactsPost
}

/**
 * ContactsApi - object-oriented interface
 * @export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
export class ContactsApi extends BaseAPI {
    /**
     * Eg. provide a phone number to check whether the user is registered on WhatsApp
     * @summary Check a given user exists on the IM platform
     * @param {ContactsApiContactsCheckExistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsCheckExists(requestParameters: ContactsApiContactsCheckExistsRequest, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsCheckExists(requestParameters.type, requestParameters.phoneNumber, requestParameters.username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete contacts
     * @param {ContactsApiContactsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsDelete(requestParameters: ContactsApiContactsDeleteRequest = {}, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsDelete(requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.notContacts, requestParameters.minMessagesSent, requestParameters.minMessagesRecv, requestParameters.maxMessagesSent, requestParameters.maxMessagesRecv, requestParameters.q, requestParameters.assignee, requestParameters.notAssignee, requestParameters.accountId, requestParameters.type, requestParameters.chatLastMessageFrom, requestParameters.chatLastMessageTo, requestParameters.lastMessageFromMe, requestParameters.unread, requestParameters.ticket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get contacts
     * @param {ContactsApiContactsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsGet(requestParameters: ContactsApiContactsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsGet(requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.notContacts, requestParameters.minMessagesSent, requestParameters.minMessagesRecv, requestParameters.maxMessagesSent, requestParameters.maxMessagesRecv, requestParameters.q, requestParameters.assignee, requestParameters.notAssignee, requestParameters.accountId, requestParameters.type, requestParameters.chatLastMessageFrom, requestParameters.chatLastMessageTo, requestParameters.lastMessageFromMe, requestParameters.unread, requestParameters.ticket, requestParameters.orderByTicketOrder, requestParameters.returnTotalCount, requestParameters.returnLastMessage, requestParameters.page, requestParameters.count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the display image of a contact
     * @param {ContactsApiContactsImageGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsImageGet(requestParameters: ContactsApiContactsImageGetRequest, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsImageGet(requestParameters.id, requestParameters.accountId, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update contacts
     * @param {ContactsApiContactsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsPatch(requestParameters: ContactsApiContactsPatchRequest = {}, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsPatch(requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.notContacts, requestParameters.minMessagesSent, requestParameters.minMessagesRecv, requestParameters.maxMessagesSent, requestParameters.maxMessagesRecv, requestParameters.q, requestParameters.assignee, requestParameters.notAssignee, requestParameters.accountId, requestParameters.type, requestParameters.chatLastMessageFrom, requestParameters.chatLastMessageTo, requestParameters.lastMessageFromMe, requestParameters.unread, requestParameters.ticket, requestParameters.contactsPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create contacts
     * @param {ContactsApiContactsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsPost(requestParameters: ContactsApiContactsPostRequest = {}, options?: RawAxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsPost(requestParameters.contactsPost, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ContactsCheckExistsTypeEnum = {
    Whatsapp: 'whatsapp',
    Tiktok: 'tiktok'
} as const;
export type ContactsCheckExistsTypeEnum = typeof ContactsCheckExistsTypeEnum[keyof typeof ContactsCheckExistsTypeEnum];
/**
 * @export
 */
export const ContactsImageGetTypeEnum = {
    Preview: 'preview',
    Full: 'full'
} as const;
export type ContactsImageGetTypeEnum = typeof ContactsImageGetTypeEnum[keyof typeof ContactsImageGetTypeEnum];


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload a file to the media files bucket
         * @param {string} mimetype 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPost: async (mimetype: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mimetype' is not null or undefined
            assertParamExists('filesPost', 'mimetype', mimetype)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('filesPost', 'name', name)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (mimetype !== undefined) {
                localVarQueryParameter['mimetype'] = mimetype;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upload a file to the media files bucket
         * @param {string} mimetype 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesPost(mimetype: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesPost(mimetype, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.filesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @summary Upload a file to the media files bucket
         * @param {FilesApiFilesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPost(requestParameters: FilesApiFilesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.filesPost(requestParameters.mimetype, requestParameters.name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for filesPost operation in FilesApi.
 * @export
 * @interface FilesApiFilesPostRequest
 */
export interface FilesApiFilesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof FilesApiFilesPost
     */
    readonly mimetype: string

    /**
     * 
     * @type {string}
     * @memberof FilesApiFilesPost
     */
    readonly name: string
}

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @summary Upload a file to the media files bucket
     * @param {FilesApiFilesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesPost(requestParameters: FilesApiFilesPostRequest, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesPost(requestParameters.mimetype, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get metadata for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {boolean} [forceRefresh] Fetches the group metadata again from the platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGet: async (accountId: string, id: string, forceRefresh?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsGet', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsGet', 'id', id)
            const localVarPath = `/groups/{accountId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL", "CHATS_ACCESS_ASSIGNED"], configuration)

            if (forceRefresh !== undefined) {
                localVarQueryParameter['forceRefresh'] = forceRefresh;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get invite code for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsInviteCode: async (accountId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsInviteCode', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsInviteCode', 'id', id)
            const localVarPath = `/groups/{accountId}/{id}/invite-code`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL", "CHATS_ACCESS_ASSIGNED"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join a group using invite code
         * @param {string} accountId 
         * @param {string} id 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsJoin: async (accountId: string, id: string, code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsJoin', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsJoin', 'id', id)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('groupsJoin', 'code', code)
            const localVarPath = `/groups/{accountId}/{id}/join`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["GROUPS_UPDATE"], configuration)

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leave a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsLeave: async (accountId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsLeave', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsLeave', 'id', id)
            const localVarPath = `/groups/{accountId}/{id}/leave`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["GROUPS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {GroupAction} [groupAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPatch: async (accountId: string, id: string, groupAction?: GroupAction, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsPatch', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsPatch', 'id', id)
            const localVarPath = `/groups/{accountId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["GROUPS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new group
         * @param {string} accountId 
         * @param {GroupCreate} [groupCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPost: async (accountId: string, groupCreate?: GroupCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsPost', 'accountId', accountId)
            const localVarPath = `/groups/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["GROUPS_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get metadata for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {boolean} [forceRefresh] Fetches the group metadata again from the platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsGet(accountId: string, id: string, forceRefresh?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsGet(accountId, id, forceRefresh, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get invite code for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsInviteCode(accountId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupsInviteCode200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsInviteCode(accountId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsInviteCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Join a group using invite code
         * @param {string} accountId 
         * @param {string} id 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsJoin(accountId: string, id: string, code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsJoin(accountId, id, code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsJoin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Leave a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsLeave(accountId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsLeave(accountId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsLeave']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {GroupAction} [groupAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsPatch(accountId: string, id: string, groupAction?: GroupAction, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsPatch(accountId, id, groupAction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new group
         * @param {string} accountId 
         * @param {GroupCreate} [groupCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsPost(accountId: string, groupCreate?: GroupCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsPost(accountId, groupCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get metadata for a group
         * @param {GroupsApiGroupsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGet(requestParameters: GroupsApiGroupsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<GroupMetadata> {
            return localVarFp.groupsGet(requestParameters.accountId, requestParameters.id, requestParameters.forceRefresh, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get invite code for a group
         * @param {GroupsApiGroupsInviteCodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsInviteCode(requestParameters: GroupsApiGroupsInviteCodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<GroupsInviteCode200Response> {
            return localVarFp.groupsInviteCode(requestParameters.accountId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join a group using invite code
         * @param {GroupsApiGroupsJoinRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsJoin(requestParameters: GroupsApiGroupsJoinRequest, options?: RawAxiosRequestConfig): AxiosPromise<GroupMetadata> {
            return localVarFp.groupsJoin(requestParameters.accountId, requestParameters.id, requestParameters.code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Leave a group
         * @param {GroupsApiGroupsLeaveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsLeave(requestParameters: GroupsApiGroupsLeaveRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.groupsLeave(requestParameters.accountId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a group
         * @param {GroupsApiGroupsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPatch(requestParameters: GroupsApiGroupsPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<GroupMetadata> {
            return localVarFp.groupsPatch(requestParameters.accountId, requestParameters.id, requestParameters.groupAction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new group
         * @param {GroupsApiGroupsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPost(requestParameters: GroupsApiGroupsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<GroupMetadata> {
            return localVarFp.groupsPost(requestParameters.accountId, requestParameters.groupCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for groupsGet operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsGetRequest
 */
export interface GroupsApiGroupsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsGet
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsGet
     */
    readonly id: string

    /**
     * Fetches the group metadata again from the platform
     * @type {boolean}
     * @memberof GroupsApiGroupsGet
     */
    readonly forceRefresh?: boolean
}

/**
 * Request parameters for groupsInviteCode operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsInviteCodeRequest
 */
export interface GroupsApiGroupsInviteCodeRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsInviteCode
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsInviteCode
     */
    readonly id: string
}

/**
 * Request parameters for groupsJoin operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsJoinRequest
 */
export interface GroupsApiGroupsJoinRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsJoin
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsJoin
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsJoin
     */
    readonly code: string
}

/**
 * Request parameters for groupsLeave operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsLeaveRequest
 */
export interface GroupsApiGroupsLeaveRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsLeave
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsLeave
     */
    readonly id: string
}

/**
 * Request parameters for groupsPatch operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsPatchRequest
 */
export interface GroupsApiGroupsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsPatch
     */
    readonly id: string

    /**
     * 
     * @type {GroupAction}
     * @memberof GroupsApiGroupsPatch
     */
    readonly groupAction?: GroupAction
}

/**
 * Request parameters for groupsPost operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsPostRequest
 */
export interface GroupsApiGroupsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsPost
     */
    readonly accountId: string

    /**
     * 
     * @type {GroupCreate}
     * @memberof GroupsApiGroupsPost
     */
    readonly groupCreate?: GroupCreate
}

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary Get metadata for a group
     * @param {GroupsApiGroupsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsGet(requestParameters: GroupsApiGroupsGetRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsGet(requestParameters.accountId, requestParameters.id, requestParameters.forceRefresh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get invite code for a group
     * @param {GroupsApiGroupsInviteCodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsInviteCode(requestParameters: GroupsApiGroupsInviteCodeRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsInviteCode(requestParameters.accountId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join a group using invite code
     * @param {GroupsApiGroupsJoinRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsJoin(requestParameters: GroupsApiGroupsJoinRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsJoin(requestParameters.accountId, requestParameters.id, requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Leave a group
     * @param {GroupsApiGroupsLeaveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsLeave(requestParameters: GroupsApiGroupsLeaveRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsLeave(requestParameters.accountId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a group
     * @param {GroupsApiGroupsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsPatch(requestParameters: GroupsApiGroupsPatchRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsPatch(requestParameters.accountId, requestParameters.id, requestParameters.groupAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new group
     * @param {GroupsApiGroupsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsPost(requestParameters: GroupsApiGroupsPostRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsPost(requestParameters.accountId, requestParameters.groupCreate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MailApi - axios parameter creator
 * @export
 */
export const MailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register an email sender
         * @param {string} accountId 
         * @param {MailRegisterPostRequest} [mailRegisterPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailRegisterPost: async (accountId: string, mailRegisterPostRequest?: MailRegisterPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('mailRegisterPost', 'accountId', accountId)
            const localVarPath = `/mail/register/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mailRegisterPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Receive a message from the platform
         * @param {WebhookMailPostRequest} [webhookMailPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookMailPost: async (webhookMailPostRequest?: WebhookMailPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mail/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookMailPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MailApi - functional programming interface
 * @export
 */
export const MailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MailApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Register an email sender
         * @param {string} accountId 
         * @param {MailRegisterPostRequest} [mailRegisterPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mailRegisterPost(accountId: string, mailRegisterPostRequest?: MailRegisterPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mailRegisterPost(accountId, mailRegisterPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailApi.mailRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Receive a message from the platform
         * @param {WebhookMailPostRequest} [webhookMailPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookMailPost(webhookMailPostRequest?: WebhookMailPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookMailPost(webhookMailPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailApi.webhookMailPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MailApi - factory interface
 * @export
 */
export const MailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MailApiFp(configuration)
    return {
        /**
         * 
         * @summary Register an email sender
         * @param {MailApiMailRegisterPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailRegisterPost(requestParameters: MailApiMailRegisterPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.mailRegisterPost(requestParameters.accountId, requestParameters.mailRegisterPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Receive a message from the platform
         * @param {MailApiWebhookMailPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookMailPost(requestParameters: MailApiWebhookMailPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.webhookMailPost(requestParameters.webhookMailPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for mailRegisterPost operation in MailApi.
 * @export
 * @interface MailApiMailRegisterPostRequest
 */
export interface MailApiMailRegisterPostRequest {
    /**
     * 
     * @type {string}
     * @memberof MailApiMailRegisterPost
     */
    readonly accountId: string

    /**
     * 
     * @type {MailRegisterPostRequest}
     * @memberof MailApiMailRegisterPost
     */
    readonly mailRegisterPostRequest?: MailRegisterPostRequest
}

/**
 * Request parameters for webhookMailPost operation in MailApi.
 * @export
 * @interface MailApiWebhookMailPostRequest
 */
export interface MailApiWebhookMailPostRequest {
    /**
     * 
     * @type {WebhookMailPostRequest}
     * @memberof MailApiWebhookMailPost
     */
    readonly webhookMailPostRequest?: WebhookMailPostRequest
}

/**
 * MailApi - object-oriented interface
 * @export
 * @class MailApi
 * @extends {BaseAPI}
 */
export class MailApi extends BaseAPI {
    /**
     * 
     * @summary Register an email sender
     * @param {MailApiMailRegisterPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public mailRegisterPost(requestParameters: MailApiMailRegisterPostRequest, options?: RawAxiosRequestConfig) {
        return MailApiFp(this.configuration).mailRegisterPost(requestParameters.accountId, requestParameters.mailRegisterPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Receive a message from the platform
     * @param {MailApiWebhookMailPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public webhookMailPost(requestParameters: MailApiWebhookMailPostRequest = {}, options?: RawAxiosRequestConfig) {
        return MailApiFp(this.configuration).webhookMailPost(requestParameters.webhookMailPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Perform bulk actions on messages
         * @param {MessagesBulkActionStatusEnum} status 
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {MessagesGetRangeParameter} [range] Fetch messages only within this range. If not specified, fetches all messages
         * @param {string} [chatId] 
         * @param {MessagesBulkActionRequest} [messagesBulkActionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesBulkAction: async (status: MessagesBulkActionStatusEnum, accountId?: Array<string>, range?: MessagesGetRangeParameter, chatId?: string, messagesBulkActionRequest?: MessagesBulkActionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('messagesBulkAction', 'status', status)
            const localVarPath = `/messages/bulk-action`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL", "MESSAGES_SEND_TO_ASSIGNED"], configuration)

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = chatId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messagesBulkActionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bulk message Get
         * @param {Array<MessageID>} ids Message IDs to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesBulkGet: async (ids: Array<MessageID>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('messagesBulkGet', 'ids', ids)
            const localVarPath = `/messages/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a message
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesDelete: async (accountId: string, chatId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesDelete', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesDelete', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messagesDelete', 'id', id)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clears all pending/error messages. Deprecated, use the /messages/bulk-action route instead
         * @param {MessagesDeletePendingStatusEnum} status Will match all messages with the given status. 
         * @param {string} [accountId] If specified, only clears messages of this account
         * @param {string} [chatId] If specified, only clears messages of this chat
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        messagesDeletePending: async (status: MessagesDeletePendingStatusEnum, accountId?: string, chatId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('messagesDeletePending', 'status', status)
            const localVarPath = `/messages/{status}/retry`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_DELETE"], configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = chatId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {MessagesForwardToChatIdParameter} toChatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesForward: async (accountId: string, chatId: string, id: string, toChatId: MessagesForwardToChatIdParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesForward', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesForward', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messagesForward', 'id', id)
            // verify required parameter 'toChatId' is not null or undefined
            assertParamExists('messagesForward', 'toChatId', toChatId)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}/forward`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL"], configuration)

            if (toChatId !== undefined) {
                localVarQueryParameter['toChatId'] = toChatId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch messages of the chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {MessagesGetRangeParameter} [range] Fetch messages only within this range. If not specified, fetches all messages
         * @param {boolean} [action] Filter messages based on actions
         * @param {string} [beforeId] Get messages before this message ID
         * @param {number} [count] Number of items to return
         * @param {boolean} [forceReload] Deletes all cached messages for this chat &amp; fetches messages again from the original API source
         * @param {boolean} [fetchFromPlatform] Fetches messages from the platform, if the messages are not present in the DB
         * @param {Array<MessageStatus>} [status] fetch messages belonging to the particular status
         * @param {boolean} [fromMe] fetch only messages sent by me/or the other party
         * @param {Array<MessageAttachmentType>} [attachmentType] Fetch only messages with attachments of this type
         * @param {boolean} [includeCursorMessage] should include cursor message in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesGet: async (accountId: string, chatId: string, range?: MessagesGetRangeParameter, action?: boolean, beforeId?: string, count?: number, forceReload?: boolean, fetchFromPlatform?: boolean, status?: Array<MessageStatus>, fromMe?: boolean, attachmentType?: Array<MessageAttachmentType>, includeCursorMessage?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesGet', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesGet', 'chatId', chatId)
            const localVarPath = `/messages/{accountId}/{chatId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (beforeId !== undefined) {
                localVarQueryParameter['beforeId'] = beforeId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (forceReload !== undefined) {
                localVarQueryParameter['forceReload'] = forceReload;
            }

            if (fetchFromPlatform !== undefined) {
                localVarQueryParameter['fetchFromPlatform'] = fetchFromPlatform;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (fromMe !== undefined) {
                localVarQueryParameter['fromMe'] = fromMe;
            }

            if (attachmentType) {
                localVarQueryParameter['attachmentType'] = attachmentType;
            }

            if (includeCursorMessage !== undefined) {
                localVarQueryParameter['includeCursorMessage'] = includeCursorMessage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Can reschedule a message, update the content of a note or mark it as resolved 
         * @summary Modify a message/note
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {MessagesPatchRequest} [messagesPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPatch: async (accountId: string, chatId: string, id: string, messagesPatchRequest?: MessagesPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesPatch', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesPatch', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messagesPatch', 'id', id)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messagesPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retry all the messages in a given status
         * @summary Use the /messages/bulk-action route instead
         * @param {MessagesPatchPendingStatusEnum} status Will match all messages with the given status. 
         * @param {MessagesPatchPendingRequest} [messagesPatchPendingRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        messagesPatchPending: async (status: MessagesPatchPendingStatusEnum, messagesPatchPendingRequest?: MessagesPatchPendingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('messagesPatchPending', 'status', status)
            const localVarPath = `/messages/{status}/retry`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ASSIGNED"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messagesPatchPendingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
         * @summary Send a message
         * @param {string} accountId The account to use to send the message. Pass as the literal \&quot;random\&quot; to use a random account 
         * @param {string} chatId The contact to send the message to. To send to a phone number, supply the phone number with country code and no spaces. Eg. &#x60;911234534211&#x60;, &#x60;91345567543@s.whatsapp.net&#x60; 
         * @param {boolean} [requireOpenAccount] Only sends the message if the account is open, returns 428 otherwise
         * @param {MessageCompose} [messageCompose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPost: async (accountId: string, chatId: string, requireOpenAccount?: boolean, messageCompose?: MessageCompose, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesPost', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesPost', 'chatId', chatId)
            const localVarPath = `/messages/{accountId}/{chatId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL", "MESSAGES_SEND_TO_ASSIGNED"], configuration)

            if (requireOpenAccount !== undefined) {
                localVarQueryParameter['requireOpenAccount'] = requireOpenAccount;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageCompose, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary refresh a message, in case the media expired
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesRefresh: async (accountId: string, chatId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesRefresh', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesRefresh', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messagesRefresh', 'id', id)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}/refresh`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search messages
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {MessagesGetRangeParameter} [range] Fetch messages only within this range. If not specified, fetches all messages
         * @param {string} [q] Search items by this string
         * @param {string} [page] 
         * @param {number} [count] Number of items to return
         * @param {string} [chatId] 
         * @param {boolean} [returnChats] Return the corresponding chats alongside the messages
         * @param {boolean} [fromMe] Fetch only messages sent by me/or the other party. If not specified, fetches both
         * @param {Array<MessagesSearchStatusEnum>} [status] fetch only \&quot;notes\&quot;, \&quot;pending\&quot; or \&quot;error\&quot; messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesSearch: async (accountId?: Array<string>, range?: MessagesGetRangeParameter, q?: string, page?: string, count?: number, chatId?: string, returnChats?: boolean, fromMe?: boolean, status?: Array<MessagesSearchStatusEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messages/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEARCH"], configuration)

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = chatId;
            }

            if (returnChats !== undefined) {
                localVarQueryParameter['returnChats'] = returnChats;
            }

            if (fromMe !== undefined) {
                localVarQueryParameter['fromMe'] = fromMe;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
         * @summary Send a message to one or more chats
         * @param {string} accountId The account to use to send the message.
         * @param {boolean} [requireOpenAccount] Only sends the message if the account is open, returns 428 otherwise
         * @param {MultiMessageCompose} [multiMessageCompose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesSend: async (accountId: string, requireOpenAccount?: boolean, multiMessageCompose?: MultiMessageCompose, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesSend', 'accountId', accountId)
            const localVarPath = `/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL", "MESSAGES_SEND_TO_ASSIGNED"], configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (requireOpenAccount !== undefined) {
                localVarQueryParameter['requireOpenAccount'] = requireOpenAccount;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(multiMessageCompose, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transcribe a voice message
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {number} index 
         * @param {boolean} [waitForCompletion] If true, the API will wait for the transcription to be completed before returning
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesTranscribe: async (accountId: string, chatId: string, id: string, index: number, waitForCompletion?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesTranscribe', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesTranscribe', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messagesTranscribe', 'id', id)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('messagesTranscribe', 'index', index)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}/{index}/transcribe`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)

            if (waitForCompletion !== undefined) {
                localVarQueryParameter['waitForCompletion'] = waitForCompletion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Given a particular message, calling this route will decode all the message attachments
         * @summary Permanently store attachments of a message
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {boolean} [waitForCompletion] If true, the API will wait for the attachments to be stored before returning
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permanentlyStoreAttachments: async (accountId: string, chatId: string, id: string, waitForCompletion?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('permanentlyStoreAttachments', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('permanentlyStoreAttachments', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('permanentlyStoreAttachments', 'id', id)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}/permanently-store-attachments`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (waitForCompletion !== undefined) {
                localVarQueryParameter['waitForCompletion'] = waitForCompletion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Perform bulk actions on messages
         * @param {MessagesBulkActionStatusEnum} status 
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {MessagesGetRangeParameter} [range] Fetch messages only within this range. If not specified, fetches all messages
         * @param {string} [chatId] 
         * @param {MessagesBulkActionRequest} [messagesBulkActionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesBulkAction(status: MessagesBulkActionStatusEnum, accountId?: Array<string>, range?: MessagesGetRangeParameter, chatId?: string, messagesBulkActionRequest?: MessagesBulkActionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesBulkAction(status, accountId, range, chatId, messagesBulkActionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.messagesBulkAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Bulk message Get
         * @param {Array<MessageID>} ids Message IDs to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesBulkGet(ids: Array<MessageID>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesBulkGet(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.messagesBulkGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a message
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesDelete(accountId: string, chatId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesDelete(accountId, chatId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.messagesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Clears all pending/error messages. Deprecated, use the /messages/bulk-action route instead
         * @param {MessagesDeletePendingStatusEnum} status Will match all messages with the given status. 
         * @param {string} [accountId] If specified, only clears messages of this account
         * @param {string} [chatId] If specified, only clears messages of this chat
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async messagesDeletePending(status: MessagesDeletePendingStatusEnum, accountId?: string, chatId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesDeletePending(status, accountId, chatId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.messagesDeletePending']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {MessagesForwardToChatIdParameter} toChatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesForward(accountId: string, chatId: string, id: string, toChatId: MessagesForwardToChatIdParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesForward(accountId, chatId, id, toChatId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.messagesForward']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch messages of the chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {MessagesGetRangeParameter} [range] Fetch messages only within this range. If not specified, fetches all messages
         * @param {boolean} [action] Filter messages based on actions
         * @param {string} [beforeId] Get messages before this message ID
         * @param {number} [count] Number of items to return
         * @param {boolean} [forceReload] Deletes all cached messages for this chat &amp; fetches messages again from the original API source
         * @param {boolean} [fetchFromPlatform] Fetches messages from the platform, if the messages are not present in the DB
         * @param {Array<MessageStatus>} [status] fetch messages belonging to the particular status
         * @param {boolean} [fromMe] fetch only messages sent by me/or the other party
         * @param {Array<MessageAttachmentType>} [attachmentType] Fetch only messages with attachments of this type
         * @param {boolean} [includeCursorMessage] should include cursor message in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesGet(accountId: string, chatId: string, range?: MessagesGetRangeParameter, action?: boolean, beforeId?: string, count?: number, forceReload?: boolean, fetchFromPlatform?: boolean, status?: Array<MessageStatus>, fromMe?: boolean, attachmentType?: Array<MessageAttachmentType>, includeCursorMessage?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessagesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesGet(accountId, chatId, range, action, beforeId, count, forceReload, fetchFromPlatform, status, fromMe, attachmentType, includeCursorMessage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.messagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Can reschedule a message, update the content of a note or mark it as resolved 
         * @summary Modify a message/note
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {MessagesPatchRequest} [messagesPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesPatch(accountId: string, chatId: string, id: string, messagesPatchRequest?: MessagesPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesPatch(accountId, chatId, id, messagesPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.messagesPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retry all the messages in a given status
         * @summary Use the /messages/bulk-action route instead
         * @param {MessagesPatchPendingStatusEnum} status Will match all messages with the given status. 
         * @param {MessagesPatchPendingRequest} [messagesPatchPendingRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async messagesPatchPending(status: MessagesPatchPendingStatusEnum, messagesPatchPendingRequest?: MessagesPatchPendingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesPatchPending(status, messagesPatchPendingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.messagesPatchPending']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
         * @summary Send a message
         * @param {string} accountId The account to use to send the message. Pass as the literal \&quot;random\&quot; to use a random account 
         * @param {string} chatId The contact to send the message to. To send to a phone number, supply the phone number with country code and no spaces. Eg. &#x60;911234534211&#x60;, &#x60;91345567543@s.whatsapp.net&#x60; 
         * @param {boolean} [requireOpenAccount] Only sends the message if the account is open, returns 428 otherwise
         * @param {MessageCompose} [messageCompose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesPost(accountId: string, chatId: string, requireOpenAccount?: boolean, messageCompose?: MessageCompose, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesPost(accountId, chatId, requireOpenAccount, messageCompose, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.messagesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary refresh a message, in case the media expired
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesRefresh(accountId: string, chatId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesRefresh(accountId, chatId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.messagesRefresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search messages
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {MessagesGetRangeParameter} [range] Fetch messages only within this range. If not specified, fetches all messages
         * @param {string} [q] Search items by this string
         * @param {string} [page] 
         * @param {number} [count] Number of items to return
         * @param {string} [chatId] 
         * @param {boolean} [returnChats] Return the corresponding chats alongside the messages
         * @param {boolean} [fromMe] Fetch only messages sent by me/or the other party. If not specified, fetches both
         * @param {Array<MessagesSearchStatusEnum>} [status] fetch only \&quot;notes\&quot;, \&quot;pending\&quot; or \&quot;error\&quot; messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesSearch(accountId?: Array<string>, range?: MessagesGetRangeParameter, q?: string, page?: string, count?: number, chatId?: string, returnChats?: boolean, fromMe?: boolean, status?: Array<MessagesSearchStatusEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessagesSearch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesSearch(accountId, range, q, page, count, chatId, returnChats, fromMe, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.messagesSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
         * @summary Send a message to one or more chats
         * @param {string} accountId The account to use to send the message.
         * @param {boolean} [requireOpenAccount] Only sends the message if the account is open, returns 428 otherwise
         * @param {MultiMessageCompose} [multiMessageCompose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesSend(accountId: string, requireOpenAccount?: boolean, multiMessageCompose?: MultiMessageCompose, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesSend(accountId, requireOpenAccount, multiMessageCompose, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.messagesSend']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Transcribe a voice message
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {number} index 
         * @param {boolean} [waitForCompletion] If true, the API will wait for the transcription to be completed before returning
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesTranscribe(accountId: string, chatId: string, id: string, index: number, waitForCompletion?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesTranscribe(accountId, chatId, id, index, waitForCompletion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.messagesTranscribe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Given a particular message, calling this route will decode all the message attachments
         * @summary Permanently store attachments of a message
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {boolean} [waitForCompletion] If true, the API will wait for the attachments to be stored before returning
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async permanentlyStoreAttachments(accountId: string, chatId: string, id: string, waitForCompletion?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermanentlyStoreAttachments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.permanentlyStoreAttachments(accountId, chatId, id, waitForCompletion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.permanentlyStoreAttachments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Perform bulk actions on messages
         * @param {MessagesApiMessagesBulkActionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesBulkAction(requestParameters: MessagesApiMessagesBulkActionRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.messagesBulkAction(requestParameters.status, requestParameters.accountId, requestParameters.range, requestParameters.chatId, requestParameters.messagesBulkActionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Bulk message Get
         * @param {MessagesApiMessagesBulkGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesBulkGet(requestParameters: MessagesApiMessagesBulkGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Message>> {
            return localVarFp.messagesBulkGet(requestParameters.ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a message
         * @param {MessagesApiMessagesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesDelete(requestParameters: MessagesApiMessagesDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.messagesDelete(requestParameters.accountId, requestParameters.chatId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clears all pending/error messages. Deprecated, use the /messages/bulk-action route instead
         * @param {MessagesApiMessagesDeletePendingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        messagesDeletePending(requestParameters: MessagesApiMessagesDeletePendingRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.messagesDeletePending(requestParameters.status, requestParameters.accountId, requestParameters.chatId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MessagesApiMessagesForwardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesForward(requestParameters: MessagesApiMessagesForwardRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Message>> {
            return localVarFp.messagesForward(requestParameters.accountId, requestParameters.chatId, requestParameters.id, requestParameters.toChatId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch messages of the chat
         * @param {MessagesApiMessagesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesGet(requestParameters: MessagesApiMessagesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<MessagesGet200Response> {
            return localVarFp.messagesGet(requestParameters.accountId, requestParameters.chatId, requestParameters.range, requestParameters.action, requestParameters.beforeId, requestParameters.count, requestParameters.forceReload, requestParameters.fetchFromPlatform, requestParameters.status, requestParameters.fromMe, requestParameters.attachmentType, requestParameters.includeCursorMessage, options).then((request) => request(axios, basePath));
        },
        /**
         * Can reschedule a message, update the content of a note or mark it as resolved 
         * @summary Modify a message/note
         * @param {MessagesApiMessagesPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPatch(requestParameters: MessagesApiMessagesPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.messagesPatch(requestParameters.accountId, requestParameters.chatId, requestParameters.id, requestParameters.messagesPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retry all the messages in a given status
         * @summary Use the /messages/bulk-action route instead
         * @param {MessagesApiMessagesPatchPendingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        messagesPatchPending(requestParameters: MessagesApiMessagesPatchPendingRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.messagesPatchPending(requestParameters.status, requestParameters.messagesPatchPendingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
         * @summary Send a message
         * @param {MessagesApiMessagesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPost(requestParameters: MessagesApiMessagesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Message>> {
            return localVarFp.messagesPost(requestParameters.accountId, requestParameters.chatId, requestParameters.requireOpenAccount, requestParameters.messageCompose, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary refresh a message, in case the media expired
         * @param {MessagesApiMessagesRefreshRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesRefresh(requestParameters: MessagesApiMessagesRefreshRequest, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.messagesRefresh(requestParameters.accountId, requestParameters.chatId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search messages
         * @param {MessagesApiMessagesSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesSearch(requestParameters: MessagesApiMessagesSearchRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<MessagesSearch200Response> {
            return localVarFp.messagesSearch(requestParameters.accountId, requestParameters.range, requestParameters.q, requestParameters.page, requestParameters.count, requestParameters.chatId, requestParameters.returnChats, requestParameters.fromMe, requestParameters.status, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
         * @summary Send a message to one or more chats
         * @param {MessagesApiMessagesSendRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesSend(requestParameters: MessagesApiMessagesSendRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Message>> {
            return localVarFp.messagesSend(requestParameters.accountId, requestParameters.requireOpenAccount, requestParameters.multiMessageCompose, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transcribe a voice message
         * @param {MessagesApiMessagesTranscribeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesTranscribe(requestParameters: MessagesApiMessagesTranscribeRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.messagesTranscribe(requestParameters.accountId, requestParameters.chatId, requestParameters.id, requestParameters.index, requestParameters.waitForCompletion, options).then((request) => request(axios, basePath));
        },
        /**
         * Given a particular message, calling this route will decode all the message attachments
         * @summary Permanently store attachments of a message
         * @param {MessagesApiPermanentlyStoreAttachmentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permanentlyStoreAttachments(requestParameters: MessagesApiPermanentlyStoreAttachmentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PermanentlyStoreAttachments200Response> {
            return localVarFp.permanentlyStoreAttachments(requestParameters.accountId, requestParameters.chatId, requestParameters.id, requestParameters.waitForCompletion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for messagesBulkAction operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesBulkActionRequest
 */
export interface MessagesApiMessagesBulkActionRequest {
    /**
     * 
     * @type {'pending' | 'error' | 'cancelled'}
     * @memberof MessagesApiMessagesBulkAction
     */
    readonly status: MessagesBulkActionStatusEnum

    /**
     * Get contacts only belonging to this account
     * @type {Array<string>}
     * @memberof MessagesApiMessagesBulkAction
     */
    readonly accountId?: Array<string>

    /**
     * Fetch messages only within this range. If not specified, fetches all messages
     * @type {MessagesGetRangeParameter}
     * @memberof MessagesApiMessagesBulkAction
     */
    readonly range?: MessagesGetRangeParameter

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesBulkAction
     */
    readonly chatId?: string

    /**
     * 
     * @type {MessagesBulkActionRequest}
     * @memberof MessagesApiMessagesBulkAction
     */
    readonly messagesBulkActionRequest?: MessagesBulkActionRequest
}

/**
 * Request parameters for messagesBulkGet operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesBulkGetRequest
 */
export interface MessagesApiMessagesBulkGetRequest {
    /**
     * Message IDs to fetch
     * @type {Array<MessageID>}
     * @memberof MessagesApiMessagesBulkGet
     */
    readonly ids: Array<MessageID>
}

/**
 * Request parameters for messagesDelete operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesDeleteRequest
 */
export interface MessagesApiMessagesDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesDelete
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesDelete
     */
    readonly chatId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesDelete
     */
    readonly id: string
}

/**
 * Request parameters for messagesDeletePending operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesDeletePendingRequest
 */
export interface MessagesApiMessagesDeletePendingRequest {
    /**
     * Will match all messages with the given status. 
     * @type {'pending' | 'error' | 'cancelled'}
     * @memberof MessagesApiMessagesDeletePending
     */
    readonly status: MessagesDeletePendingStatusEnum

    /**
     * If specified, only clears messages of this account
     * @type {string}
     * @memberof MessagesApiMessagesDeletePending
     */
    readonly accountId?: string

    /**
     * If specified, only clears messages of this chat
     * @type {string}
     * @memberof MessagesApiMessagesDeletePending
     */
    readonly chatId?: string
}

/**
 * Request parameters for messagesForward operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesForwardRequest
 */
export interface MessagesApiMessagesForwardRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesForward
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesForward
     */
    readonly chatId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesForward
     */
    readonly id: string

    /**
     * 
     * @type {MessagesForwardToChatIdParameter}
     * @memberof MessagesApiMessagesForward
     */
    readonly toChatId: MessagesForwardToChatIdParameter
}

/**
 * Request parameters for messagesGet operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesGetRequest
 */
export interface MessagesApiMessagesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesGet
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesGet
     */
    readonly chatId: string

    /**
     * Fetch messages only within this range. If not specified, fetches all messages
     * @type {MessagesGetRangeParameter}
     * @memberof MessagesApiMessagesGet
     */
    readonly range?: MessagesGetRangeParameter

    /**
     * Filter messages based on actions
     * @type {boolean}
     * @memberof MessagesApiMessagesGet
     */
    readonly action?: boolean

    /**
     * Get messages before this message ID
     * @type {string}
     * @memberof MessagesApiMessagesGet
     */
    readonly beforeId?: string

    /**
     * Number of items to return
     * @type {number}
     * @memberof MessagesApiMessagesGet
     */
    readonly count?: number

    /**
     * Deletes all cached messages for this chat &amp; fetches messages again from the original API source
     * @type {boolean}
     * @memberof MessagesApiMessagesGet
     */
    readonly forceReload?: boolean

    /**
     * Fetches messages from the platform, if the messages are not present in the DB
     * @type {boolean}
     * @memberof MessagesApiMessagesGet
     */
    readonly fetchFromPlatform?: boolean

    /**
     * fetch messages belonging to the particular status
     * @type {Array<MessageStatus>}
     * @memberof MessagesApiMessagesGet
     */
    readonly status?: Array<MessageStatus>

    /**
     * fetch only messages sent by me/or the other party
     * @type {boolean}
     * @memberof MessagesApiMessagesGet
     */
    readonly fromMe?: boolean

    /**
     * Fetch only messages with attachments of this type
     * @type {Array<MessageAttachmentType>}
     * @memberof MessagesApiMessagesGet
     */
    readonly attachmentType?: Array<MessageAttachmentType>

    /**
     * should include cursor message in the response
     * @type {boolean}
     * @memberof MessagesApiMessagesGet
     */
    readonly includeCursorMessage?: boolean
}

/**
 * Request parameters for messagesPatch operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesPatchRequest
 */
export interface MessagesApiMessagesPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesPatch
     */
    readonly chatId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesPatch
     */
    readonly id: string

    /**
     * 
     * @type {MessagesPatchRequest}
     * @memberof MessagesApiMessagesPatch
     */
    readonly messagesPatchRequest?: MessagesPatchRequest
}

/**
 * Request parameters for messagesPatchPending operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesPatchPendingRequest
 */
export interface MessagesApiMessagesPatchPendingRequest {
    /**
     * Will match all messages with the given status. 
     * @type {'pending' | 'error' | 'cancelled'}
     * @memberof MessagesApiMessagesPatchPending
     */
    readonly status: MessagesPatchPendingStatusEnum

    /**
     * 
     * @type {MessagesPatchPendingRequest}
     * @memberof MessagesApiMessagesPatchPending
     */
    readonly messagesPatchPendingRequest?: MessagesPatchPendingRequest
}

/**
 * Request parameters for messagesPost operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesPostRequest
 */
export interface MessagesApiMessagesPostRequest {
    /**
     * The account to use to send the message. Pass as the literal \&quot;random\&quot; to use a random account 
     * @type {string}
     * @memberof MessagesApiMessagesPost
     */
    readonly accountId: string

    /**
     * The contact to send the message to. To send to a phone number, supply the phone number with country code and no spaces. Eg. &#x60;911234534211&#x60;, &#x60;91345567543@s.whatsapp.net&#x60; 
     * @type {string}
     * @memberof MessagesApiMessagesPost
     */
    readonly chatId: string

    /**
     * Only sends the message if the account is open, returns 428 otherwise
     * @type {boolean}
     * @memberof MessagesApiMessagesPost
     */
    readonly requireOpenAccount?: boolean

    /**
     * 
     * @type {MessageCompose}
     * @memberof MessagesApiMessagesPost
     */
    readonly messageCompose?: MessageCompose
}

/**
 * Request parameters for messagesRefresh operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesRefreshRequest
 */
export interface MessagesApiMessagesRefreshRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesRefresh
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesRefresh
     */
    readonly chatId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesRefresh
     */
    readonly id: string
}

/**
 * Request parameters for messagesSearch operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesSearchRequest
 */
export interface MessagesApiMessagesSearchRequest {
    /**
     * Get contacts only belonging to this account
     * @type {Array<string>}
     * @memberof MessagesApiMessagesSearch
     */
    readonly accountId?: Array<string>

    /**
     * Fetch messages only within this range. If not specified, fetches all messages
     * @type {MessagesGetRangeParameter}
     * @memberof MessagesApiMessagesSearch
     */
    readonly range?: MessagesGetRangeParameter

    /**
     * Search items by this string
     * @type {string}
     * @memberof MessagesApiMessagesSearch
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesSearch
     */
    readonly page?: string

    /**
     * Number of items to return
     * @type {number}
     * @memberof MessagesApiMessagesSearch
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesSearch
     */
    readonly chatId?: string

    /**
     * Return the corresponding chats alongside the messages
     * @type {boolean}
     * @memberof MessagesApiMessagesSearch
     */
    readonly returnChats?: boolean

    /**
     * Fetch only messages sent by me/or the other party. If not specified, fetches both
     * @type {boolean}
     * @memberof MessagesApiMessagesSearch
     */
    readonly fromMe?: boolean

    /**
     * fetch only \&quot;notes\&quot;, \&quot;pending\&quot; or \&quot;error\&quot; messages
     * @type {Array<'note' | 'pending' | 'error'>}
     * @memberof MessagesApiMessagesSearch
     */
    readonly status?: Array<MessagesSearchStatusEnum>
}

/**
 * Request parameters for messagesSend operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesSendRequest
 */
export interface MessagesApiMessagesSendRequest {
    /**
     * The account to use to send the message.
     * @type {string}
     * @memberof MessagesApiMessagesSend
     */
    readonly accountId: string

    /**
     * Only sends the message if the account is open, returns 428 otherwise
     * @type {boolean}
     * @memberof MessagesApiMessagesSend
     */
    readonly requireOpenAccount?: boolean

    /**
     * 
     * @type {MultiMessageCompose}
     * @memberof MessagesApiMessagesSend
     */
    readonly multiMessageCompose?: MultiMessageCompose
}

/**
 * Request parameters for messagesTranscribe operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesTranscribeRequest
 */
export interface MessagesApiMessagesTranscribeRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesTranscribe
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesTranscribe
     */
    readonly chatId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesTranscribe
     */
    readonly id: string

    /**
     * 
     * @type {number}
     * @memberof MessagesApiMessagesTranscribe
     */
    readonly index: number

    /**
     * If true, the API will wait for the transcription to be completed before returning
     * @type {boolean}
     * @memberof MessagesApiMessagesTranscribe
     */
    readonly waitForCompletion?: boolean
}

/**
 * Request parameters for permanentlyStoreAttachments operation in MessagesApi.
 * @export
 * @interface MessagesApiPermanentlyStoreAttachmentsRequest
 */
export interface MessagesApiPermanentlyStoreAttachmentsRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiPermanentlyStoreAttachments
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiPermanentlyStoreAttachments
     */
    readonly chatId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiPermanentlyStoreAttachments
     */
    readonly id: string

    /**
     * If true, the API will wait for the attachments to be stored before returning
     * @type {boolean}
     * @memberof MessagesApiPermanentlyStoreAttachments
     */
    readonly waitForCompletion?: boolean
}

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     * 
     * @summary Perform bulk actions on messages
     * @param {MessagesApiMessagesBulkActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesBulkAction(requestParameters: MessagesApiMessagesBulkActionRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesBulkAction(requestParameters.status, requestParameters.accountId, requestParameters.range, requestParameters.chatId, requestParameters.messagesBulkActionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Bulk message Get
     * @param {MessagesApiMessagesBulkGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesBulkGet(requestParameters: MessagesApiMessagesBulkGetRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesBulkGet(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a message
     * @param {MessagesApiMessagesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesDelete(requestParameters: MessagesApiMessagesDeleteRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesDelete(requestParameters.accountId, requestParameters.chatId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clears all pending/error messages. Deprecated, use the /messages/bulk-action route instead
     * @param {MessagesApiMessagesDeletePendingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesDeletePending(requestParameters: MessagesApiMessagesDeletePendingRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesDeletePending(requestParameters.status, requestParameters.accountId, requestParameters.chatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MessagesApiMessagesForwardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesForward(requestParameters: MessagesApiMessagesForwardRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesForward(requestParameters.accountId, requestParameters.chatId, requestParameters.id, requestParameters.toChatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch messages of the chat
     * @param {MessagesApiMessagesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesGet(requestParameters: MessagesApiMessagesGetRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesGet(requestParameters.accountId, requestParameters.chatId, requestParameters.range, requestParameters.action, requestParameters.beforeId, requestParameters.count, requestParameters.forceReload, requestParameters.fetchFromPlatform, requestParameters.status, requestParameters.fromMe, requestParameters.attachmentType, requestParameters.includeCursorMessage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Can reschedule a message, update the content of a note or mark it as resolved 
     * @summary Modify a message/note
     * @param {MessagesApiMessagesPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesPatch(requestParameters: MessagesApiMessagesPatchRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesPatch(requestParameters.accountId, requestParameters.chatId, requestParameters.id, requestParameters.messagesPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retry all the messages in a given status
     * @summary Use the /messages/bulk-action route instead
     * @param {MessagesApiMessagesPatchPendingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesPatchPending(requestParameters: MessagesApiMessagesPatchPendingRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesPatchPending(requestParameters.status, requestParameters.messagesPatchPendingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
     * @summary Send a message
     * @param {MessagesApiMessagesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesPost(requestParameters: MessagesApiMessagesPostRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesPost(requestParameters.accountId, requestParameters.chatId, requestParameters.requireOpenAccount, requestParameters.messageCompose, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary refresh a message, in case the media expired
     * @param {MessagesApiMessagesRefreshRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesRefresh(requestParameters: MessagesApiMessagesRefreshRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesRefresh(requestParameters.accountId, requestParameters.chatId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search messages
     * @param {MessagesApiMessagesSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesSearch(requestParameters: MessagesApiMessagesSearchRequest = {}, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesSearch(requestParameters.accountId, requestParameters.range, requestParameters.q, requestParameters.page, requestParameters.count, requestParameters.chatId, requestParameters.returnChats, requestParameters.fromMe, requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
     * @summary Send a message to one or more chats
     * @param {MessagesApiMessagesSendRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesSend(requestParameters: MessagesApiMessagesSendRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesSend(requestParameters.accountId, requestParameters.requireOpenAccount, requestParameters.multiMessageCompose, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transcribe a voice message
     * @param {MessagesApiMessagesTranscribeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesTranscribe(requestParameters: MessagesApiMessagesTranscribeRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesTranscribe(requestParameters.accountId, requestParameters.chatId, requestParameters.id, requestParameters.index, requestParameters.waitForCompletion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Given a particular message, calling this route will decode all the message attachments
     * @summary Permanently store attachments of a message
     * @param {MessagesApiPermanentlyStoreAttachmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public permanentlyStoreAttachments(requestParameters: MessagesApiPermanentlyStoreAttachmentsRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).permanentlyStoreAttachments(requestParameters.accountId, requestParameters.chatId, requestParameters.id, requestParameters.waitForCompletion, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MessagesBulkActionStatusEnum = {
    Pending: 'pending',
    Error: 'error',
    Cancelled: 'cancelled'
} as const;
export type MessagesBulkActionStatusEnum = typeof MessagesBulkActionStatusEnum[keyof typeof MessagesBulkActionStatusEnum];
/**
 * @export
 */
export const MessagesDeletePendingStatusEnum = {
    Pending: 'pending',
    Error: 'error',
    Cancelled: 'cancelled'
} as const;
export type MessagesDeletePendingStatusEnum = typeof MessagesDeletePendingStatusEnum[keyof typeof MessagesDeletePendingStatusEnum];
/**
 * @export
 */
export const MessagesPatchPendingStatusEnum = {
    Pending: 'pending',
    Error: 'error',
    Cancelled: 'cancelled'
} as const;
export type MessagesPatchPendingStatusEnum = typeof MessagesPatchPendingStatusEnum[keyof typeof MessagesPatchPendingStatusEnum];
/**
 * @export
 */
export const MessagesSearchStatusEnum = {
    Note: 'note',
    Pending: 'pending',
    Error: 'error'
} as const;
export type MessagesSearchStatusEnum = typeof MessagesSearchStatusEnum[keyof typeof MessagesSearchStatusEnum];


/**
 * PostsApi - axios parameter creator
 * @export
 */
export const PostsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get posts from a channel
         * @param {string} accountId 
         * @param {Array<string>} [id] 
         * @param {string} [q] Search items by this string
         * @param {number} [count] Number of items to return
         * @param {string} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPosts: async (accountId: string, id?: Array<string>, q?: string, count?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getPosts', 'accountId', accountId)
            const localVarPath = `/posts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostsApi - functional programming interface
 * @export
 */
export const PostsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PostsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get posts from a channel
         * @param {string} accountId 
         * @param {Array<string>} [id] 
         * @param {string} [q] Search items by this string
         * @param {number} [count] Number of items to return
         * @param {string} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPosts(accountId: string, id?: Array<string>, q?: string, count?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPosts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPosts(accountId, id, q, count, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.getPosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PostsApi - factory interface
 * @export
 */
export const PostsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PostsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get posts from a channel
         * @param {PostsApiGetPostsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPosts(requestParameters: PostsApiGetPostsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetPosts200Response> {
            return localVarFp.getPosts(requestParameters.accountId, requestParameters.id, requestParameters.q, requestParameters.count, requestParameters.page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPosts operation in PostsApi.
 * @export
 * @interface PostsApiGetPostsRequest
 */
export interface PostsApiGetPostsRequest {
    /**
     * 
     * @type {string}
     * @memberof PostsApiGetPosts
     */
    readonly accountId: string

    /**
     * 
     * @type {Array<string>}
     * @memberof PostsApiGetPosts
     */
    readonly id?: Array<string>

    /**
     * Search items by this string
     * @type {string}
     * @memberof PostsApiGetPosts
     */
    readonly q?: string

    /**
     * Number of items to return
     * @type {number}
     * @memberof PostsApiGetPosts
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof PostsApiGetPosts
     */
    readonly page?: string
}

/**
 * PostsApi - object-oriented interface
 * @export
 * @class PostsApi
 * @extends {BaseAPI}
 */
export class PostsApi extends BaseAPI {
    /**
     * 
     * @summary Get posts from a channel
     * @param {PostsApiGetPostsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public getPosts(requestParameters: PostsApiGetPostsRequest, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).getPosts(requestParameters.accountId, requestParameters.id, requestParameters.q, requestParameters.count, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch details of an order (likely from an order message)
         * @param {string} accountId 
         * @param {string} orderId 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDetailsGet: async (accountId: string, orderId: string, token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('orderDetailsGet', 'accountId', accountId)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderDetailsGet', 'orderId', orderId)
            const localVarPath = `/{accountId}/{orderId}/order-details`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete products by the given filter from the catalog
         * @param {string} accountId 
         * @param {Array<string>} [id] 
         * @param {Array<string>} [notId] 
         * @param {string} [q] Search items by this string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsDelete: async (accountId: string, id?: Array<string>, notId?: Array<string>, q?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('platformProductsDelete', 'accountId', accountId)
            const localVarPath = `/products/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_DELETE"], configuration)

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (notId) {
                localVarQueryParameter['notId'] = notId;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the WA catalog. Only available on WA Business apps. 
         * @summary Get the products from WA catalog.
         * @param {string} teamId 
         * @param {Array<string>} [accountId] 
         * @param {string} [category] Filter based on collection/category
         * @param {string} [notCategory] Returns products not belonging to the specified category
         * @param {Array<string>} [id] 
         * @param {string} [cursor] 
         * @param {string} [q] Search items by this string
         * @param {number} [count] Number of items to return
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsGet: async (teamId: string, accountId?: Array<string>, category?: string, notCategory?: string, id?: Array<string>, cursor?: string, q?: string, count?: number, returnTotalCount?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('platformProductsGet', 'teamId', teamId)
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (notCategory !== undefined) {
                localVarQueryParameter['notCategory'] = notCategory;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update products by the given filter in the WA catalog
         * @param {string} accountId 
         * @param {Array<string>} [id] 
         * @param {Array<string>} [notId] 
         * @param {string} [q] Search items by this string
         * @param {PlatformProductUpdate} [platformProductUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsPatch: async (accountId: string, id?: Array<string>, notId?: Array<string>, q?: string, platformProductUpdate?: PlatformProductUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('platformProductsPatch', 'accountId', accountId)
            const localVarPath = `/products/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_UPDATE"], configuration)

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (notId) {
                localVarQueryParameter['notId'] = notId;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(platformProductUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upsert products to the WA catalog
         * @param {string} accountId 
         * @param {PlatformProductsPostRequest} [platformProductsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsPost: async (accountId: string, platformProductsPostRequest?: PlatformProductsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('platformProductsPost', 'accountId', accountId)
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_CREATE"], configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(platformProductsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger sync of the specified products on ChatDaddy with WhatsApp
         * @param {string} accountId Account ID to sync products from/to
         * @param {Array<string>} [id] Products to sync with WhatsApp. Leave unspecified to trigger all
         * @param {boolean} [syncForward] Sync products from ChatDaddy to WhatsApp
         * @param {boolean} [syncBackward] Sync missing products from WhatsApp to ChatDaddy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsSync: async (accountId: string, id?: Array<string>, syncForward?: boolean, syncBackward?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('platformProductsSync', 'accountId', accountId)
            const localVarPath = `/products/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_UPDATE"], configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (syncForward !== undefined) {
                localVarQueryParameter['syncForward'] = syncForward;
            }

            if (syncBackward !== undefined) {
                localVarQueryParameter['syncBackward'] = syncBackward;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch details of an order (likely from an order message)
         * @param {string} accountId 
         * @param {string} orderId 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderDetailsGet(accountId: string, orderId: string, token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderDetailsGet(accountId, orderId, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.orderDetailsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete products by the given filter from the catalog
         * @param {string} accountId 
         * @param {Array<string>} [id] 
         * @param {Array<string>} [notId] 
         * @param {string} [q] Search items by this string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductsDelete(accountId: string, id?: Array<string>, notId?: Array<string>, q?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductsDelete(accountId, id, notId, q, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.platformProductsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the WA catalog. Only available on WA Business apps. 
         * @summary Get the products from WA catalog.
         * @param {string} teamId 
         * @param {Array<string>} [accountId] 
         * @param {string} [category] Filter based on collection/category
         * @param {string} [notCategory] Returns products not belonging to the specified category
         * @param {Array<string>} [id] 
         * @param {string} [cursor] 
         * @param {string} [q] Search items by this string
         * @param {number} [count] Number of items to return
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductsGet(teamId: string, accountId?: Array<string>, category?: string, notCategory?: string, id?: Array<string>, cursor?: string, q?: string, count?: number, returnTotalCount?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformProductsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductsGet(teamId, accountId, category, notCategory, id, cursor, q, count, returnTotalCount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.platformProductsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update products by the given filter in the WA catalog
         * @param {string} accountId 
         * @param {Array<string>} [id] 
         * @param {Array<string>} [notId] 
         * @param {string} [q] Search items by this string
         * @param {PlatformProductUpdate} [platformProductUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductsPatch(accountId: string, id?: Array<string>, notId?: Array<string>, q?: string, platformProductUpdate?: PlatformProductUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformProductsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductsPatch(accountId, id, notId, q, platformProductUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.platformProductsPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upsert products to the WA catalog
         * @param {string} accountId 
         * @param {PlatformProductsPostRequest} [platformProductsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductsPost(accountId: string, platformProductsPostRequest?: PlatformProductsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformProductsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductsPost(accountId, platformProductsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.platformProductsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger sync of the specified products on ChatDaddy with WhatsApp
         * @param {string} accountId Account ID to sync products from/to
         * @param {Array<string>} [id] Products to sync with WhatsApp. Leave unspecified to trigger all
         * @param {boolean} [syncForward] Sync products from ChatDaddy to WhatsApp
         * @param {boolean} [syncBackward] Sync missing products from WhatsApp to ChatDaddy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductsSync(accountId: string, id?: Array<string>, syncForward?: boolean, syncBackward?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductsSync(accountId, id, syncForward, syncBackward, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.platformProductsSync']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch details of an order (likely from an order message)
         * @param {ProductApiOrderDetailsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDetailsGet(requestParameters: ProductApiOrderDetailsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrderDetails> {
            return localVarFp.orderDetailsGet(requestParameters.accountId, requestParameters.orderId, requestParameters.token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete products by the given filter from the catalog
         * @param {ProductApiPlatformProductsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsDelete(requestParameters: ProductApiPlatformProductsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.platformProductsDelete(requestParameters.accountId, requestParameters.id, requestParameters.notId, requestParameters.q, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the WA catalog. Only available on WA Business apps. 
         * @summary Get the products from WA catalog.
         * @param {ProductApiPlatformProductsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsGet(requestParameters: ProductApiPlatformProductsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PlatformProductsGet200Response> {
            return localVarFp.platformProductsGet(requestParameters.teamId, requestParameters.accountId, requestParameters.category, requestParameters.notCategory, requestParameters.id, requestParameters.cursor, requestParameters.q, requestParameters.count, requestParameters.returnTotalCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update products by the given filter in the WA catalog
         * @param {ProductApiPlatformProductsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsPatch(requestParameters: ProductApiPlatformProductsPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<PlatformProductsPost200Response> {
            return localVarFp.platformProductsPatch(requestParameters.accountId, requestParameters.id, requestParameters.notId, requestParameters.q, requestParameters.platformProductUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upsert products to the WA catalog
         * @param {ProductApiPlatformProductsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsPost(requestParameters: ProductApiPlatformProductsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PlatformProductsPost200Response> {
            return localVarFp.platformProductsPost(requestParameters.accountId, requestParameters.platformProductsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger sync of the specified products on ChatDaddy with WhatsApp
         * @param {ProductApiPlatformProductsSyncRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsSync(requestParameters: ProductApiPlatformProductsSyncRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.platformProductsSync(requestParameters.accountId, requestParameters.id, requestParameters.syncForward, requestParameters.syncBackward, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orderDetailsGet operation in ProductApi.
 * @export
 * @interface ProductApiOrderDetailsGetRequest
 */
export interface ProductApiOrderDetailsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiOrderDetailsGet
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiOrderDetailsGet
     */
    readonly orderId: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiOrderDetailsGet
     */
    readonly token?: string
}

/**
 * Request parameters for platformProductsDelete operation in ProductApi.
 * @export
 * @interface ProductApiPlatformProductsDeleteRequest
 */
export interface ProductApiPlatformProductsDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiPlatformProductsDelete
     */
    readonly accountId: string

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsDelete
     */
    readonly id?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsDelete
     */
    readonly notId?: Array<string>

    /**
     * Search items by this string
     * @type {string}
     * @memberof ProductApiPlatformProductsDelete
     */
    readonly q?: string
}

/**
 * Request parameters for platformProductsGet operation in ProductApi.
 * @export
 * @interface ProductApiPlatformProductsGetRequest
 */
export interface ProductApiPlatformProductsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly teamId: string

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly accountId?: Array<string>

    /**
     * Filter based on collection/category
     * @type {string}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly category?: string

    /**
     * Returns products not belonging to the specified category
     * @type {string}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly notCategory?: string

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly id?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly cursor?: string

    /**
     * Search items by this string
     * @type {string}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly q?: string

    /**
     * Number of items to return
     * @type {number}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly count?: number

    /**
     * 
     * @type {boolean}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly returnTotalCount?: boolean
}

/**
 * Request parameters for platformProductsPatch operation in ProductApi.
 * @export
 * @interface ProductApiPlatformProductsPatchRequest
 */
export interface ProductApiPlatformProductsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiPlatformProductsPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsPatch
     */
    readonly id?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsPatch
     */
    readonly notId?: Array<string>

    /**
     * Search items by this string
     * @type {string}
     * @memberof ProductApiPlatformProductsPatch
     */
    readonly q?: string

    /**
     * 
     * @type {PlatformProductUpdate}
     * @memberof ProductApiPlatformProductsPatch
     */
    readonly platformProductUpdate?: PlatformProductUpdate
}

/**
 * Request parameters for platformProductsPost operation in ProductApi.
 * @export
 * @interface ProductApiPlatformProductsPostRequest
 */
export interface ProductApiPlatformProductsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiPlatformProductsPost
     */
    readonly accountId: string

    /**
     * 
     * @type {PlatformProductsPostRequest}
     * @memberof ProductApiPlatformProductsPost
     */
    readonly platformProductsPostRequest?: PlatformProductsPostRequest
}

/**
 * Request parameters for platformProductsSync operation in ProductApi.
 * @export
 * @interface ProductApiPlatformProductsSyncRequest
 */
export interface ProductApiPlatformProductsSyncRequest {
    /**
     * Account ID to sync products from/to
     * @type {string}
     * @memberof ProductApiPlatformProductsSync
     */
    readonly accountId: string

    /**
     * Products to sync with WhatsApp. Leave unspecified to trigger all
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsSync
     */
    readonly id?: Array<string>

    /**
     * Sync products from ChatDaddy to WhatsApp
     * @type {boolean}
     * @memberof ProductApiPlatformProductsSync
     */
    readonly syncForward?: boolean

    /**
     * Sync missing products from WhatsApp to ChatDaddy
     * @type {boolean}
     * @memberof ProductApiPlatformProductsSync
     */
    readonly syncBackward?: boolean
}

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @summary Fetch details of an order (likely from an order message)
     * @param {ProductApiOrderDetailsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public orderDetailsGet(requestParameters: ProductApiOrderDetailsGetRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).orderDetailsGet(requestParameters.accountId, requestParameters.orderId, requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete products by the given filter from the catalog
     * @param {ProductApiPlatformProductsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public platformProductsDelete(requestParameters: ProductApiPlatformProductsDeleteRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).platformProductsDelete(requestParameters.accountId, requestParameters.id, requestParameters.notId, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the WA catalog. Only available on WA Business apps. 
     * @summary Get the products from WA catalog.
     * @param {ProductApiPlatformProductsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public platformProductsGet(requestParameters: ProductApiPlatformProductsGetRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).platformProductsGet(requestParameters.teamId, requestParameters.accountId, requestParameters.category, requestParameters.notCategory, requestParameters.id, requestParameters.cursor, requestParameters.q, requestParameters.count, requestParameters.returnTotalCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update products by the given filter in the WA catalog
     * @param {ProductApiPlatformProductsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public platformProductsPatch(requestParameters: ProductApiPlatformProductsPatchRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).platformProductsPatch(requestParameters.accountId, requestParameters.id, requestParameters.notId, requestParameters.q, requestParameters.platformProductUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upsert products to the WA catalog
     * @param {ProductApiPlatformProductsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public platformProductsPost(requestParameters: ProductApiPlatformProductsPostRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).platformProductsPost(requestParameters.accountId, requestParameters.platformProductsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger sync of the specified products on ChatDaddy with WhatsApp
     * @param {ProductApiPlatformProductsSyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public platformProductsSync(requestParameters: ProductApiPlatformProductsSyncRequest, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).platformProductsSync(requestParameters.accountId, requestParameters.id, requestParameters.syncForward, requestParameters.syncBackward, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductCategoriesApi - axios parameter creator
 * @export
 */
export const ProductCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a category
         * @param {string} accountId 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesDelete: async (accountId: string, categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('platformProductCategoriesDelete', 'accountId', accountId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('platformProductCategoriesDelete', 'categoryId', categoryId)
            const localVarPath = `/product-categories/{accountId}/{categoryId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the categories (collections) from WA catalog.
         * @param {string} teamId 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesGet: async (teamId: string, accountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('platformProductCategoriesGet', 'teamId', teamId)
            const localVarPath = `/product-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update name of the category or add/remove a product
         * @summary Update a category
         * @param {string} accountId 
         * @param {string} categoryId 
         * @param {ProductCategoryPatchRequest} [productCategoryPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesPatch: async (accountId: string, categoryId: string, productCategoryPatchRequest?: ProductCategoryPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('platformProductCategoriesPatch', 'accountId', accountId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('platformProductCategoriesPatch', 'categoryId', categoryId)
            const localVarPath = `/product-categories/{accountId}/{categoryId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCategoryPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new product category
         * @param {string} accountId 
         * @param {PlatformProductCategoriesPostRequest} [platformProductCategoriesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesPost: async (accountId: string, platformProductCategoriesPostRequest?: PlatformProductCategoriesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('platformProductCategoriesPost', 'accountId', accountId)
            const localVarPath = `/product-categories/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(platformProductCategoriesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductCategoriesApi - functional programming interface
 * @export
 */
export const ProductCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a category
         * @param {string} accountId 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductCategoriesDelete(accountId: string, categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductCategoriesDelete(accountId, categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductCategoriesApi.platformProductCategoriesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the categories (collections) from WA catalog.
         * @param {string} teamId 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductCategoriesGet(teamId: string, accountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformProductCategoriesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductCategoriesGet(teamId, accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductCategoriesApi.platformProductCategoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update name of the category or add/remove a product
         * @summary Update a category
         * @param {string} accountId 
         * @param {string} categoryId 
         * @param {ProductCategoryPatchRequest} [productCategoryPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductCategoriesPatch(accountId: string, categoryId: string, productCategoryPatchRequest?: ProductCategoryPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductCategoriesPatch(accountId, categoryId, productCategoryPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductCategoriesApi.platformProductCategoriesPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a new product category
         * @param {string} accountId 
         * @param {PlatformProductCategoriesPostRequest} [platformProductCategoriesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductCategoriesPost(accountId: string, platformProductCategoriesPostRequest?: PlatformProductCategoriesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductCategoriesPost(accountId, platformProductCategoriesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductCategoriesApi.platformProductCategoriesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductCategoriesApi - factory interface
 * @export
 */
export const ProductCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductCategoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a category
         * @param {ProductCategoriesApiPlatformProductCategoriesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesDelete(requestParameters: ProductCategoriesApiPlatformProductCategoriesDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.platformProductCategoriesDelete(requestParameters.accountId, requestParameters.categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the categories (collections) from WA catalog.
         * @param {ProductCategoriesApiPlatformProductCategoriesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesGet(requestParameters: ProductCategoriesApiPlatformProductCategoriesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PlatformProductCategoriesGet200Response> {
            return localVarFp.platformProductCategoriesGet(requestParameters.teamId, requestParameters.accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update name of the category or add/remove a product
         * @summary Update a category
         * @param {ProductCategoriesApiPlatformProductCategoriesPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesPatch(requestParameters: ProductCategoriesApiPlatformProductCategoriesPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.platformProductCategoriesPatch(requestParameters.accountId, requestParameters.categoryId, requestParameters.productCategoryPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new product category
         * @param {ProductCategoriesApiPlatformProductCategoriesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesPost(requestParameters: ProductCategoriesApiPlatformProductCategoriesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductCategory> {
            return localVarFp.platformProductCategoriesPost(requestParameters.accountId, requestParameters.platformProductCategoriesPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for platformProductCategoriesDelete operation in ProductCategoriesApi.
 * @export
 * @interface ProductCategoriesApiPlatformProductCategoriesDeleteRequest
 */
export interface ProductCategoriesApiPlatformProductCategoriesDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductCategoriesApiPlatformProductCategoriesDelete
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof ProductCategoriesApiPlatformProductCategoriesDelete
     */
    readonly categoryId: string
}

/**
 * Request parameters for platformProductCategoriesGet operation in ProductCategoriesApi.
 * @export
 * @interface ProductCategoriesApiPlatformProductCategoriesGetRequest
 */
export interface ProductCategoriesApiPlatformProductCategoriesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductCategoriesApiPlatformProductCategoriesGet
     */
    readonly teamId: string

    /**
     * 
     * @type {string}
     * @memberof ProductCategoriesApiPlatformProductCategoriesGet
     */
    readonly accountId?: string
}

/**
 * Request parameters for platformProductCategoriesPatch operation in ProductCategoriesApi.
 * @export
 * @interface ProductCategoriesApiPlatformProductCategoriesPatchRequest
 */
export interface ProductCategoriesApiPlatformProductCategoriesPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductCategoriesApiPlatformProductCategoriesPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof ProductCategoriesApiPlatformProductCategoriesPatch
     */
    readonly categoryId: string

    /**
     * 
     * @type {ProductCategoryPatchRequest}
     * @memberof ProductCategoriesApiPlatformProductCategoriesPatch
     */
    readonly productCategoryPatchRequest?: ProductCategoryPatchRequest
}

/**
 * Request parameters for platformProductCategoriesPost operation in ProductCategoriesApi.
 * @export
 * @interface ProductCategoriesApiPlatformProductCategoriesPostRequest
 */
export interface ProductCategoriesApiPlatformProductCategoriesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductCategoriesApiPlatformProductCategoriesPost
     */
    readonly accountId: string

    /**
     * 
     * @type {PlatformProductCategoriesPostRequest}
     * @memberof ProductCategoriesApiPlatformProductCategoriesPost
     */
    readonly platformProductCategoriesPostRequest?: PlatformProductCategoriesPostRequest
}

/**
 * ProductCategoriesApi - object-oriented interface
 * @export
 * @class ProductCategoriesApi
 * @extends {BaseAPI}
 */
export class ProductCategoriesApi extends BaseAPI {
    /**
     * 
     * @summary Delete a category
     * @param {ProductCategoriesApiPlatformProductCategoriesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public platformProductCategoriesDelete(requestParameters: ProductCategoriesApiPlatformProductCategoriesDeleteRequest, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).platformProductCategoriesDelete(requestParameters.accountId, requestParameters.categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the categories (collections) from WA catalog.
     * @param {ProductCategoriesApiPlatformProductCategoriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public platformProductCategoriesGet(requestParameters: ProductCategoriesApiPlatformProductCategoriesGetRequest, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).platformProductCategoriesGet(requestParameters.teamId, requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update name of the category or add/remove a product
     * @summary Update a category
     * @param {ProductCategoriesApiPlatformProductCategoriesPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public platformProductCategoriesPatch(requestParameters: ProductCategoriesApiPlatformProductCategoriesPatchRequest, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).platformProductCategoriesPatch(requestParameters.accountId, requestParameters.categoryId, requestParameters.productCategoryPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new product category
     * @param {ProductCategoriesApiPlatformProductCategoriesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public platformProductCategoriesPost(requestParameters: ProductCategoriesApiPlatformProductCategoriesPostRequest, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).platformProductCategoriesPost(requestParameters.accountId, requestParameters.platformProductCategoriesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileValidationApi - axios parameter creator
 * @export
 */
export const ProfileValidationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Configure various profile settings
         * @param {string} accountId 
         * @param {ProfileMessengerPostRequest} [profileMessengerPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileMessengerPost: async (accountId: string, profileMessengerPostRequest?: ProfileMessengerPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('profileMessengerPost', 'accountId', accountId)
            const localVarPath = `/messenger/profile-validation/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileMessengerPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileValidationApi - functional programming interface
 * @export
 */
export const ProfileValidationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileValidationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Configure various profile settings
         * @param {string} accountId 
         * @param {ProfileMessengerPostRequest} [profileMessengerPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileMessengerPost(accountId: string, profileMessengerPostRequest?: ProfileMessengerPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileMessengerPost(accountId, profileMessengerPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileValidationApi.profileMessengerPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfileValidationApi - factory interface
 * @export
 */
export const ProfileValidationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileValidationApiFp(configuration)
    return {
        /**
         * 
         * @summary Configure various profile settings
         * @param {ProfileValidationApiProfileMessengerPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileMessengerPost(requestParameters: ProfileValidationApiProfileMessengerPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.profileMessengerPost(requestParameters.accountId, requestParameters.profileMessengerPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for profileMessengerPost operation in ProfileValidationApi.
 * @export
 * @interface ProfileValidationApiProfileMessengerPostRequest
 */
export interface ProfileValidationApiProfileMessengerPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileValidationApiProfileMessengerPost
     */
    readonly accountId: string

    /**
     * 
     * @type {ProfileMessengerPostRequest}
     * @memberof ProfileValidationApiProfileMessengerPost
     */
    readonly profileMessengerPostRequest?: ProfileMessengerPostRequest
}

/**
 * ProfileValidationApi - object-oriented interface
 * @export
 * @class ProfileValidationApi
 * @extends {BaseAPI}
 */
export class ProfileValidationApi extends BaseAPI {
    /**
     * 
     * @summary Configure various profile settings
     * @param {ProfileValidationApiProfileMessengerPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileValidationApi
     */
    public profileMessengerPost(requestParameters: ProfileValidationApiProfileMessengerPostRequest, options?: RawAxiosRequestConfig) {
        return ProfileValidationApiFp(this.configuration).profileMessengerPost(requestParameters.accountId, requestParameters.profileMessengerPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SMSApi - axios parameter creator
 * @export
 */
export const SMSApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Set sender Id for sms channel
         * @param {string} accountId 
         * @param {SmsSenderIdPostRequest} [smsSenderIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smsSenderIdPost: async (accountId: string, smsSenderIdPostRequest?: SmsSenderIdPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('smsSenderIdPost', 'accountId', accountId)
            const localVarPath = `/sms/sender-id/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smsSenderIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Usage trigger for SMS limit exceeded
         * @param {string} triggerSecret 
         * @param {WebhookSmsLimitPostRequest} [webhookSmsLimitPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookSmsLimitPost: async (triggerSecret: string, webhookSmsLimitPostRequest?: WebhookSmsLimitPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'triggerSecret' is not null or undefined
            assertParamExists('webhookSmsLimitPost', 'triggerSecret', triggerSecret)
            const localVarPath = `/sms/webhook/limit/{triggerSecret}`
                .replace(`{${"triggerSecret"}}`, encodeURIComponent(String(triggerSecret)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookSmsLimitPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SMSApi - functional programming interface
 * @export
 */
export const SMSApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SMSApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Set sender Id for sms channel
         * @param {string} accountId 
         * @param {SmsSenderIdPostRequest} [smsSenderIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smsSenderIdPost(accountId: string, smsSenderIdPostRequest?: SmsSenderIdPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smsSenderIdPost(accountId, smsSenderIdPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SMSApi.smsSenderIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Usage trigger for SMS limit exceeded
         * @param {string} triggerSecret 
         * @param {WebhookSmsLimitPostRequest} [webhookSmsLimitPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookSmsLimitPost(triggerSecret: string, webhookSmsLimitPostRequest?: WebhookSmsLimitPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookSmsLimitPost(triggerSecret, webhookSmsLimitPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SMSApi.webhookSmsLimitPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SMSApi - factory interface
 * @export
 */
export const SMSApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SMSApiFp(configuration)
    return {
        /**
         * 
         * @summary Set sender Id for sms channel
         * @param {SMSApiSmsSenderIdPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smsSenderIdPost(requestParameters: SMSApiSmsSenderIdPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.smsSenderIdPost(requestParameters.accountId, requestParameters.smsSenderIdPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Usage trigger for SMS limit exceeded
         * @param {SMSApiWebhookSmsLimitPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookSmsLimitPost(requestParameters: SMSApiWebhookSmsLimitPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.webhookSmsLimitPost(requestParameters.triggerSecret, requestParameters.webhookSmsLimitPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for smsSenderIdPost operation in SMSApi.
 * @export
 * @interface SMSApiSmsSenderIdPostRequest
 */
export interface SMSApiSmsSenderIdPostRequest {
    /**
     * 
     * @type {string}
     * @memberof SMSApiSmsSenderIdPost
     */
    readonly accountId: string

    /**
     * 
     * @type {SmsSenderIdPostRequest}
     * @memberof SMSApiSmsSenderIdPost
     */
    readonly smsSenderIdPostRequest?: SmsSenderIdPostRequest
}

/**
 * Request parameters for webhookSmsLimitPost operation in SMSApi.
 * @export
 * @interface SMSApiWebhookSmsLimitPostRequest
 */
export interface SMSApiWebhookSmsLimitPostRequest {
    /**
     * 
     * @type {string}
     * @memberof SMSApiWebhookSmsLimitPost
     */
    readonly triggerSecret: string

    /**
     * 
     * @type {WebhookSmsLimitPostRequest}
     * @memberof SMSApiWebhookSmsLimitPost
     */
    readonly webhookSmsLimitPostRequest?: WebhookSmsLimitPostRequest
}

/**
 * SMSApi - object-oriented interface
 * @export
 * @class SMSApi
 * @extends {BaseAPI}
 */
export class SMSApi extends BaseAPI {
    /**
     * 
     * @summary Set sender Id for sms channel
     * @param {SMSApiSmsSenderIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SMSApi
     */
    public smsSenderIdPost(requestParameters: SMSApiSmsSenderIdPostRequest, options?: RawAxiosRequestConfig) {
        return SMSApiFp(this.configuration).smsSenderIdPost(requestParameters.accountId, requestParameters.smsSenderIdPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Usage trigger for SMS limit exceeded
     * @param {SMSApiWebhookSmsLimitPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SMSApi
     */
    public webhookSmsLimitPost(requestParameters: SMSApiWebhookSmsLimitPostRequest, options?: RawAxiosRequestConfig) {
        return SMSApiFp(this.configuration).webhookSmsLimitPost(requestParameters.triggerSecret, requestParameters.webhookSmsLimitPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a tag
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsDelete: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('tagsDelete', 'name', name)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TAGS_DELETE"], configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all the tags
         * @param {string} [q] Search items by this string
         * @param {number} [count] Number of items to return
         * @param {string} [page] 
         * @param {boolean} [returnTotalCount] 
         * @param {boolean} [isCustomField] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet: async (q?: string, count?: number, page?: string, returnTotalCount?: boolean, isCustomField?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TAGS_READ"], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }

            if (isCustomField !== undefined) {
                localVarQueryParameter['isCustomField'] = isCustomField;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {TagsPostRequest} [tagsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPatch: async (name: string, tagsPostRequest?: TagsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('tagsPatch', 'name', name)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TAGS_CREATE"], configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a tag
         * @param {string} name 
         * @param {TagsPostRequest} [tagsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPost: async (name: string, tagsPostRequest?: TagsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('tagsPost', 'name', name)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TAGS_CREATE"], configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a tag
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsDelete(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsDelete(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all the tags
         * @param {string} [q] Search items by this string
         * @param {number} [count] Number of items to return
         * @param {string} [page] 
         * @param {boolean} [returnTotalCount] 
         * @param {boolean} [isCustomField] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsGet(q?: string, count?: number, page?: string, returnTotalCount?: boolean, isCustomField?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsGet(q, count, page, returnTotalCount, isCustomField, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {TagsPostRequest} [tagsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsPatch(name: string, tagsPostRequest?: TagsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsPatch(name, tagsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagsPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a tag
         * @param {string} name 
         * @param {TagsPostRequest} [tagsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsPost(name: string, tagsPostRequest?: TagsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsPost(name, tagsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.tagsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a tag
         * @param {TagsApiTagsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsDelete(requestParameters: TagsApiTagsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.tagsDelete(requestParameters.name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all the tags
         * @param {TagsApiTagsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet(requestParameters: TagsApiTagsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<TagsGet200Response> {
            return localVarFp.tagsGet(requestParameters.q, requestParameters.count, requestParameters.page, requestParameters.returnTotalCount, requestParameters.isCustomField, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TagsApiTagsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPatch(requestParameters: TagsApiTagsPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.tagsPatch(requestParameters.name, requestParameters.tagsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a tag
         * @param {TagsApiTagsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPost(requestParameters: TagsApiTagsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.tagsPost(requestParameters.name, requestParameters.tagsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for tagsDelete operation in TagsApi.
 * @export
 * @interface TagsApiTagsDeleteRequest
 */
export interface TagsApiTagsDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiTagsDelete
     */
    readonly name: string
}

/**
 * Request parameters for tagsGet operation in TagsApi.
 * @export
 * @interface TagsApiTagsGetRequest
 */
export interface TagsApiTagsGetRequest {
    /**
     * Search items by this string
     * @type {string}
     * @memberof TagsApiTagsGet
     */
    readonly q?: string

    /**
     * Number of items to return
     * @type {number}
     * @memberof TagsApiTagsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof TagsApiTagsGet
     */
    readonly page?: string

    /**
     * 
     * @type {boolean}
     * @memberof TagsApiTagsGet
     */
    readonly returnTotalCount?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TagsApiTagsGet
     */
    readonly isCustomField?: boolean
}

/**
 * Request parameters for tagsPatch operation in TagsApi.
 * @export
 * @interface TagsApiTagsPatchRequest
 */
export interface TagsApiTagsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiTagsPatch
     */
    readonly name: string

    /**
     * 
     * @type {TagsPostRequest}
     * @memberof TagsApiTagsPatch
     */
    readonly tagsPostRequest?: TagsPostRequest
}

/**
 * Request parameters for tagsPost operation in TagsApi.
 * @export
 * @interface TagsApiTagsPostRequest
 */
export interface TagsApiTagsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiTagsPost
     */
    readonly name: string

    /**
     * 
     * @type {TagsPostRequest}
     * @memberof TagsApiTagsPost
     */
    readonly tagsPostRequest?: TagsPostRequest
}

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a tag
     * @param {TagsApiTagsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsDelete(requestParameters: TagsApiTagsDeleteRequest, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsDelete(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all the tags
     * @param {TagsApiTagsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsGet(requestParameters: TagsApiTagsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsGet(requestParameters.q, requestParameters.count, requestParameters.page, requestParameters.returnTotalCount, requestParameters.isCustomField, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TagsApiTagsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsPatch(requestParameters: TagsApiTagsPatchRequest, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsPatch(requestParameters.name, requestParameters.tagsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a tag
     * @param {TagsApiTagsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsPost(requestParameters: TagsApiTagsPostRequest, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsPost(requestParameters.name, requestParameters.tagsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a template on the platform
         * @param {string} accountId 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesDelete: async (accountId: string, templateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('templatesDelete', 'accountId', accountId)
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('templatesDelete', 'templateId', templateId)
            const localVarPath = `/templates/{accountId}/{templateId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_CREATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit a template for review
         * @param {string} accountId 
         * @param {TemplatesSubmitForReviewRequest} [templatesSubmitForReviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesSubmitForReview: async (accountId: string, templatesSubmitForReviewRequest?: TemplatesSubmitForReviewRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('templatesSubmitForReview', 'accountId', accountId)
            const localVarPath = `/templates/{accountId}/submit-for-review`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templatesSubmitForReviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a template on the platform
         * @param {string} accountId 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesDelete(accountId: string, templateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesDelete(accountId, templateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Submit a template for review
         * @param {string} accountId 
         * @param {TemplatesSubmitForReviewRequest} [templatesSubmitForReviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesSubmitForReview(accountId: string, templatesSubmitForReviewRequest?: TemplatesSubmitForReviewRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesSubmitForReview200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesSubmitForReview(accountId, templatesSubmitForReviewRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.templatesSubmitForReview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a template on the platform
         * @param {TemplatesApiTemplatesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesDelete(requestParameters: TemplatesApiTemplatesDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.templatesDelete(requestParameters.accountId, requestParameters.templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit a template for review
         * @param {TemplatesApiTemplatesSubmitForReviewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesSubmitForReview(requestParameters: TemplatesApiTemplatesSubmitForReviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<TemplatesSubmitForReview200Response> {
            return localVarFp.templatesSubmitForReview(requestParameters.accountId, requestParameters.templatesSubmitForReviewRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for templatesDelete operation in TemplatesApi.
 * @export
 * @interface TemplatesApiTemplatesDeleteRequest
 */
export interface TemplatesApiTemplatesDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof TemplatesApiTemplatesDelete
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof TemplatesApiTemplatesDelete
     */
    readonly templateId: string
}

/**
 * Request parameters for templatesSubmitForReview operation in TemplatesApi.
 * @export
 * @interface TemplatesApiTemplatesSubmitForReviewRequest
 */
export interface TemplatesApiTemplatesSubmitForReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof TemplatesApiTemplatesSubmitForReview
     */
    readonly accountId: string

    /**
     * 
     * @type {TemplatesSubmitForReviewRequest}
     * @memberof TemplatesApiTemplatesSubmitForReview
     */
    readonly templatesSubmitForReviewRequest?: TemplatesSubmitForReviewRequest
}

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * 
     * @summary Delete a template on the platform
     * @param {TemplatesApiTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesDelete(requestParameters: TemplatesApiTemplatesDeleteRequest, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesDelete(requestParameters.accountId, requestParameters.templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit a template for review
     * @param {TemplatesApiTemplatesSubmitForReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesSubmitForReview(requestParameters: TemplatesApiTemplatesSubmitForReviewRequest, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesSubmitForReview(requestParameters.accountId, requestParameters.templatesSubmitForReviewRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Verify and handle messaging webhook subscription
         * @param {string} hubMode The mode parameter from the webhook request
         * @param {string} hubVerifyToken The verify_token parameter from the webhook request
         * @param {string} hubChallenge The challenge parameter from the webhook request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookMessengerGet: async (hubMode: string, hubVerifyToken: string, hubChallenge: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hubMode' is not null or undefined
            assertParamExists('webhookMessengerGet', 'hubMode', hubMode)
            // verify required parameter 'hubVerifyToken' is not null or undefined
            assertParamExists('webhookMessengerGet', 'hubVerifyToken', hubVerifyToken)
            // verify required parameter 'hubChallenge' is not null or undefined
            assertParamExists('webhookMessengerGet', 'hubChallenge', hubChallenge)
            const localVarPath = `/messenger/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hubMode !== undefined) {
                localVarQueryParameter['hub.mode'] = hubMode;
            }

            if (hubVerifyToken !== undefined) {
                localVarQueryParameter['hub.verify_token'] = hubVerifyToken;
            }

            if (hubChallenge !== undefined) {
                localVarQueryParameter['hub.challenge'] = hubChallenge;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Receive a message from the platform
         * @param {string} [accountId] 
         * @param {WebhookMessengerPostRequest} [webhookMessengerPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookMessengerPost: async (accountId?: string, webhookMessengerPostRequest?: WebhookMessengerPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messenger/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookMessengerPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Verify and handle messaging webhook subscription
         * @param {string} hubMode The mode parameter from the webhook request
         * @param {string} hubVerifyToken The verify_token parameter from the webhook request
         * @param {string} hubChallenge The challenge parameter from the webhook request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookMessengerGet(hubMode: string, hubVerifyToken: string, hubChallenge: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookMessengerGet(hubMode, hubVerifyToken, hubChallenge, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookMessengerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Receive a message from the platform
         * @param {string} [accountId] 
         * @param {WebhookMessengerPostRequest} [webhookMessengerPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookMessengerPost(accountId?: string, webhookMessengerPostRequest?: WebhookMessengerPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookMessengerPost(accountId, webhookMessengerPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookMessengerPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * 
         * @summary Verify and handle messaging webhook subscription
         * @param {WebhookApiWebhookMessengerGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookMessengerGet(requestParameters: WebhookApiWebhookMessengerGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.webhookMessengerGet(requestParameters.hubMode, requestParameters.hubVerifyToken, requestParameters.hubChallenge, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Receive a message from the platform
         * @param {WebhookApiWebhookMessengerPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookMessengerPost(requestParameters: WebhookApiWebhookMessengerPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AccountsDelete200Response> {
            return localVarFp.webhookMessengerPost(requestParameters.accountId, requestParameters.webhookMessengerPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for webhookMessengerGet operation in WebhookApi.
 * @export
 * @interface WebhookApiWebhookMessengerGetRequest
 */
export interface WebhookApiWebhookMessengerGetRequest {
    /**
     * The mode parameter from the webhook request
     * @type {string}
     * @memberof WebhookApiWebhookMessengerGet
     */
    readonly hubMode: string

    /**
     * The verify_token parameter from the webhook request
     * @type {string}
     * @memberof WebhookApiWebhookMessengerGet
     */
    readonly hubVerifyToken: string

    /**
     * The challenge parameter from the webhook request
     * @type {string}
     * @memberof WebhookApiWebhookMessengerGet
     */
    readonly hubChallenge: string
}

/**
 * Request parameters for webhookMessengerPost operation in WebhookApi.
 * @export
 * @interface WebhookApiWebhookMessengerPostRequest
 */
export interface WebhookApiWebhookMessengerPostRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhookApiWebhookMessengerPost
     */
    readonly accountId?: string

    /**
     * 
     * @type {WebhookMessengerPostRequest}
     * @memberof WebhookApiWebhookMessengerPost
     */
    readonly webhookMessengerPostRequest?: WebhookMessengerPostRequest
}

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * 
     * @summary Verify and handle messaging webhook subscription
     * @param {WebhookApiWebhookMessengerGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookMessengerGet(requestParameters: WebhookApiWebhookMessengerGetRequest, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookMessengerGet(requestParameters.hubMode, requestParameters.hubVerifyToken, requestParameters.hubChallenge, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Receive a message from the platform
     * @param {WebhookApiWebhookMessengerPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookMessengerPost(requestParameters: WebhookApiWebhookMessengerPostRequest = {}, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookMessengerPost(requestParameters.accountId, requestParameters.webhookMessengerPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



