const BASE_PATH = "https://api-im.chatdaddy.tech".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Instant Messaging Service
 * Complete instant messaging API for WhatsApp Multi-Device & Business API. 
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof Account
     */
    'accountId': string;
    /**
     * Owner of thr account
     * @type {string}
     * @memberof Account
     */
    'ownerId': string;
    /**
     * Assignees who can access this account.
     * @type {Array<string>}
     * @memberof Account
     */
    'assignees'?: Array<string>;
    /**
     * User facing nickname of the account
     * @type {string}
     * @memberof Account
     */
    'nickname': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Account
     */
    'credentials'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {AccountTier}
     * @memberof Account
     */
    'tier'?: AccountTier;
    /**
     * 
     * @type {AccountType}
     * @memberof Account
     */
    'type': AccountType;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    'createdAt': string;
    /**
     * The user ID of the user on ChatDaddy
     * @type {string}
     * @memberof Account
     */
    'createdBy'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    'updatedAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    'deletedAt'?: string | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    'lastLoginAt'?: string | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    'lastLogoutAt'?: string | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Account
     */
    'lastClosedAt'?: string | null;
    /**
     * 
     * @type {AccountState}
     * @memberof Account
     */
    'state': AccountState;
    /**
     * 
     * @type {AccountError}
     * @memberof Account
     */
    'error'?: AccountError | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Account
     */
    'stateInfo': { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'canLogin': boolean;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'userId'?: string | null;
    /**
     * 
     * @type {Contact}
     * @memberof Account
     */
    'user'?: Contact;
    /**
     * 
     * @type {AccountSettings}
     * @memberof Account
     */
    'settings': AccountSettings;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AccountAssignType = {
    SmartAssign: 'smart-assign',
    RoundRobin: 'round-robin'
} as const;

export type AccountAssignType = typeof AccountAssignType[keyof typeof AccountAssignType];


/**
 * @type AccountCredentialsAlibaba
 * @export
 */
export type AccountCredentialsAlibaba = AccountCredentialsAlibabaOneOf | AccountCredentialsAlibabaV2;

/**
 * 
 * @export
 * @interface AccountCredentialsAlibabaOneOf
 */
export interface AccountCredentialsAlibabaOneOf {
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsAlibabaOneOf
     */
    'type': AccountCredentialsAlibabaOneOfTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsAlibabaOneOf
     */
    'accessKeyId': string;
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsAlibabaOneOf
     */
    'accessKeySecret': string;
    /**
     * Secret for WebHook
     * @type {string}
     * @memberof AccountCredentialsAlibabaOneOf
     */
    'secret': string;
}

export const AccountCredentialsAlibabaOneOfTypeEnum = {
    AlibabaCams: 'alibaba-cams'
} as const;

export type AccountCredentialsAlibabaOneOfTypeEnum = typeof AccountCredentialsAlibabaOneOfTypeEnum[keyof typeof AccountCredentialsAlibabaOneOfTypeEnum];

/**
 * 
 * @export
 * @interface AccountCredentialsAlibabaV2
 */
export interface AccountCredentialsAlibabaV2 {
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsAlibabaV2
     */
    'type': AccountCredentialsAlibabaV2TypeEnum;
    /**
     * The initial access token used to authenticate with Alibaba CAMS service
     * @type {string}
     * @memberof AccountCredentialsAlibabaV2
     */
    'initialAccessToken'?: string;
    /**
     * The WABA ID of the business account. This is the same as the business account\'s JID
     * @type {string}
     * @memberof AccountCredentialsAlibabaV2
     */
    'wabaId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsAlibabaV2
     */
    'templateNamespace'?: string;
    /**
     * The customer space ID of the business account. Used internally
     * @type {string}
     * @memberof AccountCredentialsAlibabaV2
     */
    'custSpaceId'?: string;
    /**
     * Secret for WebHook
     * @type {string}
     * @memberof AccountCredentialsAlibabaV2
     */
    'secret': string;
}

export const AccountCredentialsAlibabaV2TypeEnum = {
    AlibabaCamsV2: 'alibaba-cams-v2'
} as const;

export type AccountCredentialsAlibabaV2TypeEnum = typeof AccountCredentialsAlibabaV2TypeEnum[keyof typeof AccountCredentialsAlibabaV2TypeEnum];

/**
 * 
 * @export
 * @interface AccountCredentialsMail
 */
export interface AccountCredentialsMail {
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsMail
     */
    'type': AccountCredentialsMailTypeEnum;
    /**
     * Email address of the account
     * @type {string}
     * @memberof AccountCredentialsMail
     */
    'emailAddress': string;
    /**
     * Unique Id of the sender
     * @type {number}
     * @memberof AccountCredentialsMail
     */
    'senderId': number;
}

export const AccountCredentialsMailTypeEnum = {
    Mail: 'mail'
} as const;

export type AccountCredentialsMailTypeEnum = typeof AccountCredentialsMailTypeEnum[keyof typeof AccountCredentialsMailTypeEnum];

/**
 * 
 * @export
 * @interface AccountCredentialsMeta
 */
export interface AccountCredentialsMeta {
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsMeta
     */
    'type': AccountCredentialsMetaTypeEnum;
    /**
     * Page ID of the Facebook page
     * @type {string}
     * @memberof AccountCredentialsMeta
     */
    'pageId': string;
    /**
     * Page access token of the Facebook page
     * @type {string}
     * @memberof AccountCredentialsMeta
     */
    'pageAccessToken': string;
}

export const AccountCredentialsMetaTypeEnum = {
    Messenger: 'messenger'
} as const;

export type AccountCredentialsMetaTypeEnum = typeof AccountCredentialsMetaTypeEnum[keyof typeof AccountCredentialsMetaTypeEnum];

/**
 * 
 * @export
 * @interface AccountCredentialsSms
 */
export interface AccountCredentialsSms {
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsSms
     */
    'type': AccountCredentialsSmsTypeEnum;
    /**
     * Sender Id to be displayed
     * @type {string}
     * @memberof AccountCredentialsSms
     */
    'senderId': string;
}

export const AccountCredentialsSmsTypeEnum = {
    Sms: 'sms'
} as const;

export type AccountCredentialsSmsTypeEnum = typeof AccountCredentialsSmsTypeEnum[keyof typeof AccountCredentialsSmsTypeEnum];

/**
 * 
 * @export
 * @interface AccountCredentialsTikTok
 */
export interface AccountCredentialsTikTok {
    /**
     * 
     * @type {string}
     * @memberof AccountCredentialsTikTok
     */
    'type': AccountCredentialsTikTokTypeEnum;
    /**
     * Cookies for TikTok. This must be a serialised `tough-cookie` cookiejar
     * @type {{ [key: string]: any; }}
     * @memberof AccountCredentialsTikTok
     */
    'cookies': { [key: string]: any; };
}

export const AccountCredentialsTikTokTypeEnum = {
    Tiktok: 'tiktok'
} as const;

export type AccountCredentialsTikTokTypeEnum = typeof AccountCredentialsTikTokTypeEnum[keyof typeof AccountCredentialsTikTokTypeEnum];

/**
 * 
 * @export
 * @interface AccountError
 */
export interface AccountError {
    /**
     * 
     * @type {string}
     * @memberof AccountError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AccountSettings
 */
export interface AccountSettings {
    /**
     * Supply a list of user IDs to notify when a new message arrives
     * @type {Array<string>}
     * @memberof AccountSettings
     */
    'notifyUsers'?: Array<string>;
    /**
     * Should chat history be synced with the database
     * @type {boolean}
     * @memberof AccountSettings
     */
    'enableHistorySync'?: boolean;
    /**
     * Maximum number of messages that would be synced to the database
     * @type {number}
     * @memberof AccountSettings
     */
    'maxMessageSync'?: number;
    /**
     * Will doing a chat action (like archive, mark unread) actually sync it back with the primary device
     * @type {boolean}
     * @memberof AccountSettings
     */
    'nativeChatActionSync'?: boolean;
    /**
     * Should unarchived chats be archived again when a new message arrives
     * @type {boolean}
     * @memberof AccountSettings
     */
    'unArchiveOnNewMessage'?: boolean;
    /**
     * 
     * @type {AccountSettingsNewChatsAssignee}
     * @memberof AccountSettings
     */
    'newChatsAssignee'?: AccountSettingsNewChatsAssignee;
    /**
     * Should polls be sent as buttons instead of a message. This is useful for the regular WhatsApp API
     * @type {boolean}
     * @memberof AccountSettings
     */
    'sendButtonsAsPoll'?: boolean;
    /**
     * Should story receiving/sending be enabled for the account. Only applicable for regular WhatsApp accounts.
     * @type {boolean}
     * @memberof AccountSettings
     */
    'enableStories'?: boolean;
    /**
     * Should products be synced to WhatsApp automatically.
     * @type {boolean}
     * @memberof AccountSettings
     */
    'autoSyncProductsToPlatform'?: boolean;
    /**
     * 
     * @type {KeepDeletedMessagesSettings}
     * @memberof AccountSettings
     */
    'keepDeletedMessages'?: KeepDeletedMessagesSettings;
    /**
     * Provide a geo location from where all traffic will be routed. Only relevant for non-webhook account types. Leave undefined to use the default geo location.
     * @type {string}
     * @memberof AccountSettings
     */
    'geoLocation'?: string;
}
/**
 * All new chats will be auto asssigned if one of the option is enabled and select any Assignee
 * @export
 * @interface AccountSettingsNewChatsAssignee
 */
export interface AccountSettingsNewChatsAssignee {
    /**
     * 
     * @type {ChatAssignment}
     * @memberof AccountSettingsNewChatsAssignee
     */
    'incoming'?: ChatAssignment;
    /**
     * 
     * @type {ChatAssignment}
     * @memberof AccountSettingsNewChatsAssignee
     */
    'outgoing'?: ChatAssignment;
}
/**
 * Describes the current state of an account. 1. open => logged in & connected to WhatsApp. Can send & receive messages now 2. connecting => establishing connection to WhatsApp. QR code is available during this state 3. close => connection to WhatsApp is closed, account is inactive at the moment
 * @export
 * @enum {string}
 */

export const AccountState = {
    Open: 'open',
    Connecting: 'connecting',
    Close: 'close'
} as const;

export type AccountState = typeof AccountState[keyof typeof AccountState];


/**
 * Describes the tier of the account, and which features it\'ll have
 * @export
 * @enum {string}
 */

export const AccountTier = {
    LimitedMsgNoChatHistory: 'limited_msg_no_chat_history',
    UnlimitedMsgChatHistory: 'unlimited_msg_chat_history'
} as const;

export type AccountTier = typeof AccountTier[keyof typeof AccountTier];


/**
 * 
 * @export
 * @enum {string}
 */

export const AccountType = {
    Wa: 'wa',
    WaBusinessApi: 'wa-business-api',
    Mock: 'mock',
    Tiktok: 'tiktok',
    Messenger: 'messenger',
    Mail: 'mail',
    Sms: 'sms',
    Instagram: 'instagram'
} as const;

export type AccountType = typeof AccountType[keyof typeof AccountType];


/**
 * @type AccountWaChangeLoginMode
 * @export
 */
export type AccountWaChangeLoginMode = AccountWaChangeLoginModeOneOf | AccountWaChangeLoginModeOneOf1;

/**
 * 
 * @export
 * @interface AccountWaChangeLoginModeOneOf
 */
export interface AccountWaChangeLoginModeOneOf {
    /**
     * 
     * @type {string}
     * @memberof AccountWaChangeLoginModeOneOf
     */
    'type': AccountWaChangeLoginModeOneOfTypeEnum;
}

export const AccountWaChangeLoginModeOneOfTypeEnum = {
    Qr: 'qr'
} as const;

export type AccountWaChangeLoginModeOneOfTypeEnum = typeof AccountWaChangeLoginModeOneOfTypeEnum[keyof typeof AccountWaChangeLoginModeOneOfTypeEnum];

/**
 * 
 * @export
 * @interface AccountWaChangeLoginModeOneOf1
 */
export interface AccountWaChangeLoginModeOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof AccountWaChangeLoginModeOneOf1
     */
    'type': AccountWaChangeLoginModeOneOf1TypeEnum;
    /**
     * Phone number to generate PIN for
     * @type {string}
     * @memberof AccountWaChangeLoginModeOneOf1
     */
    'phoneNumber': string;
}

export const AccountWaChangeLoginModeOneOf1TypeEnum = {
    PhoneNumber: 'phoneNumber'
} as const;

export type AccountWaChangeLoginModeOneOf1TypeEnum = typeof AccountWaChangeLoginModeOneOf1TypeEnum[keyof typeof AccountWaChangeLoginModeOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface AccountsGet200Response
 */
export interface AccountsGet200Response {
    /**
     * 
     * @type {Array<Account>}
     * @memberof AccountsGet200Response
     */
    'accounts': Array<Account>;
    /**
     * 
     * @type {number}
     * @memberof AccountsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface AccountsLogout200Response
 */
export interface AccountsLogout200Response {
    /**
     * 
     * @type {boolean}
     * @memberof AccountsLogout200Response
     */
    'success': boolean;
}
/**
 * Update an account. Specifying account updates the type
 * @export
 * @interface AccountsPatchRequest
 */
export interface AccountsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountsPatchRequest
     */
    'nickname'?: string;
    /**
     * 
     * @type {AccountTier}
     * @memberof AccountsPatchRequest
     */
    'tier'?: AccountTier;
    /**
     * 
     * @type {AccountSettings}
     * @memberof AccountsPatchRequest
     */
    'settings'?: AccountSettings;
    /**
     * 
     * @type {AccountsPatchRequestCredentials}
     * @memberof AccountsPatchRequest
     */
    'credentials'?: AccountsPatchRequestCredentials;
    /**
     * Assignees who can access this account.
     * @type {Array<string>}
     * @memberof AccountsPatchRequest
     */
    'assignees'?: Array<string>;
}


/**
 * @type AccountsPatchRequestCredentials
 * @export
 */
export type AccountsPatchRequestCredentials = AccountCredentialsAlibaba | AccountCredentialsAlibabaV2 | AccountCredentialsMail | AccountCredentialsMeta | AccountCredentialsSms | AccountCredentialsTikTok;

/**
 * 
 * @export
 * @interface AccountsPostRequest
 */
export interface AccountsPostRequest {
    /**
     * 
     * @type {AccountType}
     * @memberof AccountsPostRequest
     */
    'type': AccountType;
    /**
     * 
     * @type {AccountTier}
     * @memberof AccountsPostRequest
     */
    'tier'?: AccountTier;
    /**
     * 
     * @type {string}
     * @memberof AccountsPostRequest
     */
    'nickname'?: string;
    /**
     * 
     * @type {AccountSettings}
     * @memberof AccountsPostRequest
     */
    'settings'?: AccountSettings;
}


/**
 * 
 * @export
 * @interface AlibabCAMSQuotedContext
 */
export interface AlibabCAMSQuotedContext {
    /**
     * The user ID of the person that sent it
     * @type {string}
     * @memberof AlibabCAMSQuotedContext
     */
    'from': string;
    /**
     * The ID of the message that was replied to
     * @type {string}
     * @memberof AlibabCAMSQuotedContext
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface AlibabaCAMSForwardedContext
 */
export interface AlibabaCAMSForwardedContext {
    /**
     * 
     * @type {boolean}
     * @memberof AlibabaCAMSForwardedContext
     */
    'forwarded': boolean;
}
/**
 * 
 * @export
 * @interface AlibabaCAMSISVTerms
 */
export interface AlibabaCAMSISVTerms {
    /**
     * Name of the company
     * @type {string}
     * @memberof AlibabaCAMSISVTerms
     */
    'name': string;
    /**
     * Office address of the company
     * @type {string}
     * @memberof AlibabaCAMSISVTerms
     */
    'officeAddress': string;
    /**
     * Email address of the company
     * @type {string}
     * @memberof AlibabaCAMSISVTerms
     */
    'emailAddress': string;
    /**
     * ISO Country code of the company
     * @type {string}
     * @memberof AlibabaCAMSISVTerms
     */
    'countryCode': string;
    /**
     * Description of the company
     * @type {string}
     * @memberof AlibabaCAMSISVTerms
     */
    'description': string;
    /**
     * URL for uploaded pdf of ISV terms
     * @type {string}
     * @memberof AlibabaCAMSISVTerms
     */
    'isvTerms': string;
}
/**
 * 
 * @export
 * @interface AlibabaCAMSStateInfo
 */
export interface AlibabaCAMSStateInfo {
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSStateInfo
     */
    'status'?: AlibabaCAMSStateInfoStatusEnum;
    /**
     * Status of the company name approval from WABA
     * @type {string}
     * @memberof AlibabaCAMSStateInfo
     */
    'nameStatus'?: string;
    /**
     * Whether the business account is blocked from using Alibaba CAMS by WhatsApp
     * @type {boolean}
     * @memberof AlibabaCAMSStateInfo
     */
    'isBlocked'?: boolean;
    /**
     * 
     * @type {AlibabaCAMSISVTerms}
     * @memberof AlibabaCAMSStateInfo
     */
    'isvTerms'?: AlibabaCAMSISVTerms;
    /**
     * Description of the business account visible to others on WA
     * @type {string}
     * @memberof AlibabaCAMSStateInfo
     */
    'profileDescription'?: string;
}

export const AlibabaCAMSStateInfoStatusEnum = {
    PendingApproval: 'pending-approval',
    Approved: 'approved',
    Rejected: 'rejected'
} as const;

export type AlibabaCAMSStateInfoStatusEnum = typeof AlibabaCAMSStateInfoStatusEnum[keyof typeof AlibabaCAMSStateInfoStatusEnum];

/**
 * @type AlibabaCAMSWebhookItem
 * @export
 */
export type AlibabaCAMSWebhookItem = AlibabaCAMSWebhookMessageItem | AlibabaCAMSWebhookTemplateItem;

/**
 * 
 * @export
 * @interface AlibabaCAMSWebhookMessageItem
 */
export interface AlibabaCAMSWebhookMessageItem {
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'Type': AlibabaCAMSWebhookMessageItemTypeEnum;
    /**
     * Reason for rejection of template
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'Reason'?: string;
    /**
     * Status of the template
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'AuditStatus'?: AlibabaCAMSWebhookMessageItemAuditStatusEnum;
    /**
     * Code of the template
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'TemplateCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'Status'?: AlibabaCAMSWebhookMessageItemStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'ConversationId'?: string;
    /**
     * Raw text if type=TEXT, otherwise JSON stringified content
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'Message'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'From': string;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'To': string;
    /**
     * Unix timestamp in MS
     * @type {number}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'Timestamp': number;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'MessageId': string;
    /**
     * 
     * @type {AlibabaCAMSWebhookMessageItemContext}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'Context'?: AlibabaCAMSWebhookMessageItemContext;
    /**
     * Name of the user that sent the message
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'ConversationType'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'ErrorDescription'?: string;
    /**
     * 
     * @type {AlibabaCAMSWebhookMessageItemErrorCode}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'ErrorCode'?: AlibabaCAMSWebhookMessageItemErrorCode;
    /**
     * Unix timestamp in MS
     * @type {number}
     * @memberof AlibabaCAMSWebhookMessageItem
     */
    'ConversionExpirationTime'?: number;
}

export const AlibabaCAMSWebhookMessageItemTypeEnum = {
    Text: 'TEXT',
    Template: 'TEMPLATE',
    Image: 'IMAGE',
    Video: 'VIDEO',
    Audio: 'AUDIO',
    Document: 'DOCUMENT',
    Unknown: 'UNKNOWN',
    Location: 'LOCATION',
    Interactive: 'INTERACTIVE',
    Reply: 'REPLY',
    Reaction: 'REACTION',
    Contacts: 'CONTACTS'
} as const;

export type AlibabaCAMSWebhookMessageItemTypeEnum = typeof AlibabaCAMSWebhookMessageItemTypeEnum[keyof typeof AlibabaCAMSWebhookMessageItemTypeEnum];
export const AlibabaCAMSWebhookMessageItemAuditStatusEnum = {
    Fail: 'fail',
    Pass: 'pass'
} as const;

export type AlibabaCAMSWebhookMessageItemAuditStatusEnum = typeof AlibabaCAMSWebhookMessageItemAuditStatusEnum[keyof typeof AlibabaCAMSWebhookMessageItemAuditStatusEnum];
export const AlibabaCAMSWebhookMessageItemStatusEnum = {
    Sent: 'Sent',
    Delivered: 'Delivered',
    Read: 'Read',
    Failed: 'Failed'
} as const;

export type AlibabaCAMSWebhookMessageItemStatusEnum = typeof AlibabaCAMSWebhookMessageItemStatusEnum[keyof typeof AlibabaCAMSWebhookMessageItemStatusEnum];

/**
 * @type AlibabaCAMSWebhookMessageItemContext
 * @export
 */
export type AlibabaCAMSWebhookMessageItemContext = AlibabCAMSQuotedContext | AlibabaCAMSForwardedContext;

/**
 * @type AlibabaCAMSWebhookMessageItemErrorCode
 * @export
 */
export type AlibabaCAMSWebhookMessageItemErrorCode = number | string;

/**
 * 
 * @export
 * @interface AlibabaCAMSWebhookTemplateItem
 */
export interface AlibabaCAMSWebhookTemplateItem {
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookTemplateItem
     */
    'Type': AlibabaCAMSWebhookTemplateItemTypeEnum;
    /**
     * Code of the template
     * @type {string}
     * @memberof AlibabaCAMSWebhookTemplateItem
     */
    'TemplateCode': string;
    /**
     * Status of the template
     * @type {string}
     * @memberof AlibabaCAMSWebhookTemplateItem
     */
    'AuditStatus': AlibabaCAMSWebhookTemplateItemAuditStatusEnum;
    /**
     * Language of the template
     * @type {string}
     * @memberof AlibabaCAMSWebhookTemplateItem
     */
    'Language': string;
    /**
     * Waba ID of the template
     * @type {string}
     * @memberof AlibabaCAMSWebhookTemplateItem
     */
    'WabaId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlibabaCAMSWebhookTemplateItem
     */
    'Reason'?: string;
}

export const AlibabaCAMSWebhookTemplateItemTypeEnum = {
    Template: 'template'
} as const;

export type AlibabaCAMSWebhookTemplateItemTypeEnum = typeof AlibabaCAMSWebhookTemplateItemTypeEnum[keyof typeof AlibabaCAMSWebhookTemplateItemTypeEnum];
export const AlibabaCAMSWebhookTemplateItemAuditStatusEnum = {
    Fail: 'fail',
    Pass: 'pass'
} as const;

export type AlibabaCAMSWebhookTemplateItemAuditStatusEnum = typeof AlibabaCAMSWebhookTemplateItemAuditStatusEnum[keyof typeof AlibabaCAMSWebhookTemplateItemAuditStatusEnum];

/**
 * 
 * @export
 * @interface AlibabaCamsMetadata200Response
 */
export interface AlibabaCamsMetadata200Response {
    /**
     * Meta app ID for embedded sign up
     * @type {string}
     * @memberof AlibabaCamsMetadata200Response
     */
    'appId': string;
    /**
     * Meta terms pdf template for embedded sign up
     * @type {string}
     * @memberof AlibabaCamsMetadata200Response
     */
    'isvTermsTemplate': string;
}
/**
 * 
 * @export
 * @interface AlibabaCamsProfileUpdateRequest
 */
export interface AlibabaCamsProfileUpdateRequest {
    /**
     * Business profile picture URL
     * @type {string}
     * @memberof AlibabaCamsProfileUpdateRequest
     */
    'profilePictureUrl'?: string;
    /**
     * Business description
     * @type {string}
     * @memberof AlibabaCamsProfileUpdateRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface AlibabaCamsRegister200Response
 */
export interface AlibabaCamsRegister200Response {
    /**
     * User ID for the account
     * @type {string}
     * @memberof AlibabaCamsRegister200Response
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface AlibabaCamsRegisterRequest
 */
export interface AlibabaCamsRegisterRequest {
    /**
     * Id of the latest whatsapp business account
     * @type {string}
     * @memberof AlibabaCamsRegisterRequest
     */
    'wabaId': string;
    /**
     * Phone number to connect to the account. No formatting, just digits with country code. If not provided, the first phone number will be used.
     * @type {string}
     * @memberof AlibabaCamsRegisterRequest
     */
    'selectedPhoneNumber': string;
    /**
     * Token from embedded sign up
     * @type {string}
     * @memberof AlibabaCamsRegisterRequest
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface AlibabaCamsSync200Response
 */
export interface AlibabaCamsSync200Response {
    /**
     * 
     * @type {Account}
     * @memberof AlibabaCamsSync200Response
     */
    'account': Account;
}
/**
 * Override with new cust space ID & phone number
 * @export
 * @interface AlibabaCamsSyncRequest
 */
export interface AlibabaCamsSyncRequest {
    /**
     * WABA customer space ID
     * @type {string}
     * @memberof AlibabaCamsSyncRequest
     */
    'custSpaceId'?: string;
    /**
     * Phone number to connect to the account. No formatting, just digits with country code.
     * @type {string}
     * @memberof AlibabaCamsSyncRequest
     */
    'phoneNumber'?: string;
}
/**
 * @type AnyContactID
 * @export
 */
export type AnyContactID = UniqueContactID | string;

/**
 * 
 * @export
 * @interface AssigneeFilter
 */
export interface AssigneeFilter {
    /**
     * ID of the assignee
     * @type {string}
     * @memberof AssigneeFilter
     */
    'id': string;
    /**
     * 
     * @type {MetadataQuery}
     * @memberof AssigneeFilter
     */
    'assigned'?: MetadataQuery;
}
/**
 * 
 * @export
 * @interface Chat
 */
export interface Chat {
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof Chat
     */
    'accountId': string;
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof Chat
     */
    'id': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Chat
     */
    'lastMessage': string;
    /**
     * Number of unread messages
     * @type {number}
     * @memberof Chat
     */
    'unread': number;
    /**
     * 
     * @type {boolean}
     * @memberof Chat
     */
    'spam'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Chat
     */
    'archive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Chat
     */
    'readOnly': boolean;
    /**
     * 
     * @type {TicketStatus}
     * @memberof Chat
     */
    'ticketStatus'?: TicketStatus | null;
    /**
     * Timestamp of when the chat was muted
     * @type {number}
     * @memberof Chat
     */
    'mute'?: number | null;
    /**
     * Timestamp of when the chat was pinned
     * @type {number}
     * @memberof Chat
     */
    'pin'?: number | null;
    /**
     * did the user create this contact
     * @type {boolean}
     * @memberof Chat
     */
    'isUserGenerated': boolean;
    /**
     * does this chat have any pending messages
     * @type {boolean}
     * @memberof Chat
     */
    'hasPendingMessage'?: boolean;
    /**
     * does this chat have any unsolved notes
     * @type {boolean}
     * @memberof Chat
     */
    'hasUnsolvedNote'?: boolean;
    /**
     * does this chat have any failed messages
     * @type {boolean}
     * @memberof Chat
     */
    'hasFailedMessage'?: boolean;
    /**
     * the user IDs mentioned in the chat
     * @type {Array<string>}
     * @memberof Chat
     */
    'mentions'?: Array<string>;
    /**
     * if disappearing messages is on, and for how long
     * @type {number}
     * @memberof Chat
     */
    'disappearingMessages'?: number | null;
    /**
     * If the chat has all the message history from the primary source
     * @type {boolean}
     * @memberof Chat
     */
    'hasEntireMessageHistory': boolean;
    /**
     * 
     * @type {Contact}
     * @memberof Chat
     */
    'contact': Contact;
    /**
     * 
     * @type {Array<Message>}
     * @memberof Chat
     */
    'messages'?: Array<Message>;
    /**
     * 
     * @type {Array<ChatPresence>}
     * @memberof Chat
     */
    'presences'?: Array<ChatPresence>;
    /**
     * cursor to sort chats by
     * @type {string}
     * @memberof Chat
     */
    'cursor': string;
}


/**
 * 
 * @export
 * @interface ChatAction
 */
export interface ChatAction {
    /**
     * 
     * @type {string}
     * @memberof ChatAction
     */
    'action': ChatActionActionEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ChatAction
     */
    'value': boolean;
}

export const ChatActionActionEnum = {
    Archive: 'archive',
    Pin: 'pin',
    Mute: 'mute',
    Read: 'read',
    Delete: 'delete'
} as const;

export type ChatActionActionEnum = typeof ChatActionActionEnum[keyof typeof ChatActionActionEnum];

/**
 * 
 * @export
 * @interface ChatAssignment
 */
export interface ChatAssignment {
    /**
     * This flag will define if option should enabled/disabled
     * @type {boolean}
     * @memberof ChatAssignment
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {AccountAssignType}
     * @memberof ChatAssignment
     */
    'assignType'?: AccountAssignType;
    /**
     * If round-robin assign is enabled, which member will be assigned next
     * @type {string}
     * @memberof ChatAssignment
     */
    'nextAssignee'?: string;
    /**
     * Auto assigned will work for the selected teammates
     * @type {Array<string>}
     * @memberof ChatAssignment
     */
    'assignees'?: Array<string>;
}


/**
 * 
 * @export
 * @interface ChatPresence
 */
export interface ChatPresence {
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof ChatPresence
     */
    'accountId': string;
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof ChatPresence
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ChatPresence
     */
    'contactId': string;
    /**
     * if a known team member has this presence
     * @type {string}
     * @memberof ChatPresence
     */
    'userId'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ChatPresence
     */
    'updatedAt': string;
    /**
     * 
     * @type {PresenceType}
     * @memberof ChatPresence
     */
    'type': PresenceType;
}


/**
 * 
 * @export
 * @interface ChatsGet200Response
 */
export interface ChatsGet200Response {
    /**
     * next page cursor, if it exists
     * @type {string}
     * @memberof ChatsGet200Response
     */
    'nextPage'?: string;
    /**
     * number of total unread chats given the filter
     * @type {number}
     * @memberof ChatsGet200Response
     */
    'unreadChatCount'?: number;
    /**
     * total number of chats given the filter
     * @type {number}
     * @memberof ChatsGet200Response
     */
    'totalDataCount'?: number;
    /**
     * the API counts at most N unread chats, if there are more unread chats that were not fetched, this flag is true
     * @type {boolean}
     * @memberof ChatsGet200Response
     */
    'hasMoreUnread'?: boolean;
    /**
     * 
     * @type {Array<Chat>}
     * @memberof ChatsGet200Response
     */
    'chats': Array<Chat>;
}
/**
 * @type ChatsGetAssigneeParameter
 * @export
 */
export type ChatsGetAssigneeParameter = Array<ChatsGetAssigneeParameterOneOf> | ChatsGetAssigneeParameterOneOf;

/**
 * @type ChatsGetAssigneeParameterOneOf
 * @export
 */
export type ChatsGetAssigneeParameterOneOf = AssigneeFilter | string;

/**
 * @type ChatsGetContactsParameter
 * @export
 */
export type ChatsGetContactsParameter = AnyContactID | Array<AnyContactID>;

/**
 * @type ChatsGetTagsParameter
 * @export
 */
export type ChatsGetTagsParameter = Array<ChatsGetTagsParameterOneOf> | ChatsGetTagsParameterOneOf;

/**
 * @type ChatsGetTagsParameterOneOf
 * @export
 */
export type ChatsGetTagsParameterOneOf = TagFilter | string;

/**
 * 
 * @export
 * @interface ChatsGetTicketParameter
 */
export interface ChatsGetTicketParameter {
    /**
     * ID of a CRM board
     * @type {string}
     * @memberof ChatsGetTicketParameter
     */
    'boardId': string;
    /**
     * ID of a stage
     * @type {string}
     * @memberof ChatsGetTicketParameter
     */
    'stageId'?: string;
}
/**
 * 
 * @export
 * @interface ChatsTicketStatusPatchRequest
 */
export interface ChatsTicketStatusPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatsTicketStatusPatchRequest
     */
    'ticketStatus': ChatsTicketStatusPatchRequestTicketStatusEnum;
}

export const ChatsTicketStatusPatchRequestTicketStatusEnum = {
    Closed: 'closed',
    Open: 'open'
} as const;

export type ChatsTicketStatusPatchRequestTicketStatusEnum = typeof ChatsTicketStatusPatchRequestTicketStatusEnum[keyof typeof ChatsTicketStatusPatchRequestTicketStatusEnum];

/**
 * 
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof Contact
     */
    'id': string;
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof Contact
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'cursor': string;
    /**
     * 
     * @type {ContactType}
     * @memberof Contact
     */
    'type': ContactType;
    /**
     * name of the contact as set on ChatDaddy
     * @type {string}
     * @memberof Contact
     */
    'name': string | null;
    /**
     * name of the contact, as set on the platform
     * @type {Array<string>}
     * @memberof Contact
     */
    'platformNames': Array<string>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Contact
     */
    'createdAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Contact
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'phoneNumber': string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'email'?: string | null;
    /**
     * 
     * @type {ContactImg}
     * @memberof Contact
     */
    'img'?: ContactImg | null;
    /**
     * Tags associated with this contact
     * @type {Array<ContactTag>}
     * @memberof Contact
     */
    'tags': Array<ContactTag>;
    /**
     * CRM Board Tickets associated with this contact
     * @type {Array<ContactTicket>}
     * @memberof Contact
     */
    'tickets'?: Array<ContactTicket>;
    /**
     * The assignee of the contact
     * @type {string}
     * @memberof Contact
     */
    'assignee'?: string | null;
    /**
     * The person who assigned this contact
     * @type {string}
     * @memberof Contact
     */
    'assigner'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Contact
     */
    'assignedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    'messagesSent': number;
    /**
     * 
     * @type {number}
     * @memberof Contact
     */
    'messagesReceived': number;
    /**
     * 
     * @type {ContactChat}
     * @memberof Contact
     */
    'chat'?: ContactChat;
}


/**
 * 
 * @export
 * @interface ContactChat
 */
export interface ContactChat {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ContactChat
     */
    'lastMessage': string;
}
/**
 * @type ContactCrmTicketPatch
 * @export
 */
export type ContactCrmTicketPatch = ContactCrmTicketPatchOneOf | ContactCrmTicketPatchOneOf1;

/**
 * 
 * @export
 * @interface ContactCrmTicketPatchOneOf
 */
export interface ContactCrmTicketPatchOneOf {
    /**
     * ID of a CRM board
     * @type {string}
     * @memberof ContactCrmTicketPatchOneOf
     */
    'boardId': string;
    /**
     * remove this contact from the CRM board
     * @type {boolean}
     * @memberof ContactCrmTicketPatchOneOf
     */
    'remove': boolean;
}
/**
 * 
 * @export
 * @interface ContactCrmTicketPatchOneOf1
 */
export interface ContactCrmTicketPatchOneOf1 {
    /**
     * ID of a CRM board
     * @type {string}
     * @memberof ContactCrmTicketPatchOneOf1
     */
    'boardId': string;
    /**
     * ID of a stage
     * @type {string}
     * @memberof ContactCrmTicketPatchOneOf1
     */
    'stageId': string;
    /**
     * Order of a ticket
     * @type {number}
     * @memberof ContactCrmTicketPatchOneOf1
     */
    'order'?: number;
}
/**
 * 
 * @export
 * @interface ContactImg
 */
export interface ContactImg {
    /**
     * 
     * @type {string}
     * @memberof ContactImg
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactImg
     */
    'fullUrl'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ContactImg
     */
    'fetchedAt'?: string;
}
/**
 * 
 * @export
 * @interface ContactTag
 */
export interface ContactTag {
    /**
     * 
     * @type {string}
     * @memberof ContactTag
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTag
     */
    'value'?: string | null;
    /**
     * used in events to denote that the tag has been removed
     * @type {boolean}
     * @memberof ContactTag
     */
    'remove'?: boolean;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof ContactTag
     */
    'addedMetadata': UpsertMetadata;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof ContactTag
     */
    'updatedMetadata'?: UpsertMetadata;
}
/**
 * 
 * @export
 * @interface ContactTagAllOf
 */
export interface ContactTagAllOf {
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof ContactTagAllOf
     */
    'addedMetadata': UpsertMetadata;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof ContactTagAllOf
     */
    'updatedMetadata'?: UpsertMetadata;
}
/**
 * 
 * @export
 * @interface ContactTagInsert
 */
export interface ContactTagInsert {
    /**
     * 
     * @type {string}
     * @memberof ContactTagInsert
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTagInsert
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface ContactTagUpdate
 */
export interface ContactTagUpdate {
    /**
     * 
     * @type {string}
     * @memberof ContactTagUpdate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ContactTagUpdate
     */
    'value'?: string | null;
    /**
     * used in events to denote that the tag has been removed
     * @type {boolean}
     * @memberof ContactTagUpdate
     */
    'remove'?: boolean;
}
/**
 * Metadata about a ticket in the contact
 * @export
 * @interface ContactTicket
 */
export interface ContactTicket {
    /**
     * ID of a CRM board
     * @type {string}
     * @memberof ContactTicket
     */
    'boardId': string;
    /**
     * ID of a stage
     * @type {string}
     * @memberof ContactTicket
     */
    'stageId': string;
    /**
     * ID of a ticket
     * @type {string}
     * @memberof ContactTicket
     */
    'id': string;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof ContactTicket
     */
    'createMetadata'?: UpsertMetadata;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ContactType = {
    Individual: 'individual',
    Group: 'group',
    Channel: 'channel',
    Broadcast: 'broadcast',
    Post: 'post'
} as const;

export type ContactType = typeof ContactType[keyof typeof ContactType];


/**
 * 
 * @export
 * @interface ContactsCheckExists200Response
 */
export interface ContactsCheckExists200Response {
    /**
     * Whether the user exists
     * @type {boolean}
     * @memberof ContactsCheckExists200Response
     */
    'exists': boolean;
    /**
     * True ID of the user on the platform
     * @type {string}
     * @memberof ContactsCheckExists200Response
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ContactsGet200Response
 */
export interface ContactsGet200Response {
    /**
     * total contacts present with these filters. Only returned if returnTotalCount is true
     * @type {number}
     * @memberof ContactsGet200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {Array<Contact>}
     * @memberof ContactsGet200Response
     */
    'contacts': Array<Contact>;
    /**
     * 
     * @type {string}
     * @memberof ContactsGet200Response
     */
    'nextPage': string | null;
}
/**
 * 
 * @export
 * @interface ContactsImageGet200Response
 */
export interface ContactsImageGet200Response {
    /**
     * 
     * @type {string}
     * @memberof ContactsImageGet200Response
     */
    'url': string | null;
}
/**
 * 
 * @export
 * @interface ContactsPatch
 */
export interface ContactsPatch {
    /**
     * 
     * @type {ContactsPatchPatch}
     * @memberof ContactsPatch
     */
    'patch': ContactsPatchPatch;
}
/**
 * 
 * @export
 * @interface ContactsPatch200Response
 */
export interface ContactsPatch200Response {
    /**
     * 
     * @type {number}
     * @memberof ContactsPatch200Response
     */
    'updated': number;
}
/**
 * 
 * @export
 * @interface ContactsPatchPatch
 */
export interface ContactsPatchPatch {
    /**
     * 
     * @type {string}
     * @memberof ContactsPatchPatch
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactsPatchPatch
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactsPatchPatch
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactsPatchPatch
     */
    'assignee'?: string | null;
    /**
     * 
     * @type {Array<ContactTagUpdate>}
     * @memberof ContactsPatchPatch
     */
    'tags'?: Array<ContactTagUpdate>;
}
/**
 * 
 * @export
 * @interface ContactsPost
 */
export interface ContactsPost {
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof ContactsPost
     */
    'accountId'?: string;
    /**
     * 
     * @type {Array<ContactsPostContactsInner>}
     * @memberof ContactsPost
     */
    'contacts': Array<ContactsPostContactsInner>;
}
/**
 * 
 * @export
 * @interface ContactsPostContactsInner
 */
export interface ContactsPostContactsInner {
    /**
     * 
     * @type {string}
     * @memberof ContactsPostContactsInner
     */
    'name': string | null;
    /**
     * The phone number of the contact
     * @type {string}
     * @memberof ContactsPostContactsInner
     */
    'phoneNumber': string;
    /**
     * The email of the contact
     * @type {string}
     * @memberof ContactsPostContactsInner
     */
    'email'?: string;
    /**
     * 
     * @type {Array<ContactTagInsert>}
     * @memberof ContactsPostContactsInner
     */
    'tags'?: Array<ContactTagInsert> | null;
    /**
     * 
     * @type {string}
     * @memberof ContactsPostContactsInner
     */
    'assignee'?: string | null;
}
/**
 * 
 * @export
 * @interface CrmBoard
 */
export interface CrmBoard {
    /**
     * ID of a CRM board
     * @type {string}
     * @memberof CrmBoard
     */
    'id': string;
    /**
     * Name of the CRM board
     * @type {string}
     * @memberof CrmBoard
     */
    'name': string;
    /**
     * teamId of the owner of this CRM board
     * @type {string}
     * @memberof CrmBoard
     */
    'ownerId': string;
    /**
     * 
     * @type {Array<CrmBoardStage>}
     * @memberof CrmBoard
     */
    'stages': Array<CrmBoardStage>;
    /**
     * Minimum response time after the ticket was created, in seconds
     * @type {number}
     * @memberof CrmBoard
     */
    'minResponseTime'?: number;
    /**
     * After the ticket created, within this time, the ticket should be closed, in seconds
     * @type {number}
     * @memberof CrmBoard
     */
    'minCloseTime'?: number;
    /**
     * 
     * @type {Array<CrmBoardCustomField>}
     * @memberof CrmBoard
     */
    'customFields'?: Array<CrmBoardCustomField>;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof CrmBoard
     */
    'addedMetadata'?: UpsertMetadata;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof CrmBoard
     */
    'updatedMetadata'?: UpsertMetadata;
}
/**
 * 
 * @export
 * @interface CrmBoardCustomField
 */
export interface CrmBoardCustomField {
    /**
     * 
     * @type {string}
     * @memberof CrmBoardCustomField
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof CrmBoardCustomField
     */
    'show': boolean;
}
/**
 * 
 * @export
 * @interface CrmBoardGet200Response
 */
export interface CrmBoardGet200Response {
    /**
     * 
     * @type {Array<CrmBoard>}
     * @memberof CrmBoardGet200Response
     */
    'items': Array<CrmBoard>;
}
/**
 * 
 * @export
 * @interface CrmBoardPatch
 */
export interface CrmBoardPatch {
    /**
     * Name of the CRM board
     * @type {string}
     * @memberof CrmBoardPatch
     */
    'name'?: string;
    /**
     * Minimum response time after the ticket was created, in seconds
     * @type {number}
     * @memberof CrmBoardPatch
     */
    'minResponseTime'?: number;
    /**
     * After the ticket created, within this time, the ticket should be closed, in seconds
     * @type {number}
     * @memberof CrmBoardPatch
     */
    'minCloseTime'?: number;
    /**
     * 
     * @type {Array<CrmBoardStagePatch>}
     * @memberof CrmBoardPatch
     */
    'stages'?: Array<CrmBoardStagePatch>;
    /**
     * 
     * @type {CrmBoardPatchCustomFields}
     * @memberof CrmBoardPatch
     */
    'customFields'?: CrmBoardPatchCustomFields;
}
/**
 * @type CrmBoardPatchCustomFields
 * @export
 */
export type CrmBoardPatchCustomFields = Array<CrmBoardCustomField>;

/**
 * 
 * @export
 * @interface CrmBoardPost
 */
export interface CrmBoardPost {
    /**
     * Name of the CRM board
     * @type {string}
     * @memberof CrmBoardPost
     */
    'name': string;
    /**
     * Minimum response time after the ticket was created, in seconds
     * @type {number}
     * @memberof CrmBoardPost
     */
    'minResponseTime'?: number;
    /**
     * After the ticket created, within this time, the ticket should be closed, in seconds
     * @type {number}
     * @memberof CrmBoardPost
     */
    'minCloseTime'?: number;
    /**
     * 
     * @type {Array<CrmBoardStagePost>}
     * @memberof CrmBoardPost
     */
    'stages': Array<CrmBoardStagePost>;
    /**
     * 
     * @type {Array<CrmBoardCustomField>}
     * @memberof CrmBoardPost
     */
    'customFields'?: Array<CrmBoardCustomField>;
}
/**
 * 
 * @export
 * @interface CrmBoardStage
 */
export interface CrmBoardStage {
    /**
     * ID of a stage
     * @type {string}
     * @memberof CrmBoardStage
     */
    'id': string;
    /**
     * Name of the stage
     * @type {string}
     * @memberof CrmBoardStage
     */
    'name': string;
    /**
     * Hex color code
     * @type {string}
     * @memberof CrmBoardStage
     */
    'color': string;
}
/**
 * 
 * @export
 * @interface CrmBoardStageDelete
 */
export interface CrmBoardStageDelete {
    /**
     * ID of a stage
     * @type {string}
     * @memberof CrmBoardStageDelete
     */
    'id': string;
    /**
     * True if the stage should be removed from the board
     * @type {boolean}
     * @memberof CrmBoardStageDelete
     */
    'remove': boolean;
    /**
     * ID of the stage to move all the contact\'s to when this stage removed
     * @type {string}
     * @memberof CrmBoardStageDelete
     */
    'moveTo'?: string;
}
/**
 * @type CrmBoardStagePatch
 * @export
 */
export type CrmBoardStagePatch = CrmBoardStageDelete | CrmBoardStagePatchData | CrmBoardStagePost;

/**
 * 
 * @export
 * @interface CrmBoardStagePatchData
 */
export interface CrmBoardStagePatchData {
    /**
     * ID of a stage
     * @type {string}
     * @memberof CrmBoardStagePatchData
     */
    'id': string;
    /**
     * Name of the stage
     * @type {string}
     * @memberof CrmBoardStagePatchData
     */
    'name'?: string;
    /**
     * Hex color code
     * @type {string}
     * @memberof CrmBoardStagePatchData
     */
    'color'?: string;
    /**
     * Order of a ticket
     * @type {number}
     * @memberof CrmBoardStagePatchData
     */
    'index'?: number;
}
/**
 * 
 * @export
 * @interface CrmBoardStagePost
 */
export interface CrmBoardStagePost {
    /**
     * Name of the stage
     * @type {string}
     * @memberof CrmBoardStagePost
     */
    'name': string;
    /**
     * Hex color code
     * @type {string}
     * @memberof CrmBoardStagePost
     */
    'color': string;
    /**
     * Order of a ticket
     * @type {number}
     * @memberof CrmBoardStagePost
     */
    'index'?: number;
}
/**
 * 
 * @export
 * @interface CrmTicket
 */
export interface CrmTicket {
    /**
     * ID of a ticket
     * @type {string}
     * @memberof CrmTicket
     */
    'id': string;
    /**
     * ID of a CRM board
     * @type {string}
     * @memberof CrmTicket
     */
    'boardId': string;
    /**
     * ID of a stage
     * @type {string}
     * @memberof CrmTicket
     */
    'stageId': string;
    /**
     * ID of a stage
     * @type {string}
     * @memberof CrmTicket
     */
    'prevStageId'?: string;
    /**
     * Order of a ticket
     * @type {number}
     * @memberof CrmTicket
     */
    'order': number;
    /**
     * Title of the ticket
     * @type {string}
     * @memberof CrmTicket
     */
    'title': string;
    /**
     * 
     * @type {UniqueContactID}
     * @memberof CrmTicket
     */
    'contactId': UniqueContactID;
    /**
     * 
     * @type {Contact}
     * @memberof CrmTicket
     */
    'contact'?: Contact;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof CrmTicket
     */
    'createMetadata': UpsertMetadata;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof CrmTicket
     */
    'updateMetadata': UpsertMetadata;
    /**
     * 
     * @type {UpsertMetadata}
     * @memberof CrmTicket
     */
    'resolvedMetadata'?: UpsertMetadata;
}
/**
 * 
 * @export
 * @interface CrmTicketPatch
 */
export interface CrmTicketPatch {
    /**
     * ID of a stage
     * @type {string}
     * @memberof CrmTicketPatch
     */
    'stageId'?: string;
    /**
     * Title of the ticket
     * @type {string}
     * @memberof CrmTicketPatch
     */
    'title'?: string;
    /**
     * Order of a ticket
     * @type {number}
     * @memberof CrmTicketPatch
     */
    'order'?: number;
}
/**
 * 
 * @export
 * @interface CrmTicketPost
 */
export interface CrmTicketPost {
    /**
     * ID of a CRM board
     * @type {string}
     * @memberof CrmTicketPost
     */
    'boardId': string;
    /**
     * ID of a stage
     * @type {string}
     * @memberof CrmTicketPost
     */
    'stageId'?: string;
    /**
     * Title of the ticket
     * @type {string}
     * @memberof CrmTicketPost
     */
    'title': string;
    /**
     * 
     * @type {UniqueContactID}
     * @memberof CrmTicketPost
     */
    'contactId': UniqueContactID;
    /**
     * Order of a ticket
     * @type {number}
     * @memberof CrmTicketPost
     */
    'order'?: number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CrmTicketPost
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface EntryItems
 */
export interface EntryItems {
    /**
     * 
     * @type {string}
     * @memberof EntryItems
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof EntryItems
     */
    'time'?: number;
    /**
     * 
     * @type {Array<MessagingItems>}
     * @memberof EntryItems
     */
    'messaging'?: Array<MessagingItems>;
}
/**
 * 
 * @export
 * @interface GetChatHistory200Response
 */
export interface GetChatHistory200Response {
    /**
     * 
     * @type {string}
     * @memberof GetChatHistory200Response
     */
    'requestId': string;
}
/**
 * 
 * @export
 * @interface GetTickets200Response
 */
export interface GetTickets200Response {
    /**
     * 
     * @type {Array<CrmTicket>}
     * @memberof GetTickets200Response
     */
    'items': Array<CrmTicket>;
    /**
     * 
     * @type {string}
     * @memberof GetTickets200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetTickets200Response
     */
    'totalCount'?: number;
}
/**
 * @type GroupAction
 * @export
 */
export type GroupAction = GroupMetadataAction | GroupParticipantsAction;

/**
 * 
 * @export
 * @enum {string}
 */

export const GroupActionType = {
    Add: 'add',
    Remove: 'remove',
    Demote: 'demote',
    Promote: 'promote'
} as const;

export type GroupActionType = typeof GroupActionType[keyof typeof GroupActionType];


/**
 * 
 * @export
 * @interface GroupCreate
 */
export interface GroupCreate {
    /**
     * 
     * @type {string}
     * @memberof GroupCreate
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupCreate
     */
    'participants': Array<string>;
}
/**
 * 
 * @export
 * @interface GroupMetadata
 */
export interface GroupMetadata {
    /**
     * 
     * @type {string}
     * @memberof GroupMetadata
     */
    'id': string;
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof GroupMetadata
     */
    'accountId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof GroupMetadata
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GroupMetadata
     */
    'ownerId'?: string | null;
    /**
     * 
     * @type {Contact}
     * @memberof GroupMetadata
     */
    'owner'?: Contact;
    /**
     * 
     * @type {string}
     * @memberof GroupMetadata
     */
    'description': string | null;
    /**
     * is set when the group only allows admins to change group settings
     * @type {boolean}
     * @memberof GroupMetadata
     */
    'restrict': boolean;
    /**
     * is set when the group only allows admins to write messages
     * @type {boolean}
     * @memberof GroupMetadata
     */
    'announce': boolean;
    /**
     * 
     * @type {Array<GroupParticipant>}
     * @memberof GroupMetadata
     */
    'participants': Array<GroupParticipant>;
}
/**
 * 
 * @export
 * @interface GroupMetadataAction
 */
export interface GroupMetadataAction {
    /**
     * 
     * @type {string}
     * @memberof GroupMetadataAction
     */
    'action': GroupMetadataActionActionEnum;
    /**
     * 
     * @type {string}
     * @memberof GroupMetadataAction
     */
    'value': string;
}

export const GroupMetadataActionActionEnum = {
    UpdateDescription: 'update_description'
} as const;

export type GroupMetadataActionActionEnum = typeof GroupMetadataActionActionEnum[keyof typeof GroupMetadataActionActionEnum];

/**
 * 
 * @export
 * @interface GroupParticipant
 */
export interface GroupParticipant {
    /**
     * 
     * @type {Contact}
     * @memberof GroupParticipant
     */
    'contact': Contact;
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof GroupParticipant
     */
    'contactId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupParticipant
     */
    'admin'?: GroupParticipantAdminEnum;
}

export const GroupParticipantAdminEnum = {
    Admin: 'admin',
    SuperAdmin: 'super-admin'
} as const;

export type GroupParticipantAdminEnum = typeof GroupParticipantAdminEnum[keyof typeof GroupParticipantAdminEnum];

/**
 * 
 * @export
 * @interface GroupParticipantsAction
 */
export interface GroupParticipantsAction {
    /**
     * 
     * @type {GroupActionType}
     * @memberof GroupParticipantsAction
     */
    'action': GroupActionType;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupParticipantsAction
     */
    'participants': Array<string>;
}


/**
 * 
 * @export
 * @interface GroupsInviteCode200Response
 */
export interface GroupsInviteCode200Response {
    /**
     * 
     * @type {string}
     * @memberof GroupsInviteCode200Response
     */
    'inviteCode': string;
}
/**
 * 
 * @export
 * @interface KeepDeletedMessagesSettings
 */
export interface KeepDeletedMessagesSettings {
    /**
     * Should messages sent by the account be kept.
     * @type {boolean}
     * @memberof KeepDeletedMessagesSettings
     */
    'fromMe': boolean;
}
/**
 * 
 * @export
 * @interface ListMessage
 */
export interface ListMessage {
    /**
     * The title of the list
     * @type {string}
     * @memberof ListMessage
     */
    'title'?: string;
    /**
     * 
     * @type {Array<ListMessageSection>}
     * @memberof ListMessage
     */
    'sections': Array<ListMessageSection>;
    /**
     * The maximum number of options that can be selected
     * @type {number}
     * @memberof ListMessage
     */
    'maxSelections'?: number;
}
/**
 * 
 * @export
 * @interface ListMessageOption
 */
export interface ListMessageOption {
    /**
     * 
     * @type {string}
     * @memberof ListMessageOption
     */
    'id': string;
    /**
     * The text of the option
     * @type {string}
     * @memberof ListMessageOption
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface ListMessageSection
 */
export interface ListMessageSection {
    /**
     * The title of the section
     * @type {string}
     * @memberof ListMessageSection
     */
    'title': string;
    /**
     * 
     * @type {Array<ListMessageOption>}
     * @memberof ListMessageSection
     */
    'options': Array<ListMessageOption>;
    /**
     * The maximum number of options that can be selected
     * @type {number}
     * @memberof ListMessageSection
     */
    'maxSelections'?: number;
}
/**
 * 
 * @export
 * @interface MailRegisterPostRequest
 */
export interface MailRegisterPostRequest {
    /**
     * 
     * @type {string}
     * @memberof MailRegisterPostRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface MailStateInfo
 */
export interface MailStateInfo {
    /**
     * 
     * @type {boolean}
     * @memberof MailStateInfo
     */
    'senderVerified'?: boolean;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof Message
     */
    'chatId': string;
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof Message
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'fromMe': boolean;
    /**
     * The contact that sent the message (applicable for groups)
     * @type {string}
     * @memberof Message
     */
    'senderContactId'?: string | null;
    /**
     * 
     * @type {MessageAllOfSender}
     * @memberof Message
     */
    'sender'?: MessageAllOfSender | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Message
     */
    'timestamp': string;
    /**
     * 
     * @type {MessageStatus}
     * @memberof Message
     */
    'status'?: MessageStatus;
    /**
     * 
     * @type {MessageAllOfError}
     * @memberof Message
     */
    'error'?: MessageAllOfError | null;
    /**
     * Only for notes, user ID of the person who resolved the note
     * @type {string}
     * @memberof Message
     */
    'resolvedBy'?: string | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Message
     */
    'resolvedAt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'hidden'?: boolean;
    /**
     * If the message has been revised, i.e. edited, fixed or had its status updated, this will be incremented. This number is managed by CD, and will not reflect correctly for messages newly synced from the platform
     * @type {number}
     * @memberof Message
     */
    'revision'?: number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Message
     */
    'editedAt'?: string | null;
    /**
     * 
     * @type {MiscOptions}
     * @memberof Message
     */
    'miscOptions'?: MiscOptions;
    /**
     * 
     * @type {WABAConversationMetadata}
     * @memberof Message
     */
    'conversationMetadata'?: WABAConversationMetadata;
    /**
     * 
     * @type {Array<string>}
     * @memberof Message
     */
    'mentions'?: Array<string>;
    /**
     * The subject of the message
     * @type {string}
     * @memberof Message
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'text'?: string | null;
    /**
     * 
     * @type {QuotedMessage}
     * @memberof Message
     */
    'quoted'?: QuotedMessage | null;
    /**
     * True, if the message was deleted
     * @type {boolean}
     * @memberof Message
     */
    'deleted'?: boolean;
    /**
     * True, if the message failed to decrypt
     * @type {boolean}
     * @memberof Message
     */
    'failDecryption'?: boolean;
    /**
     * 
     * @type {MessageContentAction}
     * @memberof Message
     */
    'action'?: MessageContentAction | null;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof Message
     */
    'attachments'?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<MessageButton>}
     * @memberof Message
     */
    'buttons'?: Array<MessageButton> | null;
    /**
     * 
     * @type {Poll}
     * @memberof Message
     */
    'poll'?: Poll;
    /**
     * 
     * @type {ListMessage}
     * @memberof Message
     */
    'list'?: ListMessage;
    /**
     * 
     * @type {Array<MessageProduct>}
     * @memberof Message
     */
    'products'?: Array<MessageProduct> | null;
    /**
     * 
     * @type {MessageContentOrder}
     * @memberof Message
     */
    'order'?: MessageContentOrder | null;
    /**
     * 
     * @type {MessageLinkPreview}
     * @memberof Message
     */
    'linkPreview'?: MessageLinkPreview;
    /**
     * 
     * @type {Array<MessageReaction>}
     * @memberof Message
     */
    'reactions'?: Array<MessageReaction> | null;
}


/**
 * 
 * @export
 * @interface MessageAllOf
 */
export interface MessageAllOf {
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof MessageAllOf
     */
    'chatId': string;
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof MessageAllOf
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageAllOf
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof MessageAllOf
     */
    'fromMe': boolean;
    /**
     * The contact that sent the message (applicable for groups)
     * @type {string}
     * @memberof MessageAllOf
     */
    'senderContactId'?: string | null;
    /**
     * 
     * @type {MessageAllOfSender}
     * @memberof MessageAllOf
     */
    'sender'?: MessageAllOfSender | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageAllOf
     */
    'timestamp': string;
    /**
     * 
     * @type {MessageStatus}
     * @memberof MessageAllOf
     */
    'status'?: MessageStatus;
    /**
     * 
     * @type {MessageAllOfError}
     * @memberof MessageAllOf
     */
    'error'?: MessageAllOfError | null;
    /**
     * Only for notes, user ID of the person who resolved the note
     * @type {string}
     * @memberof MessageAllOf
     */
    'resolvedBy'?: string | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageAllOf
     */
    'resolvedAt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MessageAllOf
     */
    'hidden'?: boolean;
    /**
     * If the message has been revised, i.e. edited, fixed or had its status updated, this will be incremented. This number is managed by CD, and will not reflect correctly for messages newly synced from the platform
     * @type {number}
     * @memberof MessageAllOf
     */
    'revision'?: number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageAllOf
     */
    'editedAt'?: string | null;
    /**
     * 
     * @type {MiscOptions}
     * @memberof MessageAllOf
     */
    'miscOptions'?: MiscOptions;
    /**
     * 
     * @type {WABAConversationMetadata}
     * @memberof MessageAllOf
     */
    'conversationMetadata'?: WABAConversationMetadata;
}


/**
 * 
 * @export
 * @interface MessageAllOfError
 */
export interface MessageAllOfError {
    /**
     * 
     * @type {string}
     * @memberof MessageAllOfError
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof MessageAllOfError
     */
    'statusCode': number;
    /**
     * 
     * @type {number}
     * @memberof MessageAllOfError
     */
    'retries'?: number;
}
/**
 * The user ID of the person that sent it
 * @export
 * @interface MessageAllOfSender
 */
export interface MessageAllOfSender {
    /**
     * 
     * @type {string}
     * @memberof MessageAllOfSender
     */
    'userId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageAllOfSender
     */
    'createdAt'?: string;
    /**
     * 
     * @type {MessageSenderContext}
     * @memberof MessageAllOfSender
     */
    'context'?: MessageSenderContext;
}
/**
 * 
 * @export
 * @interface MessageAttachment
 */
export interface MessageAttachment {
    /**
     * 
     * @type {MessageAttachmentType}
     * @memberof MessageAttachment
     */
    'type': MessageAttachmentType;
    /**
     * 
     * @type {string}
     * @memberof MessageAttachment
     */
    'mimetype': string;
    /**
     * 1. can be publicly hosted url, 2. or can be base64 encoded buffer. But make sure it starts with `data:;base64,` -- can be at most 1KB in size Note: the `contact` type only supports base64 encoded data. Must be a serialised vcard 
     * @type {string}
     * @memberof MessageAttachment
     */
    'url': string;
    /**
     * 
     * @type {MessageLocation}
     * @memberof MessageAttachment
     */
    'location'?: MessageLocation;
    /**
     * thumbnail of sticker/video/image
     * @type {string}
     * @memberof MessageAttachment
     */
    'jpegThumbnail'?: string | null;
    /**
     * duration of audio/video message
     * @type {number}
     * @memberof MessageAttachment
     */
    'seconds'?: number;
    /**
     * Show as PTT (voice note) -- only for audio messages
     * @type {boolean}
     * @memberof MessageAttachment
     */
    'pttAudio'?: boolean;
    /**
     * name of the doc message
     * @type {string}
     * @memberof MessageAttachment
     */
    'filename'?: string;
    /**
     * is this a gif -- only for video messages
     * @type {boolean}
     * @memberof MessageAttachment
     */
    'isGif'?: boolean;
    /**
     * 
     * @type {MessageAttachmentDecryption}
     * @memberof MessageAttachment
     */
    'decryption'?: MessageAttachmentDecryption;
}


/**
 * 
 * @export
 * @interface MessageAttachmentDecryption
 */
export interface MessageAttachmentDecryption {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MessageAttachmentDecryption
     */
    'keys'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof MessageAttachmentDecryption
     */
    'algorithm': MessageAttachmentDecryptionAlgorithmEnum;
}

export const MessageAttachmentDecryptionAlgorithmEnum = {
    Aes256Cbc: 'aes-256-cbc'
} as const;

export type MessageAttachmentDecryptionAlgorithmEnum = typeof MessageAttachmentDecryptionAlgorithmEnum[keyof typeof MessageAttachmentDecryptionAlgorithmEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const MessageAttachmentType = {
    Image: 'image',
    Video: 'video',
    Contact: 'contact',
    Sticker: 'sticker',
    Audio: 'audio',
    Document: 'document',
    Location: 'location'
} as const;

export type MessageAttachmentType = typeof MessageAttachmentType[keyof typeof MessageAttachmentType];


/**
 * 
 * @export
 * @interface MessageButton
 */
export interface MessageButton {
    /**
     * 
     * @type {string}
     * @memberof MessageButton
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MessageButton
     */
    'text': string;
    /**
     * Make a button with a link
     * @type {string}
     * @memberof MessageButton
     */
    'url'?: string;
    /**
     * Make a button with a phone number
     * @type {string}
     * @memberof MessageButton
     */
    'phoneNumber'?: string;
}
/**
 * 
 * @export
 * @interface MessageCompose
 */
export interface MessageCompose {
    /**
     * Specify the message Id -- can be used as an idempotency key. Ensures, that two messages with the same ID will never be sent twice 
     * @type {string}
     * @memberof MessageCompose
     */
    'id'?: string;
    /**
     * Set the status of the message, use to create notes
     * @type {string}
     * @memberof MessageCompose
     */
    'status'?: MessageComposeStatusEnum;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageCompose
     */
    'timestamp'?: string;
    /**
     * 
     * @type {MiscOptions}
     * @memberof MessageCompose
     */
    'miscOptions'?: MiscOptions;
    /**
     * parameters to replace in text
     * @type {{ [key: string]: any; }}
     * @memberof MessageCompose
     */
    'parameters'?: { [key: string]: any; };
    /**
     * 
     * @type {MessageComposeAllOfSender}
     * @memberof MessageCompose
     */
    'sender'?: MessageComposeAllOfSender;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageCompose
     */
    'mentions'?: Array<string>;
    /**
     * The subject of the message
     * @type {string}
     * @memberof MessageCompose
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageCompose
     */
    'text'?: string | null;
    /**
     * 
     * @type {QuotedMessage}
     * @memberof MessageCompose
     */
    'quoted'?: QuotedMessage | null;
    /**
     * True, if the message was deleted
     * @type {boolean}
     * @memberof MessageCompose
     */
    'deleted'?: boolean;
    /**
     * True, if the message failed to decrypt
     * @type {boolean}
     * @memberof MessageCompose
     */
    'failDecryption'?: boolean;
    /**
     * 
     * @type {MessageContentAction}
     * @memberof MessageCompose
     */
    'action'?: MessageContentAction | null;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof MessageCompose
     */
    'attachments'?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<MessageButton>}
     * @memberof MessageCompose
     */
    'buttons'?: Array<MessageButton> | null;
    /**
     * 
     * @type {Poll}
     * @memberof MessageCompose
     */
    'poll'?: Poll;
    /**
     * 
     * @type {ListMessage}
     * @memberof MessageCompose
     */
    'list'?: ListMessage;
    /**
     * 
     * @type {Array<MessageProduct>}
     * @memberof MessageCompose
     */
    'products'?: Array<MessageProduct> | null;
    /**
     * 
     * @type {MessageContentOrder}
     * @memberof MessageCompose
     */
    'order'?: MessageContentOrder | null;
    /**
     * 
     * @type {MessageLinkPreview}
     * @memberof MessageCompose
     */
    'linkPreview'?: MessageLinkPreview;
    /**
     * 
     * @type {Array<MessageReaction>}
     * @memberof MessageCompose
     */
    'reactions'?: Array<MessageReaction> | null;
}

export const MessageComposeStatusEnum = {
    Note: 'note',
    Pending: 'pending'
} as const;

export type MessageComposeStatusEnum = typeof MessageComposeStatusEnum[keyof typeof MessageComposeStatusEnum];

/**
 * 
 * @export
 * @interface MessageComposeAllOf
 */
export interface MessageComposeAllOf {
    /**
     * Specify the message Id -- can be used as an idempotency key. Ensures, that two messages with the same ID will never be sent twice 
     * @type {string}
     * @memberof MessageComposeAllOf
     */
    'id'?: string;
    /**
     * Set the status of the message, use to create notes
     * @type {string}
     * @memberof MessageComposeAllOf
     */
    'status'?: MessageComposeAllOfStatusEnum;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageComposeAllOf
     */
    'timestamp'?: string;
    /**
     * 
     * @type {MiscOptions}
     * @memberof MessageComposeAllOf
     */
    'miscOptions'?: MiscOptions;
    /**
     * parameters to replace in text
     * @type {{ [key: string]: any; }}
     * @memberof MessageComposeAllOf
     */
    'parameters'?: { [key: string]: any; };
    /**
     * 
     * @type {MessageComposeAllOfSender}
     * @memberof MessageComposeAllOf
     */
    'sender'?: MessageComposeAllOfSender;
}

export const MessageComposeAllOfStatusEnum = {
    Note: 'note',
    Pending: 'pending'
} as const;

export type MessageComposeAllOfStatusEnum = typeof MessageComposeAllOfStatusEnum[keyof typeof MessageComposeAllOfStatusEnum];

/**
 * 
 * @export
 * @interface MessageComposeAllOfSender
 */
export interface MessageComposeAllOfSender {
    /**
     * 
     * @type {MessageSenderContext}
     * @memberof MessageComposeAllOfSender
     */
    'context': MessageSenderContext;
}
/**
 * 
 * @export
 * @interface MessageComposeWChatID
 */
export interface MessageComposeWChatID {
    /**
     * Specify the message Id -- can be used as an idempotency key. Ensures, that two messages with the same ID will never be sent twice 
     * @type {string}
     * @memberof MessageComposeWChatID
     */
    'id'?: string;
    /**
     * Set the status of the message, use to create notes
     * @type {string}
     * @memberof MessageComposeWChatID
     */
    'status'?: MessageComposeWChatIDStatusEnum;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageComposeWChatID
     */
    'timestamp'?: string;
    /**
     * 
     * @type {MiscOptions}
     * @memberof MessageComposeWChatID
     */
    'miscOptions'?: MiscOptions;
    /**
     * parameters to replace in text
     * @type {{ [key: string]: any; }}
     * @memberof MessageComposeWChatID
     */
    'parameters'?: { [key: string]: any; };
    /**
     * 
     * @type {MessageComposeAllOfSender}
     * @memberof MessageComposeWChatID
     */
    'sender'?: MessageComposeAllOfSender;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageComposeWChatID
     */
    'mentions'?: Array<string>;
    /**
     * The subject of the message
     * @type {string}
     * @memberof MessageComposeWChatID
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageComposeWChatID
     */
    'text'?: string | null;
    /**
     * 
     * @type {QuotedMessage}
     * @memberof MessageComposeWChatID
     */
    'quoted'?: QuotedMessage | null;
    /**
     * True, if the message was deleted
     * @type {boolean}
     * @memberof MessageComposeWChatID
     */
    'deleted'?: boolean;
    /**
     * True, if the message failed to decrypt
     * @type {boolean}
     * @memberof MessageComposeWChatID
     */
    'failDecryption'?: boolean;
    /**
     * 
     * @type {MessageContentAction}
     * @memberof MessageComposeWChatID
     */
    'action'?: MessageContentAction | null;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof MessageComposeWChatID
     */
    'attachments'?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<MessageButton>}
     * @memberof MessageComposeWChatID
     */
    'buttons'?: Array<MessageButton> | null;
    /**
     * 
     * @type {Poll}
     * @memberof MessageComposeWChatID
     */
    'poll'?: Poll;
    /**
     * 
     * @type {ListMessage}
     * @memberof MessageComposeWChatID
     */
    'list'?: ListMessage;
    /**
     * 
     * @type {Array<MessageProduct>}
     * @memberof MessageComposeWChatID
     */
    'products'?: Array<MessageProduct> | null;
    /**
     * 
     * @type {MessageContentOrder}
     * @memberof MessageComposeWChatID
     */
    'order'?: MessageContentOrder | null;
    /**
     * 
     * @type {MessageLinkPreview}
     * @memberof MessageComposeWChatID
     */
    'linkPreview'?: MessageLinkPreview;
    /**
     * 
     * @type {Array<MessageReaction>}
     * @memberof MessageComposeWChatID
     */
    'reactions'?: Array<MessageReaction> | null;
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof MessageComposeWChatID
     */
    'chatId': string;
}

export const MessageComposeWChatIDStatusEnum = {
    Note: 'note',
    Pending: 'pending'
} as const;

export type MessageComposeWChatIDStatusEnum = typeof MessageComposeWChatIDStatusEnum[keyof typeof MessageComposeWChatIDStatusEnum];

/**
 * 
 * @export
 * @interface MessageComposeWChatIDAllOf
 */
export interface MessageComposeWChatIDAllOf {
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof MessageComposeWChatIDAllOf
     */
    'chatId': string;
}
/**
 * 
 * @export
 * @interface MessageContent
 */
export interface MessageContent {
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageContent
     */
    'mentions'?: Array<string>;
    /**
     * The subject of the message
     * @type {string}
     * @memberof MessageContent
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageContent
     */
    'text'?: string | null;
    /**
     * 
     * @type {QuotedMessage}
     * @memberof MessageContent
     */
    'quoted'?: QuotedMessage | null;
    /**
     * True, if the message was deleted
     * @type {boolean}
     * @memberof MessageContent
     */
    'deleted'?: boolean;
    /**
     * True, if the message failed to decrypt
     * @type {boolean}
     * @memberof MessageContent
     */
    'failDecryption'?: boolean;
    /**
     * 
     * @type {MessageContentAction}
     * @memberof MessageContent
     */
    'action'?: MessageContentAction | null;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof MessageContent
     */
    'attachments'?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<MessageButton>}
     * @memberof MessageContent
     */
    'buttons'?: Array<MessageButton> | null;
    /**
     * 
     * @type {Poll}
     * @memberof MessageContent
     */
    'poll'?: Poll;
    /**
     * 
     * @type {ListMessage}
     * @memberof MessageContent
     */
    'list'?: ListMessage;
    /**
     * 
     * @type {Array<MessageProduct>}
     * @memberof MessageContent
     */
    'products'?: Array<MessageProduct> | null;
    /**
     * 
     * @type {MessageContentOrder}
     * @memberof MessageContent
     */
    'order'?: MessageContentOrder | null;
    /**
     * 
     * @type {MessageLinkPreview}
     * @memberof MessageContent
     */
    'linkPreview'?: MessageLinkPreview;
    /**
     * 
     * @type {Array<MessageReaction>}
     * @memberof MessageContent
     */
    'reactions'?: Array<MessageReaction> | null;
}
/**
 * 
 * @export
 * @interface MessageContentAction
 */
export interface MessageContentAction {
    /**
     * 
     * @type {string}
     * @memberof MessageContentAction
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageContentAction
     */
    'parameters'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MessageContentOrder
 */
export interface MessageContentOrder {
    /**
     * 
     * @type {string}
     * @memberof MessageContentOrder
     */
    'orderId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageContentOrder
     */
    'jpegThumbnail'?: string;
    /**
     * 
     * @type {number}
     * @memberof MessageContentOrder
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof MessageContentOrder
     */
    'sellerId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageContentOrder
     */
    'token': string;
    /**
     * 
     * @type {Price}
     * @memberof MessageContentOrder
     */
    'total': Price;
}
/**
 * 
 * @export
 * @interface MessageLinkPreview
 */
export interface MessageLinkPreview {
    /**
     * 
     * @type {string}
     * @memberof MessageLinkPreview
     */
    'jpegThumbnail'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageLinkPreview
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof MessageLinkPreview
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof MessageLinkPreview
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof MessageLinkPreview
     */
    'matchedText'?: string;
}
/**
 * 
 * @export
 * @interface MessageLocation
 */
export interface MessageLocation {
    /**
     * 
     * @type {number}
     * @memberof MessageLocation
     */
    'latitude': number;
    /**
     * 
     * @type {number}
     * @memberof MessageLocation
     */
    'longitude': number;
}
/**
 * 
 * @export
 * @interface MessageProduct
 */
export interface MessageProduct {
    /**
     * 
     * @type {string}
     * @memberof MessageProduct
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MessageProduct
     */
    'accountId'?: string;
    /**
     * 
     * @type {MessageProductDetails}
     * @memberof MessageProduct
     */
    'details'?: MessageProductDetails;
}
/**
 * 
 * @export
 * @interface MessageProductDetails
 */
export interface MessageProductDetails {
    /**
     * 3-letter ISO currency code
     * @type {string}
     * @memberof MessageProductDetails
     */
    'currencyCode': string;
    /**
     * the actual price * 1000
     * @type {number}
     * @memberof MessageProductDetails
     */
    'price1000': number;
    /**
     * 
     * @type {string}
     * @memberof MessageProductDetails
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof MessageProductDetails
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageProductDetails
     */
    'url'?: string;
    /**
     * 
     * @type {MessageAttachment}
     * @memberof MessageProductDetails
     */
    'image': MessageAttachment;
    /**
     * The user ID of the business that owns this product
     * @type {string}
     * @memberof MessageProductDetails
     */
    'businessOwnerId'?: string;
}
/**
 * 
 * @export
 * @interface MessageReaction
 */
export interface MessageReaction {
    /**
     * Describes a reaction on a message
     * @type {string}
     * @memberof MessageReaction
     */
    'reaction': string;
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof MessageReaction
     */
    'fromId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageReaction
     */
    'id': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageReaction
     */
    'timestamp'?: string;
}
/**
 * Optional context about the sender of the message
 * @export
 * @interface MessageSenderContext
 */
export interface MessageSenderContext {
    /**
     * 
     * @type {string}
     * @memberof MessageSenderContext
     */
    'type': MessageSenderContextTypeEnum;
    /**
     * ID of the object that sent the message. For example, the campaign ID or keyword reply ID. Separate sub-objects with a `/`. For example, to specify the action of a bot -- use `bot_id/action_id`
     * @type {string}
     * @memberof MessageSenderContext
     */
    'objectId': string;
    /**
     * Name of the object that sent the message. For example, the campaign name or keyword reply name
     * @type {string}
     * @memberof MessageSenderContext
     */
    'objectName'?: string;
}

export const MessageSenderContextTypeEnum = {
    KeywordReply: 'keyword-reply',
    DefaultReply: 'default-reply',
    Campaigns: 'campaigns',
    Notifications: 'notifications',
    Bot: 'bot',
    AiChatbot: 'ai-chatbot',
    Trigger: 'trigger'
} as const;

export type MessageSenderContextTypeEnum = typeof MessageSenderContextTypeEnum[keyof typeof MessageSenderContextTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const MessageStatus = {
    Error: 'error',
    Pending: 'pending',
    Note: 'note',
    Sent: 'sent',
    Delivered: 'delivered',
    Read: 'read',
    Cancelled: 'cancelled'
} as const;

export type MessageStatus = typeof MessageStatus[keyof typeof MessageStatus];


/**
 * @type MessagesForwardToChatIdParameter
 * @export
 */
export type MessagesForwardToChatIdParameter = AnyContactID | Array<AnyContactID>;

/**
 * 
 * @export
 * @interface MessagesGet200Response
 */
export interface MessagesGet200Response {
    /**
     * 
     * @type {string}
     * @memberof MessagesGet200Response
     */
    'nextPage'?: string;
    /**
     * 
     * @type {Array<Message>}
     * @memberof MessagesGet200Response
     */
    'messages': Array<Message>;
}
/**
 * 
 * @export
 * @interface MessagesGetRangeParameter
 */
export interface MessagesGetRangeParameter {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessagesGetRangeParameter
     */
    'start': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessagesGetRangeParameter
     */
    'end': string;
}
/**
 * 
 * @export
 * @interface MessagesPatchPendingRequest
 */
export interface MessagesPatchPendingRequest {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessagesPatchPendingRequest
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface MessagesPatchRequest
 */
export interface MessagesPatchRequest {
    /**
     * 
     * @type {boolean}
     * @memberof MessagesPatchRequest
     */
    'resolved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MessagesPatchRequest
     */
    'text'?: string;
    /**
     * 
     * @type {Array<MessageAttachment>}
     * @memberof MessagesPatchRequest
     */
    'attachments'?: Array<MessageAttachment>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessagesPatchRequest
     */
    'mentions'?: Array<string>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessagesPatchRequest
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface MessagesSearch200Response
 */
export interface MessagesSearch200Response {
    /**
     * 
     * @type {number}
     * @memberof MessagesSearch200Response
     */
    'nextPage'?: number;
    /**
     * 
     * @type {Array<Message>}
     * @memberof MessagesSearch200Response
     */
    'messages': Array<Message>;
    /**
     * 
     * @type {Array<Chat>}
     * @memberof MessagesSearch200Response
     */
    'chats'?: Array<Chat>;
}
/**
 * 
 * @export
 * @interface MessagingItems
 */
export interface MessagingItems {
    /**
     * 
     * @type {MessagingItemsSender}
     * @memberof MessagingItems
     */
    'sender'?: MessagingItemsSender;
    /**
     * 
     * @type {MessagingItemsSender}
     * @memberof MessagingItems
     */
    'recipient'?: MessagingItemsSender;
    /**
     * 
     * @type {number}
     * @memberof MessagingItems
     */
    'timestamp'?: number;
    /**
     * 
     * @type {MessagingItemsMessage}
     * @memberof MessagingItems
     */
    'message'?: MessagingItemsMessage;
    /**
     * 
     * @type {MessagingItemsPostback}
     * @memberof MessagingItems
     */
    'postback'?: MessagingItemsPostback;
}
/**
 * 
 * @export
 * @interface MessagingItemsMessage
 */
export interface MessagingItemsMessage {
    /**
     * 
     * @type {string}
     * @memberof MessagingItemsMessage
     */
    'mid'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessagingItemsMessage
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface MessagingItemsPostback
 */
export interface MessagingItemsPostback {
    /**
     * 
     * @type {string}
     * @memberof MessagingItemsPostback
     */
    'mid'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessagingItemsPostback
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessagingItemsPostback
     */
    'payload'?: string;
}
/**
 * 
 * @export
 * @interface MessagingItemsSender
 */
export interface MessagingItemsSender {
    /**
     * 
     * @type {string}
     * @memberof MessagingItemsSender
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface MetaStateInfo
 */
export interface MetaStateInfo {
    /**
     * 
     * @type {string}
     * @memberof MetaStateInfo
     */
    'role'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MetaStateInfo
     */
    'businessVerified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MetaStateInfo
     */
    'businessName'?: string;
}
/**
 * 
 * @export
 * @interface MetaUser
 */
export interface MetaUser {
    /**
     * Page scoped ID of the user
     * @type {string}
     * @memberof MetaUser
     */
    'psid': string;
    /**
     * First name of the user
     * @type {string}
     * @memberof MetaUser
     */
    'firstName': string;
    /**
     * Last name of the user
     * @type {string}
     * @memberof MetaUser
     */
    'lastName'?: string;
    /**
     * Locale of the user
     * @type {string}
     * @memberof MetaUser
     */
    'locale'?: string;
    /**
     * Timezone of the user
     * @type {string}
     * @memberof MetaUser
     */
    'timezone'?: string;
    /**
     * Gender of the user
     * @type {string}
     * @memberof MetaUser
     */
    'gender'?: string;
}
/**
 * 
 * @export
 * @interface MetadataQuery
 */
export interface MetadataQuery {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MetadataQuery
     */
    'doneFrom'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MetadataQuery
     */
    'doneTo'?: string;
    /**
     * The user ID of the user on ChatDaddy
     * @type {string}
     * @memberof MetadataQuery
     */
    'doneBy'?: string;
}
/**
 * 
 * @export
 * @interface MiscOptions
 */
export interface MiscOptions {
    /**
     * Original ID from the provider
     * @type {string}
     * @memberof MiscOptions
     */
    'originalId'?: string;
    /**
     * WA Business template
     * @type {string}
     * @memberof MiscOptions
     */
    'templateId'?: string;
    /**
     * WA Business template params -- do not need to populate
     * @type {{ [key: string]: string; }}
     * @memberof MiscOptions
     */
    'templateParams'?: { [key: string]: string; };
    /**
     * Emulate typing behaviour before send
     * @type {boolean}
     * @memberof MiscOptions
     */
    'withTyping'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MiscOptions
     */
    'forwardCount'?: number;
    /**
     * 
     * @type {MiscOptionsForwarded}
     * @memberof MiscOptions
     */
    'forwarded'?: MiscOptionsForwarded;
    /**
     * Adds random whitespace to produce a distinct message
     * @type {boolean}
     * @memberof MiscOptions
     */
    'randomizeMessage'?: boolean;
    /**
     * the ID of the button clicked
     * @type {string}
     * @memberof MiscOptions
     */
    'buttonReplyId'?: string;
    /**
     * the ID of the list item clicked
     * @type {string}
     * @memberof MiscOptions
     */
    'listReplyId'?: string;
    /**
     * the option of the poll that was clicked
     * @type {Array<string>}
     * @memberof MiscOptions
     */
    'pollReplyOptions'?: Array<string>;
    /**
     * If true, the message will be cancelled if a reply is received
     * @type {boolean}
     * @memberof MiscOptions
     */
    'cancelIfReplyReceived'?: boolean;
}
/**
 * the message being forwarded
 * @export
 * @interface MiscOptionsForwarded
 */
export interface MiscOptionsForwarded {
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof MiscOptionsForwarded
     */
    'accountId'?: string;
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof MiscOptionsForwarded
     */
    'chatId': string;
    /**
     * 
     * @type {string}
     * @memberof MiscOptionsForwarded
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    'statusCode': number;
    /**
     * Specific description of the error
     * @type {string}
     * @memberof ModelError
     */
    'error': string;
    /**
     * What the error was
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
    /**
     * Some extra information about the error
     * @type {object}
     * @memberof ModelError
     */
    'data'?: object;
}
/**
 * Use to send 1 or more messages in a single request. You can override the default compose options for each message by passing in the compose options in the recipient object
 * @export
 * @interface MultiMessageCompose
 */
export interface MultiMessageCompose {
    /**
     * 
     * @type {MessageCompose}
     * @memberof MultiMessageCompose
     */
    'compose'?: MessageCompose;
    /**
     * 
     * @type {Array<MessageComposeWChatID>}
     * @memberof MultiMessageCompose
     */
    'recipients': Array<MessageComposeWChatID>;
}
/**
 * 
 * @export
 * @interface OrderDetails
 */
export interface OrderDetails {
    /**
     * 
     * @type {OrderPrice}
     * @memberof OrderDetails
     */
    'price'?: OrderPrice;
    /**
     * 
     * @type {Array<OrderProduct>}
     * @memberof OrderDetails
     */
    'products'?: Array<OrderProduct>;
}
/**
 * 
 * @export
 * @interface OrderPrice
 */
export interface OrderPrice {
    /**
     * actual price * 1000
     * @type {number}
     * @memberof OrderPrice
     */
    'total1000'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderPrice
     */
    'subtotal1000'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderPrice
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface OrderProduct
 */
export interface OrderProduct {
    /**
     * 
     * @type {MessageProduct}
     * @memberof OrderProduct
     */
    'product': MessageProduct;
    /**
     * 
     * @type {number}
     * @memberof OrderProduct
     */
    'quantity': number;
}
/**
 * Model for a product on an external platform (eg. WhatsApp)
 * @export
 * @interface PlatformProduct
 */
export interface PlatformProduct {
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'retailerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'url'?: string;
    /**
     * 
     * @type {Array<ProductCategory>}
     * @memberof PlatformProduct
     */
    'categories'?: Array<ProductCategory>;
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof PlatformProduct
     */
    'price': number | null;
    /**
     * 
     * @type {number}
     * @memberof PlatformProduct
     */
    'stock'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlatformProduct
     */
    'totalStockSold'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'currency': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PlatformProduct
     */
    'isHidden': boolean;
    /**
     * 
     * @type {string}
     * @memberof PlatformProduct
     */
    'id': string;
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof PlatformProduct
     */
    'accountId': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PlatformProduct
     */
    'imageUrls': { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PlatformProduct
     */
    'reviewStatus': { [key: string]: string; };
    /**
     * 
     * @type {ProductAvailability}
     * @memberof PlatformProduct
     */
    'availability'?: ProductAvailability;
    /**
     * 
     * @type {ProductSyncStatus}
     * @memberof PlatformProduct
     */
    'syncStatus': ProductSyncStatus;
    /**
     * True if sync is underway right now
     * @type {boolean}
     * @memberof PlatformProduct
     */
    'isSyncing'?: boolean;
    /**
     * 
     * @type {Error}
     * @memberof PlatformProduct
     */
    'error'?: Error;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PlatformProduct
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PlatformProduct
     */
    'updatedAt': string;
    /**
     * Cursor to sort products by
     * @type {string}
     * @memberof PlatformProduct
     */
    'cursor'?: string;
}


/**
 * 
 * @export
 * @interface PlatformProductCategoriesGet200Response
 */
export interface PlatformProductCategoriesGet200Response {
    /**
     * 
     * @type {Array<ProductCategory>}
     * @memberof PlatformProductCategoriesGet200Response
     */
    'categories': Array<ProductCategory>;
}
/**
 * 
 * @export
 * @interface PlatformProductCategoriesPostRequest
 */
export interface PlatformProductCategoriesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCategoriesPostRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface PlatformProductCreate
 */
export interface PlatformProductCreate {
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'retailerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof PlatformProductCreate
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'currency': string;
    /**
     * 
     * @type {number}
     * @memberof PlatformProductCreate
     */
    'stock'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PlatformProductCreate
     */
    'isHidden': boolean;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductCreate
     */
    'category'?: string | null;
    /**
     * List of URLs for images of the product
     * @type {Array<string>}
     * @memberof PlatformProductCreate
     */
    'imageUrls'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PlatformProductUpdate
 */
export interface PlatformProductUpdate {
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'retailerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PlatformProductUpdate
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'currency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PlatformProductUpdate
     */
    'isHidden'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdate
     */
    'category'?: string | null;
    /**
     * List of URLs for images of the product
     * @type {Array<string>}
     * @memberof PlatformProductUpdate
     */
    'imageUrls'?: Array<string>;
    /**
     * 
     * @type {PlatformProductUpdateStock}
     * @memberof PlatformProductUpdate
     */
    'stock'?: PlatformProductUpdateStock;
    /**
     * 
     * @type {number}
     * @memberof PlatformProductUpdate
     */
    'totalStockSold'?: number;
}
/**
 * 
 * @export
 * @interface PlatformProductUpdateStock
 */
export interface PlatformProductUpdateStock {
    /**
     * The new stock quantity
     * @type {number}
     * @memberof PlatformProductUpdateStock
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductUpdateStock
     */
    'action'?: PlatformProductUpdateStockActionEnum;
}

export const PlatformProductUpdateStockActionEnum = {
    Set: 'set',
    Increment: 'increment',
    Decrement: 'decrement'
} as const;

export type PlatformProductUpdateStockActionEnum = typeof PlatformProductUpdateStockActionEnum[keyof typeof PlatformProductUpdateStockActionEnum];

/**
 * 
 * @export
 * @interface PlatformProductsGet200Response
 */
export interface PlatformProductsGet200Response {
    /**
     * total products present with these filters. Only returned if returnTotalCount is true
     * @type {number}
     * @memberof PlatformProductsGet200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {Array<PlatformProduct>}
     * @memberof PlatformProductsGet200Response
     */
    'products': Array<PlatformProduct>;
    /**
     * 
     * @type {string}
     * @memberof PlatformProductsGet200Response
     */
    'nextPage'?: string;
}
/**
 * 
 * @export
 * @interface PlatformProductsPost200Response
 */
export interface PlatformProductsPost200Response {
    /**
     * 
     * @type {Array<PlatformProduct>}
     * @memberof PlatformProductsPost200Response
     */
    'products': Array<PlatformProduct>;
}
/**
 * 
 * @export
 * @interface PlatformProductsPostRequest
 */
export interface PlatformProductsPostRequest {
    /**
     * 
     * @type {Array<PlatformProductCreate>}
     * @memberof PlatformProductsPostRequest
     */
    'products': Array<PlatformProductCreate>;
}
/**
 * 
 * @export
 * @interface Poll
 */
export interface Poll {
    /**
     * 
     * @type {Array<PollOption>}
     * @memberof Poll
     */
    'options': Array<PollOption>;
    /**
     * The maximum number of options that can be selected
     * @type {number}
     * @memberof Poll
     */
    'maxSelections'?: number;
}
/**
 * 
 * @export
 * @interface PollChatHistory200Response
 */
export interface PollChatHistory200Response {
    /**
     * 
     * @type {string}
     * @memberof PollChatHistory200Response
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PollChatHistory200Response
     */
    'status'?: PollChatHistory200ResponseStatusEnum;
}

export const PollChatHistory200ResponseStatusEnum = {
    Success: 'success',
    Executing: 'executing',
    Error: 'error'
} as const;

export type PollChatHistory200ResponseStatusEnum = typeof PollChatHistory200ResponseStatusEnum[keyof typeof PollChatHistory200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface PollOption
 */
export interface PollOption {
    /**
     * The text of the option
     * @type {string}
     * @memberof PollOption
     */
    'text': string;
    /**
     * The IDs of the contacts that selected this option
     * @type {Array<string>}
     * @memberof PollOption
     */
    'voters'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PresenceType = {
    Available: 'available',
    Unavailable: 'unavailable',
    Typing: 'typing',
    StoppedTyping: 'stoppedTyping'
} as const;

export type PresenceType = typeof PresenceType[keyof typeof PresenceType];


/**
 * 
 * @export
 * @interface Price
 */
export interface Price {
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'currency': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ProductAvailability = {
    InStock: 'in-stock'
} as const;

export type ProductAvailability = typeof ProductAvailability[keyof typeof ProductAvailability];


/**
 * 
 * @export
 * @interface ProductCategory
 */
export interface ProductCategory {
    /**
     * 
     * @type {string}
     * @memberof ProductCategory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductCategory
     */
    'name': string;
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof ProductCategory
     */
    'accountId': string;
    /**
     * 
     * @type {number}
     * @memberof ProductCategory
     */
    'productCount': number;
}
/**
 * Update a product category
 * @export
 * @interface ProductCategoryPatchRequest
 */
export interface ProductCategoryPatchRequest {
    /**
     * New name of the category
     * @type {string}
     * @memberof ProductCategoryPatchRequest
     */
    'name'?: string;
    /**
     * 
     * @type {Array<ProductCategoryPatchRequestProductsInner>}
     * @memberof ProductCategoryPatchRequest
     */
    'products'?: Array<ProductCategoryPatchRequestProductsInner>;
}
/**
 * 
 * @export
 * @interface ProductCategoryPatchRequestProductsInner
 */
export interface ProductCategoryPatchRequestProductsInner {
    /**
     * 
     * @type {string}
     * @memberof ProductCategoryPatchRequestProductsInner
     */
    'productId': string;
    /**
     * 
     * @type {string}
     * @memberof ProductCategoryPatchRequestProductsInner
     */
    'type': ProductCategoryPatchRequestProductsInnerTypeEnum;
}

export const ProductCategoryPatchRequestProductsInnerTypeEnum = {
    Add: 'add',
    Remove: 'remove'
} as const;

export type ProductCategoryPatchRequestProductsInnerTypeEnum = typeof ProductCategoryPatchRequestProductsInnerTypeEnum[keyof typeof ProductCategoryPatchRequestProductsInnerTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

const ProductSyncStatus = {
    Synced: 'synced',
    PendingCreate: 'pendingCreate',
    PendingUpdate: 'pendingUpdate',
    PendingDelete: 'pendingDelete'
} as const;

type ProductSyncStatus = typeof ProductSyncStatus[keyof typeof ProductSyncStatus];


/**
 * 
 * @export
 * @interface ProfileMessengerPostRequest
 */
export interface ProfileMessengerPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileMessengerPostRequest
     */
    'pageId': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileMessengerPostRequest
     */
    'pageAccessToken': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileMessengerPostRequest
     */
    'userAccessToken': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileMessengerPostRequest
     */
    'type'?: ProfileMessengerPostRequestTypeEnum;
}

export const ProfileMessengerPostRequestTypeEnum = {
    Messenger: 'messenger',
    Instagram: 'instagram'
} as const;

export type ProfileMessengerPostRequestTypeEnum = typeof ProfileMessengerPostRequestTypeEnum[keyof typeof ProfileMessengerPostRequestTypeEnum];

/**
 * 
 * @export
 * @interface QuotedMessage
 */
export interface QuotedMessage {
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof QuotedMessage
     */
    'chatId': string;
    /**
     * 
     * @type {string}
     * @memberof QuotedMessage
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof QuotedMessage
     */
    'senderContactId'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuotedMessage
     */
    'text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof QuotedMessage
     */
    'jpegThumbnail'?: string | null;
}
/**
 * 
 * @export
 * @interface SmsSenderIdPostRequest
 */
export interface SmsSenderIdPostRequest {
    /**
     * 
     * @type {string}
     * @memberof SmsSenderIdPostRequest
     */
    'senderId': string;
}
/**
 * 
 * @export
 * @interface SmsStateInfo
 */
export interface SmsStateInfo {
    /**
     * 
     * @type {boolean}
     * @memberof SmsStateInfo
     */
    'senderVerified'?: boolean;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'name': string;
    /**
     * The filters for a dynamic tag
     * @type {object}
     * @memberof Tag
     */
    'filters'?: object | null;
    /**
     * Hex color code
     * @type {string}
     * @memberof Tag
     */
    'color'?: string;
    /**
     * 
     * @type {TagFieldValidation}
     * @memberof Tag
     */
    'validation'?: TagFieldValidation;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Tag
     */
    'createdAt': string;
    /**
     * The user ID of the user on ChatDaddy
     * @type {string}
     * @memberof Tag
     */
    'createdBy': string;
}
/**
 * @type TagFieldValidation
 * @export
 */
export type TagFieldValidation = TagFieldValidationOneOf | TagFieldValidationOneOf1;

/**
 * 
 * @export
 * @interface TagFieldValidationOneOf
 */
export interface TagFieldValidationOneOf {
    /**
     * 
     * @type {string}
     * @memberof TagFieldValidationOneOf
     */
    'type'?: TagFieldValidationOneOfTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TagFieldValidationOneOf
     */
    'format'?: TagFieldValidationOneOfFormatEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof TagFieldValidationOneOf
     */
    'enum'?: Array<string>;
}

export const TagFieldValidationOneOfTypeEnum = {
    String: 'string'
} as const;

export type TagFieldValidationOneOfTypeEnum = typeof TagFieldValidationOneOfTypeEnum[keyof typeof TagFieldValidationOneOfTypeEnum];
export const TagFieldValidationOneOfFormatEnum = {
    Email: 'email',
    Phone: 'phone',
    Uri: 'uri',
    Attachment: 'attachment'
} as const;

export type TagFieldValidationOneOfFormatEnum = typeof TagFieldValidationOneOfFormatEnum[keyof typeof TagFieldValidationOneOfFormatEnum];

/**
 * 
 * @export
 * @interface TagFieldValidationOneOf1
 */
export interface TagFieldValidationOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof TagFieldValidationOneOf1
     */
    'type'?: TagFieldValidationOneOf1TypeEnum;
}

export const TagFieldValidationOneOf1TypeEnum = {
    Number: 'number',
    Integer: 'integer',
    Boolean: 'boolean'
} as const;

export type TagFieldValidationOneOf1TypeEnum = typeof TagFieldValidationOneOf1TypeEnum[keyof typeof TagFieldValidationOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface TagFilter
 */
export interface TagFilter {
    /**
     * 
     * @type {string}
     * @memberof TagFilter
     */
    'name': string;
    /**
     * Filter by value of the tag
     * @type {string}
     * @memberof TagFilter
     */
    'value'?: string | null;
    /**
     * The operator to use for the value
     * @type {string}
     * @memberof TagFilter
     */
    'operator'?: TagFilterOperatorEnum;
    /**
     * 
     * @type {MetadataQuery}
     * @memberof TagFilter
     */
    'added'?: MetadataQuery;
}

export const TagFilterOperatorEnum = {
    Equals: 'equals',
    NotEquals: 'notEquals'
} as const;

export type TagFilterOperatorEnum = typeof TagFilterOperatorEnum[keyof typeof TagFilterOperatorEnum];

/**
 * 
 * @export
 * @interface TagsGet200Response
 */
export interface TagsGet200Response {
    /**
     * 
     * @type {Array<Tag>}
     * @memberof TagsGet200Response
     */
    'tags': Array<Tag>;
    /**
     * total tags present
     * @type {number}
     * @memberof TagsGet200Response
     */
    'total'?: number;
    /**
     * next page cursor, if it exists
     * @type {string}
     * @memberof TagsGet200Response
     */
    'nextPageCursor'?: string;
}
/**
 * 
 * @export
 * @interface TagsPatchRequest
 */
export interface TagsPatchRequest {
    /**
     * 
     * @type {TagFieldValidation}
     * @memberof TagsPatchRequest
     */
    'validation'?: TagFieldValidation;
    /**
     * Hex color code
     * @type {string}
     * @memberof TagsPatchRequest
     */
    'color'?: string;
}
/**
 * 
 * @export
 * @interface TagsPostRequest
 */
export interface TagsPostRequest {
    /**
     * 
     * @type {TagFieldValidation}
     * @memberof TagsPostRequest
     */
    'validation'?: TagFieldValidation;
}
/**
 * Description of the category of the template
 * @export
 * @enum {string}
 */

export const TemplateCategory = {
    Transactional: 'transactional',
    Marketing: 'marketing',
    Otp: 'otp'
} as const;

export type TemplateCategory = typeof TemplateCategory[keyof typeof TemplateCategory];


/**
 * 
 * @export
 * @interface TemplateCreate
 */
export interface TemplateCreate {
    /**
     * 
     * @type {string}
     * @memberof TemplateCreate
     */
    'text': string | null;
    /**
     * 
     * @type {Array<MessageButton>}
     * @memberof TemplateCreate
     */
    'buttons'?: Array<MessageButton>;
    /**
     * 
     * @type {ListMessage}
     * @memberof TemplateCreate
     */
    'list'?: ListMessage;
    /**
     * 
     * @type {Array<TemplateCreateAttachmentsInner>}
     * @memberof TemplateCreate
     */
    'attachments'?: Array<TemplateCreateAttachmentsInner>;
}
/**
 * 
 * @export
 * @interface TemplateCreateAttachmentsInner
 */
export interface TemplateCreateAttachmentsInner {
    /**
     * 
     * @type {MessageAttachmentType}
     * @memberof TemplateCreateAttachmentsInner
     */
    'type': MessageAttachmentType;
    /**
     * 
     * @type {string}
     * @memberof TemplateCreateAttachmentsInner
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateCreateAttachmentsInner
     */
    'filename'?: string;
}


/**
 * 
 * @export
 * @interface TemplateParams
 */
export interface TemplateParams {
    /**
     * 
     * @type {string}
     * @memberof TemplateParams
     */
    'name': string;
    /**
     * ISO language code
     * @type {string}
     * @memberof TemplateParams
     */
    'language': string;
    /**
     * 
     * @type {TemplateCategory}
     * @memberof TemplateParams
     */
    'category': TemplateCategory;
}


/**
 * 
 * @export
 * @interface TemplatesSubmitForReview200Response
 */
export interface TemplatesSubmitForReview200Response {
    /**
     * ID of the template submitted for review
     * @type {string}
     * @memberof TemplatesSubmitForReview200Response
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface TemplatesSubmitForReviewRequest
 */
export interface TemplatesSubmitForReviewRequest {
    /**
     * 
     * @type {TemplateParams}
     * @memberof TemplatesSubmitForReviewRequest
     */
    'params': TemplateParams;
    /**
     * 
     * @type {TemplateCreate}
     * @memberof TemplatesSubmitForReviewRequest
     */
    'message': TemplateCreate;
}
/**
 * Status of the ticket. Null/undefined mean the ticket is open
 * @export
 * @enum {string}
 */

export const TicketStatus = {
    Closed: 'closed',
    Null: null as null
} as const;

export type TicketStatus = typeof TicketStatus[keyof typeof TicketStatus];


/**
 * 
 * @export
 * @interface TikTokChatState
 */
export interface TikTokChatState {
    /**
     * Whether the chat is synced. If false, the chat will not be available
     * @type {number}
     * @memberof TikTokChatState
     */
    'synced': number;
    /**
     * Cursor to sync from. If null, the chat will be synced from the beginning
     * @type {string}
     * @memberof TikTokChatState
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface TikTokStateInfo
 */
export interface TikTokStateInfo {
    /**
     * 
     * @type {boolean}
     * @memberof TikTokStateInfo
     */
    'isSyncing'?: boolean;
    /**
     * 
     * @type {TikTokChatState}
     * @memberof TikTokStateInfo
     */
    'strangerChats'?: TikTokChatState;
    /**
     * 
     * @type {TikTokChatState}
     * @memberof TikTokStateInfo
     */
    'normalChats'?: TikTokChatState;
    /**
     * 
     * @type {string}
     * @memberof TikTokStateInfo
     */
    'lastSyncCursor'?: string;
    /**
     * 
     * @type {string}
     * @memberof TikTokStateInfo
     */
    'latestNotificationCursor'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TikTokStateInfo
     */
    'syncCompletedAt'?: string;
}
/**
 * 
 * @export
 * @interface UniqueContactID
 */
export interface UniqueContactID {
    /**
     * ID for the contact/chat on the platform
     * @type {string}
     * @memberof UniqueContactID
     */
    'id': string;
    /**
     * Unique identifier for an account.  The account ID is constructed from the first 21 characters of the team ID, prefixed by \"acc\" and suffixed by 4 random hex characters. This helps uniquely identify each account as well as establish a connection between the account\'s team by embedding the partial team ID in it.
     * @type {string}
     * @memberof UniqueContactID
     */
    'accountId': string;
}
/**
 * 
 * @export
 * @interface UpsertMetadata
 */
export interface UpsertMetadata {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof UpsertMetadata
     */
    'doneAt': string;
    /**
     * The user ID of the user on ChatDaddy
     * @type {string}
     * @memberof UpsertMetadata
     */
    'doneBy': string;
}
/**
 * Metadata about a WABA conversation. This is set on the message when a new conversation is created.
 * @export
 * @interface WABAConversationMetadata
 */
export interface WABAConversationMetadata {
    /**
     * ID of the conversation
     * @type {string}
     * @memberof WABAConversationMetadata
     */
    'id': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof WABAConversationMetadata
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WABAConversationMetadata
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface WAPhonePairingState
 */
export interface WAPhonePairingState {
    /**
     * The WA ID of the phone
     * @type {string}
     * @memberof WAPhonePairingState
     */
    'jid': string;
    /**
     * The code to enter on the phone
     * @type {string}
     * @memberof WAPhonePairingState
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface WAStateInfo
 */
export interface WAStateInfo {
    /**
     * The QR to scan to log into the account
     * @type {string}
     * @memberof WAStateInfo
     */
    'qr'?: string;
    /**
     * 
     * @type {WAPhonePairingState}
     * @memberof WAStateInfo
     */
    'phonePairingState'?: WAPhonePairingState;
    /**
     * Whether the client has received all pending/offline notifications
     * @type {boolean}
     * @memberof WAStateInfo
     */
    'receivedPendingNotifications'?: boolean;
    /**
     * If the user logged in with a WA business account. Product APIs would be available now
     * @type {boolean}
     * @memberof WAStateInfo
     */
    'isBusiness'?: boolean;
    /**
     * If syncing history right now. If such is the case, regular event processing will be queued till the sync is complete
     * @type {boolean}
     * @memberof WAStateInfo
     */
    'isSyncingHistory'?: boolean;
    /**
     * 
     * @type {WASyncStateInfo}
     * @memberof WAStateInfo
     */
    'sync'?: WASyncStateInfo;
}
/**
 * @type WASyncData
 * @export
 */
export type WASyncData = WASyncDataOneOf | WASyncDataOneOf1;

/**
 * 
 * @export
 * @interface WASyncDataOneOf
 */
export interface WASyncDataOneOf {
    /**
     * Total number of objects received
     * @type {number}
     * @memberof WASyncDataOneOf
     */
    'total': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof WASyncDataOneOf
     */
    'lastRecvAt': string;
}
/**
 * 
 * @export
 * @interface WASyncDataOneOf1
 */
export interface WASyncDataOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof WASyncDataOneOf1
     */
    'error': string;
}
/**
 * State of how many chats, messages, contacts are synced, and if there was an error
 * @export
 * @interface WASyncStateInfo
 */
export interface WASyncStateInfo {
    /**
     * 
     * @type {WASyncData}
     * @memberof WASyncStateInfo
     */
    'chats'?: WASyncData;
    /**
     * 
     * @type {WASyncData}
     * @memberof WASyncStateInfo
     */
    'contacts'?: WASyncData;
    /**
     * 
     * @type {WASyncData}
     * @memberof WASyncStateInfo
     */
    'messages'?: WASyncData;
}
/**
 * 
 * @export
 * @interface WebhookMessengerPostRequest
 */
export interface WebhookMessengerPostRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhookMessengerPostRequest
     */
    'object'?: string;
    /**
     * 
     * @type {Array<EntryItems>}
     * @memberof WebhookMessengerPostRequest
     */
    'entry'?: Array<EntryItems>;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive an account. Logs out of the account & removes all synced chats, messages. Keeps contacts, and notes.
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsArchive: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsArchive', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/archive`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Close connection to the account
         * @param {string} accountId 
         * @param {boolean} [logout] Closes the account and logs out from the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClose: async (accountId: string, logout?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsClose', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/close`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)

            if (logout !== undefined) {
                localVarQueryParameter['logout'] = logout;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can continue to poll this route to check if it has been deleted. When deleted, the route will return a 404.
         * @summary Enqueues a task to delete the account
         * @param {string} accountId 
         * @param {boolean} [deleteNow] Delete the account immediately. Otherwise, the account will be completely removed after 24 hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsDelete: async (accountId: string, deleteNow?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsDelete', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_DELETE"], configuration)

            if (deleteNow !== undefined) {
                localVarQueryParameter['deleteNow'] = deleteNow;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of all accounts
         * @param {string} [q] Search items by this string
         * @param {number} [page] Page number to paginate through results
         * @param {number} [count] Number of items to return
         * @param {boolean} [all] 
         * @param {AccountState} [state] only fetch accounts with a state
         * @param {boolean} [returnCount] return total count of accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsGet: async (q?: string, page?: number, count?: number, all?: boolean, state?: AccountState, returnCount?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (returnCount !== undefined) {
                localVarQueryParameter['returnCount'] = returnCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout and clear credentials from the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLogout: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsLogout', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/logout`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Open connection to the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsOpen: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsOpen', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/open`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update name of the account or its settings
         * @summary Update an account
         * @param {string} accountId 
         * @param {AccountsPatchRequest} [accountsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPatch: async (accountId: string, accountsPatchRequest?: AccountsPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsPatch', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountsPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new account
         * @param {AccountsPostRequest} [accountsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPost: async (accountsPostRequest?: AccountsPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change login mode of a WhatsApp account
         * @param {string} accountId 
         * @param {AccountWaChangeLoginMode} [accountWaChangeLoginMode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waChangeLoginMode: async (accountId: string, accountWaChangeLoginMode?: AccountWaChangeLoginMode, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('waChangeLoginMode', 'accountId', accountId)
            const localVarPath = `/accounts/wa/{accountId}/change-login-mode`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountWaChangeLoginMode, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Archive an account. Logs out of the account & removes all synced chats, messages. Keeps contacts, and notes.
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsArchive(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsArchive(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Close connection to the account
         * @param {string} accountId 
         * @param {boolean} [logout] Closes the account and logs out from the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsClose(accountId: string, logout?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsClose(accountId, logout, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can continue to poll this route to check if it has been deleted. When deleted, the route will return a 404.
         * @summary Enqueues a task to delete the account
         * @param {string} accountId 
         * @param {boolean} [deleteNow] Delete the account immediately. Otherwise, the account will be completely removed after 24 hours
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsDelete(accountId: string, deleteNow?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsDelete(accountId, deleteNow, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of all accounts
         * @param {string} [q] Search items by this string
         * @param {number} [page] Page number to paginate through results
         * @param {number} [count] Number of items to return
         * @param {boolean} [all] 
         * @param {AccountState} [state] only fetch accounts with a state
         * @param {boolean} [returnCount] return total count of accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsGet(q?: string, page?: number, count?: number, all?: boolean, state?: AccountState, returnCount?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsGet(q, page, count, all, state, returnCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logout and clear credentials from the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsLogout(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsLogout(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Open connection to the account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsOpen(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsOpen(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update name of the account or its settings
         * @summary Update an account
         * @param {string} accountId 
         * @param {AccountsPatchRequest} [accountsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPatch(accountId: string, accountsPatchRequest?: AccountsPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPatch(accountId, accountsPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new account
         * @param {AccountsPostRequest} [accountsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPost(accountsPostRequest?: AccountsPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPost(accountsPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change login mode of a WhatsApp account
         * @param {string} accountId 
         * @param {AccountWaChangeLoginMode} [accountWaChangeLoginMode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waChangeLoginMode(accountId: string, accountWaChangeLoginMode?: AccountWaChangeLoginMode, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.waChangeLoginMode(accountId, accountWaChangeLoginMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Archive an account. Logs out of the account & removes all synced chats, messages. Keeps contacts, and notes.
         * @param {AccountApiAccountsArchiveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsArchive(requestParameters: AccountApiAccountsArchiveRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.accountsArchive(requestParameters.accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Close connection to the account
         * @param {AccountApiAccountsCloseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsClose(requestParameters: AccountApiAccountsCloseRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountsClose(requestParameters.accountId, requestParameters.logout, options).then((request) => request(axios, basePath));
        },
        /**
         * You can continue to poll this route to check if it has been deleted. When deleted, the route will return a 404.
         * @summary Enqueues a task to delete the account
         * @param {AccountApiAccountsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsDelete(requestParameters: AccountApiAccountsDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.accountsDelete(requestParameters.accountId, requestParameters.deleteNow, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of all accounts
         * @param {AccountApiAccountsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsGet(requestParameters: AccountApiAccountsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<AccountsGet200Response> {
            return localVarFp.accountsGet(requestParameters.q, requestParameters.page, requestParameters.count, requestParameters.all, requestParameters.state, requestParameters.returnCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout and clear credentials from the account
         * @param {AccountApiAccountsLogoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLogout(requestParameters: AccountApiAccountsLogoutRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.accountsLogout(requestParameters.accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Open connection to the account
         * @param {AccountApiAccountsOpenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsOpen(requestParameters: AccountApiAccountsOpenRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountsOpen(requestParameters.accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update name of the account or its settings
         * @summary Update an account
         * @param {AccountApiAccountsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPatch(requestParameters: AccountApiAccountsPatchRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.accountsPatch(requestParameters.accountId, requestParameters.accountsPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new account
         * @param {AccountApiAccountsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPost(requestParameters: AccountApiAccountsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.accountsPost(requestParameters.accountsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change login mode of a WhatsApp account
         * @param {AccountApiWaChangeLoginModeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waChangeLoginMode(requestParameters: AccountApiWaChangeLoginModeRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.waChangeLoginMode(requestParameters.accountId, requestParameters.accountWaChangeLoginMode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for accountsArchive operation in AccountApi.
 * @export
 * @interface AccountApiAccountsArchiveRequest
 */
export interface AccountApiAccountsArchiveRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsArchive
     */
    readonly accountId: string
}

/**
 * Request parameters for accountsClose operation in AccountApi.
 * @export
 * @interface AccountApiAccountsCloseRequest
 */
export interface AccountApiAccountsCloseRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsClose
     */
    readonly accountId: string

    /**
     * Closes the account and logs out from the account
     * @type {boolean}
     * @memberof AccountApiAccountsClose
     */
    readonly logout?: boolean
}

/**
 * Request parameters for accountsDelete operation in AccountApi.
 * @export
 * @interface AccountApiAccountsDeleteRequest
 */
export interface AccountApiAccountsDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsDelete
     */
    readonly accountId: string

    /**
     * Delete the account immediately. Otherwise, the account will be completely removed after 24 hours
     * @type {boolean}
     * @memberof AccountApiAccountsDelete
     */
    readonly deleteNow?: boolean
}

/**
 * Request parameters for accountsGet operation in AccountApi.
 * @export
 * @interface AccountApiAccountsGetRequest
 */
export interface AccountApiAccountsGetRequest {
    /**
     * Search items by this string
     * @type {string}
     * @memberof AccountApiAccountsGet
     */
    readonly q?: string

    /**
     * Page number to paginate through results
     * @type {number}
     * @memberof AccountApiAccountsGet
     */
    readonly page?: number

    /**
     * Number of items to return
     * @type {number}
     * @memberof AccountApiAccountsGet
     */
    readonly count?: number

    /**
     * 
     * @type {boolean}
     * @memberof AccountApiAccountsGet
     */
    readonly all?: boolean

    /**
     * only fetch accounts with a state
     * @type {AccountState}
     * @memberof AccountApiAccountsGet
     */
    readonly state?: AccountState

    /**
     * return total count of accounts
     * @type {boolean}
     * @memberof AccountApiAccountsGet
     */
    readonly returnCount?: boolean
}

/**
 * Request parameters for accountsLogout operation in AccountApi.
 * @export
 * @interface AccountApiAccountsLogoutRequest
 */
export interface AccountApiAccountsLogoutRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsLogout
     */
    readonly accountId: string
}

/**
 * Request parameters for accountsOpen operation in AccountApi.
 * @export
 * @interface AccountApiAccountsOpenRequest
 */
export interface AccountApiAccountsOpenRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsOpen
     */
    readonly accountId: string
}

/**
 * Request parameters for accountsPatch operation in AccountApi.
 * @export
 * @interface AccountApiAccountsPatchRequest
 */
export interface AccountApiAccountsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiAccountsPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {AccountsPatchRequest}
     * @memberof AccountApiAccountsPatch
     */
    readonly accountsPatchRequest?: AccountsPatchRequest
}

/**
 * Request parameters for accountsPost operation in AccountApi.
 * @export
 * @interface AccountApiAccountsPostRequest
 */
export interface AccountApiAccountsPostRequest {
    /**
     * 
     * @type {AccountsPostRequest}
     * @memberof AccountApiAccountsPost
     */
    readonly accountsPostRequest?: AccountsPostRequest
}

/**
 * Request parameters for waChangeLoginMode operation in AccountApi.
 * @export
 * @interface AccountApiWaChangeLoginModeRequest
 */
export interface AccountApiWaChangeLoginModeRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountApiWaChangeLoginMode
     */
    readonly accountId: string

    /**
     * 
     * @type {AccountWaChangeLoginMode}
     * @memberof AccountApiWaChangeLoginMode
     */
    readonly accountWaChangeLoginMode?: AccountWaChangeLoginMode
}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Archive an account. Logs out of the account & removes all synced chats, messages. Keeps contacts, and notes.
     * @param {AccountApiAccountsArchiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsArchive(requestParameters: AccountApiAccountsArchiveRequest, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsArchive(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Close connection to the account
     * @param {AccountApiAccountsCloseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsClose(requestParameters: AccountApiAccountsCloseRequest, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsClose(requestParameters.accountId, requestParameters.logout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can continue to poll this route to check if it has been deleted. When deleted, the route will return a 404.
     * @summary Enqueues a task to delete the account
     * @param {AccountApiAccountsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsDelete(requestParameters: AccountApiAccountsDeleteRequest, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsDelete(requestParameters.accountId, requestParameters.deleteNow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of all accounts
     * @param {AccountApiAccountsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsGet(requestParameters: AccountApiAccountsGetRequest = {}, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsGet(requestParameters.q, requestParameters.page, requestParameters.count, requestParameters.all, requestParameters.state, requestParameters.returnCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout and clear credentials from the account
     * @param {AccountApiAccountsLogoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsLogout(requestParameters: AccountApiAccountsLogoutRequest, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsLogout(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Open connection to the account
     * @param {AccountApiAccountsOpenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsOpen(requestParameters: AccountApiAccountsOpenRequest, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsOpen(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update name of the account or its settings
     * @summary Update an account
     * @param {AccountApiAccountsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsPatch(requestParameters: AccountApiAccountsPatchRequest, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsPatch(requestParameters.accountId, requestParameters.accountsPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new account
     * @param {AccountApiAccountsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsPost(requestParameters: AccountApiAccountsPostRequest = {}, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsPost(requestParameters.accountsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change login mode of a WhatsApp account
     * @param {AccountApiWaChangeLoginModeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public waChangeLoginMode(requestParameters: AccountApiWaChangeLoginModeRequest, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).waChangeLoginMode(requestParameters.accountId, requestParameters.accountWaChangeLoginMode, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlibabaCamsApi - axios parameter creator
 * @export
 */
export const AlibabaCamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Submit ISV terms to Alibaba CAMS API
         * @param {string} accountId 
         * @param {AlibabaCAMSISVTerms} [alibabaCAMSISVTerms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsIsvTerms: async (accountId: string, alibabaCAMSISVTerms?: AlibabaCAMSISVTerms, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('alibabaCamsIsvTerms', 'accountId', accountId)
            const localVarPath = `/alibaba-cams/isv-terms/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alibabaCAMSISVTerms, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query metadata for Alibaba CAMS API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsMetadata: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/alibaba-cams/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update business info for Alibaba CAMS API
         * @param {string} accountId 
         * @param {AlibabaCamsProfileUpdateRequest} [alibabaCamsProfileUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsProfileUpdate: async (accountId: string, alibabaCamsProfileUpdateRequest?: AlibabaCamsProfileUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('alibabaCamsProfileUpdate', 'accountId', accountId)
            const localVarPath = `/alibaba-cams/profile/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alibabaCamsProfileUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register an account with a token from embedded sign up
         * @param {string} accountId 
         * @param {AlibabaCamsRegisterRequest} [alibabaCamsRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsRegister: async (accountId: string, alibabaCamsRegisterRequest?: AlibabaCamsRegisterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('alibabaCamsRegister', 'accountId', accountId)
            const localVarPath = `/alibaba-cams/register/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alibabaCamsRegisterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sync the account state with Alibaba CAMS
         * @param {string} accountId 
         * @param {AlibabaCamsSyncRequest} [alibabaCamsSyncRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsSync: async (accountId: string, alibabaCamsSyncRequest?: AlibabaCamsSyncRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('alibabaCamsSync', 'accountId', accountId)
            const localVarPath = `/alibaba-cams/sync/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alibabaCamsSyncRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Receive a message from Alibaba CAMS API
         * @param {string} accountId 
         * @param {string} secret 
         * @param {Array<AlibabaCAMSWebhookItem>} [alibabaCAMSWebhookItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookAlibabaCamsPost: async (accountId: string, secret: string, alibabaCAMSWebhookItem?: Array<AlibabaCAMSWebhookItem>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('webhookAlibabaCamsPost', 'accountId', accountId)
            // verify required parameter 'secret' is not null or undefined
            assertParamExists('webhookAlibabaCamsPost', 'secret', secret)
            const localVarPath = `/webhook/{accountId}/{secret}/alibaba-cams`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"secret"}}`, encodeURIComponent(String(secret)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alibabaCAMSWebhookItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlibabaCamsApi - functional programming interface
 * @export
 */
export const AlibabaCamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlibabaCamsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Submit ISV terms to Alibaba CAMS API
         * @param {string} accountId 
         * @param {AlibabaCAMSISVTerms} [alibabaCAMSISVTerms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alibabaCamsIsvTerms(accountId: string, alibabaCAMSISVTerms?: AlibabaCAMSISVTerms, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alibabaCamsIsvTerms(accountId, alibabaCAMSISVTerms, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Query metadata for Alibaba CAMS API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alibabaCamsMetadata(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlibabaCamsMetadata200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alibabaCamsMetadata(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update business info for Alibaba CAMS API
         * @param {string} accountId 
         * @param {AlibabaCamsProfileUpdateRequest} [alibabaCamsProfileUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alibabaCamsProfileUpdate(accountId: string, alibabaCamsProfileUpdateRequest?: AlibabaCamsProfileUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alibabaCamsProfileUpdate(accountId, alibabaCamsProfileUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register an account with a token from embedded sign up
         * @param {string} accountId 
         * @param {AlibabaCamsRegisterRequest} [alibabaCamsRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alibabaCamsRegister(accountId: string, alibabaCamsRegisterRequest?: AlibabaCamsRegisterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlibabaCamsRegister200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alibabaCamsRegister(accountId, alibabaCamsRegisterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sync the account state with Alibaba CAMS
         * @param {string} accountId 
         * @param {AlibabaCamsSyncRequest} [alibabaCamsSyncRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alibabaCamsSync(accountId: string, alibabaCamsSyncRequest?: AlibabaCamsSyncRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlibabaCamsSync200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alibabaCamsSync(accountId, alibabaCamsSyncRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Receive a message from Alibaba CAMS API
         * @param {string} accountId 
         * @param {string} secret 
         * @param {Array<AlibabaCAMSWebhookItem>} [alibabaCAMSWebhookItem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookAlibabaCamsPost(accountId: string, secret: string, alibabaCAMSWebhookItem?: Array<AlibabaCAMSWebhookItem>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookAlibabaCamsPost(accountId, secret, alibabaCAMSWebhookItem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlibabaCamsApi - factory interface
 * @export
 */
export const AlibabaCamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlibabaCamsApiFp(configuration)
    return {
        /**
         * 
         * @summary Submit ISV terms to Alibaba CAMS API
         * @param {AlibabaCamsApiAlibabaCamsIsvTermsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsIsvTerms(requestParameters: AlibabaCamsApiAlibabaCamsIsvTermsRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.alibabaCamsIsvTerms(requestParameters.accountId, requestParameters.alibabaCAMSISVTerms, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query metadata for Alibaba CAMS API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsMetadata(options?: AxiosRequestConfig): AxiosPromise<AlibabaCamsMetadata200Response> {
            return localVarFp.alibabaCamsMetadata(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update business info for Alibaba CAMS API
         * @param {AlibabaCamsApiAlibabaCamsProfileUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsProfileUpdate(requestParameters: AlibabaCamsApiAlibabaCamsProfileUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.alibabaCamsProfileUpdate(requestParameters.accountId, requestParameters.alibabaCamsProfileUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register an account with a token from embedded sign up
         * @param {AlibabaCamsApiAlibabaCamsRegisterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsRegister(requestParameters: AlibabaCamsApiAlibabaCamsRegisterRequest, options?: AxiosRequestConfig): AxiosPromise<AlibabaCamsRegister200Response> {
            return localVarFp.alibabaCamsRegister(requestParameters.accountId, requestParameters.alibabaCamsRegisterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sync the account state with Alibaba CAMS
         * @param {AlibabaCamsApiAlibabaCamsSyncRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alibabaCamsSync(requestParameters: AlibabaCamsApiAlibabaCamsSyncRequest, options?: AxiosRequestConfig): AxiosPromise<AlibabaCamsSync200Response> {
            return localVarFp.alibabaCamsSync(requestParameters.accountId, requestParameters.alibabaCamsSyncRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Receive a message from Alibaba CAMS API
         * @param {AlibabaCamsApiWebhookAlibabaCamsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookAlibabaCamsPost(requestParameters: AlibabaCamsApiWebhookAlibabaCamsPostRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.webhookAlibabaCamsPost(requestParameters.accountId, requestParameters.secret, requestParameters.alibabaCAMSWebhookItem, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for alibabaCamsIsvTerms operation in AlibabaCamsApi.
 * @export
 * @interface AlibabaCamsApiAlibabaCamsIsvTermsRequest
 */
export interface AlibabaCamsApiAlibabaCamsIsvTermsRequest {
    /**
     * 
     * @type {string}
     * @memberof AlibabaCamsApiAlibabaCamsIsvTerms
     */
    readonly accountId: string

    /**
     * 
     * @type {AlibabaCAMSISVTerms}
     * @memberof AlibabaCamsApiAlibabaCamsIsvTerms
     */
    readonly alibabaCAMSISVTerms?: AlibabaCAMSISVTerms
}

/**
 * Request parameters for alibabaCamsProfileUpdate operation in AlibabaCamsApi.
 * @export
 * @interface AlibabaCamsApiAlibabaCamsProfileUpdateRequest
 */
export interface AlibabaCamsApiAlibabaCamsProfileUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AlibabaCamsApiAlibabaCamsProfileUpdate
     */
    readonly accountId: string

    /**
     * 
     * @type {AlibabaCamsProfileUpdateRequest}
     * @memberof AlibabaCamsApiAlibabaCamsProfileUpdate
     */
    readonly alibabaCamsProfileUpdateRequest?: AlibabaCamsProfileUpdateRequest
}

/**
 * Request parameters for alibabaCamsRegister operation in AlibabaCamsApi.
 * @export
 * @interface AlibabaCamsApiAlibabaCamsRegisterRequest
 */
export interface AlibabaCamsApiAlibabaCamsRegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof AlibabaCamsApiAlibabaCamsRegister
     */
    readonly accountId: string

    /**
     * 
     * @type {AlibabaCamsRegisterRequest}
     * @memberof AlibabaCamsApiAlibabaCamsRegister
     */
    readonly alibabaCamsRegisterRequest?: AlibabaCamsRegisterRequest
}

/**
 * Request parameters for alibabaCamsSync operation in AlibabaCamsApi.
 * @export
 * @interface AlibabaCamsApiAlibabaCamsSyncRequest
 */
export interface AlibabaCamsApiAlibabaCamsSyncRequest {
    /**
     * 
     * @type {string}
     * @memberof AlibabaCamsApiAlibabaCamsSync
     */
    readonly accountId: string

    /**
     * 
     * @type {AlibabaCamsSyncRequest}
     * @memberof AlibabaCamsApiAlibabaCamsSync
     */
    readonly alibabaCamsSyncRequest?: AlibabaCamsSyncRequest
}

/**
 * Request parameters for webhookAlibabaCamsPost operation in AlibabaCamsApi.
 * @export
 * @interface AlibabaCamsApiWebhookAlibabaCamsPostRequest
 */
export interface AlibabaCamsApiWebhookAlibabaCamsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AlibabaCamsApiWebhookAlibabaCamsPost
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof AlibabaCamsApiWebhookAlibabaCamsPost
     */
    readonly secret: string

    /**
     * 
     * @type {Array<AlibabaCAMSWebhookItem>}
     * @memberof AlibabaCamsApiWebhookAlibabaCamsPost
     */
    readonly alibabaCAMSWebhookItem?: Array<AlibabaCAMSWebhookItem>
}

/**
 * AlibabaCamsApi - object-oriented interface
 * @export
 * @class AlibabaCamsApi
 * @extends {BaseAPI}
 */
export class AlibabaCamsApi extends BaseAPI {
    /**
     * 
     * @summary Submit ISV terms to Alibaba CAMS API
     * @param {AlibabaCamsApiAlibabaCamsIsvTermsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlibabaCamsApi
     */
    public alibabaCamsIsvTerms(requestParameters: AlibabaCamsApiAlibabaCamsIsvTermsRequest, options?: AxiosRequestConfig) {
        return AlibabaCamsApiFp(this.configuration).alibabaCamsIsvTerms(requestParameters.accountId, requestParameters.alibabaCAMSISVTerms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query metadata for Alibaba CAMS API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlibabaCamsApi
     */
    public alibabaCamsMetadata(options?: AxiosRequestConfig) {
        return AlibabaCamsApiFp(this.configuration).alibabaCamsMetadata(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update business info for Alibaba CAMS API
     * @param {AlibabaCamsApiAlibabaCamsProfileUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlibabaCamsApi
     */
    public alibabaCamsProfileUpdate(requestParameters: AlibabaCamsApiAlibabaCamsProfileUpdateRequest, options?: AxiosRequestConfig) {
        return AlibabaCamsApiFp(this.configuration).alibabaCamsProfileUpdate(requestParameters.accountId, requestParameters.alibabaCamsProfileUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register an account with a token from embedded sign up
     * @param {AlibabaCamsApiAlibabaCamsRegisterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlibabaCamsApi
     */
    public alibabaCamsRegister(requestParameters: AlibabaCamsApiAlibabaCamsRegisterRequest, options?: AxiosRequestConfig) {
        return AlibabaCamsApiFp(this.configuration).alibabaCamsRegister(requestParameters.accountId, requestParameters.alibabaCamsRegisterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sync the account state with Alibaba CAMS
     * @param {AlibabaCamsApiAlibabaCamsSyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlibabaCamsApi
     */
    public alibabaCamsSync(requestParameters: AlibabaCamsApiAlibabaCamsSyncRequest, options?: AxiosRequestConfig) {
        return AlibabaCamsApiFp(this.configuration).alibabaCamsSync(requestParameters.accountId, requestParameters.alibabaCamsSyncRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Receive a message from Alibaba CAMS API
     * @param {AlibabaCamsApiWebhookAlibabaCamsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlibabaCamsApi
     */
    public webhookAlibabaCamsPost(requestParameters: AlibabaCamsApiWebhookAlibabaCamsPostRequest, options?: AxiosRequestConfig) {
        return AlibabaCamsApiFp(this.configuration).webhookAlibabaCamsPost(requestParameters.accountId, requestParameters.secret, requestParameters.alibabaCAMSWebhookItem, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CRMApi - axios parameter creator
 * @export
 */
export const CRMApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new CRM ticket
         * @param {CrmTicketPost} [crmTicketPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket: async (crmTicketPost?: CrmTicketPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/crm/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(crmTicketPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a CRM board
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmBoardDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('crmBoardDelete', 'id', id)
            const localVarPath = `/crm/boards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get CRM Board data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmBoardGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/crm/boards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a CRM board
         * @param {string} id 
         * @param {CrmBoardPatch} [crmBoardPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmBoardPatch: async (id: string, crmBoardPatch?: CrmBoardPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('crmBoardPatch', 'id', id)
            const localVarPath = `/crm/boards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(crmBoardPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new CRM board
         * @param {CrmBoardPost} [crmBoardPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmBoardPost: async (crmBoardPost?: CrmBoardPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/crm/boards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(crmBoardPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a CRM ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicket: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTicket', 'id', id)
            const localVarPath = `/crm/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get CRM tickets
         * @param {number} [count] Number of items to return
         * @param {string} [page] 
         * @param {string} [boardId] 
         * @param {string} [stageId] 
         * @param {UniqueContactID} [contactId] 
         * @param {boolean} [returnTotalCount] 
         * @param {string} [q] Search items by this string
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickets: async (count?: number, page?: string, boardId?: string, stageId?: string, contactId?: UniqueContactID, returnTotalCount?: boolean, q?: string, tags?: ChatsGetTagsParameter, assignee?: ChatsGetAssigneeParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/crm/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (boardId !== undefined) {
                localVarQueryParameter['boardId'] = boardId;
            }

            if (stageId !== undefined) {
                localVarQueryParameter['stageId'] = stageId;
            }

            if (contactId !== undefined) {
                localVarQueryParameter['contactId'] = contactId;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a CRM ticket
         * @param {string} id 
         * @param {CrmTicketPatch} [crmTicketPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicket: async (id: string, crmTicketPatch?: CrmTicketPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTicket', 'id', id)
            const localVarPath = `/crm/tickets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(crmTicketPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CRMApi - functional programming interface
 * @export
 */
export const CRMApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CRMApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new CRM ticket
         * @param {CrmTicketPost} [crmTicketPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTicket(crmTicketPost?: CrmTicketPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrmTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTicket(crmTicketPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a CRM board
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crmBoardDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crmBoardDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get CRM Board data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crmBoardGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrmBoardGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crmBoardGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a CRM board
         * @param {string} id 
         * @param {CrmBoardPatch} [crmBoardPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crmBoardPatch(id: string, crmBoardPatch?: CrmBoardPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrmBoard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crmBoardPatch(id, crmBoardPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new CRM board
         * @param {CrmBoardPost} [crmBoardPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crmBoardPost(crmBoardPost?: CrmBoardPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrmBoard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crmBoardPost(crmBoardPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a CRM ticket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTicket(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTicket(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get CRM tickets
         * @param {number} [count] Number of items to return
         * @param {string} [page] 
         * @param {string} [boardId] 
         * @param {string} [stageId] 
         * @param {UniqueContactID} [contactId] 
         * @param {boolean} [returnTotalCount] 
         * @param {string} [q] Search items by this string
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickets(count?: number, page?: string, boardId?: string, stageId?: string, contactId?: UniqueContactID, returnTotalCount?: boolean, q?: string, tags?: ChatsGetTagsParameter, assignee?: ChatsGetAssigneeParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTickets200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickets(count, page, boardId, stageId, contactId, returnTotalCount, q, tags, assignee, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a CRM ticket
         * @param {string} id 
         * @param {CrmTicketPatch} [crmTicketPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTicket(id: string, crmTicketPatch?: CrmTicketPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrmTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTicket(id, crmTicketPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CRMApi - factory interface
 * @export
 */
export const CRMApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CRMApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new CRM ticket
         * @param {CRMApiCreateTicketRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket(requestParameters: CRMApiCreateTicketRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CrmTicket> {
            return localVarFp.createTicket(requestParameters.crmTicketPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a CRM board
         * @param {CRMApiCrmBoardDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmBoardDelete(requestParameters: CRMApiCrmBoardDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.crmBoardDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get CRM Board data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmBoardGet(options?: AxiosRequestConfig): AxiosPromise<CrmBoardGet200Response> {
            return localVarFp.crmBoardGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a CRM board
         * @param {CRMApiCrmBoardPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmBoardPatch(requestParameters: CRMApiCrmBoardPatchRequest, options?: AxiosRequestConfig): AxiosPromise<CrmBoard> {
            return localVarFp.crmBoardPatch(requestParameters.id, requestParameters.crmBoardPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new CRM board
         * @param {CRMApiCrmBoardPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crmBoardPost(requestParameters: CRMApiCrmBoardPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CrmBoard> {
            return localVarFp.crmBoardPost(requestParameters.crmBoardPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a CRM ticket
         * @param {CRMApiDeleteTicketRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicket(requestParameters: CRMApiDeleteTicketRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.deleteTicket(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get CRM tickets
         * @param {CRMApiGetTicketsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickets(requestParameters: CRMApiGetTicketsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetTickets200Response> {
            return localVarFp.getTickets(requestParameters.count, requestParameters.page, requestParameters.boardId, requestParameters.stageId, requestParameters.contactId, requestParameters.returnTotalCount, requestParameters.q, requestParameters.tags, requestParameters.assignee, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a CRM ticket
         * @param {CRMApiUpdateTicketRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicket(requestParameters: CRMApiUpdateTicketRequest, options?: AxiosRequestConfig): AxiosPromise<CrmTicket> {
            return localVarFp.updateTicket(requestParameters.id, requestParameters.crmTicketPatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTicket operation in CRMApi.
 * @export
 * @interface CRMApiCreateTicketRequest
 */
export interface CRMApiCreateTicketRequest {
    /**
     * 
     * @type {CrmTicketPost}
     * @memberof CRMApiCreateTicket
     */
    readonly crmTicketPost?: CrmTicketPost
}

/**
 * Request parameters for crmBoardDelete operation in CRMApi.
 * @export
 * @interface CRMApiCrmBoardDeleteRequest
 */
export interface CRMApiCrmBoardDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof CRMApiCrmBoardDelete
     */
    readonly id: string
}

/**
 * Request parameters for crmBoardPatch operation in CRMApi.
 * @export
 * @interface CRMApiCrmBoardPatchRequest
 */
export interface CRMApiCrmBoardPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof CRMApiCrmBoardPatch
     */
    readonly id: string

    /**
     * 
     * @type {CrmBoardPatch}
     * @memberof CRMApiCrmBoardPatch
     */
    readonly crmBoardPatch?: CrmBoardPatch
}

/**
 * Request parameters for crmBoardPost operation in CRMApi.
 * @export
 * @interface CRMApiCrmBoardPostRequest
 */
export interface CRMApiCrmBoardPostRequest {
    /**
     * 
     * @type {CrmBoardPost}
     * @memberof CRMApiCrmBoardPost
     */
    readonly crmBoardPost?: CrmBoardPost
}

/**
 * Request parameters for deleteTicket operation in CRMApi.
 * @export
 * @interface CRMApiDeleteTicketRequest
 */
export interface CRMApiDeleteTicketRequest {
    /**
     * 
     * @type {string}
     * @memberof CRMApiDeleteTicket
     */
    readonly id: string
}

/**
 * Request parameters for getTickets operation in CRMApi.
 * @export
 * @interface CRMApiGetTicketsRequest
 */
export interface CRMApiGetTicketsRequest {
    /**
     * Number of items to return
     * @type {number}
     * @memberof CRMApiGetTickets
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof CRMApiGetTickets
     */
    readonly page?: string

    /**
     * 
     * @type {string}
     * @memberof CRMApiGetTickets
     */
    readonly boardId?: string

    /**
     * 
     * @type {string}
     * @memberof CRMApiGetTickets
     */
    readonly stageId?: string

    /**
     * 
     * @type {UniqueContactID}
     * @memberof CRMApiGetTickets
     */
    readonly contactId?: UniqueContactID

    /**
     * 
     * @type {boolean}
     * @memberof CRMApiGetTickets
     */
    readonly returnTotalCount?: boolean

    /**
     * Search items by this string
     * @type {string}
     * @memberof CRMApiGetTickets
     */
    readonly q?: string

    /**
     * Get contacts who fall in either of these tags
     * @type {ChatsGetTagsParameter}
     * @memberof CRMApiGetTickets
     */
    readonly tags?: ChatsGetTagsParameter

    /**
     * Get contacts assigned to the specified users
     * @type {ChatsGetAssigneeParameter}
     * @memberof CRMApiGetTickets
     */
    readonly assignee?: ChatsGetAssigneeParameter
}

/**
 * Request parameters for updateTicket operation in CRMApi.
 * @export
 * @interface CRMApiUpdateTicketRequest
 */
export interface CRMApiUpdateTicketRequest {
    /**
     * 
     * @type {string}
     * @memberof CRMApiUpdateTicket
     */
    readonly id: string

    /**
     * 
     * @type {CrmTicketPatch}
     * @memberof CRMApiUpdateTicket
     */
    readonly crmTicketPatch?: CrmTicketPatch
}

/**
 * CRMApi - object-oriented interface
 * @export
 * @class CRMApi
 * @extends {BaseAPI}
 */
export class CRMApi extends BaseAPI {
    /**
     * 
     * @summary Create a new CRM ticket
     * @param {CRMApiCreateTicketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public createTicket(requestParameters: CRMApiCreateTicketRequest = {}, options?: AxiosRequestConfig) {
        return CRMApiFp(this.configuration).createTicket(requestParameters.crmTicketPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a CRM board
     * @param {CRMApiCrmBoardDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public crmBoardDelete(requestParameters: CRMApiCrmBoardDeleteRequest, options?: AxiosRequestConfig) {
        return CRMApiFp(this.configuration).crmBoardDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get CRM Board data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public crmBoardGet(options?: AxiosRequestConfig) {
        return CRMApiFp(this.configuration).crmBoardGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a CRM board
     * @param {CRMApiCrmBoardPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public crmBoardPatch(requestParameters: CRMApiCrmBoardPatchRequest, options?: AxiosRequestConfig) {
        return CRMApiFp(this.configuration).crmBoardPatch(requestParameters.id, requestParameters.crmBoardPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new CRM board
     * @param {CRMApiCrmBoardPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public crmBoardPost(requestParameters: CRMApiCrmBoardPostRequest = {}, options?: AxiosRequestConfig) {
        return CRMApiFp(this.configuration).crmBoardPost(requestParameters.crmBoardPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a CRM ticket
     * @param {CRMApiDeleteTicketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public deleteTicket(requestParameters: CRMApiDeleteTicketRequest, options?: AxiosRequestConfig) {
        return CRMApiFp(this.configuration).deleteTicket(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get CRM tickets
     * @param {CRMApiGetTicketsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public getTickets(requestParameters: CRMApiGetTicketsRequest = {}, options?: AxiosRequestConfig) {
        return CRMApiFp(this.configuration).getTickets(requestParameters.count, requestParameters.page, requestParameters.boardId, requestParameters.stageId, requestParameters.contactId, requestParameters.returnTotalCount, requestParameters.q, requestParameters.tags, requestParameters.assignee, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a CRM ticket
     * @param {CRMApiUpdateTicketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CRMApi
     */
    public updateTicket(requestParameters: CRMApiUpdateTicketRequest, options?: AxiosRequestConfig) {
        return CRMApiFp(this.configuration).updateTicket(requestParameters.id, requestParameters.crmTicketPatch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChatHistoryApi - axios parameter creator
 * @export
 */
export const ChatHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch chat history as a file
         * @param {string} [timeZone] 
         * @param {Array<string>} [chatId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatHistory: async (timeZone?: string, chatId?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chat-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL"], configuration)

            if (timeZone !== undefined) {
                localVarQueryParameter['timeZone'] = timeZone;
            }

            if (chatId) {
                localVarQueryParameter['chatId'] = chatId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Poll route to see if file is done
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollChatHistory: async (requestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('pollChatHistory', 'requestId', requestId)
            const localVarPath = `/chat-history/{requestId}`
                .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatHistoryApi - functional programming interface
 * @export
 */
export const ChatHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch chat history as a file
         * @param {string} [timeZone] 
         * @param {Array<string>} [chatId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatHistory(timeZone?: string, chatId?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChatHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatHistory(timeZone, chatId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Poll route to see if file is done
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pollChatHistory(requestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PollChatHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pollChatHistory(requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChatHistoryApi - factory interface
 * @export
 */
export const ChatHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatHistoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch chat history as a file
         * @param {ChatHistoryApiGetChatHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatHistory(requestParameters: ChatHistoryApiGetChatHistoryRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetChatHistory200Response> {
            return localVarFp.getChatHistory(requestParameters.timeZone, requestParameters.chatId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Poll route to see if file is done
         * @param {ChatHistoryApiPollChatHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollChatHistory(requestParameters: ChatHistoryApiPollChatHistoryRequest, options?: AxiosRequestConfig): AxiosPromise<PollChatHistory200Response> {
            return localVarFp.pollChatHistory(requestParameters.requestId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getChatHistory operation in ChatHistoryApi.
 * @export
 * @interface ChatHistoryApiGetChatHistoryRequest
 */
export interface ChatHistoryApiGetChatHistoryRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatHistoryApiGetChatHistory
     */
    readonly timeZone?: string

    /**
     * 
     * @type {Array<string>}
     * @memberof ChatHistoryApiGetChatHistory
     */
    readonly chatId?: Array<string>
}

/**
 * Request parameters for pollChatHistory operation in ChatHistoryApi.
 * @export
 * @interface ChatHistoryApiPollChatHistoryRequest
 */
export interface ChatHistoryApiPollChatHistoryRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatHistoryApiPollChatHistory
     */
    readonly requestId: string
}

/**
 * ChatHistoryApi - object-oriented interface
 * @export
 * @class ChatHistoryApi
 * @extends {BaseAPI}
 */
export class ChatHistoryApi extends BaseAPI {
    /**
     * 
     * @summary Fetch chat history as a file
     * @param {ChatHistoryApiGetChatHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatHistoryApi
     */
    public getChatHistory(requestParameters: ChatHistoryApiGetChatHistoryRequest = {}, options?: AxiosRequestConfig) {
        return ChatHistoryApiFp(this.configuration).getChatHistory(requestParameters.timeZone, requestParameters.chatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Poll route to see if file is done
     * @param {ChatHistoryApiPollChatHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatHistoryApi
     */
    public pollChatHistory(requestParameters: ChatHistoryApiPollChatHistoryRequest, options?: AxiosRequestConfig) {
        return ChatHistoryApiFp(this.configuration).pollChatHistory(requestParameters.requestId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChatsApi - axios parameter creator
 * @export
 */
export const ChatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get chats
         * @param {number} [count] Number of items to return
         * @param {string} [page] 
         * @param {boolean} [archive] 
         * @param {boolean} [unread] Only get chats with unread/read messages
         * @param {boolean} [returnTotalCount] 
         * @param {boolean} [hasPendingMessage] 
         * @param {string} [mentioned] 
         * @param {boolean} [hasUnsolvedNote] 
         * @param {boolean} [hasFailedMessage] 
         * @param {'closed' | 'open'} [ticketStatus] 
         * @param {boolean} [lastMessageFromMe] Only get chats where the last message was sent by me/not me
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {ChatsGetContactsParameter} [contacts] Get these specific contact ids
         * @param {string} [q] Search items by this string
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {ContactType} [type] only get contacts of type
         * @param {ChatsGetTicketParameter} [ticket] Query the status of a ticket
         * @param {boolean} [returnUnreadChatCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsGet: async (count?: number, page?: string, archive?: boolean, unread?: boolean, returnTotalCount?: boolean, hasPendingMessage?: boolean, mentioned?: string, hasUnsolvedNote?: boolean, hasFailedMessage?: boolean, ticketStatus?: 'closed' | 'open', lastMessageFromMe?: boolean, tags?: ChatsGetTagsParameter, notTags?: Array<string>, contacts?: ChatsGetContactsParameter, q?: string, assignee?: ChatsGetAssigneeParameter, accountId?: Array<string>, type?: ContactType, ticket?: ChatsGetTicketParameter, returnUnreadChatCount?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL", "CHATS_ACCESS_ASSIGNED"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (archive !== undefined) {
                localVarQueryParameter['archive'] = archive;
            }

            if (unread !== undefined) {
                localVarQueryParameter['unread'] = unread;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }

            if (hasPendingMessage !== undefined) {
                localVarQueryParameter['hasPendingMessage'] = hasPendingMessage;
            }

            if (mentioned !== undefined) {
                localVarQueryParameter['mentioned'] = mentioned;
            }

            if (hasUnsolvedNote !== undefined) {
                localVarQueryParameter['hasUnsolvedNote'] = hasUnsolvedNote;
            }

            if (hasFailedMessage !== undefined) {
                localVarQueryParameter['hasFailedMessage'] = hasFailedMessage;
            }

            if (ticketStatus !== undefined) {
                localVarQueryParameter['ticketStatus'] = ticketStatus;
            }

            if (lastMessageFromMe !== undefined) {
                localVarQueryParameter['lastMessageFromMe'] = lastMessageFromMe;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (notTags) {
                localVarQueryParameter['notTags'] = notTags;
            }

            if (contacts !== undefined) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (ticket !== undefined) {
                localVarQueryParameter['ticket'] = ticket;
            }

            if (returnUnreadChatCount !== undefined) {
                localVarQueryParameter['returnUnreadChatCount'] = returnUnreadChatCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a chat -- read, unread, archive, pin etc.
         * @param {string} accountId 
         * @param {string} id 
         * @param {ChatAction} [chatAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPatch: async (accountId: string, id: string, chatAction?: ChatAction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('chatsPatch', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsPatch', 'id', id)
            const localVarPath = `/chats/{accountId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL", "CHATS_ACCESS_ASSIGNED"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: Sending an \"available\" presence, will also subscribe you to events from the other party
         * @summary Update a chat\'s presence.
         * @param {string} accountId 
         * @param {string} id 
         * @param {PresenceType} presence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPresencePost: async (accountId: string, id: string, presence: PresenceType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('chatsPresencePost', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsPresencePost', 'id', id)
            // verify required parameter 'presence' is not null or undefined
            assertParamExists('chatsPresencePost', 'presence', presence)
            const localVarPath = `/chats/{accountId}/{id}/presence`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ASSIGNED", "CHATS_ACCESS_ALL"], configuration)

            if (presence !== undefined) {
                localVarQueryParameter['presence'] = presence;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a chat\'s ticket status -- closed | null\'
         * @param {string} accountId 
         * @param {string} id 
         * @param {ChatsTicketStatusPatchRequest} [chatsTicketStatusPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsTicketStatusPatch: async (accountId: string, id: string, chatsTicketStatusPatchRequest?: ChatsTicketStatusPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('chatsTicketStatusPatch', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatsTicketStatusPatch', 'id', id)
            const localVarPath = `/chats/{accountId}/{id}/ticket-status`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL", "CHATS_ACCESS_ASSIGNED"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatsTicketStatusPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatsApi - functional programming interface
 * @export
 */
export const ChatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get chats
         * @param {number} [count] Number of items to return
         * @param {string} [page] 
         * @param {boolean} [archive] 
         * @param {boolean} [unread] Only get chats with unread/read messages
         * @param {boolean} [returnTotalCount] 
         * @param {boolean} [hasPendingMessage] 
         * @param {string} [mentioned] 
         * @param {boolean} [hasUnsolvedNote] 
         * @param {boolean} [hasFailedMessage] 
         * @param {'closed' | 'open'} [ticketStatus] 
         * @param {boolean} [lastMessageFromMe] Only get chats where the last message was sent by me/not me
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {ChatsGetContactsParameter} [contacts] Get these specific contact ids
         * @param {string} [q] Search items by this string
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {ContactType} [type] only get contacts of type
         * @param {ChatsGetTicketParameter} [ticket] Query the status of a ticket
         * @param {boolean} [returnUnreadChatCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsGet(count?: number, page?: string, archive?: boolean, unread?: boolean, returnTotalCount?: boolean, hasPendingMessage?: boolean, mentioned?: string, hasUnsolvedNote?: boolean, hasFailedMessage?: boolean, ticketStatus?: 'closed' | 'open', lastMessageFromMe?: boolean, tags?: ChatsGetTagsParameter, notTags?: Array<string>, contacts?: ChatsGetContactsParameter, q?: string, assignee?: ChatsGetAssigneeParameter, accountId?: Array<string>, type?: ContactType, ticket?: ChatsGetTicketParameter, returnUnreadChatCount?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsGet(count, page, archive, unread, returnTotalCount, hasPendingMessage, mentioned, hasUnsolvedNote, hasFailedMessage, ticketStatus, lastMessageFromMe, tags, notTags, contacts, q, assignee, accountId, type, ticket, returnUnreadChatCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a chat -- read, unread, archive, pin etc.
         * @param {string} accountId 
         * @param {string} id 
         * @param {ChatAction} [chatAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsPatch(accountId: string, id: string, chatAction?: ChatAction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsPatch(accountId, id, chatAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: Sending an \"available\" presence, will also subscribe you to events from the other party
         * @summary Update a chat\'s presence.
         * @param {string} accountId 
         * @param {string} id 
         * @param {PresenceType} presence 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsPresencePost(accountId: string, id: string, presence: PresenceType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsPresencePost(accountId, id, presence, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a chat\'s ticket status -- closed | null\'
         * @param {string} accountId 
         * @param {string} id 
         * @param {ChatsTicketStatusPatchRequest} [chatsTicketStatusPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatsTicketStatusPatch(accountId: string, id: string, chatsTicketStatusPatchRequest?: ChatsTicketStatusPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatsTicketStatusPatch(accountId, id, chatsTicketStatusPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChatsApi - factory interface
 * @export
 */
export const ChatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get chats
         * @param {ChatsApiChatsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsGet(requestParameters: ChatsApiChatsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ChatsGet200Response> {
            return localVarFp.chatsGet(requestParameters.count, requestParameters.page, requestParameters.archive, requestParameters.unread, requestParameters.returnTotalCount, requestParameters.hasPendingMessage, requestParameters.mentioned, requestParameters.hasUnsolvedNote, requestParameters.hasFailedMessage, requestParameters.ticketStatus, requestParameters.lastMessageFromMe, requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.q, requestParameters.assignee, requestParameters.accountId, requestParameters.type, requestParameters.ticket, requestParameters.returnUnreadChatCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a chat -- read, unread, archive, pin etc.
         * @param {ChatsApiChatsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPatch(requestParameters: ChatsApiChatsPatchRequest, options?: AxiosRequestConfig): AxiosPromise<Chat> {
            return localVarFp.chatsPatch(requestParameters.accountId, requestParameters.id, requestParameters.chatAction, options).then((request) => request(axios, basePath));
        },
        /**
         * Note: Sending an \"available\" presence, will also subscribe you to events from the other party
         * @summary Update a chat\'s presence.
         * @param {ChatsApiChatsPresencePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsPresencePost(requestParameters: ChatsApiChatsPresencePostRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.chatsPresencePost(requestParameters.accountId, requestParameters.id, requestParameters.presence, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a chat\'s ticket status -- closed | null\'
         * @param {ChatsApiChatsTicketStatusPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatsTicketStatusPatch(requestParameters: ChatsApiChatsTicketStatusPatchRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.chatsTicketStatusPatch(requestParameters.accountId, requestParameters.id, requestParameters.chatsTicketStatusPatchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for chatsGet operation in ChatsApi.
 * @export
 * @interface ChatsApiChatsGetRequest
 */
export interface ChatsApiChatsGetRequest {
    /**
     * Number of items to return
     * @type {number}
     * @memberof ChatsApiChatsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsGet
     */
    readonly page?: string

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly archive?: boolean

    /**
     * Only get chats with unread/read messages
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly unread?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly returnTotalCount?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly hasPendingMessage?: boolean

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsGet
     */
    readonly mentioned?: string

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly hasUnsolvedNote?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly hasFailedMessage?: boolean

    /**
     * 
     * @type {'closed' | 'open'}
     * @memberof ChatsApiChatsGet
     */
    readonly ticketStatus?: 'closed' | 'open'

    /**
     * Only get chats where the last message was sent by me/not me
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly lastMessageFromMe?: boolean

    /**
     * Get contacts who fall in either of these tags
     * @type {ChatsGetTagsParameter}
     * @memberof ChatsApiChatsGet
     */
    readonly tags?: ChatsGetTagsParameter

    /**
     * Get contacts who are not in any of these tags
     * @type {Array<string>}
     * @memberof ChatsApiChatsGet
     */
    readonly notTags?: Array<string>

    /**
     * Get these specific contact ids
     * @type {ChatsGetContactsParameter}
     * @memberof ChatsApiChatsGet
     */
    readonly contacts?: ChatsGetContactsParameter

    /**
     * Search items by this string
     * @type {string}
     * @memberof ChatsApiChatsGet
     */
    readonly q?: string

    /**
     * Get contacts assigned to the specified users
     * @type {ChatsGetAssigneeParameter}
     * @memberof ChatsApiChatsGet
     */
    readonly assignee?: ChatsGetAssigneeParameter

    /**
     * Get contacts only belonging to this account
     * @type {Array<string>}
     * @memberof ChatsApiChatsGet
     */
    readonly accountId?: Array<string>

    /**
     * only get contacts of type
     * @type {ContactType}
     * @memberof ChatsApiChatsGet
     */
    readonly type?: ContactType

    /**
     * Query the status of a ticket
     * @type {ChatsGetTicketParameter}
     * @memberof ChatsApiChatsGet
     */
    readonly ticket?: ChatsGetTicketParameter

    /**
     * 
     * @type {boolean}
     * @memberof ChatsApiChatsGet
     */
    readonly returnUnreadChatCount?: boolean
}

/**
 * Request parameters for chatsPatch operation in ChatsApi.
 * @export
 * @interface ChatsApiChatsPatchRequest
 */
export interface ChatsApiChatsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsPatch
     */
    readonly id: string

    /**
     * 
     * @type {ChatAction}
     * @memberof ChatsApiChatsPatch
     */
    readonly chatAction?: ChatAction
}

/**
 * Request parameters for chatsPresencePost operation in ChatsApi.
 * @export
 * @interface ChatsApiChatsPresencePostRequest
 */
export interface ChatsApiChatsPresencePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsPresencePost
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsPresencePost
     */
    readonly id: string

    /**
     * 
     * @type {PresenceType}
     * @memberof ChatsApiChatsPresencePost
     */
    readonly presence: PresenceType
}

/**
 * Request parameters for chatsTicketStatusPatch operation in ChatsApi.
 * @export
 * @interface ChatsApiChatsTicketStatusPatchRequest
 */
export interface ChatsApiChatsTicketStatusPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsTicketStatusPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof ChatsApiChatsTicketStatusPatch
     */
    readonly id: string

    /**
     * 
     * @type {ChatsTicketStatusPatchRequest}
     * @memberof ChatsApiChatsTicketStatusPatch
     */
    readonly chatsTicketStatusPatchRequest?: ChatsTicketStatusPatchRequest
}

/**
 * ChatsApi - object-oriented interface
 * @export
 * @class ChatsApi
 * @extends {BaseAPI}
 */
export class ChatsApi extends BaseAPI {
    /**
     * 
     * @summary Get chats
     * @param {ChatsApiChatsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatsGet(requestParameters: ChatsApiChatsGetRequest = {}, options?: AxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatsGet(requestParameters.count, requestParameters.page, requestParameters.archive, requestParameters.unread, requestParameters.returnTotalCount, requestParameters.hasPendingMessage, requestParameters.mentioned, requestParameters.hasUnsolvedNote, requestParameters.hasFailedMessage, requestParameters.ticketStatus, requestParameters.lastMessageFromMe, requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.q, requestParameters.assignee, requestParameters.accountId, requestParameters.type, requestParameters.ticket, requestParameters.returnUnreadChatCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a chat -- read, unread, archive, pin etc.
     * @param {ChatsApiChatsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatsPatch(requestParameters: ChatsApiChatsPatchRequest, options?: AxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatsPatch(requestParameters.accountId, requestParameters.id, requestParameters.chatAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: Sending an \"available\" presence, will also subscribe you to events from the other party
     * @summary Update a chat\'s presence.
     * @param {ChatsApiChatsPresencePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatsPresencePost(requestParameters: ChatsApiChatsPresencePostRequest, options?: AxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatsPresencePost(requestParameters.accountId, requestParameters.id, requestParameters.presence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a chat\'s ticket status -- closed | null\'
     * @param {ChatsApiChatsTicketStatusPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatsApi
     */
    public chatsTicketStatusPatch(requestParameters: ChatsApiChatsTicketStatusPatchRequest, options?: AxiosRequestConfig) {
        return ChatsApiFp(this.configuration).chatsTicketStatusPatch(requestParameters.accountId, requestParameters.id, requestParameters.chatsTicketStatusPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContactsApi - axios parameter creator
 * @export
 */
export const ContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Eg. provide a phone number to check whether the user is registered on WhatsApp
         * @summary Check a given user exists on the IM platform
         * @param {'whatsapp' | 'tiktok'} type which account type to check from
         * @param {string} [phoneNumber] Phone number to check
         * @param {string} [username] Username to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsCheckExists: async (type: 'whatsapp' | 'tiktok', phoneNumber?: string, username?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('contactsCheckExists', 'type', type)
            const localVarPath = `/contacts/exists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_READ_ALL"], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (phoneNumber !== undefined) {
                localVarQueryParameter['phoneNumber'] = phoneNumber;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete contacts
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {ChatsGetContactsParameter} [contacts] Get these specific contact ids
         * @param {ChatsGetContactsParameter} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search items by this string
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [notAssignee] Exclude contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {ContactType} [type] only get contacts of type
         * @param {string} [chatLastMessageFrom] 
         * @param {string} [chatLastMessageTo] 
         * @param {boolean} [lastMessageFromMe] Only get chats where the last message was sent by me/not me
         * @param {boolean} [unread] Only get chats with unread/read messages
         * @param {ChatsGetTicketParameter} [ticket] Query the status of a ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDelete: async (tags?: ChatsGetTagsParameter, notTags?: Array<string>, contacts?: ChatsGetContactsParameter, notContacts?: ChatsGetContactsParameter, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: ChatsGetAssigneeParameter, notAssignee?: Array<string>, accountId?: Array<string>, type?: ContactType, chatLastMessageFrom?: string, chatLastMessageTo?: string, lastMessageFromMe?: boolean, unread?: boolean, ticket?: ChatsGetTicketParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_DELETE"], configuration)

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (notTags) {
                localVarQueryParameter['notTags'] = notTags;
            }

            if (contacts !== undefined) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (notContacts !== undefined) {
                localVarQueryParameter['notContacts'] = notContacts;
            }

            if (minMessagesSent !== undefined) {
                localVarQueryParameter['minMessagesSent'] = minMessagesSent;
            }

            if (minMessagesRecv !== undefined) {
                localVarQueryParameter['minMessagesRecv'] = minMessagesRecv;
            }

            if (maxMessagesSent !== undefined) {
                localVarQueryParameter['maxMessagesSent'] = maxMessagesSent;
            }

            if (maxMessagesRecv !== undefined) {
                localVarQueryParameter['maxMessagesRecv'] = maxMessagesRecv;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (notAssignee) {
                localVarQueryParameter['notAssignee'] = notAssignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (chatLastMessageFrom !== undefined) {
                localVarQueryParameter['chatLastMessageFrom'] = (chatLastMessageFrom as any instanceof Date) ?
                    (chatLastMessageFrom as any).toISOString() :
                    chatLastMessageFrom;
            }

            if (chatLastMessageTo !== undefined) {
                localVarQueryParameter['chatLastMessageTo'] = (chatLastMessageTo as any instanceof Date) ?
                    (chatLastMessageTo as any).toISOString() :
                    chatLastMessageTo;
            }

            if (lastMessageFromMe !== undefined) {
                localVarQueryParameter['lastMessageFromMe'] = lastMessageFromMe;
            }

            if (unread !== undefined) {
                localVarQueryParameter['unread'] = unread;
            }

            if (ticket !== undefined) {
                localVarQueryParameter['ticket'] = ticket;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get contacts
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {ChatsGetContactsParameter} [contacts] Get these specific contact ids
         * @param {ChatsGetContactsParameter} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search items by this string
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [notAssignee] Exclude contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {ContactType} [type] only get contacts of type
         * @param {string} [chatLastMessageFrom] 
         * @param {string} [chatLastMessageTo] 
         * @param {boolean} [lastMessageFromMe] Only get chats where the last message was sent by me/not me
         * @param {boolean} [unread] Only get chats with unread/read messages
         * @param {ChatsGetTicketParameter} [ticket] Query the status of a ticket
         * @param {boolean} [orderByTicketOrder] 
         * @param {boolean} [returnTotalCount] 
         * @param {boolean} [returnLastMessage] 
         * @param {string} [page] 
         * @param {number} [count] Number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGet: async (tags?: ChatsGetTagsParameter, notTags?: Array<string>, contacts?: ChatsGetContactsParameter, notContacts?: ChatsGetContactsParameter, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: ChatsGetAssigneeParameter, notAssignee?: Array<string>, accountId?: Array<string>, type?: ContactType, chatLastMessageFrom?: string, chatLastMessageTo?: string, lastMessageFromMe?: boolean, unread?: boolean, ticket?: ChatsGetTicketParameter, orderByTicketOrder?: boolean, returnTotalCount?: boolean, returnLastMessage?: boolean, page?: string, count?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_READ_ALL", "CONTACTS_READ_ASSIGNED"], configuration)

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (notTags) {
                localVarQueryParameter['notTags'] = notTags;
            }

            if (contacts !== undefined) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (notContacts !== undefined) {
                localVarQueryParameter['notContacts'] = notContacts;
            }

            if (minMessagesSent !== undefined) {
                localVarQueryParameter['minMessagesSent'] = minMessagesSent;
            }

            if (minMessagesRecv !== undefined) {
                localVarQueryParameter['minMessagesRecv'] = minMessagesRecv;
            }

            if (maxMessagesSent !== undefined) {
                localVarQueryParameter['maxMessagesSent'] = maxMessagesSent;
            }

            if (maxMessagesRecv !== undefined) {
                localVarQueryParameter['maxMessagesRecv'] = maxMessagesRecv;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (notAssignee) {
                localVarQueryParameter['notAssignee'] = notAssignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (chatLastMessageFrom !== undefined) {
                localVarQueryParameter['chatLastMessageFrom'] = (chatLastMessageFrom as any instanceof Date) ?
                    (chatLastMessageFrom as any).toISOString() :
                    chatLastMessageFrom;
            }

            if (chatLastMessageTo !== undefined) {
                localVarQueryParameter['chatLastMessageTo'] = (chatLastMessageTo as any instanceof Date) ?
                    (chatLastMessageTo as any).toISOString() :
                    chatLastMessageTo;
            }

            if (lastMessageFromMe !== undefined) {
                localVarQueryParameter['lastMessageFromMe'] = lastMessageFromMe;
            }

            if (unread !== undefined) {
                localVarQueryParameter['unread'] = unread;
            }

            if (ticket !== undefined) {
                localVarQueryParameter['ticket'] = ticket;
            }

            if (orderByTicketOrder !== undefined) {
                localVarQueryParameter['orderByTicketOrder'] = orderByTicketOrder;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }

            if (returnLastMessage !== undefined) {
                localVarQueryParameter['returnLastMessage'] = returnLastMessage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the display image of a contact
         * @param {string} id 
         * @param {string} accountId 
         * @param {'preview' | 'full'} [type] Whether to fetch preview sized image or the full image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsImageGet: async (id: string, accountId: string, type?: 'preview' | 'full', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contactsImageGet', 'id', id)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('contactsImageGet', 'accountId', accountId)
            const localVarPath = `/contacts/{accountId}/{id}/image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update contacts
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {ChatsGetContactsParameter} [contacts] Get these specific contact ids
         * @param {ChatsGetContactsParameter} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search items by this string
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [notAssignee] Exclude contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {ContactType} [type] only get contacts of type
         * @param {string} [chatLastMessageFrom] 
         * @param {string} [chatLastMessageTo] 
         * @param {boolean} [lastMessageFromMe] Only get chats where the last message was sent by me/not me
         * @param {boolean} [unread] Only get chats with unread/read messages
         * @param {ChatsGetTicketParameter} [ticket] Query the status of a ticket
         * @param {ContactsPatch} [contactsPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPatch: async (tags?: ChatsGetTagsParameter, notTags?: Array<string>, contacts?: ChatsGetContactsParameter, notContacts?: ChatsGetContactsParameter, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: ChatsGetAssigneeParameter, notAssignee?: Array<string>, accountId?: Array<string>, type?: ContactType, chatLastMessageFrom?: string, chatLastMessageTo?: string, lastMessageFromMe?: boolean, unread?: boolean, ticket?: ChatsGetTicketParameter, contactsPatch?: ContactsPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_UPDATE"], configuration)

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (notTags) {
                localVarQueryParameter['notTags'] = notTags;
            }

            if (contacts !== undefined) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (notContacts !== undefined) {
                localVarQueryParameter['notContacts'] = notContacts;
            }

            if (minMessagesSent !== undefined) {
                localVarQueryParameter['minMessagesSent'] = minMessagesSent;
            }

            if (minMessagesRecv !== undefined) {
                localVarQueryParameter['minMessagesRecv'] = minMessagesRecv;
            }

            if (maxMessagesSent !== undefined) {
                localVarQueryParameter['maxMessagesSent'] = maxMessagesSent;
            }

            if (maxMessagesRecv !== undefined) {
                localVarQueryParameter['maxMessagesRecv'] = maxMessagesRecv;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (notAssignee) {
                localVarQueryParameter['notAssignee'] = notAssignee;
            }

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (chatLastMessageFrom !== undefined) {
                localVarQueryParameter['chatLastMessageFrom'] = (chatLastMessageFrom as any instanceof Date) ?
                    (chatLastMessageFrom as any).toISOString() :
                    chatLastMessageFrom;
            }

            if (chatLastMessageTo !== undefined) {
                localVarQueryParameter['chatLastMessageTo'] = (chatLastMessageTo as any instanceof Date) ?
                    (chatLastMessageTo as any).toISOString() :
                    chatLastMessageTo;
            }

            if (lastMessageFromMe !== undefined) {
                localVarQueryParameter['lastMessageFromMe'] = lastMessageFromMe;
            }

            if (unread !== undefined) {
                localVarQueryParameter['unread'] = unread;
            }

            if (ticket !== undefined) {
                localVarQueryParameter['ticket'] = ticket;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactsPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create contacts
         * @param {ContactsPost} [contactsPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPost: async (contactsPost?: ContactsPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts/upsert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CONTACTS_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactsPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsApi - functional programming interface
 * @export
 */
export const ContactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactsApiAxiosParamCreator(configuration)
    return {
        /**
         * Eg. provide a phone number to check whether the user is registered on WhatsApp
         * @summary Check a given user exists on the IM platform
         * @param {'whatsapp' | 'tiktok'} type which account type to check from
         * @param {string} [phoneNumber] Phone number to check
         * @param {string} [username] Username to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsCheckExists(type: 'whatsapp' | 'tiktok', phoneNumber?: string, username?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsCheckExists200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsCheckExists(type, phoneNumber, username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete contacts
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {ChatsGetContactsParameter} [contacts] Get these specific contact ids
         * @param {ChatsGetContactsParameter} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search items by this string
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [notAssignee] Exclude contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {ContactType} [type] only get contacts of type
         * @param {string} [chatLastMessageFrom] 
         * @param {string} [chatLastMessageTo] 
         * @param {boolean} [lastMessageFromMe] Only get chats where the last message was sent by me/not me
         * @param {boolean} [unread] Only get chats with unread/read messages
         * @param {ChatsGetTicketParameter} [ticket] Query the status of a ticket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsDelete(tags?: ChatsGetTagsParameter, notTags?: Array<string>, contacts?: ChatsGetContactsParameter, notContacts?: ChatsGetContactsParameter, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: ChatsGetAssigneeParameter, notAssignee?: Array<string>, accountId?: Array<string>, type?: ContactType, chatLastMessageFrom?: string, chatLastMessageTo?: string, lastMessageFromMe?: boolean, unread?: boolean, ticket?: ChatsGetTicketParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsDelete(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, notAssignee, accountId, type, chatLastMessageFrom, chatLastMessageTo, lastMessageFromMe, unread, ticket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get contacts
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {ChatsGetContactsParameter} [contacts] Get these specific contact ids
         * @param {ChatsGetContactsParameter} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search items by this string
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [notAssignee] Exclude contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {ContactType} [type] only get contacts of type
         * @param {string} [chatLastMessageFrom] 
         * @param {string} [chatLastMessageTo] 
         * @param {boolean} [lastMessageFromMe] Only get chats where the last message was sent by me/not me
         * @param {boolean} [unread] Only get chats with unread/read messages
         * @param {ChatsGetTicketParameter} [ticket] Query the status of a ticket
         * @param {boolean} [orderByTicketOrder] 
         * @param {boolean} [returnTotalCount] 
         * @param {boolean} [returnLastMessage] 
         * @param {string} [page] 
         * @param {number} [count] Number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsGet(tags?: ChatsGetTagsParameter, notTags?: Array<string>, contacts?: ChatsGetContactsParameter, notContacts?: ChatsGetContactsParameter, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: ChatsGetAssigneeParameter, notAssignee?: Array<string>, accountId?: Array<string>, type?: ContactType, chatLastMessageFrom?: string, chatLastMessageTo?: string, lastMessageFromMe?: boolean, unread?: boolean, ticket?: ChatsGetTicketParameter, orderByTicketOrder?: boolean, returnTotalCount?: boolean, returnLastMessage?: boolean, page?: string, count?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsGet(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, notAssignee, accountId, type, chatLastMessageFrom, chatLastMessageTo, lastMessageFromMe, unread, ticket, orderByTicketOrder, returnTotalCount, returnLastMessage, page, count, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the display image of a contact
         * @param {string} id 
         * @param {string} accountId 
         * @param {'preview' | 'full'} [type] Whether to fetch preview sized image or the full image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsImageGet(id: string, accountId: string, type?: 'preview' | 'full', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsImageGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsImageGet(id, accountId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update contacts
         * @param {ChatsGetTagsParameter} [tags] Get contacts who fall in either of these tags
         * @param {Array<string>} [notTags] Get contacts who are not in any of these tags
         * @param {ChatsGetContactsParameter} [contacts] Get these specific contact ids
         * @param {ChatsGetContactsParameter} [notContacts] Do not get these specific contacts
         * @param {number} [minMessagesSent] Minimum messages sent
         * @param {number} [minMessagesRecv] Minimum messages received
         * @param {number} [maxMessagesSent] Maximum messages sent
         * @param {number} [maxMessagesRecv] Maximum messages received
         * @param {string} [q] Search items by this string
         * @param {ChatsGetAssigneeParameter} [assignee] Get contacts assigned to the specified users
         * @param {Array<string>} [notAssignee] Exclude contacts assigned to the specified users
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {ContactType} [type] only get contacts of type
         * @param {string} [chatLastMessageFrom] 
         * @param {string} [chatLastMessageTo] 
         * @param {boolean} [lastMessageFromMe] Only get chats where the last message was sent by me/not me
         * @param {boolean} [unread] Only get chats with unread/read messages
         * @param {ChatsGetTicketParameter} [ticket] Query the status of a ticket
         * @param {ContactsPatch} [contactsPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPatch(tags?: ChatsGetTagsParameter, notTags?: Array<string>, contacts?: ChatsGetContactsParameter, notContacts?: ChatsGetContactsParameter, minMessagesSent?: number, minMessagesRecv?: number, maxMessagesSent?: number, maxMessagesRecv?: number, q?: string, assignee?: ChatsGetAssigneeParameter, notAssignee?: Array<string>, accountId?: Array<string>, type?: ContactType, chatLastMessageFrom?: string, chatLastMessageTo?: string, lastMessageFromMe?: boolean, unread?: boolean, ticket?: ChatsGetTicketParameter, contactsPatch?: ContactsPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPatch(tags, notTags, contacts, notContacts, minMessagesSent, minMessagesRecv, maxMessagesSent, maxMessagesRecv, q, assignee, notAssignee, accountId, type, chatLastMessageFrom, chatLastMessageTo, lastMessageFromMe, unread, ticket, contactsPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create contacts
         * @param {ContactsPost} [contactsPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPost(contactsPost?: ContactsPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPost(contactsPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContactsApi - factory interface
 * @export
 */
export const ContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactsApiFp(configuration)
    return {
        /**
         * Eg. provide a phone number to check whether the user is registered on WhatsApp
         * @summary Check a given user exists on the IM platform
         * @param {ContactsApiContactsCheckExistsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsCheckExists(requestParameters: ContactsApiContactsCheckExistsRequest, options?: AxiosRequestConfig): AxiosPromise<ContactsCheckExists200Response> {
            return localVarFp.contactsCheckExists(requestParameters.type, requestParameters.phoneNumber, requestParameters.username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete contacts
         * @param {ContactsApiContactsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDelete(requestParameters: ContactsApiContactsDeleteRequest = {}, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.contactsDelete(requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.notContacts, requestParameters.minMessagesSent, requestParameters.minMessagesRecv, requestParameters.maxMessagesSent, requestParameters.maxMessagesRecv, requestParameters.q, requestParameters.assignee, requestParameters.notAssignee, requestParameters.accountId, requestParameters.type, requestParameters.chatLastMessageFrom, requestParameters.chatLastMessageTo, requestParameters.lastMessageFromMe, requestParameters.unread, requestParameters.ticket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get contacts
         * @param {ContactsApiContactsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGet(requestParameters: ContactsApiContactsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ContactsGet200Response> {
            return localVarFp.contactsGet(requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.notContacts, requestParameters.minMessagesSent, requestParameters.minMessagesRecv, requestParameters.maxMessagesSent, requestParameters.maxMessagesRecv, requestParameters.q, requestParameters.assignee, requestParameters.notAssignee, requestParameters.accountId, requestParameters.type, requestParameters.chatLastMessageFrom, requestParameters.chatLastMessageTo, requestParameters.lastMessageFromMe, requestParameters.unread, requestParameters.ticket, requestParameters.orderByTicketOrder, requestParameters.returnTotalCount, requestParameters.returnLastMessage, requestParameters.page, requestParameters.count, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the display image of a contact
         * @param {ContactsApiContactsImageGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsImageGet(requestParameters: ContactsApiContactsImageGetRequest, options?: AxiosRequestConfig): AxiosPromise<ContactsImageGet200Response> {
            return localVarFp.contactsImageGet(requestParameters.id, requestParameters.accountId, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update contacts
         * @param {ContactsApiContactsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPatch(requestParameters: ContactsApiContactsPatchRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ContactsPatch200Response> {
            return localVarFp.contactsPatch(requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.notContacts, requestParameters.minMessagesSent, requestParameters.minMessagesRecv, requestParameters.maxMessagesSent, requestParameters.maxMessagesRecv, requestParameters.q, requestParameters.assignee, requestParameters.notAssignee, requestParameters.accountId, requestParameters.type, requestParameters.chatLastMessageFrom, requestParameters.chatLastMessageTo, requestParameters.lastMessageFromMe, requestParameters.unread, requestParameters.ticket, requestParameters.contactsPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create contacts
         * @param {ContactsApiContactsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPost(requestParameters: ContactsApiContactsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.contactsPost(requestParameters.contactsPost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for contactsCheckExists operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsCheckExistsRequest
 */
export interface ContactsApiContactsCheckExistsRequest {
    /**
     * which account type to check from
     * @type {'whatsapp' | 'tiktok'}
     * @memberof ContactsApiContactsCheckExists
     */
    readonly type: 'whatsapp' | 'tiktok'

    /**
     * Phone number to check
     * @type {string}
     * @memberof ContactsApiContactsCheckExists
     */
    readonly phoneNumber?: string

    /**
     * Username to check
     * @type {string}
     * @memberof ContactsApiContactsCheckExists
     */
    readonly username?: string
}

/**
 * Request parameters for contactsDelete operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsDeleteRequest
 */
export interface ContactsApiContactsDeleteRequest {
    /**
     * Get contacts who fall in either of these tags
     * @type {ChatsGetTagsParameter}
     * @memberof ContactsApiContactsDelete
     */
    readonly tags?: ChatsGetTagsParameter

    /**
     * Get contacts who are not in any of these tags
     * @type {Array<string>}
     * @memberof ContactsApiContactsDelete
     */
    readonly notTags?: Array<string>

    /**
     * Get these specific contact ids
     * @type {ChatsGetContactsParameter}
     * @memberof ContactsApiContactsDelete
     */
    readonly contacts?: ChatsGetContactsParameter

    /**
     * Do not get these specific contacts
     * @type {ChatsGetContactsParameter}
     * @memberof ContactsApiContactsDelete
     */
    readonly notContacts?: ChatsGetContactsParameter

    /**
     * Minimum messages sent
     * @type {number}
     * @memberof ContactsApiContactsDelete
     */
    readonly minMessagesSent?: number

    /**
     * Minimum messages received
     * @type {number}
     * @memberof ContactsApiContactsDelete
     */
    readonly minMessagesRecv?: number

    /**
     * Maximum messages sent
     * @type {number}
     * @memberof ContactsApiContactsDelete
     */
    readonly maxMessagesSent?: number

    /**
     * Maximum messages received
     * @type {number}
     * @memberof ContactsApiContactsDelete
     */
    readonly maxMessagesRecv?: number

    /**
     * Search items by this string
     * @type {string}
     * @memberof ContactsApiContactsDelete
     */
    readonly q?: string

    /**
     * Get contacts assigned to the specified users
     * @type {ChatsGetAssigneeParameter}
     * @memberof ContactsApiContactsDelete
     */
    readonly assignee?: ChatsGetAssigneeParameter

    /**
     * Exclude contacts assigned to the specified users
     * @type {Array<string>}
     * @memberof ContactsApiContactsDelete
     */
    readonly notAssignee?: Array<string>

    /**
     * Get contacts only belonging to this account
     * @type {Array<string>}
     * @memberof ContactsApiContactsDelete
     */
    readonly accountId?: Array<string>

    /**
     * only get contacts of type
     * @type {ContactType}
     * @memberof ContactsApiContactsDelete
     */
    readonly type?: ContactType

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsDelete
     */
    readonly chatLastMessageFrom?: string

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsDelete
     */
    readonly chatLastMessageTo?: string

    /**
     * Only get chats where the last message was sent by me/not me
     * @type {boolean}
     * @memberof ContactsApiContactsDelete
     */
    readonly lastMessageFromMe?: boolean

    /**
     * Only get chats with unread/read messages
     * @type {boolean}
     * @memberof ContactsApiContactsDelete
     */
    readonly unread?: boolean

    /**
     * Query the status of a ticket
     * @type {ChatsGetTicketParameter}
     * @memberof ContactsApiContactsDelete
     */
    readonly ticket?: ChatsGetTicketParameter
}

/**
 * Request parameters for contactsGet operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsGetRequest
 */
export interface ContactsApiContactsGetRequest {
    /**
     * Get contacts who fall in either of these tags
     * @type {ChatsGetTagsParameter}
     * @memberof ContactsApiContactsGet
     */
    readonly tags?: ChatsGetTagsParameter

    /**
     * Get contacts who are not in any of these tags
     * @type {Array<string>}
     * @memberof ContactsApiContactsGet
     */
    readonly notTags?: Array<string>

    /**
     * Get these specific contact ids
     * @type {ChatsGetContactsParameter}
     * @memberof ContactsApiContactsGet
     */
    readonly contacts?: ChatsGetContactsParameter

    /**
     * Do not get these specific contacts
     * @type {ChatsGetContactsParameter}
     * @memberof ContactsApiContactsGet
     */
    readonly notContacts?: ChatsGetContactsParameter

    /**
     * Minimum messages sent
     * @type {number}
     * @memberof ContactsApiContactsGet
     */
    readonly minMessagesSent?: number

    /**
     * Minimum messages received
     * @type {number}
     * @memberof ContactsApiContactsGet
     */
    readonly minMessagesRecv?: number

    /**
     * Maximum messages sent
     * @type {number}
     * @memberof ContactsApiContactsGet
     */
    readonly maxMessagesSent?: number

    /**
     * Maximum messages received
     * @type {number}
     * @memberof ContactsApiContactsGet
     */
    readonly maxMessagesRecv?: number

    /**
     * Search items by this string
     * @type {string}
     * @memberof ContactsApiContactsGet
     */
    readonly q?: string

    /**
     * Get contacts assigned to the specified users
     * @type {ChatsGetAssigneeParameter}
     * @memberof ContactsApiContactsGet
     */
    readonly assignee?: ChatsGetAssigneeParameter

    /**
     * Exclude contacts assigned to the specified users
     * @type {Array<string>}
     * @memberof ContactsApiContactsGet
     */
    readonly notAssignee?: Array<string>

    /**
     * Get contacts only belonging to this account
     * @type {Array<string>}
     * @memberof ContactsApiContactsGet
     */
    readonly accountId?: Array<string>

    /**
     * only get contacts of type
     * @type {ContactType}
     * @memberof ContactsApiContactsGet
     */
    readonly type?: ContactType

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsGet
     */
    readonly chatLastMessageFrom?: string

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsGet
     */
    readonly chatLastMessageTo?: string

    /**
     * Only get chats where the last message was sent by me/not me
     * @type {boolean}
     * @memberof ContactsApiContactsGet
     */
    readonly lastMessageFromMe?: boolean

    /**
     * Only get chats with unread/read messages
     * @type {boolean}
     * @memberof ContactsApiContactsGet
     */
    readonly unread?: boolean

    /**
     * Query the status of a ticket
     * @type {ChatsGetTicketParameter}
     * @memberof ContactsApiContactsGet
     */
    readonly ticket?: ChatsGetTicketParameter

    /**
     * 
     * @type {boolean}
     * @memberof ContactsApiContactsGet
     */
    readonly orderByTicketOrder?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ContactsApiContactsGet
     */
    readonly returnTotalCount?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ContactsApiContactsGet
     */
    readonly returnLastMessage?: boolean

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsGet
     */
    readonly page?: string

    /**
     * Number of items to return
     * @type {number}
     * @memberof ContactsApiContactsGet
     */
    readonly count?: number
}

/**
 * Request parameters for contactsImageGet operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsImageGetRequest
 */
export interface ContactsApiContactsImageGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsImageGet
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsImageGet
     */
    readonly accountId: string

    /**
     * Whether to fetch preview sized image or the full image
     * @type {'preview' | 'full'}
     * @memberof ContactsApiContactsImageGet
     */
    readonly type?: 'preview' | 'full'
}

/**
 * Request parameters for contactsPatch operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsPatchRequest
 */
export interface ContactsApiContactsPatchRequest {
    /**
     * Get contacts who fall in either of these tags
     * @type {ChatsGetTagsParameter}
     * @memberof ContactsApiContactsPatch
     */
    readonly tags?: ChatsGetTagsParameter

    /**
     * Get contacts who are not in any of these tags
     * @type {Array<string>}
     * @memberof ContactsApiContactsPatch
     */
    readonly notTags?: Array<string>

    /**
     * Get these specific contact ids
     * @type {ChatsGetContactsParameter}
     * @memberof ContactsApiContactsPatch
     */
    readonly contacts?: ChatsGetContactsParameter

    /**
     * Do not get these specific contacts
     * @type {ChatsGetContactsParameter}
     * @memberof ContactsApiContactsPatch
     */
    readonly notContacts?: ChatsGetContactsParameter

    /**
     * Minimum messages sent
     * @type {number}
     * @memberof ContactsApiContactsPatch
     */
    readonly minMessagesSent?: number

    /**
     * Minimum messages received
     * @type {number}
     * @memberof ContactsApiContactsPatch
     */
    readonly minMessagesRecv?: number

    /**
     * Maximum messages sent
     * @type {number}
     * @memberof ContactsApiContactsPatch
     */
    readonly maxMessagesSent?: number

    /**
     * Maximum messages received
     * @type {number}
     * @memberof ContactsApiContactsPatch
     */
    readonly maxMessagesRecv?: number

    /**
     * Search items by this string
     * @type {string}
     * @memberof ContactsApiContactsPatch
     */
    readonly q?: string

    /**
     * Get contacts assigned to the specified users
     * @type {ChatsGetAssigneeParameter}
     * @memberof ContactsApiContactsPatch
     */
    readonly assignee?: ChatsGetAssigneeParameter

    /**
     * Exclude contacts assigned to the specified users
     * @type {Array<string>}
     * @memberof ContactsApiContactsPatch
     */
    readonly notAssignee?: Array<string>

    /**
     * Get contacts only belonging to this account
     * @type {Array<string>}
     * @memberof ContactsApiContactsPatch
     */
    readonly accountId?: Array<string>

    /**
     * only get contacts of type
     * @type {ContactType}
     * @memberof ContactsApiContactsPatch
     */
    readonly type?: ContactType

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsPatch
     */
    readonly chatLastMessageFrom?: string

    /**
     * 
     * @type {string}
     * @memberof ContactsApiContactsPatch
     */
    readonly chatLastMessageTo?: string

    /**
     * Only get chats where the last message was sent by me/not me
     * @type {boolean}
     * @memberof ContactsApiContactsPatch
     */
    readonly lastMessageFromMe?: boolean

    /**
     * Only get chats with unread/read messages
     * @type {boolean}
     * @memberof ContactsApiContactsPatch
     */
    readonly unread?: boolean

    /**
     * Query the status of a ticket
     * @type {ChatsGetTicketParameter}
     * @memberof ContactsApiContactsPatch
     */
    readonly ticket?: ChatsGetTicketParameter

    /**
     * 
     * @type {ContactsPatch}
     * @memberof ContactsApiContactsPatch
     */
    readonly contactsPatch?: ContactsPatch
}

/**
 * Request parameters for contactsPost operation in ContactsApi.
 * @export
 * @interface ContactsApiContactsPostRequest
 */
export interface ContactsApiContactsPostRequest {
    /**
     * 
     * @type {ContactsPost}
     * @memberof ContactsApiContactsPost
     */
    readonly contactsPost?: ContactsPost
}

/**
 * ContactsApi - object-oriented interface
 * @export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
export class ContactsApi extends BaseAPI {
    /**
     * Eg. provide a phone number to check whether the user is registered on WhatsApp
     * @summary Check a given user exists on the IM platform
     * @param {ContactsApiContactsCheckExistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsCheckExists(requestParameters: ContactsApiContactsCheckExistsRequest, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsCheckExists(requestParameters.type, requestParameters.phoneNumber, requestParameters.username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete contacts
     * @param {ContactsApiContactsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsDelete(requestParameters: ContactsApiContactsDeleteRequest = {}, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsDelete(requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.notContacts, requestParameters.minMessagesSent, requestParameters.minMessagesRecv, requestParameters.maxMessagesSent, requestParameters.maxMessagesRecv, requestParameters.q, requestParameters.assignee, requestParameters.notAssignee, requestParameters.accountId, requestParameters.type, requestParameters.chatLastMessageFrom, requestParameters.chatLastMessageTo, requestParameters.lastMessageFromMe, requestParameters.unread, requestParameters.ticket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get contacts
     * @param {ContactsApiContactsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsGet(requestParameters: ContactsApiContactsGetRequest = {}, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsGet(requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.notContacts, requestParameters.minMessagesSent, requestParameters.minMessagesRecv, requestParameters.maxMessagesSent, requestParameters.maxMessagesRecv, requestParameters.q, requestParameters.assignee, requestParameters.notAssignee, requestParameters.accountId, requestParameters.type, requestParameters.chatLastMessageFrom, requestParameters.chatLastMessageTo, requestParameters.lastMessageFromMe, requestParameters.unread, requestParameters.ticket, requestParameters.orderByTicketOrder, requestParameters.returnTotalCount, requestParameters.returnLastMessage, requestParameters.page, requestParameters.count, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the display image of a contact
     * @param {ContactsApiContactsImageGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsImageGet(requestParameters: ContactsApiContactsImageGetRequest, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsImageGet(requestParameters.id, requestParameters.accountId, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update contacts
     * @param {ContactsApiContactsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsPatch(requestParameters: ContactsApiContactsPatchRequest = {}, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsPatch(requestParameters.tags, requestParameters.notTags, requestParameters.contacts, requestParameters.notContacts, requestParameters.minMessagesSent, requestParameters.minMessagesRecv, requestParameters.maxMessagesSent, requestParameters.maxMessagesRecv, requestParameters.q, requestParameters.assignee, requestParameters.notAssignee, requestParameters.accountId, requestParameters.type, requestParameters.chatLastMessageFrom, requestParameters.chatLastMessageTo, requestParameters.lastMessageFromMe, requestParameters.unread, requestParameters.ticket, requestParameters.contactsPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create contacts
     * @param {ContactsApiContactsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsPost(requestParameters: ContactsApiContactsPostRequest = {}, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).contactsPost(requestParameters.contactsPost, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload a file to the media files bucket
         * @param {string} mimetype 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPost: async (mimetype: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mimetype' is not null or undefined
            assertParamExists('filesPost', 'mimetype', mimetype)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('filesPost', 'name', name)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (mimetype !== undefined) {
                localVarQueryParameter['mimetype'] = mimetype;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upload a file to the media files bucket
         * @param {string} mimetype 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesPost(mimetype: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesPost(mimetype, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @summary Upload a file to the media files bucket
         * @param {FilesApiFilesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPost(requestParameters: FilesApiFilesPostRequest, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.filesPost(requestParameters.mimetype, requestParameters.name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for filesPost operation in FilesApi.
 * @export
 * @interface FilesApiFilesPostRequest
 */
export interface FilesApiFilesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof FilesApiFilesPost
     */
    readonly mimetype: string

    /**
     * 
     * @type {string}
     * @memberof FilesApiFilesPost
     */
    readonly name: string
}

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @summary Upload a file to the media files bucket
     * @param {FilesApiFilesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesPost(requestParameters: FilesApiFilesPostRequest, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesPost(requestParameters.mimetype, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get metadata for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {boolean} [forceRefresh] Fetches the group metadata again from the platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGet: async (accountId: string, id: string, forceRefresh?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsGet', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsGet', 'id', id)
            const localVarPath = `/groups/{accountId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL", "CHATS_ACCESS_ASSIGNED"], configuration)

            if (forceRefresh !== undefined) {
                localVarQueryParameter['forceRefresh'] = forceRefresh;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get invite code for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsInviteCode: async (accountId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsInviteCode', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsInviteCode', 'id', id)
            const localVarPath = `/groups/{accountId}/{id}/invite-code`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CHATS_ACCESS_ALL", "CHATS_ACCESS_ASSIGNED"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join a group using invite code
         * @param {string} accountId 
         * @param {string} id 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsJoin: async (accountId: string, id: string, code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsJoin', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsJoin', 'id', id)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('groupsJoin', 'code', code)
            const localVarPath = `/groups/{accountId}/{id}/join`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["GROUPS_UPDATE"], configuration)

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leave a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsLeave: async (accountId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsLeave', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsLeave', 'id', id)
            const localVarPath = `/groups/{accountId}/{id}/leave`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["GROUPS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {GroupAction} [groupAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPatch: async (accountId: string, id: string, groupAction?: GroupAction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsPatch', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('groupsPatch', 'id', id)
            const localVarPath = `/groups/{accountId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["GROUPS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new group
         * @param {string} accountId 
         * @param {GroupCreate} [groupCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPost: async (accountId: string, groupCreate?: GroupCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('groupsPost', 'accountId', accountId)
            const localVarPath = `/groups/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["GROUPS_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get metadata for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {boolean} [forceRefresh] Fetches the group metadata again from the platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsGet(accountId: string, id: string, forceRefresh?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsGet(accountId, id, forceRefresh, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get invite code for a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsInviteCode(accountId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupsInviteCode200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsInviteCode(accountId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Join a group using invite code
         * @param {string} accountId 
         * @param {string} id 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsJoin(accountId: string, id: string, code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsJoin(accountId, id, code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Leave a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsLeave(accountId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsLeave(accountId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a group
         * @param {string} accountId 
         * @param {string} id 
         * @param {GroupAction} [groupAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsPatch(accountId: string, id: string, groupAction?: GroupAction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsPatch(accountId, id, groupAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new group
         * @param {string} accountId 
         * @param {GroupCreate} [groupCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsPost(accountId: string, groupCreate?: GroupCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsPost(accountId, groupCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get metadata for a group
         * @param {GroupsApiGroupsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGet(requestParameters: GroupsApiGroupsGetRequest, options?: AxiosRequestConfig): AxiosPromise<GroupMetadata> {
            return localVarFp.groupsGet(requestParameters.accountId, requestParameters.id, requestParameters.forceRefresh, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get invite code for a group
         * @param {GroupsApiGroupsInviteCodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsInviteCode(requestParameters: GroupsApiGroupsInviteCodeRequest, options?: AxiosRequestConfig): AxiosPromise<GroupsInviteCode200Response> {
            return localVarFp.groupsInviteCode(requestParameters.accountId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join a group using invite code
         * @param {GroupsApiGroupsJoinRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsJoin(requestParameters: GroupsApiGroupsJoinRequest, options?: AxiosRequestConfig): AxiosPromise<GroupMetadata> {
            return localVarFp.groupsJoin(requestParameters.accountId, requestParameters.id, requestParameters.code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Leave a group
         * @param {GroupsApiGroupsLeaveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsLeave(requestParameters: GroupsApiGroupsLeaveRequest, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.groupsLeave(requestParameters.accountId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a group
         * @param {GroupsApiGroupsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPatch(requestParameters: GroupsApiGroupsPatchRequest, options?: AxiosRequestConfig): AxiosPromise<GroupMetadata> {
            return localVarFp.groupsPatch(requestParameters.accountId, requestParameters.id, requestParameters.groupAction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new group
         * @param {GroupsApiGroupsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPost(requestParameters: GroupsApiGroupsPostRequest, options?: AxiosRequestConfig): AxiosPromise<GroupMetadata> {
            return localVarFp.groupsPost(requestParameters.accountId, requestParameters.groupCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for groupsGet operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsGetRequest
 */
export interface GroupsApiGroupsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsGet
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsGet
     */
    readonly id: string

    /**
     * Fetches the group metadata again from the platform
     * @type {boolean}
     * @memberof GroupsApiGroupsGet
     */
    readonly forceRefresh?: boolean
}

/**
 * Request parameters for groupsInviteCode operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsInviteCodeRequest
 */
export interface GroupsApiGroupsInviteCodeRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsInviteCode
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsInviteCode
     */
    readonly id: string
}

/**
 * Request parameters for groupsJoin operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsJoinRequest
 */
export interface GroupsApiGroupsJoinRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsJoin
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsJoin
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsJoin
     */
    readonly code: string
}

/**
 * Request parameters for groupsLeave operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsLeaveRequest
 */
export interface GroupsApiGroupsLeaveRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsLeave
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsLeave
     */
    readonly id: string
}

/**
 * Request parameters for groupsPatch operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsPatchRequest
 */
export interface GroupsApiGroupsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsPatch
     */
    readonly id: string

    /**
     * 
     * @type {GroupAction}
     * @memberof GroupsApiGroupsPatch
     */
    readonly groupAction?: GroupAction
}

/**
 * Request parameters for groupsPost operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupsPostRequest
 */
export interface GroupsApiGroupsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupsApiGroupsPost
     */
    readonly accountId: string

    /**
     * 
     * @type {GroupCreate}
     * @memberof GroupsApiGroupsPost
     */
    readonly groupCreate?: GroupCreate
}

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary Get metadata for a group
     * @param {GroupsApiGroupsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsGet(requestParameters: GroupsApiGroupsGetRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsGet(requestParameters.accountId, requestParameters.id, requestParameters.forceRefresh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get invite code for a group
     * @param {GroupsApiGroupsInviteCodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsInviteCode(requestParameters: GroupsApiGroupsInviteCodeRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsInviteCode(requestParameters.accountId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join a group using invite code
     * @param {GroupsApiGroupsJoinRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsJoin(requestParameters: GroupsApiGroupsJoinRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsJoin(requestParameters.accountId, requestParameters.id, requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Leave a group
     * @param {GroupsApiGroupsLeaveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsLeave(requestParameters: GroupsApiGroupsLeaveRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsLeave(requestParameters.accountId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a group
     * @param {GroupsApiGroupsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsPatch(requestParameters: GroupsApiGroupsPatchRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsPatch(requestParameters.accountId, requestParameters.id, requestParameters.groupAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new group
     * @param {GroupsApiGroupsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsPost(requestParameters: GroupsApiGroupsPostRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsPost(requestParameters.accountId, requestParameters.groupCreate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MailApi - axios parameter creator
 * @export
 */
export const MailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register an email sender
         * @param {string} accountId 
         * @param {MailRegisterPostRequest} [mailRegisterPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailRegisterPost: async (accountId: string, mailRegisterPostRequest?: MailRegisterPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('mailRegisterPost', 'accountId', accountId)
            const localVarPath = `/mail/register/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mailRegisterPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MailApi - functional programming interface
 * @export
 */
export const MailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MailApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Register an email sender
         * @param {string} accountId 
         * @param {MailRegisterPostRequest} [mailRegisterPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mailRegisterPost(accountId: string, mailRegisterPostRequest?: MailRegisterPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mailRegisterPost(accountId, mailRegisterPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MailApi - factory interface
 * @export
 */
export const MailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MailApiFp(configuration)
    return {
        /**
         * 
         * @summary Register an email sender
         * @param {MailApiMailRegisterPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mailRegisterPost(requestParameters: MailApiMailRegisterPostRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.mailRegisterPost(requestParameters.accountId, requestParameters.mailRegisterPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for mailRegisterPost operation in MailApi.
 * @export
 * @interface MailApiMailRegisterPostRequest
 */
export interface MailApiMailRegisterPostRequest {
    /**
     * 
     * @type {string}
     * @memberof MailApiMailRegisterPost
     */
    readonly accountId: string

    /**
     * 
     * @type {MailRegisterPostRequest}
     * @memberof MailApiMailRegisterPost
     */
    readonly mailRegisterPostRequest?: MailRegisterPostRequest
}

/**
 * MailApi - object-oriented interface
 * @export
 * @class MailApi
 * @extends {BaseAPI}
 */
export class MailApi extends BaseAPI {
    /**
     * 
     * @summary Register an email sender
     * @param {MailApiMailRegisterPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailApi
     */
    public mailRegisterPost(requestParameters: MailApiMailRegisterPostRequest, options?: AxiosRequestConfig) {
        return MailApiFp(this.configuration).mailRegisterPost(requestParameters.accountId, requestParameters.mailRegisterPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a message
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesDelete: async (accountId: string, chatId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesDelete', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesDelete', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messagesDelete', 'id', id)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clears all pending/error messages
         * @param {'pending' | 'error' | 'cancelled'} status 
         * @param {string} [accountId] If specified, only clears messages of this account
         * @param {string} [chatId] If specified, only clears messages of this chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesDeletePending: async (status: 'pending' | 'error' | 'cancelled', accountId?: string, chatId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('messagesDeletePending', 'status', status)
            const localVarPath = `/messages/{status}/retry`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_DELETE"], configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = chatId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {MessagesForwardToChatIdParameter} toChatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesForward: async (accountId: string, chatId: string, id: string, toChatId: MessagesForwardToChatIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesForward', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesForward', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messagesForward', 'id', id)
            // verify required parameter 'toChatId' is not null or undefined
            assertParamExists('messagesForward', 'toChatId', toChatId)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}/forward`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL"], configuration)

            if (toChatId !== undefined) {
                localVarQueryParameter['toChatId'] = toChatId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch messages of the chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {MessagesGetRangeParameter} [range] Fetch messages only within this range. If not specified, fetches all messages
         * @param {boolean} [action] Filter messages based on actions
         * @param {string} [beforeId] Get messages before this message ID
         * @param {number} [count] Number of items to return
         * @param {boolean} [forceReload] Deletes all cached messages for this chat &amp; fetches messages again from the original API source
         * @param {boolean} [fetchFromPlatform] Fetches messages from the platform, if the messages are not present in the DB
         * @param {'note' | 'pending' | 'error'} [status] fetch only \&quot;notes\&quot;, \&quot;pending\&quot; or \&quot;error\&quot; messages
         * @param {boolean} [fromMe] fetch only messages sent by me/or the other party
         * @param {Array<MessageAttachmentType>} [attachmentType] Fetch only messages with attachments of this type
         * @param {boolean} [includeCursorMessage] should include cursor message in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesGet: async (accountId: string, chatId: string, range?: MessagesGetRangeParameter, action?: boolean, beforeId?: string, count?: number, forceReload?: boolean, fetchFromPlatform?: boolean, status?: 'note' | 'pending' | 'error', fromMe?: boolean, attachmentType?: Array<MessageAttachmentType>, includeCursorMessage?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesGet', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesGet', 'chatId', chatId)
            const localVarPath = `/messages/{accountId}/{chatId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (beforeId !== undefined) {
                localVarQueryParameter['beforeId'] = beforeId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (forceReload !== undefined) {
                localVarQueryParameter['forceReload'] = forceReload;
            }

            if (fetchFromPlatform !== undefined) {
                localVarQueryParameter['fetchFromPlatform'] = fetchFromPlatform;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (fromMe !== undefined) {
                localVarQueryParameter['fromMe'] = fromMe;
            }

            if (attachmentType) {
                localVarQueryParameter['attachmentType'] = attachmentType;
            }

            if (includeCursorMessage !== undefined) {
                localVarQueryParameter['includeCursorMessage'] = includeCursorMessage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Can reschedule a message, update the content of a note or mark it as resolved 
         * @summary Modify a message/note
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {MessagesPatchRequest} [messagesPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPatch: async (accountId: string, chatId: string, id: string, messagesPatchRequest?: MessagesPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesPatch', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesPatch', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messagesPatch', 'id', id)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messagesPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retry all the messages in a given status
         * @param {'pending' | 'error' | 'cancelled'} status 
         * @param {MessagesPatchPendingRequest} [messagesPatchPendingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPatchPending: async (status: 'pending' | 'error' | 'cancelled', messagesPatchPendingRequest?: MessagesPatchPendingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('messagesPatchPending', 'status', status)
            const localVarPath = `/messages/{status}/retry`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ASSIGNED"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messagesPatchPendingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
         * @summary Send a message
         * @param {string} accountId The account to use to send the message. Pass as the literal \&quot;random\&quot; to use a random account 
         * @param {string} chatId The contact to send the message to.  To send to a phone number, supply the phone number with country code and no spaces. Eg. &#x60;911234534211&#x60;, &#x60;91345567543@s.whatsapp.net&#x60; 
         * @param {boolean} [requireOpenAccount] Only sends the message if the account is open, returns 428 otherwise
         * @param {boolean} [useRandomAccountIfAccountClosed] Use random account (if available) to send the message, if the account specified is closed
         * @param {boolean} [includeMarketingMessage] Includes the default marketing message for the account in the message
         * @param {MessageCompose} [messageCompose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPost: async (accountId: string, chatId: string, requireOpenAccount?: boolean, useRandomAccountIfAccountClosed?: boolean, includeMarketingMessage?: boolean, messageCompose?: MessageCompose, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesPost', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesPost', 'chatId', chatId)
            const localVarPath = `/messages/{accountId}/{chatId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL", "MESSAGES_SEND_TO_ASSIGNED"], configuration)

            if (requireOpenAccount !== undefined) {
                localVarQueryParameter['requireOpenAccount'] = requireOpenAccount;
            }

            if (useRandomAccountIfAccountClosed !== undefined) {
                localVarQueryParameter['useRandomAccountIfAccountClosed'] = useRandomAccountIfAccountClosed;
            }

            if (includeMarketingMessage !== undefined) {
                localVarQueryParameter['includeMarketingMessage'] = includeMarketingMessage;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageCompose, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary refresh a message, in case the media expired
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesRefresh: async (accountId: string, chatId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesRefresh', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('messagesRefresh', 'chatId', chatId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messagesRefresh', 'id', id)
            const localVarPath = `/messages/{accountId}/{chatId}/{id}/refresh`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search messages
         * @param {string} q The search query
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {MessagesGetRangeParameter} [range] Fetch messages only within this range. If not specified, fetches all messages
         * @param {number} [page] Page number to paginate through results
         * @param {number} [count] Number of items to return
         * @param {string} [chatId] 
         * @param {boolean} [returnChats] Return the corresponding chats alongside the messages
         * @param {boolean} [fromMe] Fetch only messages sent by me/or the other party. If not specified, fetches both
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesSearch: async (q: string, accountId?: Array<string>, range?: MessagesGetRangeParameter, page?: number, count?: number, chatId?: string, returnChats?: boolean, fromMe?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('messagesSearch', 'q', q)
            const localVarPath = `/messages/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEARCH"], configuration)

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = chatId;
            }

            if (returnChats !== undefined) {
                localVarQueryParameter['returnChats'] = returnChats;
            }

            if (fromMe !== undefined) {
                localVarQueryParameter['fromMe'] = fromMe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
         * @summary Send a message to one or more chats
         * @param {string} accountId The account to use to send the message.
         * @param {boolean} [requireOpenAccount] Only sends the message if the account is open, returns 428 otherwise
         * @param {MultiMessageCompose} [multiMessageCompose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesSend: async (accountId: string, requireOpenAccount?: boolean, multiMessageCompose?: MultiMessageCompose, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('messagesSend', 'accountId', accountId)
            const localVarPath = `/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL", "MESSAGES_SEND_TO_ASSIGNED"], configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (requireOpenAccount !== undefined) {
                localVarQueryParameter['requireOpenAccount'] = requireOpenAccount;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(multiMessageCompose, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a message
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesDelete(accountId: string, chatId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesDelete(accountId, chatId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Clears all pending/error messages
         * @param {'pending' | 'error' | 'cancelled'} status 
         * @param {string} [accountId] If specified, only clears messages of this account
         * @param {string} [chatId] If specified, only clears messages of this chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesDeletePending(status: 'pending' | 'error' | 'cancelled', accountId?: string, chatId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesDeletePending(status, accountId, chatId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {MessagesForwardToChatIdParameter} toChatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesForward(accountId: string, chatId: string, id: string, toChatId: MessagesForwardToChatIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesForward(accountId, chatId, id, toChatId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch messages of the chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {MessagesGetRangeParameter} [range] Fetch messages only within this range. If not specified, fetches all messages
         * @param {boolean} [action] Filter messages based on actions
         * @param {string} [beforeId] Get messages before this message ID
         * @param {number} [count] Number of items to return
         * @param {boolean} [forceReload] Deletes all cached messages for this chat &amp; fetches messages again from the original API source
         * @param {boolean} [fetchFromPlatform] Fetches messages from the platform, if the messages are not present in the DB
         * @param {'note' | 'pending' | 'error'} [status] fetch only \&quot;notes\&quot;, \&quot;pending\&quot; or \&quot;error\&quot; messages
         * @param {boolean} [fromMe] fetch only messages sent by me/or the other party
         * @param {Array<MessageAttachmentType>} [attachmentType] Fetch only messages with attachments of this type
         * @param {boolean} [includeCursorMessage] should include cursor message in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesGet(accountId: string, chatId: string, range?: MessagesGetRangeParameter, action?: boolean, beforeId?: string, count?: number, forceReload?: boolean, fetchFromPlatform?: boolean, status?: 'note' | 'pending' | 'error', fromMe?: boolean, attachmentType?: Array<MessageAttachmentType>, includeCursorMessage?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessagesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesGet(accountId, chatId, range, action, beforeId, count, forceReload, fetchFromPlatform, status, fromMe, attachmentType, includeCursorMessage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Can reschedule a message, update the content of a note or mark it as resolved 
         * @summary Modify a message/note
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {MessagesPatchRequest} [messagesPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesPatch(accountId: string, chatId: string, id: string, messagesPatchRequest?: MessagesPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesPatch(accountId, chatId, id, messagesPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retry all the messages in a given status
         * @param {'pending' | 'error' | 'cancelled'} status 
         * @param {MessagesPatchPendingRequest} [messagesPatchPendingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesPatchPending(status: 'pending' | 'error' | 'cancelled', messagesPatchPendingRequest?: MessagesPatchPendingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesPatchPending(status, messagesPatchPendingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
         * @summary Send a message
         * @param {string} accountId The account to use to send the message. Pass as the literal \&quot;random\&quot; to use a random account 
         * @param {string} chatId The contact to send the message to.  To send to a phone number, supply the phone number with country code and no spaces. Eg. &#x60;911234534211&#x60;, &#x60;91345567543@s.whatsapp.net&#x60; 
         * @param {boolean} [requireOpenAccount] Only sends the message if the account is open, returns 428 otherwise
         * @param {boolean} [useRandomAccountIfAccountClosed] Use random account (if available) to send the message, if the account specified is closed
         * @param {boolean} [includeMarketingMessage] Includes the default marketing message for the account in the message
         * @param {MessageCompose} [messageCompose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesPost(accountId: string, chatId: string, requireOpenAccount?: boolean, useRandomAccountIfAccountClosed?: boolean, includeMarketingMessage?: boolean, messageCompose?: MessageCompose, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesPost(accountId, chatId, requireOpenAccount, useRandomAccountIfAccountClosed, includeMarketingMessage, messageCompose, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary refresh a message, in case the media expired
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesRefresh(accountId: string, chatId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesRefresh(accountId, chatId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search messages
         * @param {string} q The search query
         * @param {Array<string>} [accountId] Get contacts only belonging to this account
         * @param {MessagesGetRangeParameter} [range] Fetch messages only within this range. If not specified, fetches all messages
         * @param {number} [page] Page number to paginate through results
         * @param {number} [count] Number of items to return
         * @param {string} [chatId] 
         * @param {boolean} [returnChats] Return the corresponding chats alongside the messages
         * @param {boolean} [fromMe] Fetch only messages sent by me/or the other party. If not specified, fetches both
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesSearch(q: string, accountId?: Array<string>, range?: MessagesGetRangeParameter, page?: number, count?: number, chatId?: string, returnChats?: boolean, fromMe?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessagesSearch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesSearch(q, accountId, range, page, count, chatId, returnChats, fromMe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
         * @summary Send a message to one or more chats
         * @param {string} accountId The account to use to send the message.
         * @param {boolean} [requireOpenAccount] Only sends the message if the account is open, returns 428 otherwise
         * @param {MultiMessageCompose} [multiMessageCompose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messagesSend(accountId: string, requireOpenAccount?: boolean, multiMessageCompose?: MultiMessageCompose, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messagesSend(accountId, requireOpenAccount, multiMessageCompose, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a message
         * @param {MessagesApiMessagesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesDelete(requestParameters: MessagesApiMessagesDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.messagesDelete(requestParameters.accountId, requestParameters.chatId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clears all pending/error messages
         * @param {MessagesApiMessagesDeletePendingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesDeletePending(requestParameters: MessagesApiMessagesDeletePendingRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.messagesDeletePending(requestParameters.status, requestParameters.accountId, requestParameters.chatId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MessagesApiMessagesForwardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesForward(requestParameters: MessagesApiMessagesForwardRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Message>> {
            return localVarFp.messagesForward(requestParameters.accountId, requestParameters.chatId, requestParameters.id, requestParameters.toChatId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch messages of the chat
         * @param {MessagesApiMessagesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesGet(requestParameters: MessagesApiMessagesGetRequest, options?: AxiosRequestConfig): AxiosPromise<MessagesGet200Response> {
            return localVarFp.messagesGet(requestParameters.accountId, requestParameters.chatId, requestParameters.range, requestParameters.action, requestParameters.beforeId, requestParameters.count, requestParameters.forceReload, requestParameters.fetchFromPlatform, requestParameters.status, requestParameters.fromMe, requestParameters.attachmentType, requestParameters.includeCursorMessage, options).then((request) => request(axios, basePath));
        },
        /**
         * Can reschedule a message, update the content of a note or mark it as resolved 
         * @summary Modify a message/note
         * @param {MessagesApiMessagesPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPatch(requestParameters: MessagesApiMessagesPatchRequest, options?: AxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.messagesPatch(requestParameters.accountId, requestParameters.chatId, requestParameters.id, requestParameters.messagesPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retry all the messages in a given status
         * @param {MessagesApiMessagesPatchPendingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPatchPending(requestParameters: MessagesApiMessagesPatchPendingRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.messagesPatchPending(requestParameters.status, requestParameters.messagesPatchPendingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
         * @summary Send a message
         * @param {MessagesApiMessagesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesPost(requestParameters: MessagesApiMessagesPostRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Message>> {
            return localVarFp.messagesPost(requestParameters.accountId, requestParameters.chatId, requestParameters.requireOpenAccount, requestParameters.useRandomAccountIfAccountClosed, requestParameters.includeMarketingMessage, requestParameters.messageCompose, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary refresh a message, in case the media expired
         * @param {MessagesApiMessagesRefreshRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesRefresh(requestParameters: MessagesApiMessagesRefreshRequest, options?: AxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.messagesRefresh(requestParameters.accountId, requestParameters.chatId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search messages
         * @param {MessagesApiMessagesSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesSearch(requestParameters: MessagesApiMessagesSearchRequest, options?: AxiosRequestConfig): AxiosPromise<MessagesSearch200Response> {
            return localVarFp.messagesSearch(requestParameters.q, requestParameters.accountId, requestParameters.range, requestParameters.page, requestParameters.count, requestParameters.chatId, requestParameters.returnChats, requestParameters.fromMe, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
         * @summary Send a message to one or more chats
         * @param {MessagesApiMessagesSendRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesSend(requestParameters: MessagesApiMessagesSendRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Message>> {
            return localVarFp.messagesSend(requestParameters.accountId, requestParameters.requireOpenAccount, requestParameters.multiMessageCompose, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for messagesDelete operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesDeleteRequest
 */
export interface MessagesApiMessagesDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesDelete
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesDelete
     */
    readonly chatId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesDelete
     */
    readonly id: string
}

/**
 * Request parameters for messagesDeletePending operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesDeletePendingRequest
 */
export interface MessagesApiMessagesDeletePendingRequest {
    /**
     * 
     * @type {'pending' | 'error' | 'cancelled'}
     * @memberof MessagesApiMessagesDeletePending
     */
    readonly status: 'pending' | 'error' | 'cancelled'

    /**
     * If specified, only clears messages of this account
     * @type {string}
     * @memberof MessagesApiMessagesDeletePending
     */
    readonly accountId?: string

    /**
     * If specified, only clears messages of this chat
     * @type {string}
     * @memberof MessagesApiMessagesDeletePending
     */
    readonly chatId?: string
}

/**
 * Request parameters for messagesForward operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesForwardRequest
 */
export interface MessagesApiMessagesForwardRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesForward
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesForward
     */
    readonly chatId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesForward
     */
    readonly id: string

    /**
     * 
     * @type {MessagesForwardToChatIdParameter}
     * @memberof MessagesApiMessagesForward
     */
    readonly toChatId: MessagesForwardToChatIdParameter
}

/**
 * Request parameters for messagesGet operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesGetRequest
 */
export interface MessagesApiMessagesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesGet
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesGet
     */
    readonly chatId: string

    /**
     * Fetch messages only within this range. If not specified, fetches all messages
     * @type {MessagesGetRangeParameter}
     * @memberof MessagesApiMessagesGet
     */
    readonly range?: MessagesGetRangeParameter

    /**
     * Filter messages based on actions
     * @type {boolean}
     * @memberof MessagesApiMessagesGet
     */
    readonly action?: boolean

    /**
     * Get messages before this message ID
     * @type {string}
     * @memberof MessagesApiMessagesGet
     */
    readonly beforeId?: string

    /**
     * Number of items to return
     * @type {number}
     * @memberof MessagesApiMessagesGet
     */
    readonly count?: number

    /**
     * Deletes all cached messages for this chat &amp; fetches messages again from the original API source
     * @type {boolean}
     * @memberof MessagesApiMessagesGet
     */
    readonly forceReload?: boolean

    /**
     * Fetches messages from the platform, if the messages are not present in the DB
     * @type {boolean}
     * @memberof MessagesApiMessagesGet
     */
    readonly fetchFromPlatform?: boolean

    /**
     * fetch only \&quot;notes\&quot;, \&quot;pending\&quot; or \&quot;error\&quot; messages
     * @type {'note' | 'pending' | 'error'}
     * @memberof MessagesApiMessagesGet
     */
    readonly status?: 'note' | 'pending' | 'error'

    /**
     * fetch only messages sent by me/or the other party
     * @type {boolean}
     * @memberof MessagesApiMessagesGet
     */
    readonly fromMe?: boolean

    /**
     * Fetch only messages with attachments of this type
     * @type {Array<MessageAttachmentType>}
     * @memberof MessagesApiMessagesGet
     */
    readonly attachmentType?: Array<MessageAttachmentType>

    /**
     * should include cursor message in the response
     * @type {boolean}
     * @memberof MessagesApiMessagesGet
     */
    readonly includeCursorMessage?: boolean
}

/**
 * Request parameters for messagesPatch operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesPatchRequest
 */
export interface MessagesApiMessagesPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesPatch
     */
    readonly chatId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesPatch
     */
    readonly id: string

    /**
     * 
     * @type {MessagesPatchRequest}
     * @memberof MessagesApiMessagesPatch
     */
    readonly messagesPatchRequest?: MessagesPatchRequest
}

/**
 * Request parameters for messagesPatchPending operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesPatchPendingRequest
 */
export interface MessagesApiMessagesPatchPendingRequest {
    /**
     * 
     * @type {'pending' | 'error' | 'cancelled'}
     * @memberof MessagesApiMessagesPatchPending
     */
    readonly status: 'pending' | 'error' | 'cancelled'

    /**
     * 
     * @type {MessagesPatchPendingRequest}
     * @memberof MessagesApiMessagesPatchPending
     */
    readonly messagesPatchPendingRequest?: MessagesPatchPendingRequest
}

/**
 * Request parameters for messagesPost operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesPostRequest
 */
export interface MessagesApiMessagesPostRequest {
    /**
     * The account to use to send the message. Pass as the literal \&quot;random\&quot; to use a random account 
     * @type {string}
     * @memberof MessagesApiMessagesPost
     */
    readonly accountId: string

    /**
     * The contact to send the message to.  To send to a phone number, supply the phone number with country code and no spaces. Eg. &#x60;911234534211&#x60;, &#x60;91345567543@s.whatsapp.net&#x60; 
     * @type {string}
     * @memberof MessagesApiMessagesPost
     */
    readonly chatId: string

    /**
     * Only sends the message if the account is open, returns 428 otherwise
     * @type {boolean}
     * @memberof MessagesApiMessagesPost
     */
    readonly requireOpenAccount?: boolean

    /**
     * Use random account (if available) to send the message, if the account specified is closed
     * @type {boolean}
     * @memberof MessagesApiMessagesPost
     */
    readonly useRandomAccountIfAccountClosed?: boolean

    /**
     * Includes the default marketing message for the account in the message
     * @type {boolean}
     * @memberof MessagesApiMessagesPost
     */
    readonly includeMarketingMessage?: boolean

    /**
     * 
     * @type {MessageCompose}
     * @memberof MessagesApiMessagesPost
     */
    readonly messageCompose?: MessageCompose
}

/**
 * Request parameters for messagesRefresh operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesRefreshRequest
 */
export interface MessagesApiMessagesRefreshRequest {
    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesRefresh
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesRefresh
     */
    readonly chatId: string

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesRefresh
     */
    readonly id: string
}

/**
 * Request parameters for messagesSearch operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesSearchRequest
 */
export interface MessagesApiMessagesSearchRequest {
    /**
     * The search query
     * @type {string}
     * @memberof MessagesApiMessagesSearch
     */
    readonly q: string

    /**
     * Get contacts only belonging to this account
     * @type {Array<string>}
     * @memberof MessagesApiMessagesSearch
     */
    readonly accountId?: Array<string>

    /**
     * Fetch messages only within this range. If not specified, fetches all messages
     * @type {MessagesGetRangeParameter}
     * @memberof MessagesApiMessagesSearch
     */
    readonly range?: MessagesGetRangeParameter

    /**
     * Page number to paginate through results
     * @type {number}
     * @memberof MessagesApiMessagesSearch
     */
    readonly page?: number

    /**
     * Number of items to return
     * @type {number}
     * @memberof MessagesApiMessagesSearch
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof MessagesApiMessagesSearch
     */
    readonly chatId?: string

    /**
     * Return the corresponding chats alongside the messages
     * @type {boolean}
     * @memberof MessagesApiMessagesSearch
     */
    readonly returnChats?: boolean

    /**
     * Fetch only messages sent by me/or the other party. If not specified, fetches both
     * @type {boolean}
     * @memberof MessagesApiMessagesSearch
     */
    readonly fromMe?: boolean
}

/**
 * Request parameters for messagesSend operation in MessagesApi.
 * @export
 * @interface MessagesApiMessagesSendRequest
 */
export interface MessagesApiMessagesSendRequest {
    /**
     * The account to use to send the message.
     * @type {string}
     * @memberof MessagesApiMessagesSend
     */
    readonly accountId: string

    /**
     * Only sends the message if the account is open, returns 428 otherwise
     * @type {boolean}
     * @memberof MessagesApiMessagesSend
     */
    readonly requireOpenAccount?: boolean

    /**
     * 
     * @type {MultiMessageCompose}
     * @memberof MessagesApiMessagesSend
     */
    readonly multiMessageCompose?: MultiMessageCompose
}

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     * 
     * @summary Delete a message
     * @param {MessagesApiMessagesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesDelete(requestParameters: MessagesApiMessagesDeleteRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesDelete(requestParameters.accountId, requestParameters.chatId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clears all pending/error messages
     * @param {MessagesApiMessagesDeletePendingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesDeletePending(requestParameters: MessagesApiMessagesDeletePendingRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesDeletePending(requestParameters.status, requestParameters.accountId, requestParameters.chatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MessagesApiMessagesForwardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesForward(requestParameters: MessagesApiMessagesForwardRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesForward(requestParameters.accountId, requestParameters.chatId, requestParameters.id, requestParameters.toChatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch messages of the chat
     * @param {MessagesApiMessagesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesGet(requestParameters: MessagesApiMessagesGetRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesGet(requestParameters.accountId, requestParameters.chatId, requestParameters.range, requestParameters.action, requestParameters.beforeId, requestParameters.count, requestParameters.forceReload, requestParameters.fetchFromPlatform, requestParameters.status, requestParameters.fromMe, requestParameters.attachmentType, requestParameters.includeCursorMessage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Can reschedule a message, update the content of a note or mark it as resolved 
     * @summary Modify a message/note
     * @param {MessagesApiMessagesPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesPatch(requestParameters: MessagesApiMessagesPatchRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesPatch(requestParameters.accountId, requestParameters.chatId, requestParameters.id, requestParameters.messagesPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retry all the messages in a given status
     * @param {MessagesApiMessagesPatchPendingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesPatchPending(requestParameters: MessagesApiMessagesPatchPendingRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesPatchPending(requestParameters.status, requestParameters.messagesPatchPendingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
     * @summary Send a message
     * @param {MessagesApiMessagesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesPost(requestParameters: MessagesApiMessagesPostRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesPost(requestParameters.accountId, requestParameters.chatId, requestParameters.requireOpenAccount, requestParameters.useRandomAccountIfAccountClosed, requestParameters.includeMarketingMessage, requestParameters.messageCompose, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary refresh a message, in case the media expired
     * @param {MessagesApiMessagesRefreshRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesRefresh(requestParameters: MessagesApiMessagesRefreshRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesRefresh(requestParameters.accountId, requestParameters.chatId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search messages
     * @param {MessagesApiMessagesSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesSearch(requestParameters: MessagesApiMessagesSearchRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesSearch(requestParameters.q, requestParameters.accountId, requestParameters.range, requestParameters.page, requestParameters.count, requestParameters.chatId, requestParameters.returnChats, requestParameters.fromMe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a message with text and/or attachments. The `text` property can be used as a [mustache](https://mustache.github.io) template which automatically prefills data from the contact\'s details including **custom fields**. Some examples:   1. `{\"text\": \"Hello there {{name}}\"}` will automatically pre-fill the contact\'s name (if present)   2. `{\"text\": \"Hello {{name}} your number is {{phoneNumber}}\"}` will automatically pre-fill the contact\'s name & phone number   3. `{\"text\": \"Hello {{name}} your pet name is {{pet name}}\"}` will automatically pre-fill `petName` if the contact has such a custom field
     * @summary Send a message to one or more chats
     * @param {MessagesApiMessagesSendRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesSend(requestParameters: MessagesApiMessagesSendRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).messagesSend(requestParameters.accountId, requestParameters.requireOpenAccount, requestParameters.multiMessageCompose, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch details of an order (likely from an order message)
         * @param {string} accountId 
         * @param {string} orderId 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDetailsGet: async (accountId: string, orderId: string, token?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('orderDetailsGet', 'accountId', accountId)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderDetailsGet', 'orderId', orderId)
            const localVarPath = `/{accountId}/{orderId}/order-details`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete products by the given filter from the catalog
         * @param {string} accountId 
         * @param {Array<string>} [id] 
         * @param {Array<string>} [notId] 
         * @param {string} [q] Search items by this string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsDelete: async (accountId: string, id?: Array<string>, notId?: Array<string>, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('platformProductsDelete', 'accountId', accountId)
            const localVarPath = `/products/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_DELETE"], configuration)

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (notId) {
                localVarQueryParameter['notId'] = notId;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the WA catalog. Only available on WA Business apps. 
         * @summary Get the products from WA catalog.
         * @param {string} teamId 
         * @param {Array<string>} [accountId] 
         * @param {string} [category] Filter based on collection/category
         * @param {string} [notCategory] Returns products not belonging to the specified category
         * @param {Array<string>} [id] 
         * @param {string} [cursor] 
         * @param {string} [q] Search items by this string
         * @param {number} [count] Number of items to return
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsGet: async (teamId: string, accountId?: Array<string>, category?: string, notCategory?: string, id?: Array<string>, cursor?: string, q?: string, count?: number, returnTotalCount?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('platformProductsGet', 'teamId', teamId)
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (notCategory !== undefined) {
                localVarQueryParameter['notCategory'] = notCategory;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update products by the given filter in the WA catalog
         * @param {string} accountId 
         * @param {Array<string>} [id] 
         * @param {Array<string>} [notId] 
         * @param {string} [q] Search items by this string
         * @param {PlatformProductUpdate} [platformProductUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsPatch: async (accountId: string, id?: Array<string>, notId?: Array<string>, q?: string, platformProductUpdate?: PlatformProductUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('platformProductsPatch', 'accountId', accountId)
            const localVarPath = `/products/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_UPDATE"], configuration)

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (notId) {
                localVarQueryParameter['notId'] = notId;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(platformProductUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upsert products to the WA catalog
         * @param {string} accountId 
         * @param {PlatformProductsPostRequest} [platformProductsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsPost: async (accountId: string, platformProductsPostRequest?: PlatformProductsPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('platformProductsPost', 'accountId', accountId)
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_CREATE"], configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(platformProductsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger sync of the specified products on ChatDaddy with WhatsApp
         * @param {string} accountId Account ID to sync products from/to
         * @param {Array<string>} [id] Products to sync with WhatsApp. Leave unspecified to trigger all
         * @param {boolean} [syncForward] Sync products from ChatDaddy to WhatsApp
         * @param {boolean} [syncBackward] Sync missing products from WhatsApp to ChatDaddy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsSync: async (accountId: string, id?: Array<string>, syncForward?: boolean, syncBackward?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('platformProductsSync', 'accountId', accountId)
            const localVarPath = `/products/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_UPDATE"], configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (syncForward !== undefined) {
                localVarQueryParameter['syncForward'] = syncForward;
            }

            if (syncBackward !== undefined) {
                localVarQueryParameter['syncBackward'] = syncBackward;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch details of an order (likely from an order message)
         * @param {string} accountId 
         * @param {string} orderId 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderDetailsGet(accountId: string, orderId: string, token?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderDetailsGet(accountId, orderId, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete products by the given filter from the catalog
         * @param {string} accountId 
         * @param {Array<string>} [id] 
         * @param {Array<string>} [notId] 
         * @param {string} [q] Search items by this string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductsDelete(accountId: string, id?: Array<string>, notId?: Array<string>, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductsDelete(accountId, id, notId, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the WA catalog. Only available on WA Business apps. 
         * @summary Get the products from WA catalog.
         * @param {string} teamId 
         * @param {Array<string>} [accountId] 
         * @param {string} [category] Filter based on collection/category
         * @param {string} [notCategory] Returns products not belonging to the specified category
         * @param {Array<string>} [id] 
         * @param {string} [cursor] 
         * @param {string} [q] Search items by this string
         * @param {number} [count] Number of items to return
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductsGet(teamId: string, accountId?: Array<string>, category?: string, notCategory?: string, id?: Array<string>, cursor?: string, q?: string, count?: number, returnTotalCount?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformProductsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductsGet(teamId, accountId, category, notCategory, id, cursor, q, count, returnTotalCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update products by the given filter in the WA catalog
         * @param {string} accountId 
         * @param {Array<string>} [id] 
         * @param {Array<string>} [notId] 
         * @param {string} [q] Search items by this string
         * @param {PlatformProductUpdate} [platformProductUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductsPatch(accountId: string, id?: Array<string>, notId?: Array<string>, q?: string, platformProductUpdate?: PlatformProductUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformProductsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductsPatch(accountId, id, notId, q, platformProductUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upsert products to the WA catalog
         * @param {string} accountId 
         * @param {PlatformProductsPostRequest} [platformProductsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductsPost(accountId: string, platformProductsPostRequest?: PlatformProductsPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformProductsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductsPost(accountId, platformProductsPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger sync of the specified products on ChatDaddy with WhatsApp
         * @param {string} accountId Account ID to sync products from/to
         * @param {Array<string>} [id] Products to sync with WhatsApp. Leave unspecified to trigger all
         * @param {boolean} [syncForward] Sync products from ChatDaddy to WhatsApp
         * @param {boolean} [syncBackward] Sync missing products from WhatsApp to ChatDaddy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductsSync(accountId: string, id?: Array<string>, syncForward?: boolean, syncBackward?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductsSync(accountId, id, syncForward, syncBackward, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch details of an order (likely from an order message)
         * @param {ProductApiOrderDetailsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDetailsGet(requestParameters: ProductApiOrderDetailsGetRequest, options?: AxiosRequestConfig): AxiosPromise<OrderDetails> {
            return localVarFp.orderDetailsGet(requestParameters.accountId, requestParameters.orderId, requestParameters.token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete products by the given filter from the catalog
         * @param {ProductApiPlatformProductsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsDelete(requestParameters: ProductApiPlatformProductsDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.platformProductsDelete(requestParameters.accountId, requestParameters.id, requestParameters.notId, requestParameters.q, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the WA catalog. Only available on WA Business apps. 
         * @summary Get the products from WA catalog.
         * @param {ProductApiPlatformProductsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsGet(requestParameters: ProductApiPlatformProductsGetRequest, options?: AxiosRequestConfig): AxiosPromise<PlatformProductsGet200Response> {
            return localVarFp.platformProductsGet(requestParameters.teamId, requestParameters.accountId, requestParameters.category, requestParameters.notCategory, requestParameters.id, requestParameters.cursor, requestParameters.q, requestParameters.count, requestParameters.returnTotalCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update products by the given filter in the WA catalog
         * @param {ProductApiPlatformProductsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsPatch(requestParameters: ProductApiPlatformProductsPatchRequest, options?: AxiosRequestConfig): AxiosPromise<PlatformProductsPost200Response> {
            return localVarFp.platformProductsPatch(requestParameters.accountId, requestParameters.id, requestParameters.notId, requestParameters.q, requestParameters.platformProductUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upsert products to the WA catalog
         * @param {ProductApiPlatformProductsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsPost(requestParameters: ProductApiPlatformProductsPostRequest, options?: AxiosRequestConfig): AxiosPromise<PlatformProductsPost200Response> {
            return localVarFp.platformProductsPost(requestParameters.accountId, requestParameters.platformProductsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger sync of the specified products on ChatDaddy with WhatsApp
         * @param {ProductApiPlatformProductsSyncRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductsSync(requestParameters: ProductApiPlatformProductsSyncRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.platformProductsSync(requestParameters.accountId, requestParameters.id, requestParameters.syncForward, requestParameters.syncBackward, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orderDetailsGet operation in ProductApi.
 * @export
 * @interface ProductApiOrderDetailsGetRequest
 */
export interface ProductApiOrderDetailsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiOrderDetailsGet
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiOrderDetailsGet
     */
    readonly orderId: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiOrderDetailsGet
     */
    readonly token?: string
}

/**
 * Request parameters for platformProductsDelete operation in ProductApi.
 * @export
 * @interface ProductApiPlatformProductsDeleteRequest
 */
export interface ProductApiPlatformProductsDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiPlatformProductsDelete
     */
    readonly accountId: string

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsDelete
     */
    readonly id?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsDelete
     */
    readonly notId?: Array<string>

    /**
     * Search items by this string
     * @type {string}
     * @memberof ProductApiPlatformProductsDelete
     */
    readonly q?: string
}

/**
 * Request parameters for platformProductsGet operation in ProductApi.
 * @export
 * @interface ProductApiPlatformProductsGetRequest
 */
export interface ProductApiPlatformProductsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly teamId: string

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly accountId?: Array<string>

    /**
     * Filter based on collection/category
     * @type {string}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly category?: string

    /**
     * Returns products not belonging to the specified category
     * @type {string}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly notCategory?: string

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly id?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly cursor?: string

    /**
     * Search items by this string
     * @type {string}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly q?: string

    /**
     * Number of items to return
     * @type {number}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly count?: number

    /**
     * 
     * @type {boolean}
     * @memberof ProductApiPlatformProductsGet
     */
    readonly returnTotalCount?: boolean
}

/**
 * Request parameters for platformProductsPatch operation in ProductApi.
 * @export
 * @interface ProductApiPlatformProductsPatchRequest
 */
export interface ProductApiPlatformProductsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiPlatformProductsPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsPatch
     */
    readonly id?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsPatch
     */
    readonly notId?: Array<string>

    /**
     * Search items by this string
     * @type {string}
     * @memberof ProductApiPlatformProductsPatch
     */
    readonly q?: string

    /**
     * 
     * @type {PlatformProductUpdate}
     * @memberof ProductApiPlatformProductsPatch
     */
    readonly platformProductUpdate?: PlatformProductUpdate
}

/**
 * Request parameters for platformProductsPost operation in ProductApi.
 * @export
 * @interface ProductApiPlatformProductsPostRequest
 */
export interface ProductApiPlatformProductsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiPlatformProductsPost
     */
    readonly accountId: string

    /**
     * 
     * @type {PlatformProductsPostRequest}
     * @memberof ProductApiPlatformProductsPost
     */
    readonly platformProductsPostRequest?: PlatformProductsPostRequest
}

/**
 * Request parameters for platformProductsSync operation in ProductApi.
 * @export
 * @interface ProductApiPlatformProductsSyncRequest
 */
export interface ProductApiPlatformProductsSyncRequest {
    /**
     * Account ID to sync products from/to
     * @type {string}
     * @memberof ProductApiPlatformProductsSync
     */
    readonly accountId: string

    /**
     * Products to sync with WhatsApp. Leave unspecified to trigger all
     * @type {Array<string>}
     * @memberof ProductApiPlatformProductsSync
     */
    readonly id?: Array<string>

    /**
     * Sync products from ChatDaddy to WhatsApp
     * @type {boolean}
     * @memberof ProductApiPlatformProductsSync
     */
    readonly syncForward?: boolean

    /**
     * Sync missing products from WhatsApp to ChatDaddy
     * @type {boolean}
     * @memberof ProductApiPlatformProductsSync
     */
    readonly syncBackward?: boolean
}

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @summary Fetch details of an order (likely from an order message)
     * @param {ProductApiOrderDetailsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public orderDetailsGet(requestParameters: ProductApiOrderDetailsGetRequest, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).orderDetailsGet(requestParameters.accountId, requestParameters.orderId, requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete products by the given filter from the catalog
     * @param {ProductApiPlatformProductsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public platformProductsDelete(requestParameters: ProductApiPlatformProductsDeleteRequest, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).platformProductsDelete(requestParameters.accountId, requestParameters.id, requestParameters.notId, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the WA catalog. Only available on WA Business apps. 
     * @summary Get the products from WA catalog.
     * @param {ProductApiPlatformProductsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public platformProductsGet(requestParameters: ProductApiPlatformProductsGetRequest, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).platformProductsGet(requestParameters.teamId, requestParameters.accountId, requestParameters.category, requestParameters.notCategory, requestParameters.id, requestParameters.cursor, requestParameters.q, requestParameters.count, requestParameters.returnTotalCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update products by the given filter in the WA catalog
     * @param {ProductApiPlatformProductsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public platformProductsPatch(requestParameters: ProductApiPlatformProductsPatchRequest, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).platformProductsPatch(requestParameters.accountId, requestParameters.id, requestParameters.notId, requestParameters.q, requestParameters.platformProductUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upsert products to the WA catalog
     * @param {ProductApiPlatformProductsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public platformProductsPost(requestParameters: ProductApiPlatformProductsPostRequest, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).platformProductsPost(requestParameters.accountId, requestParameters.platformProductsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger sync of the specified products on ChatDaddy with WhatsApp
     * @param {ProductApiPlatformProductsSyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public platformProductsSync(requestParameters: ProductApiPlatformProductsSyncRequest, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).platformProductsSync(requestParameters.accountId, requestParameters.id, requestParameters.syncForward, requestParameters.syncBackward, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductCategoriesApi - axios parameter creator
 * @export
 */
export const ProductCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a category
         * @param {string} accountId 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesDelete: async (accountId: string, categoryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('platformProductCategoriesDelete', 'accountId', accountId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('platformProductCategoriesDelete', 'categoryId', categoryId)
            const localVarPath = `/product-categories/{accountId}/{categoryId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the categories (collections) from WA catalog.
         * @param {string} teamId 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesGet: async (teamId: string, accountId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('platformProductCategoriesGet', 'teamId', teamId)
            const localVarPath = `/product-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update name of the category or add/remove a product
         * @summary Update a category
         * @param {string} accountId 
         * @param {string} categoryId 
         * @param {ProductCategoryPatchRequest} [productCategoryPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesPatch: async (accountId: string, categoryId: string, productCategoryPatchRequest?: ProductCategoryPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('platformProductCategoriesPatch', 'accountId', accountId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('platformProductCategoriesPatch', 'categoryId', categoryId)
            const localVarPath = `/product-categories/{accountId}/{categoryId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCategoryPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new product category
         * @param {string} accountId 
         * @param {PlatformProductCategoriesPostRequest} [platformProductCategoriesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesPost: async (accountId: string, platformProductCategoriesPostRequest?: PlatformProductCategoriesPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('platformProductCategoriesPost', 'accountId', accountId)
            const localVarPath = `/product-categories/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(platformProductCategoriesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductCategoriesApi - functional programming interface
 * @export
 */
export const ProductCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a category
         * @param {string} accountId 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductCategoriesDelete(accountId: string, categoryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductCategoriesDelete(accountId, categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the categories (collections) from WA catalog.
         * @param {string} teamId 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductCategoriesGet(teamId: string, accountId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformProductCategoriesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductCategoriesGet(teamId, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update name of the category or add/remove a product
         * @summary Update a category
         * @param {string} accountId 
         * @param {string} categoryId 
         * @param {ProductCategoryPatchRequest} [productCategoryPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductCategoriesPatch(accountId: string, categoryId: string, productCategoryPatchRequest?: ProductCategoryPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductCategoriesPatch(accountId, categoryId, productCategoryPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new product category
         * @param {string} accountId 
         * @param {PlatformProductCategoriesPostRequest} [platformProductCategoriesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async platformProductCategoriesPost(accountId: string, platformProductCategoriesPostRequest?: PlatformProductCategoriesPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.platformProductCategoriesPost(accountId, platformProductCategoriesPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductCategoriesApi - factory interface
 * @export
 */
export const ProductCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductCategoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a category
         * @param {ProductCategoriesApiPlatformProductCategoriesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesDelete(requestParameters: ProductCategoriesApiPlatformProductCategoriesDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.platformProductCategoriesDelete(requestParameters.accountId, requestParameters.categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the categories (collections) from WA catalog.
         * @param {ProductCategoriesApiPlatformProductCategoriesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesGet(requestParameters: ProductCategoriesApiPlatformProductCategoriesGetRequest, options?: AxiosRequestConfig): AxiosPromise<PlatformProductCategoriesGet200Response> {
            return localVarFp.platformProductCategoriesGet(requestParameters.teamId, requestParameters.accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update name of the category or add/remove a product
         * @summary Update a category
         * @param {ProductCategoriesApiPlatformProductCategoriesPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesPatch(requestParameters: ProductCategoriesApiPlatformProductCategoriesPatchRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.platformProductCategoriesPatch(requestParameters.accountId, requestParameters.categoryId, requestParameters.productCategoryPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new product category
         * @param {ProductCategoriesApiPlatformProductCategoriesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        platformProductCategoriesPost(requestParameters: ProductCategoriesApiPlatformProductCategoriesPostRequest, options?: AxiosRequestConfig): AxiosPromise<ProductCategory> {
            return localVarFp.platformProductCategoriesPost(requestParameters.accountId, requestParameters.platformProductCategoriesPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for platformProductCategoriesDelete operation in ProductCategoriesApi.
 * @export
 * @interface ProductCategoriesApiPlatformProductCategoriesDeleteRequest
 */
export interface ProductCategoriesApiPlatformProductCategoriesDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductCategoriesApiPlatformProductCategoriesDelete
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof ProductCategoriesApiPlatformProductCategoriesDelete
     */
    readonly categoryId: string
}

/**
 * Request parameters for platformProductCategoriesGet operation in ProductCategoriesApi.
 * @export
 * @interface ProductCategoriesApiPlatformProductCategoriesGetRequest
 */
export interface ProductCategoriesApiPlatformProductCategoriesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductCategoriesApiPlatformProductCategoriesGet
     */
    readonly teamId: string

    /**
     * 
     * @type {string}
     * @memberof ProductCategoriesApiPlatformProductCategoriesGet
     */
    readonly accountId?: string
}

/**
 * Request parameters for platformProductCategoriesPatch operation in ProductCategoriesApi.
 * @export
 * @interface ProductCategoriesApiPlatformProductCategoriesPatchRequest
 */
export interface ProductCategoriesApiPlatformProductCategoriesPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductCategoriesApiPlatformProductCategoriesPatch
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof ProductCategoriesApiPlatformProductCategoriesPatch
     */
    readonly categoryId: string

    /**
     * 
     * @type {ProductCategoryPatchRequest}
     * @memberof ProductCategoriesApiPlatformProductCategoriesPatch
     */
    readonly productCategoryPatchRequest?: ProductCategoryPatchRequest
}

/**
 * Request parameters for platformProductCategoriesPost operation in ProductCategoriesApi.
 * @export
 * @interface ProductCategoriesApiPlatformProductCategoriesPostRequest
 */
export interface ProductCategoriesApiPlatformProductCategoriesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductCategoriesApiPlatformProductCategoriesPost
     */
    readonly accountId: string

    /**
     * 
     * @type {PlatformProductCategoriesPostRequest}
     * @memberof ProductCategoriesApiPlatformProductCategoriesPost
     */
    readonly platformProductCategoriesPostRequest?: PlatformProductCategoriesPostRequest
}

/**
 * ProductCategoriesApi - object-oriented interface
 * @export
 * @class ProductCategoriesApi
 * @extends {BaseAPI}
 */
export class ProductCategoriesApi extends BaseAPI {
    /**
     * 
     * @summary Delete a category
     * @param {ProductCategoriesApiPlatformProductCategoriesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public platformProductCategoriesDelete(requestParameters: ProductCategoriesApiPlatformProductCategoriesDeleteRequest, options?: AxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).platformProductCategoriesDelete(requestParameters.accountId, requestParameters.categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the categories (collections) from WA catalog.
     * @param {ProductCategoriesApiPlatformProductCategoriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public platformProductCategoriesGet(requestParameters: ProductCategoriesApiPlatformProductCategoriesGetRequest, options?: AxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).platformProductCategoriesGet(requestParameters.teamId, requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update name of the category or add/remove a product
     * @summary Update a category
     * @param {ProductCategoriesApiPlatformProductCategoriesPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public platformProductCategoriesPatch(requestParameters: ProductCategoriesApiPlatformProductCategoriesPatchRequest, options?: AxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).platformProductCategoriesPatch(requestParameters.accountId, requestParameters.categoryId, requestParameters.productCategoryPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new product category
     * @param {ProductCategoriesApiPlatformProductCategoriesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public platformProductCategoriesPost(requestParameters: ProductCategoriesApiPlatformProductCategoriesPostRequest, options?: AxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).platformProductCategoriesPost(requestParameters.accountId, requestParameters.platformProductCategoriesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfileValidationApi - axios parameter creator
 * @export
 */
export const ProfileValidationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Configure various profile settings
         * @param {string} accountId 
         * @param {ProfileMessengerPostRequest} [profileMessengerPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileMessengerPost: async (accountId: string, profileMessengerPostRequest?: ProfileMessengerPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('profileMessengerPost', 'accountId', accountId)
            const localVarPath = `/messenger/profile-validation/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileMessengerPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileValidationApi - functional programming interface
 * @export
 */
export const ProfileValidationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileValidationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Configure various profile settings
         * @param {string} accountId 
         * @param {ProfileMessengerPostRequest} [profileMessengerPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileMessengerPost(accountId: string, profileMessengerPostRequest?: ProfileMessengerPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileMessengerPost(accountId, profileMessengerPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfileValidationApi - factory interface
 * @export
 */
export const ProfileValidationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileValidationApiFp(configuration)
    return {
        /**
         * 
         * @summary Configure various profile settings
         * @param {ProfileValidationApiProfileMessengerPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileMessengerPost(requestParameters: ProfileValidationApiProfileMessengerPostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.profileMessengerPost(requestParameters.accountId, requestParameters.profileMessengerPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for profileMessengerPost operation in ProfileValidationApi.
 * @export
 * @interface ProfileValidationApiProfileMessengerPostRequest
 */
export interface ProfileValidationApiProfileMessengerPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileValidationApiProfileMessengerPost
     */
    readonly accountId: string

    /**
     * 
     * @type {ProfileMessengerPostRequest}
     * @memberof ProfileValidationApiProfileMessengerPost
     */
    readonly profileMessengerPostRequest?: ProfileMessengerPostRequest
}

/**
 * ProfileValidationApi - object-oriented interface
 * @export
 * @class ProfileValidationApi
 * @extends {BaseAPI}
 */
export class ProfileValidationApi extends BaseAPI {
    /**
     * 
     * @summary Configure various profile settings
     * @param {ProfileValidationApiProfileMessengerPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileValidationApi
     */
    public profileMessengerPost(requestParameters: ProfileValidationApiProfileMessengerPostRequest, options?: AxiosRequestConfig) {
        return ProfileValidationApiFp(this.configuration).profileMessengerPost(requestParameters.accountId, requestParameters.profileMessengerPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SMSApi - axios parameter creator
 * @export
 */
export const SMSApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Set sender Id for sms channel
         * @param {string} accountId 
         * @param {SmsSenderIdPostRequest} [smsSenderIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smsSenderIdPost: async (accountId: string, smsSenderIdPostRequest?: SmsSenderIdPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('smsSenderIdPost', 'accountId', accountId)
            const localVarPath = `/sms/sender-id/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ACCOUNT_PATCH"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smsSenderIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SMSApi - functional programming interface
 * @export
 */
export const SMSApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SMSApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Set sender Id for sms channel
         * @param {string} accountId 
         * @param {SmsSenderIdPostRequest} [smsSenderIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smsSenderIdPost(accountId: string, smsSenderIdPostRequest?: SmsSenderIdPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smsSenderIdPost(accountId, smsSenderIdPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SMSApi - factory interface
 * @export
 */
export const SMSApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SMSApiFp(configuration)
    return {
        /**
         * 
         * @summary Set sender Id for sms channel
         * @param {SMSApiSmsSenderIdPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smsSenderIdPost(requestParameters: SMSApiSmsSenderIdPostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.smsSenderIdPost(requestParameters.accountId, requestParameters.smsSenderIdPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for smsSenderIdPost operation in SMSApi.
 * @export
 * @interface SMSApiSmsSenderIdPostRequest
 */
export interface SMSApiSmsSenderIdPostRequest {
    /**
     * 
     * @type {string}
     * @memberof SMSApiSmsSenderIdPost
     */
    readonly accountId: string

    /**
     * 
     * @type {SmsSenderIdPostRequest}
     * @memberof SMSApiSmsSenderIdPost
     */
    readonly smsSenderIdPostRequest?: SmsSenderIdPostRequest
}

/**
 * SMSApi - object-oriented interface
 * @export
 * @class SMSApi
 * @extends {BaseAPI}
 */
export class SMSApi extends BaseAPI {
    /**
     * 
     * @summary Set sender Id for sms channel
     * @param {SMSApiSmsSenderIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SMSApi
     */
    public smsSenderIdPost(requestParameters: SMSApiSmsSenderIdPostRequest, options?: AxiosRequestConfig) {
        return SMSApiFp(this.configuration).smsSenderIdPost(requestParameters.accountId, requestParameters.smsSenderIdPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a tag
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsDelete: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('tagsDelete', 'name', name)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TAGS_DELETE"], configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all the tags
         * @param {string} [q] Search items by this string
         * @param {number} [count] Number of items to return
         * @param {string} [page] 
         * @param {boolean} [returnTotalCount] 
         * @param {boolean} [isCustomField] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet: async (q?: string, count?: number, page?: string, returnTotalCount?: boolean, isCustomField?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TAGS_READ"], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }

            if (isCustomField !== undefined) {
                localVarQueryParameter['isCustomField'] = isCustomField;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {TagsPatchRequest} [tagsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPatch: async (name: string, tagsPatchRequest?: TagsPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('tagsPatch', 'name', name)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TAGS_CREATE"], configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagsPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a tag
         * @param {string} name 
         * @param {TagsPostRequest} [tagsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPost: async (name: string, tagsPostRequest?: TagsPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('tagsPost', 'name', name)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TAGS_CREATE"], configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a tag
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsDelete(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsDelete(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all the tags
         * @param {string} [q] Search items by this string
         * @param {number} [count] Number of items to return
         * @param {string} [page] 
         * @param {boolean} [returnTotalCount] 
         * @param {boolean} [isCustomField] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsGet(q?: string, count?: number, page?: string, returnTotalCount?: boolean, isCustomField?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsGet(q, count, page, returnTotalCount, isCustomField, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name 
         * @param {TagsPatchRequest} [tagsPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsPatch(name: string, tagsPatchRequest?: TagsPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsPatch(name, tagsPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a tag
         * @param {string} name 
         * @param {TagsPostRequest} [tagsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsPost(name: string, tagsPostRequest?: TagsPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsPost(name, tagsPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a tag
         * @param {TagsApiTagsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsDelete(requestParameters: TagsApiTagsDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.tagsDelete(requestParameters.name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all the tags
         * @param {TagsApiTagsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet(requestParameters: TagsApiTagsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<TagsGet200Response> {
            return localVarFp.tagsGet(requestParameters.q, requestParameters.count, requestParameters.page, requestParameters.returnTotalCount, requestParameters.isCustomField, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TagsApiTagsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPatch(requestParameters: TagsApiTagsPatchRequest, options?: AxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.tagsPatch(requestParameters.name, requestParameters.tagsPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a tag
         * @param {TagsApiTagsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPost(requestParameters: TagsApiTagsPostRequest, options?: AxiosRequestConfig): AxiosPromise<Tag> {
            return localVarFp.tagsPost(requestParameters.name, requestParameters.tagsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for tagsDelete operation in TagsApi.
 * @export
 * @interface TagsApiTagsDeleteRequest
 */
export interface TagsApiTagsDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiTagsDelete
     */
    readonly name: string
}

/**
 * Request parameters for tagsGet operation in TagsApi.
 * @export
 * @interface TagsApiTagsGetRequest
 */
export interface TagsApiTagsGetRequest {
    /**
     * Search items by this string
     * @type {string}
     * @memberof TagsApiTagsGet
     */
    readonly q?: string

    /**
     * Number of items to return
     * @type {number}
     * @memberof TagsApiTagsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof TagsApiTagsGet
     */
    readonly page?: string

    /**
     * 
     * @type {boolean}
     * @memberof TagsApiTagsGet
     */
    readonly returnTotalCount?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TagsApiTagsGet
     */
    readonly isCustomField?: boolean
}

/**
 * Request parameters for tagsPatch operation in TagsApi.
 * @export
 * @interface TagsApiTagsPatchRequest
 */
export interface TagsApiTagsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiTagsPatch
     */
    readonly name: string

    /**
     * 
     * @type {TagsPatchRequest}
     * @memberof TagsApiTagsPatch
     */
    readonly tagsPatchRequest?: TagsPatchRequest
}

/**
 * Request parameters for tagsPost operation in TagsApi.
 * @export
 * @interface TagsApiTagsPostRequest
 */
export interface TagsApiTagsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof TagsApiTagsPost
     */
    readonly name: string

    /**
     * 
     * @type {TagsPostRequest}
     * @memberof TagsApiTagsPost
     */
    readonly tagsPostRequest?: TagsPostRequest
}

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a tag
     * @param {TagsApiTagsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsDelete(requestParameters: TagsApiTagsDeleteRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsDelete(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all the tags
     * @param {TagsApiTagsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsGet(requestParameters: TagsApiTagsGetRequest = {}, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsGet(requestParameters.q, requestParameters.count, requestParameters.page, requestParameters.returnTotalCount, requestParameters.isCustomField, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TagsApiTagsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsPatch(requestParameters: TagsApiTagsPatchRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsPatch(requestParameters.name, requestParameters.tagsPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a tag
     * @param {TagsApiTagsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsPost(requestParameters: TagsApiTagsPostRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsPost(requestParameters.name, requestParameters.tagsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a template on the platform
         * @param {string} accountId 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesDelete: async (accountId: string, templateId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('templatesDelete', 'accountId', accountId)
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('templatesDelete', 'templateId', templateId)
            const localVarPath = `/templates/{accountId}/{templateId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_CREATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit a template for review
         * @param {string} accountId 
         * @param {TemplatesSubmitForReviewRequest} [templatesSubmitForReviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesSubmitForReview: async (accountId: string, templatesSubmitForReviewRequest?: TemplatesSubmitForReviewRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('templatesSubmitForReview', 'accountId', accountId)
            const localVarPath = `/templates/{accountId}/submit-for-review`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templatesSubmitForReviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a template on the platform
         * @param {string} accountId 
         * @param {string} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesDelete(accountId: string, templateId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesDelete(accountId, templateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit a template for review
         * @param {string} accountId 
         * @param {TemplatesSubmitForReviewRequest} [templatesSubmitForReviewRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesSubmitForReview(accountId: string, templatesSubmitForReviewRequest?: TemplatesSubmitForReviewRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesSubmitForReview200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesSubmitForReview(accountId, templatesSubmitForReviewRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a template on the platform
         * @param {TemplatesApiTemplatesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesDelete(requestParameters: TemplatesApiTemplatesDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.templatesDelete(requestParameters.accountId, requestParameters.templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit a template for review
         * @param {TemplatesApiTemplatesSubmitForReviewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesSubmitForReview(requestParameters: TemplatesApiTemplatesSubmitForReviewRequest, options?: AxiosRequestConfig): AxiosPromise<TemplatesSubmitForReview200Response> {
            return localVarFp.templatesSubmitForReview(requestParameters.accountId, requestParameters.templatesSubmitForReviewRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for templatesDelete operation in TemplatesApi.
 * @export
 * @interface TemplatesApiTemplatesDeleteRequest
 */
export interface TemplatesApiTemplatesDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof TemplatesApiTemplatesDelete
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof TemplatesApiTemplatesDelete
     */
    readonly templateId: string
}

/**
 * Request parameters for templatesSubmitForReview operation in TemplatesApi.
 * @export
 * @interface TemplatesApiTemplatesSubmitForReviewRequest
 */
export interface TemplatesApiTemplatesSubmitForReviewRequest {
    /**
     * 
     * @type {string}
     * @memberof TemplatesApiTemplatesSubmitForReview
     */
    readonly accountId: string

    /**
     * 
     * @type {TemplatesSubmitForReviewRequest}
     * @memberof TemplatesApiTemplatesSubmitForReview
     */
    readonly templatesSubmitForReviewRequest?: TemplatesSubmitForReviewRequest
}

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * 
     * @summary Delete a template on the platform
     * @param {TemplatesApiTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesDelete(requestParameters: TemplatesApiTemplatesDeleteRequest, options?: AxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesDelete(requestParameters.accountId, requestParameters.templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit a template for review
     * @param {TemplatesApiTemplatesSubmitForReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templatesSubmitForReview(requestParameters: TemplatesApiTemplatesSubmitForReviewRequest, options?: AxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templatesSubmitForReview(requestParameters.accountId, requestParameters.templatesSubmitForReviewRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Verify and handle messaging webhook subscription
         * @param {string} hubMode The mode parameter from the webhook request
         * @param {string} hubVerifyToken The verify_token parameter from the webhook request
         * @param {string} hubChallenge The challenge parameter from the webhook request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookMessengerGet: async (hubMode: string, hubVerifyToken: string, hubChallenge: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hubMode' is not null or undefined
            assertParamExists('webhookMessengerGet', 'hubMode', hubMode)
            // verify required parameter 'hubVerifyToken' is not null or undefined
            assertParamExists('webhookMessengerGet', 'hubVerifyToken', hubVerifyToken)
            // verify required parameter 'hubChallenge' is not null or undefined
            assertParamExists('webhookMessengerGet', 'hubChallenge', hubChallenge)
            const localVarPath = `/messenger/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hubMode !== undefined) {
                localVarQueryParameter['hub.mode'] = hubMode;
            }

            if (hubVerifyToken !== undefined) {
                localVarQueryParameter['hub.verify_token'] = hubVerifyToken;
            }

            if (hubChallenge !== undefined) {
                localVarQueryParameter['hub.challenge'] = hubChallenge;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Receive a message from the platform
         * @param {string} [accountId] 
         * @param {WebhookMessengerPostRequest} [webhookMessengerPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookMessengerPost: async (accountId?: string, webhookMessengerPostRequest?: WebhookMessengerPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messenger/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookMessengerPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Verify and handle messaging webhook subscription
         * @param {string} hubMode The mode parameter from the webhook request
         * @param {string} hubVerifyToken The verify_token parameter from the webhook request
         * @param {string} hubChallenge The challenge parameter from the webhook request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookMessengerGet(hubMode: string, hubVerifyToken: string, hubChallenge: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookMessengerGet(hubMode, hubVerifyToken, hubChallenge, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Receive a message from the platform
         * @param {string} [accountId] 
         * @param {WebhookMessengerPostRequest} [webhookMessengerPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookMessengerPost(accountId?: string, webhookMessengerPostRequest?: WebhookMessengerPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookMessengerPost(accountId, webhookMessengerPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * 
         * @summary Verify and handle messaging webhook subscription
         * @param {WebhookApiWebhookMessengerGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookMessengerGet(requestParameters: WebhookApiWebhookMessengerGetRequest, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.webhookMessengerGet(requestParameters.hubMode, requestParameters.hubVerifyToken, requestParameters.hubChallenge, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Receive a message from the platform
         * @param {WebhookApiWebhookMessengerPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookMessengerPost(requestParameters: WebhookApiWebhookMessengerPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<AccountsLogout200Response> {
            return localVarFp.webhookMessengerPost(requestParameters.accountId, requestParameters.webhookMessengerPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for webhookMessengerGet operation in WebhookApi.
 * @export
 * @interface WebhookApiWebhookMessengerGetRequest
 */
export interface WebhookApiWebhookMessengerGetRequest {
    /**
     * The mode parameter from the webhook request
     * @type {string}
     * @memberof WebhookApiWebhookMessengerGet
     */
    readonly hubMode: string

    /**
     * The verify_token parameter from the webhook request
     * @type {string}
     * @memberof WebhookApiWebhookMessengerGet
     */
    readonly hubVerifyToken: string

    /**
     * The challenge parameter from the webhook request
     * @type {string}
     * @memberof WebhookApiWebhookMessengerGet
     */
    readonly hubChallenge: string
}

/**
 * Request parameters for webhookMessengerPost operation in WebhookApi.
 * @export
 * @interface WebhookApiWebhookMessengerPostRequest
 */
export interface WebhookApiWebhookMessengerPostRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhookApiWebhookMessengerPost
     */
    readonly accountId?: string

    /**
     * 
     * @type {WebhookMessengerPostRequest}
     * @memberof WebhookApiWebhookMessengerPost
     */
    readonly webhookMessengerPostRequest?: WebhookMessengerPostRequest
}

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * 
     * @summary Verify and handle messaging webhook subscription
     * @param {WebhookApiWebhookMessengerGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookMessengerGet(requestParameters: WebhookApiWebhookMessengerGetRequest, options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookMessengerGet(requestParameters.hubMode, requestParameters.hubVerifyToken, requestParameters.hubChallenge, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Receive a message from the platform
     * @param {WebhookApiWebhookMessengerPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookMessengerPost(requestParameters: WebhookApiWebhookMessengerPostRequest = {}, options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookMessengerPost(requestParameters.accountId, requestParameters.webhookMessengerPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


