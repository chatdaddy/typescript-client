const BASE_PATH = "https://api.chatdaddy.tech/bots".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Bots Service
 * Make, Get & Execute Bots
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError } from '../base';

/**
 * @type AccountIDSelector
 * @export
 */
export type AccountIDSelector = AccountIDSelectorOneOf | AccountIDSelectorOneOf1;

/**
 * Specify the exact accountID. Specify an array to round robin between the accounts
 * @export
 * @interface AccountIDSelectorOneOf
 */
export interface AccountIDSelectorOneOf {
    /**
     * 
     * @type {string}
     * @memberof AccountIDSelectorOneOf
     */
    'type': AccountIDSelectorOneOfTypeEnum;
    /**
     * 
     * @type {AccountIDSelectorOneOfValue}
     * @memberof AccountIDSelectorOneOf
     */
    'value': AccountIDSelectorOneOfValue;
}

export const AccountIDSelectorOneOfTypeEnum = {
    Exact: 'exact'
} as const;

export type AccountIDSelectorOneOfTypeEnum = typeof AccountIDSelectorOneOfTypeEnum[keyof typeof AccountIDSelectorOneOfTypeEnum];

/**
 * 
 * @export
 * @interface AccountIDSelectorOneOf1
 */
export interface AccountIDSelectorOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof AccountIDSelectorOneOf1
     */
    'type': AccountIDSelectorOneOf1TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountIDSelectorOneOf1
     */
    'value': string;
}

export const AccountIDSelectorOneOf1TypeEnum = {
    PropertyPath: 'propertyPath'
} as const;

export type AccountIDSelectorOneOf1TypeEnum = typeof AccountIDSelectorOneOf1TypeEnum[keyof typeof AccountIDSelectorOneOf1TypeEnum];

/**
 * @type AccountIDSelectorOneOfValue
 * @export
 */
export type AccountIDSelectorOneOfValue = Array<string> | string;

/**
 * 
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof Action
     */
    'botId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Action
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Action
     */
    'updatedAt': string;
    /**
     * Map from channel to external template provider status. Channel is the key and the value is the status of the template on the provider.
     * @type {{ [key: string]: ExternalTemplateProvider; }}
     * @memberof Action
     */
    'externalTemplate'?: { [key: string]: ExternalTemplateProvider; };
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    'id': string;
    /**
     * Name of the template
     * @type {string}
     * @memberof Action
     */
    'name': string;
    /**
     * 
     * @type {MessageObj}
     * @memberof Action
     */
    'message'?: MessageObj | null;
    /**
     * set the assignee on the contact
     * @type {string}
     * @memberof Action
     */
    'assignee'?: string | null;
    /**
     * Tags to set on this contact.
     * @type {Array<ActionContentTagsInner>}
     * @memberof Action
     */
    'tags'?: Array<ActionContentTagsInner> | null;
    /**
     * Array of UserId
     * @type {Array<string>}
     * @memberof Action
     */
    'notifyUsers'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Action
     * @deprecated
     */
    'webhooks'?: Array<string> | null;
    /**
     * 
     * @type {Array<WebhookItem>}
     * @memberof Action
     */
    'httpRequest'?: Array<WebhookItem> | null;
    /**
     * 
     * @type {Position}
     * @memberof Action
     */
    'position'?: Position | null;
    /**
     * 
     * @type {Position}
     * @memberof Action
     */
    'actionPosition'?: Position | null;
    /**
     * send in to remove the action
     * @type {boolean}
     * @memberof Action
     */
    'remove'?: boolean;
    /**
     * 
     * @type {FormRef}
     * @memberof Action
     */
    'formRef'?: FormRef | null;
    /**
     * 
     * @type {FormActionMetadata}
     * @memberof Action
     */
    'formActionMetadata'?: FormActionMetadata | null;
    /**
     * Type of the message being sent
     * @type {string}
     * @memberof Action
     */
    'messageType'?: ActionMessageTypeEnum;
    /**
     * Account ID of the sender
     * @type {string}
     * @memberof Action
     */
    'accountId'?: string;
    /**
     * 
     * @type {ActionContentZapierAction}
     * @memberof Action
     */
    'zapierAction'?: ActionContentZapierAction | null;
    /**
     * 
     * @type {AppAction}
     * @memberof Action
     */
    'app'?: AppAction;
}

export const ActionMessageTypeEnum = {
    Message: 'message',
    Email: 'email'
} as const;

export type ActionMessageTypeEnum = typeof ActionMessageTypeEnum[keyof typeof ActionMessageTypeEnum];

/**
 * 
 * @export
 * @interface ActionAllOf
 */
export interface ActionAllOf {
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof ActionAllOf
     */
    'botId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionAllOf
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionAllOf
     */
    'updatedAt': string;
    /**
     * Map from channel to external template provider status. Channel is the key and the value is the status of the template on the provider.
     * @type {{ [key: string]: ExternalTemplateProvider; }}
     * @memberof ActionAllOf
     */
    'externalTemplate'?: { [key: string]: ExternalTemplateProvider; };
}
/**
 * 
 * @export
 * @interface ActionAppConfig
 */
export interface ActionAppConfig {
    /**
     * 
     * @type {string}
     * @memberof ActionAppConfig
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ActionAppConfig
     */
    'title': string;
    /**
     * If true, the app requires an integration to be set up before it can be used
     * @type {boolean}
     * @memberof ActionAppConfig
     */
    'requiresIntegration'?: boolean;
    /**
     * 
     * @type {DisplayIcon}
     * @memberof ActionAppConfig
     */
    'icon'?: DisplayIcon;
    /**
     * 
     * @type {Array<DataProperty>}
     * @memberof ActionAppConfig
     */
    'inputProperties': Array<DataProperty>;
    /**
     * 
     * @type {Array<DataProperty>}
     * @memberof ActionAppConfig
     */
    'outputProperties': Array<DataProperty>;
    /**
     * Enable the feature for the specified domains. If empty, the feature will be enabled for all domains.
     * @type {Array<string>}
     * @memberof ActionAppConfig
     */
    'domains'?: Array<string>;
    /**
     * Article ID of helpkit article to be linked
     * @type {string}
     * @memberof ActionAppConfig
     */
    'helpkitId'?: string;
    /**
     * ID corresponding to which platforms an app node can be integrated with
     * @type {string}
     * @memberof ActionAppConfig
     */
    'appGroupId'?: string;
}
/**
 * 
 * @export
 * @interface ActionContent
 */
export interface ActionContent {
    /**
     * 
     * @type {string}
     * @memberof ActionContent
     */
    'id'?: string;
    /**
     * Name of the template
     * @type {string}
     * @memberof ActionContent
     */
    'name'?: string;
    /**
     * 
     * @type {MessageObj}
     * @memberof ActionContent
     */
    'message'?: MessageObj | null;
    /**
     * set the assignee on the contact
     * @type {string}
     * @memberof ActionContent
     */
    'assignee'?: string | null;
    /**
     * Tags to set on this contact.
     * @type {Array<ActionContentTagsInner>}
     * @memberof ActionContent
     */
    'tags'?: Array<ActionContentTagsInner> | null;
    /**
     * Array of UserId
     * @type {Array<string>}
     * @memberof ActionContent
     */
    'notifyUsers'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ActionContent
     * @deprecated
     */
    'webhooks'?: Array<string> | null;
    /**
     * 
     * @type {Array<WebhookItem>}
     * @memberof ActionContent
     */
    'httpRequest'?: Array<WebhookItem> | null;
    /**
     * 
     * @type {Position}
     * @memberof ActionContent
     */
    'position'?: Position | null;
    /**
     * 
     * @type {Position}
     * @memberof ActionContent
     */
    'actionPosition'?: Position | null;
    /**
     * send in to remove the action
     * @type {boolean}
     * @memberof ActionContent
     */
    'remove'?: boolean;
    /**
     * 
     * @type {FormRef}
     * @memberof ActionContent
     */
    'formRef'?: FormRef | null;
    /**
     * 
     * @type {FormActionMetadata}
     * @memberof ActionContent
     */
    'formActionMetadata'?: FormActionMetadata | null;
    /**
     * Type of the message being sent
     * @type {string}
     * @memberof ActionContent
     */
    'messageType'?: ActionContentMessageTypeEnum;
    /**
     * Account ID of the sender
     * @type {string}
     * @memberof ActionContent
     */
    'accountId'?: string;
    /**
     * 
     * @type {ActionContentZapierAction}
     * @memberof ActionContent
     */
    'zapierAction'?: ActionContentZapierAction | null;
    /**
     * 
     * @type {AppAction}
     * @memberof ActionContent
     */
    'app'?: AppAction;
}

export const ActionContentMessageTypeEnum = {
    Message: 'message',
    Email: 'email'
} as const;

export type ActionContentMessageTypeEnum = typeof ActionContentMessageTypeEnum[keyof typeof ActionContentMessageTypeEnum];

/**
 * 
 * @export
 * @interface ActionContentTagsInner
 */
export interface ActionContentTagsInner {
    /**
     * 
     * @type {string}
     * @memberof ActionContentTagsInner
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ActionContentTagsInner
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface ActionContentZapierAction
 */
export interface ActionContentZapierAction {
    /**
     * 
     * @type {string}
     * @memberof ActionContentZapierAction
     */
    'editZapPopupURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionContentZapierAction
     */
    'zapId'?: string;
}
/**
 * 
 * @export
 * @interface ActionExecuteCount
 */
export interface ActionExecuteCount {
    /**
     * ID of the action
     * @type {string}
     * @memberof ActionExecuteCount
     */
    'actionId': string;
    /**
     * ID of the previous action triggered before this action
     * @type {string}
     * @memberof ActionExecuteCount
     */
    'previousActionId': string;
    /**
     * Number of time this action is sent out to contacts
     * @type {number}
     * @memberof ActionExecuteCount
     */
    'count': number;
}
/**
 * called ActionExecuteDataType because it will clash with event repos ActionExecuteData if not
 * @export
 * @interface ActionExecuteDataType
 */
export interface ActionExecuteDataType {
    /**
     * 
     * @type {number}
     * @memberof ActionExecuteDataType
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ActionExecuteDataType
     */
    'actionId': string;
    /**
     * 
     * @type {string}
     * @memberof ActionExecuteDataType
     */
    'botId': string;
    /**
     * 
     * @type {string}
     * @memberof ActionExecuteDataType
     */
    'status'?: ActionExecuteDataTypeStatusEnum;
    /**
     * ID of the contact
     * @type {string}
     * @memberof ActionExecuteDataType
     */
    'contactId'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ActionExecuteDataType
     */
    'inputParameters'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ActionExecuteDataType
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionExecuteDataType
     */
    'createdAt'?: string;
    /**
     * 
     * @type {Array<ActionExecuteDataTypeMessagesInner>}
     * @memberof ActionExecuteDataType
     */
    'messages'?: Array<ActionExecuteDataTypeMessagesInner>;
    /**
     * 
     * @type {Array<ActionExecuteDataTypeMessagesInner>}
     * @memberof ActionExecuteDataType
     */
    'webhooks'?: Array<ActionExecuteDataTypeMessagesInner>;
    /**
     * 
     * @type {ActionExecuteDataTypeMessagesInner}
     * @memberof ActionExecuteDataType
     */
    'contact'?: ActionExecuteDataTypeMessagesInner;
    /**
     * 
     * @type {ActionExecuteDataTypeMessagesInner}
     * @memberof ActionExecuteDataType
     */
    'app'?: ActionExecuteDataTypeMessagesInner;
    /**
     * 
     * @type {boolean}
     * @memberof ActionExecuteDataType
     */
    'isStart'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ActionExecuteDataType
     */
    'isFinal'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ActionExecuteDataType
     */
    'previousActionId'?: string;
}

export const ActionExecuteDataTypeStatusEnum = {
    Pending: 'pending',
    Sent: 'sent',
    Failed: 'failed',
    Cancelled: 'cancelled'
} as const;

export type ActionExecuteDataTypeStatusEnum = typeof ActionExecuteDataTypeStatusEnum[keyof typeof ActionExecuteDataTypeStatusEnum];

/**
 * 
 * @export
 * @interface ActionExecuteDataTypeMessagesInner
 */
export interface ActionExecuteDataTypeMessagesInner {
    /**
     * 
     * @type {number}
     * @memberof ActionExecuteDataTypeMessagesInner
     */
    'statusCode': number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ActionExecuteDataTypeMessagesInner
     */
    'body'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ActionExternalTemplateCommand
 */
export interface ActionExternalTemplateCommand {
    /**
     * 
     * @type {Array<string>}
     * @memberof ActionExternalTemplateCommand
     */
    'actionIds': Array<string>;
    /**
     * 
     * @type {ActionExternalTemplateCommandCommand}
     * @memberof ActionExternalTemplateCommand
     */
    'command': ActionExternalTemplateCommandCommand;
}
/**
 * @type ActionExternalTemplateCommandCommand
 * @export
 */
export type ActionExternalTemplateCommandCommand = LinkExternalTemplateCommand | SubmitForReviewExternalTemplateCommand | UnlinkExternalTemplateCommand;

/**
 * 
 * @export
 * @interface ActionFireRecord
 */
export interface ActionFireRecord {
    /**
     * 
     * @type {number}
     * @memberof ActionFireRecord
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'actionId': string;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'botId': string;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'status'?: ActionFireRecordStatusEnum;
    /**
     * ID of the contact
     * @type {string}
     * @memberof ActionFireRecord
     */
    'contactId'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ActionFireRecord
     */
    'inputParameters'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'accountId'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionFireRecord
     */
    'createdAt'?: string;
    /**
     * 
     * @type {Array<ServiceResponse>}
     * @memberof ActionFireRecord
     */
    'messages'?: Array<ServiceResponse>;
    /**
     * 
     * @type {Array<ServiceResponse>}
     * @memberof ActionFireRecord
     */
    'webhooks'?: Array<ServiceResponse>;
    /**
     * 
     * @type {ServiceResponse}
     * @memberof ActionFireRecord
     */
    'contact'?: ServiceResponse;
    /**
     * 
     * @type {ServiceResponse}
     * @memberof ActionFireRecord
     */
    'app'?: ServiceResponse;
    /**
     * 
     * @type {boolean}
     * @memberof ActionFireRecord
     */
    'isStart'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ActionFireRecord
     */
    'isFinal'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'previousActionId'?: string;
}

export const ActionFireRecordStatusEnum = {
    Pending: 'pending',
    Sent: 'sent',
    Failed: 'failed',
    Cancelled: 'cancelled'
} as const;

export type ActionFireRecordStatusEnum = typeof ActionFireRecordStatusEnum[keyof typeof ActionFireRecordStatusEnum];

/**
 * @type ActionInteraction
 * @export
 */
export type ActionInteraction = ActionInteractionOneOf | ActionInteractionOneOf1 | ActionInteractionOneOf2 | ActionInteractionOneOf3;

/**
 * 
 * @export
 * @interface ActionInteractionBase
 */
export interface ActionInteractionBase {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionInteractionBase
     */
    'doneAt': string;
}
/**
 * 
 * @export
 * @interface ActionInteractionOneOf
 */
export interface ActionInteractionOneOf {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionInteractionOneOf
     */
    'doneAt': string;
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionOneOf
     */
    'type': ActionInteractionOneOfTypeEnum;
    /**
     * Error message
     * @type {string}
     * @memberof ActionInteractionOneOf
     */
    'message'?: string;
}

export const ActionInteractionOneOfTypeEnum = {
    Error: 'error'
} as const;

export type ActionInteractionOneOfTypeEnum = typeof ActionInteractionOneOfTypeEnum[keyof typeof ActionInteractionOneOfTypeEnum];

/**
 * 
 * @export
 * @interface ActionInteractionOneOf1
 */
export interface ActionInteractionOneOf1 {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionInteractionOneOf1
     */
    'doneAt': string;
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionOneOf1
     */
    'type': ActionInteractionOneOf1TypeEnum;
}

export const ActionInteractionOneOf1TypeEnum = {
    Sent: 'sent',
    Delivered: 'delivered'
} as const;

export type ActionInteractionOneOf1TypeEnum = typeof ActionInteractionOneOf1TypeEnum[keyof typeof ActionInteractionOneOf1TypeEnum];

/**
 * Action was simply sent out, no further interaction recorded
 * @export
 * @interface ActionInteractionOneOf1AllOf
 */
export interface ActionInteractionOneOf1AllOf {
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionOneOf1AllOf
     */
    'type': ActionInteractionOneOf1AllOfTypeEnum;
}

export const ActionInteractionOneOf1AllOfTypeEnum = {
    Sent: 'sent',
    Delivered: 'delivered'
} as const;

export type ActionInteractionOneOf1AllOfTypeEnum = typeof ActionInteractionOneOf1AllOfTypeEnum[keyof typeof ActionInteractionOneOf1AllOfTypeEnum];

/**
 * 
 * @export
 * @interface ActionInteractionOneOf2
 */
export interface ActionInteractionOneOf2 {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionInteractionOneOf2
     */
    'doneAt': string;
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionOneOf2
     */
    'type': ActionInteractionOneOf2TypeEnum;
    /**
     * Text of the button or list item that was clicked
     * @type {string}
     * @memberof ActionInteractionOneOf2
     */
    'text': string;
}

export const ActionInteractionOneOf2TypeEnum = {
    Click: 'click'
} as const;

export type ActionInteractionOneOf2TypeEnum = typeof ActionInteractionOneOf2TypeEnum[keyof typeof ActionInteractionOneOf2TypeEnum];

/**
 * Action was sent out and a button/list item was clicked
 * @export
 * @interface ActionInteractionOneOf2AllOf
 */
export interface ActionInteractionOneOf2AllOf {
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionOneOf2AllOf
     */
    'type': ActionInteractionOneOf2AllOfTypeEnum;
    /**
     * Text of the button or list item that was clicked
     * @type {string}
     * @memberof ActionInteractionOneOf2AllOf
     */
    'text': string;
}

export const ActionInteractionOneOf2AllOfTypeEnum = {
    Click: 'click'
} as const;

export type ActionInteractionOneOf2AllOfTypeEnum = typeof ActionInteractionOneOf2AllOfTypeEnum[keyof typeof ActionInteractionOneOf2AllOfTypeEnum];

/**
 * 
 * @export
 * @interface ActionInteractionOneOf3
 */
export interface ActionInteractionOneOf3 {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionInteractionOneOf3
     */
    'doneAt': string;
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionOneOf3
     */
    'type': ActionInteractionOneOf3TypeEnum;
    /**
     * 
     * @type {ActionInteractionOneOf3AllOfContent}
     * @memberof ActionInteractionOneOf3
     */
    'content': ActionInteractionOneOf3AllOfContent;
}

export const ActionInteractionOneOf3TypeEnum = {
    UserInput: 'user_input'
} as const;

export type ActionInteractionOneOf3TypeEnum = typeof ActionInteractionOneOf3TypeEnum[keyof typeof ActionInteractionOneOf3TypeEnum];

/**
 * Action was sent out and a user input was submitted
 * @export
 * @interface ActionInteractionOneOf3AllOf
 */
export interface ActionInteractionOneOf3AllOf {
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionOneOf3AllOf
     */
    'type': ActionInteractionOneOf3AllOfTypeEnum;
    /**
     * 
     * @type {ActionInteractionOneOf3AllOfContent}
     * @memberof ActionInteractionOneOf3AllOf
     */
    'content': ActionInteractionOneOf3AllOfContent;
}

export const ActionInteractionOneOf3AllOfTypeEnum = {
    UserInput: 'user_input'
} as const;

export type ActionInteractionOneOf3AllOfTypeEnum = typeof ActionInteractionOneOf3AllOfTypeEnum[keyof typeof ActionInteractionOneOf3AllOfTypeEnum];

/**
 * Content of the user input that was submitted
 * @export
 * @interface ActionInteractionOneOf3AllOfContent
 */
export interface ActionInteractionOneOf3AllOfContent {
    /**
     * Text of the user input
     * @type {string}
     * @memberof ActionInteractionOneOf3AllOfContent
     */
    'text'?: string;
    /**
     * Attachments of the user input
     * @type {Array<IMMessageAttachment>}
     * @memberof ActionInteractionOneOf3AllOfContent
     */
    'attachments'?: Array<IMMessageAttachment>;
}
/**
 * Action was simply sent out, no further interaction recorded
 * @export
 * @interface ActionInteractionOneOfAllOf
 */
export interface ActionInteractionOneOfAllOf {
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionOneOfAllOf
     */
    'type': ActionInteractionOneOfAllOfTypeEnum;
    /**
     * Error message
     * @type {string}
     * @memberof ActionInteractionOneOfAllOf
     */
    'message'?: string;
}

export const ActionInteractionOneOfAllOfTypeEnum = {
    Error: 'error'
} as const;

export type ActionInteractionOneOfAllOfTypeEnum = typeof ActionInteractionOneOfAllOfTypeEnum[keyof typeof ActionInteractionOneOfAllOfTypeEnum];

/**
 * 
 * @export
 * @interface ActionInteractionQueryItem
 */
export interface ActionInteractionQueryItem {
    /**
     * 
     * @type {ActionInteractionType}
     * @memberof ActionInteractionQueryItem
     */
    'type': ActionInteractionType;
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionQueryItem
     */
    'text'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ActionInteractionType = {
    Sent: 'sent',
    Delivered: 'delivered',
    Click: 'click',
    UserInput: 'user_input',
    Error: 'error',
    Scheduled: 'scheduled',
    Exists: 'exists'
} as const;

export type ActionInteractionType = typeof ActionInteractionType[keyof typeof ActionInteractionType];


/**
 * 
 * @export
 * @interface ActionTarget
 */
export interface ActionTarget {
    /**
     * 
     * @type {string}
     * @memberof ActionTarget
     */
    'triggerActionId': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof ActionTarget
     */
    'triggerBotId'?: string;
    /**
     * 
     * @type {Position}
     * @memberof ActionTarget
     */
    'position'?: Position | null;
}
/**
 * 
 * @export
 * @interface ActionsGet200Response
 */
export interface ActionsGet200Response {
    /**
     * 
     * @type {Array<Action>}
     * @memberof ActionsGet200Response
     */
    'actions': Array<Action>;
    /**
     * Name of the last record fetched
     * @type {string}
     * @memberof ActionsGet200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface ActionsGptGenerate200Response
 */
export interface ActionsGptGenerate200Response {
    /**
     * 
     * @type {Array<ActionContent>}
     * @memberof ActionsGptGenerate200Response
     */
    'actions': Array<ActionContent>;
}
/**
 * 
 * @export
 * @interface ActionsGptGenerateRequest
 */
export interface ActionsGptGenerateRequest {
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof ActionsGptGenerateRequest
     */
    'botId': string;
    /**
     * 
     * @type {string}
     * @memberof ActionsGptGenerateRequest
     */
    'actionId': string;
    /**
     * 
     * @type {Array<ActionContent>}
     * @memberof ActionsGptGenerateRequest
     */
    'actions': Array<ActionContent>;
    /**
     * 
     * @type {string}
     * @memberof ActionsGptGenerateRequest
     */
    'industry': string;
    /**
     * 
     * @type {string}
     * @memberof ActionsGptGenerateRequest
     */
    'additionalContext'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActionsGptGenerateRequest
     */
    'amount'?: number;
}
/**
 * 
 * @export
 * @interface AppAction
 */
export interface AppAction {
    /**
     * 
     * @type {string}
     * @memberof AppAction
     */
    'appId': string;
    /**
     * 
     * @type {string}
     * @memberof AppAction
     */
    'integrationId'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AppAction
     */
    'input': { [key: string]: any; };
    /**
     * 
     * @type {NextAction}
     * @memberof AppAction
     */
    'nextAction'?: NextAction;
}
/**
 * 
 * @export
 * @interface AppGroupConfig
 */
export interface AppGroupConfig {
    /**
     * ID corresponding to which platforms an app node can be integrated with
     * @type {string}
     * @memberof AppGroupConfig
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AppGroupConfig
     */
    'title': string;
    /**
     * 
     * @type {Array<DataProperty>}
     * @memberof AppGroupConfig
     */
    'integrationConfig': Array<DataProperty>;
}
/**
 * 
 * @export
 * @interface AppIntegration
 */
export interface AppIntegration {
    /**
     * 
     * @type {string}
     * @memberof AppIntegration
     */
    'name': string;
    /**
     * ID corresponding to which platforms an app node can be integrated with
     * @type {string}
     * @memberof AppIntegration
     */
    'appGroupId': string;
    /**
     * configures the authorization required. Pass additional props as needed.
     * @type {{ [key: string]: any; }}
     * @memberof AppIntegration
     */
    'config': { [key: string]: any; };
    /**
     * randomly generated id for an integration
     * @type {string}
     * @memberof AppIntegration
     */
    'id': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof AppIntegration
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof AppIntegration
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof AppIntegration
     */
    'teamId': string;
}
/**
 * 
 * @export
 * @interface AppIntegrationAllOf
 */
export interface AppIntegrationAllOf {
    /**
     * randomly generated id for an integration
     * @type {string}
     * @memberof AppIntegrationAllOf
     */
    'id': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof AppIntegrationAllOf
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof AppIntegrationAllOf
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof AppIntegrationAllOf
     */
    'teamId': string;
}
/**
 * 
 * @export
 * @interface AppIntegrationCreate
 */
export interface AppIntegrationCreate {
    /**
     * 
     * @type {string}
     * @memberof AppIntegrationCreate
     */
    'name': string;
    /**
     * ID corresponding to which platforms an app node can be integrated with
     * @type {string}
     * @memberof AppIntegrationCreate
     */
    'appGroupId': string;
    /**
     * configures the authorization required. Pass additional props as needed.
     * @type {{ [key: string]: any; }}
     * @memberof AppIntegrationCreate
     */
    'config': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface AppTriggerMethod
 */
export interface AppTriggerMethod {
    /**
     * 
     * @type {string}
     * @memberof AppTriggerMethod
     */
    'type': AppTriggerMethodTypeEnum;
    /**
     * 
     * @type {AppTriggerMethodData}
     * @memberof AppTriggerMethod
     */
    'data': AppTriggerMethodData;
}

export const AppTriggerMethodTypeEnum = {
    App: 'app'
} as const;

export type AppTriggerMethodTypeEnum = typeof AppTriggerMethodTypeEnum[keyof typeof AppTriggerMethodTypeEnum];

/**
 * 
 * @export
 * @interface AppTriggerMethodData
 */
export interface AppTriggerMethodData {
    /**
     * 
     * @type {string}
     * @memberof AppTriggerMethodData
     */
    'appId': string;
    /**
     * 
     * @type {string}
     * @memberof AppTriggerMethodData
     */
    'integrationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppTriggerMethodData
     */
    'secretId'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AppTriggerMethodData
     */
    'registrationOutput'?: { [key: string]: any; };
}
/**
 * Describe an array
 * @export
 * @interface ArrayPropertyDescriptor
 */
export interface ArrayPropertyDescriptor {
    /**
     * 
     * @type {string}
     * @memberof ArrayPropertyDescriptor
     */
    'type': ArrayPropertyDescriptorTypeEnum;
    /**
     * 
     * @type {DataPropertyDescriptor}
     * @memberof ArrayPropertyDescriptor
     */
    'items': DataPropertyDescriptor;
}

export const ArrayPropertyDescriptorTypeEnum = {
    Array: 'array'
} as const;

export type ArrayPropertyDescriptorTypeEnum = typeof ArrayPropertyDescriptorTypeEnum[keyof typeof ArrayPropertyDescriptorTypeEnum];

/**
 * 
 * @export
 * @interface BaseTriggerConfig
 */
export interface BaseTriggerConfig {
    /**
     * 
     * @type {string}
     * @memberof BaseTriggerConfig
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof BaseTriggerConfig
     */
    'description': string;
    /**
     * 
     * @type {DisplayIcon}
     * @memberof BaseTriggerConfig
     */
    'icon'?: DisplayIcon;
    /**
     * 
     * @type {TriggersUIConfig}
     * @memberof BaseTriggerConfig
     */
    'config': TriggersUIConfig;
    /**
     * Enable the feature for the specified domains. If empty, the feature will be enabled for all domains.
     * @type {Array<string>}
     * @memberof BaseTriggerConfig
     */
    'domains'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Bot
 */
export interface Bot {
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'name': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof Bot
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'teamId': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof Bot
     */
    'defaultAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'startingActionId'?: string | null;
    /**
     * 
     * @type {Array<Action>}
     * @memberof Bot
     */
    'actions'?: Array<Action>;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'folderId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'templateId'?: string | null;
    /**
     * If true, this bot is treated as a form
     * @type {boolean}
     * @memberof Bot
     */
    'isForm'?: boolean;
    /**
     * 
     * @type {BotExternalTemplateStatus}
     * @memberof Bot
     */
    'externalTemplateStatus'?: BotExternalTemplateStatus;
    /**
     * 
     * @type {any}
     * @memberof Bot
     */
    'externalTemplate'?: any;
    /**
     * URL of the thumbnail image
     * @type {string}
     * @memberof Bot
     */
    'imageUrl'?: string;
    /**
     * Description of the bot
     * @type {string}
     * @memberof Bot
     */
    'description'?: string;
    /**
     * Industry of the bot
     * @type {string}
     * @memberof Bot
     */
    'industry'?: string;
    /**
     * Industries of the bot
     * @type {Array<string>}
     * @memberof Bot
     */
    'industries'?: Array<string>;
    /**
     * 
     * @type {Array<BotTriggersInner>}
     * @memberof Bot
     */
    'triggers'?: Array<BotTriggersInner>;
    /**
     * Language of the bot
     * @type {string}
     * @memberof Bot
     */
    'language'?: string;
    /**
     * 
     * @type {Array<BotNote>}
     * @memberof Bot
     */
    'notes'?: Array<BotNote>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Bot
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Bot
     */
    'updatedAt': string;
    /**
     * ID of the user who created the bot
     * @type {string}
     * @memberof Bot
     */
    'createdBy': string;
    /**
     * Slugs which is generated and shared with other to view the message flow
     * @type {Array<SharedSlug>}
     * @memberof Bot
     */
    'sharedSlugs'?: Array<SharedSlug>;
    /**
     * Define variables that can be used in the bot. These variables can be used to replace parameters in the bot\'s actions. For any \"board\" type properties, any conditions can use the `board_path_stages` property to get the stages of the board as an array, assuming `board_path` is the property name of the board.
     * @type {Array<DataProperty>}
     * @memberof Bot
     */
    'properties'?: Array<DataProperty>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Bot
     */
    'propertyValues'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BotBoolCondition
 */
export interface BotBoolCondition {
    /**
     * 
     * @type {string}
     * @memberof BotBoolCondition
     */
    'propertyPath': string;
    /**
     * 
     * @type {string}
     * @memberof BotBoolCondition
     */
    'operator': BotBoolConditionOperatorEnum;
}

export const BotBoolConditionOperatorEnum = {
    IsTrue: 'isTrue',
    IsFalse: 'isFalse'
} as const;

export type BotBoolConditionOperatorEnum = typeof BotBoolConditionOperatorEnum[keyof typeof BotBoolConditionOperatorEnum];

/**
 * @type BotCondition
 * @export
 */
export type BotCondition = BotBoolCondition | BotEqualityCondition | BotLegacyCondition | BotNumericalCondition | BotTextCondition | BotTimeCondition | BotTimestampCondition;

/**
 * 
 * @export
 * @interface BotData
 */
export interface BotData {
    /**
     * 
     * @type {Array<BotTrigger>}
     * @memberof BotData
     */
    'triggers': Array<BotTrigger>;
    /**
     * 
     * @type {Array<Action>}
     * @memberof BotData
     */
    'actions': Array<Action>;
    /**
     * 
     * @type {Array<BotNote>}
     * @memberof BotData
     */
    'notes': Array<BotNote>;
}
/**
 * 
 * @export
 * @interface BotEqualityCondition
 */
export interface BotEqualityCondition {
    /**
     * 
     * @type {string}
     * @memberof BotEqualityCondition
     */
    'propertyPath': string;
    /**
     * 
     * @type {BotEqualityConditionValue}
     * @memberof BotEqualityCondition
     */
    'value': BotEqualityConditionValue;
    /**
     * 
     * @type {string}
     * @memberof BotEqualityCondition
     */
    'operator': BotEqualityConditionOperatorEnum;
}

export const BotEqualityConditionOperatorEnum = {
    Equals: 'equals',
    NotEquals: 'notEquals'
} as const;

export type BotEqualityConditionOperatorEnum = typeof BotEqualityConditionOperatorEnum[keyof typeof BotEqualityConditionOperatorEnum];

/**
 * @type BotEqualityConditionValue
 * @export
 */
export type BotEqualityConditionValue = Array<string> | number | string;

/**
 * @type BotExternalTemplateStatus
 * Status of the external template on the provider. If all actions belong to a particular status then this reflects that status. Otherwise, it\'ll be set to \"mixed\"
 * @export
 */
export type BotExternalTemplateStatus = ExternalTemplateStatus | string;

/**
 * Stores the record for whenever a bot is fired.
 * @export
 * @interface BotFireRecord
 */
export interface BotFireRecord {
    /**
     * 
     * @type {string}
     * @memberof BotFireRecord
     */
    'id': string;
    /**
     * ID of the contact
     * @type {string}
     * @memberof BotFireRecord
     */
    'contactId': string;
    /**
     * 
     * @type {string}
     * @memberof BotFireRecord
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof BotFireRecord
     */
    'botId': string;
    /**
     * 
     * @type {string}
     * @memberof BotFireRecord
     */
    'status': BotFireRecordStatusEnum;
    /**
     * ID of the user who fired the bot.
     * @type {string}
     * @memberof BotFireRecord
     */
    'createdBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotFireRecord
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotFireRecord
     */
    'updatedAt': string;
    /**
     * Map of all actions sent & interacted with during this instance. Keyed by action ID
     * @type {{ [key: string]: ActionInteraction; }}
     * @memberof BotFireRecord
     */
    'interactions': { [key: string]: ActionInteraction; };
    /**
     * 
     * @type {string}
     * @memberof BotFireRecord
     */
    'instanceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotFireRecord
     */
    'scheduledActionId'?: string;
}

export const BotFireRecordStatusEnum = {
    Scheduled: 'scheduled',
    Running: 'running',
    Completed: 'completed'
} as const;

export type BotFireRecordStatusEnum = typeof BotFireRecordStatusEnum[keyof typeof BotFireRecordStatusEnum];

/**
 * 
 * @export
 * @interface BotLegacyCondition
 */
export interface BotLegacyCondition {
    /**
     * 
     * @type {string}
     * @memberof BotLegacyCondition
     */
    'propertyPath': string;
    /**
     * 
     * @type {Array<BotLegacyConditionValuesInner>}
     * @memberof BotLegacyCondition
     */
    'values': Array<BotLegacyConditionValuesInner>;
    /**
     * 
     * @type {string}
     * @memberof BotLegacyCondition
     */
    'operator': BotLegacyConditionOperatorEnum;
}

export const BotLegacyConditionOperatorEnum = {
    NotEmpty: 'notEmpty',
    Equals: 'equals',
    NotEquals: 'notEquals',
    GreaterThan: 'greaterThan',
    LessThan: 'lessThan',
    GreaterThanOrEquals: 'greaterThanOrEquals',
    LessThanOrEquals: 'lessThanOrEquals',
    Contains: 'contains',
    NotContains: 'notContains',
    StartsWith: 'startsWith',
    EndsWith: 'endsWith'
} as const;

export type BotLegacyConditionOperatorEnum = typeof BotLegacyConditionOperatorEnum[keyof typeof BotLegacyConditionOperatorEnum];

/**
 * @type BotLegacyConditionValuesInner
 * @export
 */
export type BotLegacyConditionValuesInner = number | string;

/**
 * 
 * @export
 * @interface BotMessageButton
 */
export interface BotMessageButton {
    /**
     * 
     * @type {string}
     * @memberof BotMessageButton
     */
    'text': string;
    /**
     * Use \"nextAction\" instead
     * @type {string}
     * @memberof BotMessageButton
     * @deprecated
     */
    'triggerActionId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BotMessageButton
     */
    'triggerBotId'?: string | null;
    /**
     * Make a button with a link
     * @type {string}
     * @memberof BotMessageButton
     */
    'url'?: string;
    /**
     * Make a button with a phone number
     * @type {string}
     * @memberof BotMessageButton
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {Position}
     * @memberof BotMessageButton
     */
    'position'?: Position | null;
    /**
     * 
     * @type {NextAction}
     * @memberof BotMessageButton
     */
    'nextAction'?: NextAction;
}
/**
 * @type BotMessageDelay
 * @export
 */
export type BotMessageDelay = LegacyBotMessageDelay | SecondsBotMessageDelay | TimestampBotMessageDelay | WeekdayBotMessageDelay;

/**
 * 
 * @export
 * @interface BotMessageInput
 */
export interface BotMessageInput {
    /**
     * Name of the input. If not specified, the input received will be forwarded as the key \"value\" in the next action
     * @type {string}
     * @memberof BotMessageInput
     */
    'name'?: string;
    /**
     * 
     * @type {BotMessageInputValidation}
     * @memberof BotMessageInput
     */
    'validation'?: BotMessageInputValidation;
    /**
     * Use \"nextAction\" instead
     * @type {string}
     * @memberof BotMessageInput
     * @deprecated
     */
    'triggerActionId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BotMessageInput
     */
    'triggerBotId'?: string | null;
    /**
     * 
     * @type {NextAction}
     * @memberof BotMessageInput
     */
    'nextAction'?: NextAction;
    /**
     * 
     * @type {NextAction}
     * @memberof BotMessageInput
     */
    'validationFailAction'?: NextAction;
    /**
     * 
     * @type {Position}
     * @memberof BotMessageInput
     */
    'position'?: Position | null;
}
/**
 * 
 * @export
 * @interface BotMessageInputValidation
 */
export interface BotMessageInputValidation {
    /**
     * 
     * @type {string}
     * @memberof BotMessageInputValidation
     */
    'type': BotMessageInputValidationTypeEnum;
}

export const BotMessageInputValidationTypeEnum = {
    String: 'string',
    Integer: 'integer',
    Boolean: 'boolean',
    ImageAttachment: 'image_attachment',
    Attachment: 'attachment'
} as const;

export type BotMessageInputValidationTypeEnum = typeof BotMessageInputValidationTypeEnum[keyof typeof BotMessageInputValidationTypeEnum];

/**
 * 
 * @export
 * @interface BotMessageList
 */
export interface BotMessageList {
    /**
     * 
     * @type {string}
     * @memberof BotMessageList
     */
    'title'?: string;
    /**
     * 
     * @type {Array<BotMessageListSectionsInner>}
     * @memberof BotMessageList
     */
    'sections': Array<BotMessageListSectionsInner>;
    /**
     * 
     * @type {Position}
     * @memberof BotMessageList
     */
    'position'?: Position | null;
}
/**
 * 
 * @export
 * @interface BotMessageListSectionsInner
 */
export interface BotMessageListSectionsInner {
    /**
     * 
     * @type {string}
     * @memberof BotMessageListSectionsInner
     */
    'title': string;
    /**
     * 
     * @type {Array<BotMessageListSectionsInnerOptionsInner>}
     * @memberof BotMessageListSectionsInner
     */
    'options': Array<BotMessageListSectionsInnerOptionsInner>;
}
/**
 * 
 * @export
 * @interface BotMessageListSectionsInnerOptionsInner
 */
export interface BotMessageListSectionsInnerOptionsInner {
    /**
     * 
     * @type {string}
     * @memberof BotMessageListSectionsInnerOptionsInner
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof BotMessageListSectionsInnerOptionsInner
     */
    'description'?: string;
    /**
     * 
     * @type {NextAction}
     * @memberof BotMessageListSectionsInnerOptionsInner
     */
    'nextAction'?: NextAction;
}
/**
 * 
 * @export
 * @interface BotNote
 */
export interface BotNote {
    /**
     * 
     * @type {string}
     * @memberof BotNote
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotNote
     */
    'noteType'?: BotNoteNoteTypeEnum;
    /**
     * 
     * @type {Array<IMMessageAttachment>}
     * @memberof BotNote
     */
    'attachments'?: Array<IMMessageAttachment>;
    /**
     * 
     * @type {string}
     * @memberof BotNote
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotNote
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof BotNote
     */
    'height'?: number;
    /**
     * 
     * @type {number}
     * @memberof BotNote
     */
    'width'?: number;
    /**
     * 
     * @type {Array<BotNoteTargetsInner>}
     * @memberof BotNote
     */
    'targets'?: Array<BotNoteTargetsInner> | null;
    /**
     * 
     * @type {string}
     * @memberof BotNote
     */
    'color'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BotNote
     */
    'zIndex'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BotNote
     */
    'fillColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BotNote
     */
    'shapeType'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BotNote
     */
    'textStyles'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {Position}
     * @memberof BotNote
     */
    'position': Position | null;
    /**
     * send in to remove the note
     * @type {boolean}
     * @memberof BotNote
     */
    'remove'?: boolean;
}

export const BotNoteNoteTypeEnum = {
    Text: 'text',
    Image: 'image',
    Shape: 'shape'
} as const;

export type BotNoteNoteTypeEnum = typeof BotNoteNoteTypeEnum[keyof typeof BotNoteNoteTypeEnum];

/**
 * 
 * @export
 * @interface BotNoteTargetsInner
 */
export interface BotNoteTargetsInner {
    /**
     * 
     * @type {string}
     * @memberof BotNoteTargetsInner
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof BotNoteTargetsInner
     */
    'sourceHandle': string;
    /**
     * 
     * @type {string}
     * @memberof BotNoteTargetsInner
     */
    'targetHandle': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BotNoteTargetsInner
     */
    'edgeStyles'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BotNumericalCondition
 */
export interface BotNumericalCondition {
    /**
     * 
     * @type {string}
     * @memberof BotNumericalCondition
     */
    'propertyPath': string;
    /**
     * 
     * @type {number}
     * @memberof BotNumericalCondition
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof BotNumericalCondition
     */
    'operator': BotNumericalConditionOperatorEnum;
}

export const BotNumericalConditionOperatorEnum = {
    GreaterThan: 'greaterThan',
    LessThan: 'lessThan',
    GreaterThanOrEquals: 'greaterThanOrEquals',
    LessThanOrEquals: 'lessThanOrEquals'
} as const;

export type BotNumericalConditionOperatorEnum = typeof BotNumericalConditionOperatorEnum[keyof typeof BotNumericalConditionOperatorEnum];

/**
 * 
 * @export
 * @interface BotPatch
 */
export interface BotPatch {
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'startingActionId'?: string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof BotPatch
     */
    'defaultAccountId'?: string;
    /**
     * List of actions to upsert. Do not specify the ID to add a new action
     * @type {Array<ActionContent>}
     * @memberof BotPatch
     */
    'actions'?: Array<ActionContent>;
    /**
     * 
     * @type {Array<BotNote>}
     * @memberof BotPatch
     */
    'notes'?: Array<BotNote>;
    /**
     * 
     * @type {Array<TriggerUpsert>}
     * @memberof BotPatch
     */
    'triggers'?: Array<TriggerUpsert>;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'description'?: string;
    /**
     * Industry of the bot
     * @type {string}
     * @memberof BotPatch
     */
    'industry'?: string;
    /**
     * Industries of the bot
     * @type {Array<string>}
     * @memberof BotPatch
     */
    'industries'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'templateId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'folderId'?: string | null;
    /**
     * Define variables that can be used in the bot. These variables can be used to replace parameters in the bot\'s actions. For any \"board\" type properties, any conditions can use the `board_path_stages` property to get the stages of the board as an array, assuming `board_path` is the property name of the board.
     * @type {Array<DataProperty>}
     * @memberof BotPatch
     */
    'properties'?: Array<DataProperty>;
    /**
     * Values of the properties defined in the bot. These values can be used to replace parameters in the bot\'s actions. Will be validated against the schema defined in the properties
     * @type {{ [key: string]: any; }}
     * @memberof BotPatch
     */
    'propertyValues'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BotSharePatchRequest
 */
export interface BotSharePatchRequest {
    /**
     * If true, the slug can be edited. If false, the slug cannot be edited
     * @type {boolean}
     * @memberof BotSharePatchRequest
     */
    'editable': boolean;
}
/**
 * 
 * @export
 * @interface BotShareRequest
 */
export interface BotShareRequest {
    /**
     * 
     * @type {string}
     * @memberof BotShareRequest
     */
    'botId': string;
    /**
     * If true, the slug can be edited. If false, the slug cannot be edited
     * @type {boolean}
     * @memberof BotShareRequest
     */
    'editable': boolean;
    /**
     * Identity of the user to whom the slug was shared like email/phone. Will be null if type is public
     * @type {string}
     * @memberof BotShareRequest
     */
    'userIdentity'?: string;
    /**
     * 
     * @type {UserIdentityType}
     * @memberof BotShareRequest
     */
    'userIdentityType'?: UserIdentityType;
}


/**
 * 
 * @export
 * @interface BotTextCondition
 */
export interface BotTextCondition {
    /**
     * 
     * @type {string}
     * @memberof BotTextCondition
     */
    'propertyPath': string;
    /**
     * 
     * @type {string}
     * @memberof BotTextCondition
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof BotTextCondition
     */
    'operator': BotTextConditionOperatorEnum;
}

export const BotTextConditionOperatorEnum = {
    NotEmpty: 'notEmpty',
    Contains: 'contains',
    NotContains: 'notContains',
    StartsWith: 'startsWith',
    EndsWith: 'endsWith',
    ContainsPhrase: 'containsPhrase'
} as const;

export type BotTextConditionOperatorEnum = typeof BotTextConditionOperatorEnum[keyof typeof BotTextConditionOperatorEnum];

/**
 * 
 * @export
 * @interface BotTimeCondition
 */
export interface BotTimeCondition {
    /**
     * 
     * @type {string}
     * @memberof BotTimeCondition
     */
    'propertyPath': string;
    /**
     * 
     * @type {TimePeriodDescriptor}
     * @memberof BotTimeCondition
     */
    'value': TimePeriodDescriptor;
    /**
     * 
     * @type {string}
     * @memberof BotTimeCondition
     */
    'operator': BotTimeConditionOperatorEnum;
}

export const BotTimeConditionOperatorEnum = {
    Timestamp: 'timestamp'
} as const;

export type BotTimeConditionOperatorEnum = typeof BotTimeConditionOperatorEnum[keyof typeof BotTimeConditionOperatorEnum];

/**
 * 
 * @export
 * @interface BotTimestampCondition
 */
export interface BotTimestampCondition {
    /**
     * 
     * @type {string}
     * @memberof BotTimestampCondition
     */
    'propertyPath': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTimestampCondition
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof BotTimestampCondition
     */
    'operator': BotTimestampConditionOperatorEnum;
}

export const BotTimestampConditionOperatorEnum = {
    TimestampGreaterThan: 'timestampGreaterThan',
    TimestampLessThan: 'timestampLessThan'
} as const;

export type BotTimestampConditionOperatorEnum = typeof BotTimestampConditionOperatorEnum[keyof typeof BotTimestampConditionOperatorEnum];

/**
 * 
 * @export
 * @interface BotTrigger
 */
export interface BotTrigger {
    /**
     * 
     * @type {string}
     * @memberof BotTrigger
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof BotTrigger
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof BotTrigger
     */
    'name': string;
    /**
     * 
     * @type {NextAction}
     * @memberof BotTrigger
     */
    'action': NextAction;
    /**
     * 
     * @type {BotTriggerTarget}
     * @memberof BotTrigger
     */
    'target': BotTriggerTarget;
    /**
     * 
     * @type {BotTriggerOptions}
     * @memberof BotTrigger
     */
    'options': BotTriggerOptions;
    /**
     * 
     * @type {TriggerMethod}
     * @memberof BotTrigger
     */
    'method': TriggerMethod;
    /**
     * 
     * @type {boolean}
     * @memberof BotTrigger
     */
    'remove'?: boolean;
    /**
     * 
     * @type {Position}
     * @memberof BotTrigger
     */
    'position'?: Position | null;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof BotTrigger
     */
    'botId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTrigger
     */
    'lastTriggered'?: string;
    /**
     * 
     * @type {number}
     * @memberof BotTrigger
     */
    'triggered': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTrigger
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTrigger
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface BotTriggerAllOf
 */
export interface BotTriggerAllOf {
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof BotTriggerAllOf
     */
    'botId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTriggerAllOf
     */
    'lastTriggered'?: string;
    /**
     * 
     * @type {number}
     * @memberof BotTriggerAllOf
     */
    'triggered': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTriggerAllOf
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTriggerAllOf
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface BotTriggerContext
 */
export interface BotTriggerContext {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTriggerContext
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface BotTriggerInstance
 */
export interface BotTriggerInstance {
    /**
     * 
     * @type {string}
     * @memberof BotTriggerInstance
     */
    'id': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTriggerInstance
     */
    'createdAt': string;
    /**
     * 
     * @type {BotTriggerInstanceStatus}
     * @memberof BotTriggerInstance
     */
    'status': BotTriggerInstanceStatus;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BotTriggerInstance
     */
    'data': { [key: string]: any; };
    /**
     * 
     * @type {InstanceFirstActionStatusCounts}
     * @memberof BotTriggerInstance
     */
    'firstActionCounts': InstanceFirstActionStatusCounts;
    /**
     * 
     * @type {string}
     * @memberof BotTriggerInstance
     */
    'triggerId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTriggerInstance
     */
    'nextScheduledAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTriggerInstance
     */
    'completedAt'?: string;
    /**
     * 
     * @type {BotTriggerInstanceError}
     * @memberof BotTriggerInstance
     */
    'error'?: BotTriggerInstanceError;
    /**
     * 
     * @type {BotTriggerInstanceTrigger}
     * @memberof BotTriggerInstance
     */
    'trigger'?: BotTriggerInstanceTrigger;
}


/**
 * 
 * @export
 * @interface BotTriggerInstanceError
 */
export interface BotTriggerInstanceError {
    /**
     * 
     * @type {string}
     * @memberof BotTriggerInstanceError
     */
    'message': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BotTriggerInstanceStatus = {
    Running: 'running',
    Completed: 'completed',
    Stopped: 'stopped'
} as const;

export type BotTriggerInstanceStatus = typeof BotTriggerInstanceStatus[keyof typeof BotTriggerInstanceStatus];


/**
 * 
 * @export
 * @interface BotTriggerInstanceTrigger
 */
export interface BotTriggerInstanceTrigger {
    [key: string]: any;

    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof BotTriggerInstanceTrigger
     */
    'botId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotTriggerInstanceTrigger
     */
    'name'?: string;
    /**
     * 
     * @type {BotTriggerInstanceTriggerBot}
     * @memberof BotTriggerInstanceTrigger
     */
    'bot'?: BotTriggerInstanceTriggerBot;
}
/**
 * 
 * @export
 * @interface BotTriggerInstanceTriggerBot
 */
export interface BotTriggerInstanceTriggerBot {
    /**
     * 
     * @type {string}
     * @memberof BotTriggerInstanceTriggerBot
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface BotTriggerOptions
 */
export interface BotTriggerOptions {
    /**
     * 
     * @type {TriggerDelay}
     * @memberof BotTriggerOptions
     */
    'delay'?: TriggerDelay;
    /**
     * 
     * @type {MessageSendOptions}
     * @memberof BotTriggerOptions
     */
    'sendOptions'?: MessageSendOptions;
    /**
     * The interval in seconds between each message being sent.
     * @type {number}
     * @memberof BotTriggerOptions
     */
    'sendIntervalS'?: number;
    /**
     * 
     * @type {TimePeriodDescriptor}
     * @memberof BotTriggerOptions
     */
    'sendTimeRange'?: TimePeriodDescriptor;
    /**
     * 
     * @type {ThrottleOptions}
     * @memberof BotTriggerOptions
     */
    'perContactThrottle'?: ThrottleOptions;
}
/**
 * 
 * @export
 * @interface BotTriggerPayload
 */
export interface BotTriggerPayload {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BotTriggerPayload
     */
    'contact'?: { [key: string]: any; };
    /**
     * The data that is being sent to the bot. The data has the following properties
     * @type {{ [key: string]: any; }}
     * @memberof BotTriggerPayload
     */
    'data': { [key: string]: any; };
    /**
     * 
     * @type {BotTriggerContext}
     * @memberof BotTriggerPayload
     */
    'context': BotTriggerContext;
}
/**
 * @type BotTriggerTarget
 * @export
 */
export type BotTriggerTarget = ContactsQueryTarget | PropertyPathTarget;

/**
 * 
 * @export
 * @interface BotTriggersInner
 */
export interface BotTriggersInner {
    /**
     * 
     * @type {string}
     * @memberof BotTriggersInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BotTriggersInner
     */
    'name': string;
    /**
     * 
     * @type {TriggerMethod}
     * @memberof BotTriggersInner
     */
    'method': TriggerMethod;
}
/**
 * 
 * @export
 * @interface BotsAnalyticsGet200Response
 */
export interface BotsAnalyticsGet200Response {
    /**
     * 
     * @type {Array<ActionExecuteCount>}
     * @memberof BotsAnalyticsGet200Response
     */
    'counts': Array<ActionExecuteCount>;
}
/**
 * 
 * @export
 * @interface BotsBulkFire200Response
 */
export interface BotsBulkFire200Response {
    /**
     * 
     * @type {Array<ActionFireRecord>}
     * @memberof BotsBulkFire200Response
     */
    'records': Array<ActionFireRecord>;
}
/**
 * 
 * @export
 * @interface BotsBulkFireRequest
 */
export interface BotsBulkFireRequest {
    /**
     * Which account to use. If not specified here, it must be specified in each recipient
     * @type {string}
     * @memberof BotsBulkFireRequest
     */
    'accountId'?: string;
    /**
     * List of recipients to send the message to
     * @type {Array<Recipient>}
     * @memberof BotsBulkFireRequest
     */
    'recipients': Array<Recipient>;
    /**
     * 
     * @type {MessageSendOptions}
     * @memberof BotsBulkFireRequest
     */
    'messageSendOptions'?: MessageSendOptions;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BotsBulkFireRequest
     */
    'parameters'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BotsCreateRequest
 */
export interface BotsCreateRequest {
    /**
     * Specify the ID of the bot to be created. Has to be globally unique
     * @type {string}
     * @memberof BotsCreateRequest
     */
    'id'?: string;
    /**
     * The name of the bot to be created
     * @type {string}
     * @memberof BotsCreateRequest
     */
    'name'?: string;
    /**
     * If true, the bot will be a form. If false, the bot will not be a form
     * @type {boolean}
     * @memberof BotsCreateRequest
     */
    'isForm'?: boolean;
}
/**
 * 
 * @export
 * @interface BotsExternalTemplateCommand200Response
 */
export interface BotsExternalTemplateCommand200Response {
    /**
     * 
     * @type {ExternalTemplateProvider}
     * @memberof BotsExternalTemplateCommand200Response
     */
    'config': ExternalTemplateProvider;
}
/**
 * 
 * @export
 * @interface BotsFireRequest
 */
export interface BotsFireRequest {
    /**
     * Which account to use
     * @type {string}
     * @memberof BotsFireRequest
     */
    'accountId'?: string;
    /**
     * ID of the contact
     * @type {string}
     * @memberof BotsFireRequest
     */
    'toContact': string;
    /**
     * 
     * @type {MessageSendOptions}
     * @memberof BotsFireRequest
     */
    'messageSendOptions'?: MessageSendOptions;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BotsFireRequest
     */
    'parameters'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BotsGets200Response
 */
export interface BotsGets200Response {
    /**
     * 
     * @type {Array<Bot>}
     * @memberof BotsGets200Response
     */
    'bots': Array<Bot>;
    /**
     * Cursor to use to fetch next page of results
     * @type {string}
     * @memberof BotsGets200Response
     */
    'cursor'?: string;
    /**
     * total bots present with these filters. Only returned if returnTotalCount is true
     * @type {number}
     * @memberof BotsGets200Response
     */
    'totalCount'?: number;
}
/**
 * @type BotsGetsTriggerTypesParameter
 * @export
 */
export type BotsGetsTriggerTypesParameter = Array<TriggerMethodFilter> | TriggerMethodFilter;

/**
 * 
 * @export
 * @interface CalendarAuth200Response
 */
export interface CalendarAuth200Response {
    /**
     * 
     * @type {string}
     * @memberof CalendarAuth200Response
     */
    'refreshToken': string;
    /**
     * 
     * @type {string}
     * @memberof CalendarAuth200Response
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ConditionalPropertyOption
 */
export interface ConditionalPropertyOption {
    /**
     * Stringified value of the option.
     * @type {string}
     * @memberof ConditionalPropertyOption
     */
    'valueStr': string;
    /**
     * 
     * @type {string}
     * @memberof ConditionalPropertyOption
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface ContactsQueryTarget
 */
export interface ContactsQueryTarget {
    /**
     * 
     * @type {string}
     * @memberof ContactsQueryTarget
     */
    'type': ContactsQueryTargetTypeEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ContactsQueryTarget
     */
    'query': { [key: string]: any; };
    /**
     * 
     * @type {AccountIDSelector}
     * @memberof ContactsQueryTarget
     */
    'accountId'?: AccountIDSelector;
}

export const ContactsQueryTargetTypeEnum = {
    Query: 'query'
} as const;

export type ContactsQueryTargetTypeEnum = typeof ContactsQueryTargetTypeEnum[keyof typeof ContactsQueryTargetTypeEnum];

/**
 * Description of a property
 * @export
 * @interface DataProperty
 */
export type DataProperty = DataPropertyDescriptor & PropertyMetadata
/**
 * @type DataPropertyDescriptor
 * @export
 */
export type DataPropertyDescriptor = SimplePropertyDescriptor | ArrayPropertyDescriptor | MapPropertyDescriptor | OAuthPropertyDescriptor;

/**
 * 
 * @export
 * @enum {string}
 */

export const DayOfWeek = {
    Monday: 'Monday',
    Tuesday: 'Tuesday',
    Wednesday: 'Wednesday',
    Thursday: 'Thursday',
    Friday: 'Friday',
    Saturday: 'Saturday',
    Sunday: 'Sunday'
} as const;

export type DayOfWeek = typeof DayOfWeek[keyof typeof DayOfWeek];


/**
 * 
 * @export
 * @interface DisplayIcon
 */
export interface DisplayIcon {
    /**
     * Material symbol name
     * @type {string}
     * @memberof DisplayIcon
     */
    'name': string;
    /**
     * Color name, hex code or theme color
     * @type {string}
     * @memberof DisplayIcon
     */
    'color'?: string;
}
/**
 * 
 * @export
 * @interface ExternalTemplateProvider
 */
export interface ExternalTemplateProvider {
    /**
     * ID of the template on the provider
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'category': string;
    /**
     * Language of the template
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'language'?: string;
    /**
     * 
     * @type {ExternalTemplateStatus}
     * @memberof ExternalTemplateProvider
     */
    'status': ExternalTemplateStatus;
    /**
     * Details of the rejection, if rejected
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'rejectionDetails'?: string;
    /**
     * ID of the user who submitted the template
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'submittedBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'submittedAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'updatedAt': string;
    /**
     * If true, the template status is stale due to the message having been updated
     * @type {boolean}
     * @memberof ExternalTemplateProvider
     */
    'isStale'?: boolean;
}


/**
 * Status of the template on the provider
 * @export
 * @enum {string}
 */

export const ExternalTemplateStatus = {
    Pending: 'pending',
    Approved: 'approved',
    Rejected: 'rejected'
} as const;

export type ExternalTemplateStatus = typeof ExternalTemplateStatus[keyof typeof ExternalTemplateStatus];


/**
 * 
 * @export
 * @interface FireTriggerWebhook200Response
 */
export interface FireTriggerWebhook200Response {
    /**
     * 
     * @type {FireTriggerWebhook200ResponseInstance}
     * @memberof FireTriggerWebhook200Response
     */
    'instance': FireTriggerWebhook200ResponseInstance;
}
/**
 * The trigger instance that was created
 * @export
 * @interface FireTriggerWebhook200ResponseInstance
 */
export interface FireTriggerWebhook200ResponseInstance {
    /**
     * 
     * @type {string}
     * @memberof FireTriggerWebhook200ResponseInstance
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface Folder
 */
export interface Folder {
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'teamId': string;
    /**
     * 
     * @type {number}
     * @memberof Folder
     */
    'botCount': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Folder
     */
    'createdAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Folder
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface FolderCreateRequest
 */
export interface FolderCreateRequest {
    /**
     * Folder name
     * @type {string}
     * @memberof FolderCreateRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface FolderGet200Response
 */
export interface FolderGet200Response {
    /**
     * 
     * @type {Array<Folder>}
     * @memberof FolderGet200Response
     */
    'folders': Array<Folder>;
    /**
     * Cursor to use to fetch next page of results
     * @type {string}
     * @memberof FolderGet200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface FolderUpdateRequest
 */
export interface FolderUpdateRequest {
    /**
     * Folder name
     * @type {string}
     * @memberof FolderUpdateRequest
     */
    'name'?: string;
    /**
     * Bot IDs to add to the folder
     * @type {Array<FolderUpdateRequestBotIdsInner>}
     * @memberof FolderUpdateRequest
     */
    'botIds'?: Array<FolderUpdateRequestBotIdsInner>;
}
/**
 * 
 * @export
 * @interface FolderUpdateRequestBotIdsInner
 */
export interface FolderUpdateRequestBotIdsInner {
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof FolderUpdateRequestBotIdsInner
     */
    'botId': string;
    /**
     * If true, remove the bot from the folder
     * @type {boolean}
     * @memberof FolderUpdateRequestBotIdsInner
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface FormActionMetadata
 */
export interface FormActionMetadata {
    /**
     * If true, the field is required
     * @type {boolean}
     * @memberof FormActionMetadata
     */
    'required'?: boolean;
    /**
     * Type of the field
     * @type {string}
     * @memberof FormActionMetadata
     */
    'type'?: FormActionMetadataTypeEnum;
    /**
     * Index of the field
     * @type {number}
     * @memberof FormActionMetadata
     */
    'index'?: number;
    /**
     * Custom field to save the value to
     * @type {string}
     * @memberof FormActionMetadata
     */
    'saveToCustomField'?: string;
}

export const FormActionMetadataTypeEnum = {
    Text: 'text',
    Number: 'number',
    Date: 'date',
    Select: 'select',
    Multiselect: 'multiselect',
    Rating: 'rating',
    Nps: 'nps',
    Time: 'time'
} as const;

export type FormActionMetadataTypeEnum = typeof FormActionMetadataTypeEnum[keyof typeof FormActionMetadataTypeEnum];

/**
 * 
 * @export
 * @interface FormActions
 */
export interface FormActions {
    /**
     * 
     * @type {NextAction}
     * @memberof FormActions
     */
    'onSubmit'?: NextAction;
    /**
     * 
     * @type {NextAction}
     * @memberof FormActions
     */
    'onAbandon'?: NextAction;
}
/**
 * 
 * @export
 * @interface FormDataGet200Response
 */
export interface FormDataGet200Response {
    /**
     * 
     * @type {Array<Action>}
     * @memberof FormDataGet200Response
     */
    'actions': Array<Action>;
    /**
     * 
     * @type {Bot}
     * @memberof FormDataGet200Response
     */
    'form'?: Bot;
    /**
     * 
     * @type {FormSubmission}
     * @memberof FormDataGet200Response
     */
    'submission': FormSubmission;
}
/**
 * 
 * @export
 * @interface FormRef
 */
export interface FormRef {
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof FormRef
     */
    'id': string;
    /**
     * 
     * @type {FormActions}
     * @memberof FormRef
     */
    'actions'?: FormActions;
    /**
     * 
     * @type {Position}
     * @memberof FormRef
     */
    'position'?: Position | null;
}
/**
 * 
 * @export
 * @interface FormSubmission
 */
export interface FormSubmission {
    /**
     * 
     * @type {string}
     * @memberof FormSubmission
     */
    'id': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof FormSubmission
     */
    'botId': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof FormSubmission
     */
    'accountId'?: string;
    /**
     * ID of the contact
     * @type {string}
     * @memberof FormSubmission
     */
    'contactId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof FormSubmission
     */
    'createdAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof FormSubmission
     */
    'startedAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof FormSubmission
     */
    'updatedAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof FormSubmission
     */
    'submittedAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof FormSubmission
     */
    'abandonedAt'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FormSubmission
     */
    'fields'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof FormSubmission
     */
    'lastSubmittedActionId'?: string;
    /**
     * 
     * @type {FormSubmissionSource}
     * @memberof FormSubmission
     */
    'source'?: FormSubmissionSource;
}
/**
 * 
 * @export
 * @interface FormSubmissionCreate200Response
 */
export interface FormSubmissionCreate200Response {
    /**
     * ID of the submission
     * @type {string}
     * @memberof FormSubmissionCreate200Response
     */
    'submissionId': string;
}
/**
 * 
 * @export
 * @interface FormSubmissionCreateRequest
 */
export interface FormSubmissionCreateRequest {
    /**
     * Phone number of the submitter
     * @type {string}
     * @memberof FormSubmissionCreateRequest
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof FormSubmissionCreateRequest
     */
    'captchaToken': string;
}
/**
 * 
 * @export
 * @interface FormSubmissionSource
 */
export interface FormSubmissionSource {
    /**
     * 
     * @type {string}
     * @memberof FormSubmissionSource
     */
    'actionId': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof FormSubmissionSource
     */
    'botId': string;
}
/**
 * 
 * @export
 * @interface FormSubmissionUpdate
 */
export interface FormSubmissionUpdate {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FormSubmissionUpdate
     */
    'fields'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface FormSubmissionsGet200Response
 */
export interface FormSubmissionsGet200Response {
    /**
     * 
     * @type {Array<FormSubmission>}
     * @memberof FormSubmissionsGet200Response
     */
    'submissions': Array<FormSubmission>;
    /**
     * Cursor to use to fetch next page of results
     * @type {string}
     * @memberof FormSubmissionsGet200Response
     */
    'cursor'?: string;
    /**
     * total submissions present with these filters.
     * @type {number}
     * @memberof FormSubmissionsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface GetActionFireRecords200Response
 */
export interface GetActionFireRecords200Response {
    /**
     * 
     * @type {Array<ActionFireRecord>}
     * @memberof GetActionFireRecords200Response
     */
    'records': Array<ActionFireRecord>;
    /**
     * Name of the last record fetched
     * @type {string}
     * @memberof GetActionFireRecords200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface GetBotFireRecords200Response
 */
export interface GetBotFireRecords200Response {
    /**
     * 
     * @type {Array<BotFireRecord>}
     * @memberof GetBotFireRecords200Response
     */
    'items': Array<BotFireRecord>;
    /**
     * 
     * @type {string}
     * @memberof GetBotFireRecords200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetBotFireRecords200Response
     */
    'total'?: number;
}
/**
 * @type GetBotFireRecordsContactsParameter
 * @export
 */
export type GetBotFireRecordsContactsParameter = Array<IMUniqueContactID> | IMUniqueContactID;

/**
 * 
 * @export
 * @interface GetTriggerInstances200Response
 */
export interface GetTriggerInstances200Response {
    /**
     * 
     * @type {Array<BotTriggerInstance>}
     * @memberof GetTriggerInstances200Response
     */
    'items': Array<BotTriggerInstance>;
    /**
     * Cursor to use to fetch next page of results
     * @type {string}
     * @memberof GetTriggerInstances200Response
     */
    'nextPageCursor'?: string;
    /**
     * total bots present with these filters. Only returned if returnTotalCount is true
     * @type {number}
     * @memberof GetTriggerInstances200Response
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface GetTriggerInstancesDateRageParameter
 */
export interface GetTriggerInstancesDateRageParameter {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof GetTriggerInstancesDateRageParameter
     */
    'from'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof GetTriggerInstancesDateRageParameter
     */
    'to'?: string;
}
/**
 * 
 * @export
 * @interface IMMessageAttachment
 */
export interface IMMessageAttachment {
    /**
     * 
     * @type {IMMessageAttachmentType}
     * @memberof IMMessageAttachment
     */
    'type': IMMessageAttachmentType;
    /**
     * MIME type of the attachment
     * @type {string}
     * @memberof IMMessageAttachment
     */
    'mimetype': string;
    /**
     * 
     * @type {boolean}
     * @memberof IMMessageAttachment
     */
    'isGif'?: boolean;
    /**
     * Public URL of the attachment, also it will allow variable attachment which will start with \'{{\' and end with \'}}\' or \'data:;base64\'
     * @type {string}
     * @memberof IMMessageAttachment
     */
    'url': string;
    /**
     * thumbnail of sticker/video/image
     * @type {string}
     * @memberof IMMessageAttachment
     */
    'jpegThumbnail'?: string | null;
    /**
     * duration of audio/video message
     * @type {number}
     * @memberof IMMessageAttachment
     */
    'seconds'?: number;
    /**
     * name of the doc message
     * @type {string}
     * @memberof IMMessageAttachment
     */
    'filename'?: string;
    /**
     * push to text feature
     * @type {boolean}
     * @memberof IMMessageAttachment
     */
    'pttAudio'?: boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const IMMessageAttachmentType = {
    Image: 'image',
    Video: 'video',
    Contact: 'contact',
    Sticker: 'sticker',
    Audio: 'audio',
    Document: 'document',
    Location: 'location'
} as const;

export type IMMessageAttachmentType = typeof IMMessageAttachmentType[keyof typeof IMMessageAttachmentType];


/**
 * 
 * @export
 * @interface IMMessageProduct
 */
export interface IMMessageProduct {
    /**
     * 
     * @type {string}
     * @memberof IMMessageProduct
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof IMMessageProduct
     */
    'accountId': string;
}
/**
 * Optional context about the sender of the message
 * @export
 * @interface IMMessageSenderContext
 */
export interface IMMessageSenderContext {
    /**
     * 
     * @type {string}
     * @memberof IMMessageSenderContext
     */
    'type': IMMessageSenderContextTypeEnum;
    /**
     * ID of the object that sent the message. For example, the campaign ID or keyword reply ID
     * @type {string}
     * @memberof IMMessageSenderContext
     */
    'objectId': string;
    /**
     * Name of the object that sent the message. For example, the campaign name or keyword reply name
     * @type {string}
     * @memberof IMMessageSenderContext
     */
    'objectName'?: string;
}

export const IMMessageSenderContextTypeEnum = {
    KeywordReply: 'keyword-reply',
    DefaultReply: 'default-reply',
    Campaigns: 'campaigns',
    Notifications: 'notifications',
    Bot: 'bot',
    AiChatbot: 'ai-chatbot',
    Trigger: 'trigger'
} as const;

export type IMMessageSenderContextTypeEnum = typeof IMMessageSenderContextTypeEnum[keyof typeof IMMessageSenderContextTypeEnum];

/**
 * 
 * @export
 * @interface IMUniqueContactID
 */
export interface IMUniqueContactID {
    /**
     * ID of the contact
     * @type {string}
     * @memberof IMUniqueContactID
     */
    'id': string;
    /**
     * ID of the account
     * @type {string}
     * @memberof IMUniqueContactID
     */
    'accountId': string;
}
/**
 * Describes how many contacts are in each status for the first action sent in a trigger instance. Keyed by ActionInteractionType
 * @export
 * @interface InstanceFirstActionStatusCounts
 */
export interface InstanceFirstActionStatusCounts {
    /**
     * 
     * @type {number}
     * @memberof InstanceFirstActionStatusCounts
     */
    'scheduled'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceFirstActionStatusCounts
     */
    'sent'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceFirstActionStatusCounts
     */
    'delivered'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceFirstActionStatusCounts
     */
    'error'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceFirstActionStatusCounts
     */
    'click'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceFirstActionStatusCounts
     */
    'user_input'?: number;
}
/**
 * 
 * @export
 * @interface IntegrationsGet200Response
 */
export interface IntegrationsGet200Response {
    /**
     * 
     * @type {Array<AppIntegration>}
     * @memberof IntegrationsGet200Response
     */
    'items': Array<AppIntegration>;
}
/**
 * 
 * @export
 * @interface InternalEventTriggerMethod
 */
export interface InternalEventTriggerMethod {
    /**
     * 
     * @type {string}
     * @memberof InternalEventTriggerMethod
     */
    'type': InternalEventTriggerMethodTypeEnum;
    /**
     * 
     * @type {InternalEventTriggerMethodData}
     * @memberof InternalEventTriggerMethod
     */
    'data': InternalEventTriggerMethodData;
}

export const InternalEventTriggerMethodTypeEnum = {
    InternalEvent: 'internal_event'
} as const;

export type InternalEventTriggerMethodTypeEnum = typeof InternalEventTriggerMethodTypeEnum[keyof typeof InternalEventTriggerMethodTypeEnum];

/**
 * 
 * @export
 * @interface InternalEventTriggerMethodData
 */
export interface InternalEventTriggerMethodData {
    /**
     * 
     * @type {string}
     * @memberof InternalEventTriggerMethodData
     */
    'event': string;
    /**
     * Useful for \'order-insert\' event, to specify the service type of the integration. This\'ll help distinguish which conditions to display in the UI
     * @type {string}
     * @memberof InternalEventTriggerMethodData
     */
    'serviceType'?: string;
}
/**
 * 
 * @export
 * @interface InternalEventUIConfig
 */
export interface InternalEventUIConfig {
    /**
     * 
     * @type {string}
     * @memberof InternalEventUIConfig
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof InternalEventUIConfig
     */
    'description': string;
    /**
     * 
     * @type {DisplayIcon}
     * @memberof InternalEventUIConfig
     */
    'icon'?: DisplayIcon;
    /**
     * 
     * @type {TriggersUIConfig}
     * @memberof InternalEventUIConfig
     */
    'config': TriggersUIConfig;
    /**
     * Enable the feature for the specified domains. If empty, the feature will be enabled for all domains.
     * @type {Array<string>}
     * @memberof InternalEventUIConfig
     */
    'domains'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InternalEventUIConfig
     */
    'event': string;
    /**
     * Article ID of helpkit article to be linked
     * @type {string}
     * @memberof InternalEventUIConfig
     */
    'helpkitId'?: string;
}
/**
 * 
 * @export
 * @interface InternalEventUIConfigAllOf
 */
export interface InternalEventUIConfigAllOf {
    /**
     * 
     * @type {string}
     * @memberof InternalEventUIConfigAllOf
     */
    'event': string;
    /**
     * Article ID of helpkit article to be linked
     * @type {string}
     * @memberof InternalEventUIConfigAllOf
     */
    'helpkitId'?: string;
}
/**
 * 
 * @export
 * @interface LegacyBotMessageDelay
 */
export interface LegacyBotMessageDelay {
    /**
     * Time delays on second
     * @type {number}
     * @memberof LegacyBotMessageDelay
     */
    'timeDelaySec': number;
    /**
     * 
     * @type {Position}
     * @memberof LegacyBotMessageDelay
     */
    'position'?: Position | null;
    /**
     * Use \"nextAction\" instead
     * @type {string}
     * @memberof LegacyBotMessageDelay
     * @deprecated
     */
    'triggerActionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof LegacyBotMessageDelay
     */
    'triggerBotId'?: string | null;
    /**
     * Simulate typing
     * @type {boolean}
     * @memberof LegacyBotMessageDelay
     */
    'simulateTyping'?: boolean;
    /**
     * If true, the message will be cancelled if a reply is received
     * @type {boolean}
     * @memberof LegacyBotMessageDelay
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * 
     * @type {NextAction}
     * @memberof LegacyBotMessageDelay
     */
    'nextAction'?: NextAction;
}
/**
 * 
 * @export
 * @interface LinkExternalTemplateCommand
 */
export interface LinkExternalTemplateCommand {
    /**
     * 
     * @type {string}
     * @memberof LinkExternalTemplateCommand
     */
    'type': LinkExternalTemplateCommandTypeEnum;
    /**
     * ID of the external template
     * @type {string}
     * @memberof LinkExternalTemplateCommand
     */
    'templateId': string;
    /**
     * ISO Language code of the template
     * @type {string}
     * @memberof LinkExternalTemplateCommand
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkExternalTemplateCommand
     */
    'category': string;
}

export const LinkExternalTemplateCommandTypeEnum = {
    Link: 'link'
} as const;

export type LinkExternalTemplateCommandTypeEnum = typeof LinkExternalTemplateCommandTypeEnum[keyof typeof LinkExternalTemplateCommandTypeEnum];

/**
 * Describe a map
 * @export
 * @interface MapPropertyDescriptor
 */
export interface MapPropertyDescriptor {
    /**
     * 
     * @type {string}
     * @memberof MapPropertyDescriptor
     */
    'type': MapPropertyDescriptorTypeEnum;
    /**
     * 
     * @type {Array<DataProperty>}
     * @memberof MapPropertyDescriptor
     */
    'properties': Array<DataProperty>;
    /**
     * 
     * @type {DataPropertyDescriptor}
     * @memberof MapPropertyDescriptor
     */
    'additionalProperties'?: DataPropertyDescriptor;
}

export const MapPropertyDescriptorTypeEnum = {
    Map: 'map'
} as const;

export type MapPropertyDescriptorTypeEnum = typeof MapPropertyDescriptorTypeEnum[keyof typeof MapPropertyDescriptorTypeEnum];

/**
 * 
 * @export
 * @interface MessageObj
 */
export interface MessageObj {
    /**
     * the template message itself
     * @type {string}
     * @memberof MessageObj
     */
    'text': string | null;
    /**
     * array of attachments for the template
     * @type {Array<IMMessageAttachment>}
     * @memberof MessageObj
     */
    'attachments'?: Array<IMMessageAttachment>;
    /**
     * 
     * @type {Array<BotMessageButton>}
     * @memberof MessageObj
     */
    'buttons'?: Array<BotMessageButton>;
    /**
     * 
     * @type {Array<BotMessageDelay>}
     * @memberof MessageObj
     */
    'delays'?: Array<BotMessageDelay>;
    /**
     * 
     * @type {BotMessageInput}
     * @memberof MessageObj
     */
    'input'?: BotMessageInput;
    /**
     * 
     * @type {BotMessageList}
     * @memberof MessageObj
     */
    'list'?: BotMessageList;
    /**
     * 
     * @type {string}
     * @memberof MessageObj
     */
    'quoted'?: string;
    /**
     * 
     * @type {Array<IMMessageProduct>}
     * @memberof MessageObj
     */
    'products'?: Array<IMMessageProduct>;
    /**
     * the subject of the message, if applicable
     * @type {string}
     * @memberof MessageObj
     */
    'subject'?: string;
    /**
     * 
     * @type {MinMessageSendOptions}
     * @memberof MessageObj
     */
    'defaultSendOptions'?: MinMessageSendOptions;
}
/**
 * Optional parameters to send a message
 * @export
 * @interface MessageSendOptions
 */
export interface MessageSendOptions {
    /**
     * 
     * @type {string}
     * @memberof MessageSendOptions
     */
    'messageId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MessageSendOptions
     */
    'simulateTyping'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MessageSendOptions
     */
    'requireOpenAccount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MessageSendOptions
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageSendOptions
     */
    'scheduleAt'?: string;
    /**
     * Forwards option to IM service
     * @type {boolean}
     * @memberof MessageSendOptions
     */
    'includeMarketingMessage'?: boolean;
    /**
     * 
     * @type {MessageSendOptionsQuoted}
     * @memberof MessageSendOptions
     */
    'quoted'?: MessageSendOptionsQuoted;
    /**
     * 
     * @type {MessageSendOptionsSender}
     * @memberof MessageSendOptions
     */
    'sender'?: MessageSendOptionsSender;
}
/**
 * 
 * @export
 * @interface MessageSendOptionsQuoted
 */
export interface MessageSendOptionsQuoted {
    /**
     * 
     * @type {string}
     * @memberof MessageSendOptionsQuoted
     */
    'chatId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageSendOptionsQuoted
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface MessageSendOptionsSender
 */
export interface MessageSendOptionsSender {
    /**
     * 
     * @type {IMMessageSenderContext}
     * @memberof MessageSendOptionsSender
     */
    'context': IMMessageSenderContext;
}
/**
 * Minimal default send options for the message
 * @export
 * @interface MinMessageSendOptions
 */
export interface MinMessageSendOptions {
    /**
     * 
     * @type {boolean}
     * @memberof MinMessageSendOptions
     */
    'simulateTyping'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MinMessageSendOptions
     */
    'cancelIfReplyReceived'?: boolean;
}
/**
 * Specify the next action to be fired
 * @export
 * @interface NextAction
 */
export interface NextAction {
    /**
     * 
     * @type {NextActionDefaultAction}
     * @memberof NextAction
     */
    'defaultAction'?: NextActionDefaultAction;
    /**
     * List of conditions to validate
     * @type {Array<NextActionGroupsInner>}
     * @memberof NextAction
     */
    'groups'?: Array<NextActionGroupsInner>;
    /**
     * 
     * @type {Position}
     * @memberof NextAction
     */
    'position'?: Position | null;
}
/**
 * Fired if all validations failed or no validations are provided
 * @export
 * @interface NextActionDefaultAction
 */
export interface NextActionDefaultAction {
    /**
     * 
     * @type {string}
     * @memberof NextActionDefaultAction
     */
    'triggerActionId': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof NextActionDefaultAction
     */
    'triggerBotId'?: string;
    /**
     * 
     * @type {Position}
     * @memberof NextActionDefaultAction
     */
    'position'?: Position | null;
}
/**
 * 
 * @export
 * @interface NextActionGroupsInner
 */
export interface NextActionGroupsInner {
    /**
     * Operator for all validations
     * @type {string}
     * @memberof NextActionGroupsInner
     */
    'operator': NextActionGroupsInnerOperatorEnum;
    /**
     * Fields to validate
     * @type {Array<BotCondition>}
     * @memberof NextActionGroupsInner
     */
    'validation': Array<BotCondition>;
    /**
     * 
     * @type {NextActionGroupsInnerTarget}
     * @memberof NextActionGroupsInner
     */
    'target': NextActionGroupsInnerTarget;
}

export const NextActionGroupsInnerOperatorEnum = {
    And: 'and',
    Or: 'or'
} as const;

export type NextActionGroupsInnerOperatorEnum = typeof NextActionGroupsInnerOperatorEnum[keyof typeof NextActionGroupsInnerOperatorEnum];

/**
 * Action to fire if all validations pass
 * @export
 * @interface NextActionGroupsInnerTarget
 */
export interface NextActionGroupsInnerTarget {
    /**
     * 
     * @type {string}
     * @memberof NextActionGroupsInnerTarget
     */
    'triggerActionId': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof NextActionGroupsInnerTarget
     */
    'triggerBotId'?: string;
    /**
     * 
     * @type {Position}
     * @memberof NextActionGroupsInnerTarget
     */
    'position'?: Position | null;
}
/**
 * describe OAuth input for access tokens
 * @export
 * @interface OAuthPropertyDescriptor
 */
export interface OAuthPropertyDescriptor {
    /**
     * 
     * @type {string}
     * @memberof OAuthPropertyDescriptor
     */
    'type': OAuthPropertyDescriptorTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OAuthPropertyDescriptor
     */
    'url'?: string;
}

export const OAuthPropertyDescriptorTypeEnum = {
    Oauth: 'oauth'
} as const;

export type OAuthPropertyDescriptorTypeEnum = typeof OAuthPropertyDescriptorTypeEnum[keyof typeof OAuthPropertyDescriptorTypeEnum];

/**
 * 
 * @export
 * @interface PatchBotBySlugRequest
 */
export interface PatchBotBySlugRequest {
    /**
     * 
     * @type {BotPatch}
     * @memberof PatchBotBySlugRequest
     */
    'patchData': BotPatch;
}
/**
 * position in x-y coordinate space
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'y': number;
}
/**
 * 
 * @export
 * @interface PropertyMetadata
 */
export interface PropertyMetadata {
    /**
     * 
     * @type {string}
     * @memberof PropertyMetadata
     */
    'propertyPath': string;
    /**
     * 
     * @type {string}
     * @memberof PropertyMetadata
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PropertyMetadata
     */
    'description'?: string;
    /**
     * 
     * @type {DisplayIcon}
     * @memberof PropertyMetadata
     */
    'icon'?: DisplayIcon;
    /**
     * Is the property always expected to be present.
     * @type {boolean}
     * @memberof PropertyMetadata
     */
    'required'?: boolean;
}
/**
 * Target a property in the payload data. Use dot notation for nested properties. Please note, this is inside the `data` object of the payload, so avoid the `data.` prefix.
 * @export
 * @interface PropertyPathTarget
 */
export interface PropertyPathTarget {
    /**
     * 
     * @type {string}
     * @memberof PropertyPathTarget
     */
    'type': PropertyPathTargetTypeEnum;
    /**
     * Path of the property to access in the payload data. Use dot notation for nested properties. Please note, this is inside the `data` object of the payload, so avoid the `data.` prefix.
     * @type {string}
     * @memberof PropertyPathTarget
     */
    'propertyPath': string;
    /**
     * 
     * @type {AccountIDSelector}
     * @memberof PropertyPathTarget
     */
    'accountId'?: AccountIDSelector;
}

export const PropertyPathTargetTypeEnum = {
    PropertyPath: 'propertyPath'
} as const;

export type PropertyPathTargetTypeEnum = typeof PropertyPathTargetTypeEnum[keyof typeof PropertyPathTargetTypeEnum];

/**
 * Provide either a property path to extract from the payload /payload data or an exact value
 * @export
 * @interface PropertyPathValue
 */
export interface PropertyPathValue {
    /**
     * 
     * @type {string}
     * @memberof PropertyPathValue
     */
    'type': PropertyPathValueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PropertyPathValue
     */
    'value': string;
}

export const PropertyPathValueTypeEnum = {
    PropertyPath: 'propertyPath',
    Exact: 'exact'
} as const;

export type PropertyPathValueTypeEnum = typeof PropertyPathValueTypeEnum[keyof typeof PropertyPathValueTypeEnum];

/**
 * Options provided here will override the global options provided in the botsFire request
 * @export
 * @interface Recipient
 */
export interface Recipient {
    /**
     * ID of the account to send from
     * @type {string}
     * @memberof Recipient
     */
    'accountId'?: string;
    /**
     * ID of the contact
     * @type {string}
     * @memberof Recipient
     */
    'id': string;
    /**
     * 
     * @type {MessageSendOptions}
     * @memberof Recipient
     */
    'sendOptions'?: MessageSendOptions;
    /**
     * Parameters to replace in text. These can also be used to build conditions, as they\'ll be set on the \"data\" property of the payload. Internally, an app will set the parameters of a recipient with its output 
     * @type {{ [key: string]: any; }}
     * @memberof Recipient
     */
    'parameters'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface SecondsBotMessageDelay
 */
export interface SecondsBotMessageDelay {
    /**
     * 
     * @type {string}
     * @memberof SecondsBotMessageDelay
     */
    'type': SecondsBotMessageDelayTypeEnum;
    /**
     * Delay in seconds
     * @type {number}
     * @memberof SecondsBotMessageDelay
     */
    'value': number;
    /**
     * 
     * @type {Position}
     * @memberof SecondsBotMessageDelay
     */
    'position'?: Position | null;
    /**
     * Simulate typing
     * @type {boolean}
     * @memberof SecondsBotMessageDelay
     */
    'simulateTyping'?: boolean;
    /**
     * If true, the message will be cancelled if a reply is received
     * @type {boolean}
     * @memberof SecondsBotMessageDelay
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * 
     * @type {NextAction}
     * @memberof SecondsBotMessageDelay
     */
    'nextAction'?: NextAction;
}

export const SecondsBotMessageDelayTypeEnum = {
    DelaySeconds: 'delay_seconds'
} as const;

export type SecondsBotMessageDelayTypeEnum = typeof SecondsBotMessageDelayTypeEnum[keyof typeof SecondsBotMessageDelayTypeEnum];

/**
 * 
 * @export
 * @interface ServiceResponse
 */
export interface ServiceResponse {
    /**
     * 
     * @type {number}
     * @memberof ServiceResponse
     */
    'statusCode': number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ServiceResponse
     */
    'body'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface SharedSlug
 */
export interface SharedSlug {
    /**
     * 
     * @type {string}
     * @memberof SharedSlug
     */
    'slug': string;
    /**
     * 
     * @type {boolean}
     * @memberof SharedSlug
     */
    'editable': boolean;
    /**
     * ID of the user who shared the slug
     * @type {string}
     * @memberof SharedSlug
     */
    'sharedBy': string;
    /**
     * Identity of the user to whom the slug was shared like email/phone. Will be null if type is public
     * @type {string}
     * @memberof SharedSlug
     */
    'userIdentity'?: string | null;
    /**
     * 
     * @type {UserIdentityType}
     * @memberof SharedSlug
     */
    'userIdentityType'?: UserIdentityType;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof SharedSlug
     */
    'createdAt': string;
}


/**
 * Simple string/number/boolean type
 * @export
 * @interface SimplePropertyDescriptor
 */
export interface SimplePropertyDescriptor {
    /**
     * 
     * @type {SimplePropertyType}
     * @memberof SimplePropertyDescriptor
     */
    'type': SimplePropertyType;
    /**
     * 
     * @type {Array<ConditionalPropertyOption>}
     * @memberof SimplePropertyDescriptor
     */
    'options'?: Array<ConditionalPropertyOption>;
    /**
     * Format of the property.  Only valid for string type. For example, \'date-time\' for timestamp properties
     * @type {string}
     * @memberof SimplePropertyDescriptor
     */
    'format'?: string;
    /**
     * Minimum number of stages required in the board for the condition to be valid. Only valid for \"board\" type
     * @type {number}
     * @memberof SimplePropertyDescriptor
     */
    'minimumStages'?: number;
}


/**
 * Type of property. - string, number, boolean: Simple property type - timestamp: timestamp string in ISO format - timezone: timezone in offset format - time: time in 24 hour format - channel, tag, team_member, chat, board_stage, board, ticket:     Reference to another object by ID - custom_field: Object of type { name: string, value: string } - duration: integer representing seconds - credit_consumption_type: all credit consumption types 
 * @export
 * @enum {string}
 */

export const SimplePropertyType = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean',
    Channel: 'channel',
    Tag: 'tag',
    CustomField: 'custom_field',
    Timestamp: 'timestamp',
    CountryCode: 'country_code',
    TeamMember: 'team_member',
    Chat: 'chat',
    BoardStage: 'board_stage',
    Duration: 'duration',
    Ticket: 'ticket',
    Board: 'board',
    Oauth: 'oauth',
    Timezone: 'timezone',
    Time: 'time',
    CreditConsumptionType: 'credit_consumption_type'
} as const;

export type SimplePropertyType = typeof SimplePropertyType[keyof typeof SimplePropertyType];


/**
 * 
 * @export
 * @interface SimulateActionExecuteResult200Response
 */
export interface SimulateActionExecuteResult200Response {
    /**
     * 
     * @type {string}
     * @memberof SimulateActionExecuteResult200Response
     */
    'event'?: SimulateActionExecuteResult200ResponseEventEnum;
    /**
     * 
     * @type {Array<ActionExecuteDataType>}
     * @memberof SimulateActionExecuteResult200Response
     */
    'data'?: Array<ActionExecuteDataType>;
}

export const SimulateActionExecuteResult200ResponseEventEnum = {
    ActionExecute: 'action-execute'
} as const;

export type SimulateActionExecuteResult200ResponseEventEnum = typeof SimulateActionExecuteResult200ResponseEventEnum[keyof typeof SimulateActionExecuteResult200ResponseEventEnum];

/**
 * 
 * @export
 * @interface StoreCreateRequest
 */
export interface StoreCreateRequest {
    /**
     * 
     * @type {StoreCreateRequestValues}
     * @memberof StoreCreateRequest
     */
    'values': StoreCreateRequestValues;
    /**
     * yaml file of boat
     * @type {string}
     * @memberof StoreCreateRequest
     */
    'botFileUrl': string;
    /**
     * User Name for the store
     * @type {string}
     * @memberof StoreCreateRequest
     */
    'userName': string;
    /**
     * Language for the store
     * @type {string}
     * @memberof StoreCreateRequest
     */
    'language': string;
    /**
     * Image Url for the store
     * @type {string}
     * @memberof StoreCreateRequest
     */
    'imageUrl': string;
}
/**
 * 
 * @export
 * @interface StoreCreateRequestValues
 */
export interface StoreCreateRequestValues {
    /**
     * Name of Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'templateName': string;
    /**
     * Category of Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'templateCategory': string;
    /**
     * Name of Bot Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'botTemplate': string;
    /**
     * Image of Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'image': string;
    /**
     * Description of Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface StoreGet200Response
 */
export interface StoreGet200Response {
    /**
     * 
     * @type {Array<TemplateItem>}
     * @memberof StoreGet200Response
     */
    'templates': Array<TemplateItem>;
    /**
     * Cursor to fetch the next page
     * @type {string}
     * @memberof StoreGet200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface SubmitForReviewExternalTemplateCommand
 */
export interface SubmitForReviewExternalTemplateCommand {
    /**
     * 
     * @type {string}
     * @memberof SubmitForReviewExternalTemplateCommand
     */
    'type': SubmitForReviewExternalTemplateCommandTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SubmitForReviewExternalTemplateCommand
     */
    'category': string;
    /**
     * Language of the template
     * @type {string}
     * @memberof SubmitForReviewExternalTemplateCommand
     */
    'language': string;
}

export const SubmitForReviewExternalTemplateCommandTypeEnum = {
    SubmitForReview: 'submit-for-review'
} as const;

export type SubmitForReviewExternalTemplateCommandTypeEnum = typeof SubmitForReviewExternalTemplateCommandTypeEnum[keyof typeof SubmitForReviewExternalTemplateCommandTypeEnum];

/**
 * 
 * @export
 * @interface SubmitFormRequest
 */
export interface SubmitFormRequest {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SubmitFormRequest
     */
    'fields': { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof SubmitFormRequest
     */
    'finalizeSubmission'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TemplateCommand = {
    SubmitForReview: 'submit-for-review',
    Link: 'link',
    Unlink: 'unlink'
} as const;

export type TemplateCommand = typeof TemplateCommand[keyof typeof TemplateCommand];


/**
 * 
 * @export
 * @interface TemplateItem
 */
export interface TemplateItem {
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'yamlFileUrl': string;
}
/**
 * 
 * @export
 * @interface TemplateStatusUpdateRequest
 */
export interface TemplateStatusUpdateRequest {
    /**
     * 
     * @type {Array<TemplateStatusUpdateRequestTemplatesInner>}
     * @memberof TemplateStatusUpdateRequest
     */
    'templates': Array<TemplateStatusUpdateRequestTemplatesInner>;
}
/**
 * 
 * @export
 * @interface TemplateStatusUpdateRequestTemplatesInner
 */
export interface TemplateStatusUpdateRequestTemplatesInner {
    /**
     * ID of the template
     * @type {string}
     * @memberof TemplateStatusUpdateRequestTemplatesInner
     */
    'id': string;
    /**
     * Status of the template
     * @type {string}
     * @memberof TemplateStatusUpdateRequestTemplatesInner
     */
    'status': TemplateStatusUpdateRequestTemplatesInnerStatusEnum;
    /**
     * Reason for rejection of the template
     * @type {string}
     * @memberof TemplateStatusUpdateRequestTemplatesInner
     */
    'rejectionReason': string;
}

export const TemplateStatusUpdateRequestTemplatesInnerStatusEnum = {
    Fail: 'fail',
    Pass: 'pass'
} as const;

export type TemplateStatusUpdateRequestTemplatesInnerStatusEnum = typeof TemplateStatusUpdateRequestTemplatesInnerStatusEnum[keyof typeof TemplateStatusUpdateRequestTemplatesInnerStatusEnum];

/**
 * Options to throttle the number of messages sent in a time period. By default, for per contact throttling -- the minimum is 1 trigger per 30 seconds
 * @export
 * @interface ThrottleOptions
 */
export interface ThrottleOptions {
    /**
     * The maximum number of messages that can be sent in the time period
     * @type {number}
     * @memberof ThrottleOptions
     */
    'maximum': number;
    /**
     * The time period in seconds in which the maximum number of messages can be sent
     * @type {number}
     * @memberof ThrottleOptions
     */
    'intervalS': number;
}
/**
 * 
 * @export
 * @interface TimePeriodDescriptor
 */
export interface TimePeriodDescriptor {
    /**
     * 
     * @type {Array<DayOfWeek>}
     * @memberof TimePeriodDescriptor
     */
    'days'?: Array<DayOfWeek>;
    /**
     * 
     * @type {string}
     * @memberof TimePeriodDescriptor
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof TimePeriodDescriptor
     */
    'endTime': string;
    /**
     * 
     * @type {string}
     * @memberof TimePeriodDescriptor
     */
    'timezone': string;
}
/**
 * 
 * @export
 * @interface TimestampBotMessageDelay
 */
export interface TimestampBotMessageDelay {
    /**
     * 
     * @type {string}
     * @memberof TimestampBotMessageDelay
     */
    'type': TimestampBotMessageDelayTypeEnum;
    /**
     * 
     * @type {PropertyPathValue}
     * @memberof TimestampBotMessageDelay
     */
    'value': PropertyPathValue;
    /**
     * 
     * @type {Position}
     * @memberof TimestampBotMessageDelay
     */
    'position'?: Position | null;
    /**
     * Simulate typing
     * @type {boolean}
     * @memberof TimestampBotMessageDelay
     */
    'simulateTyping'?: boolean;
    /**
     * If true, the message will be cancelled if a reply is received
     * @type {boolean}
     * @memberof TimestampBotMessageDelay
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * 
     * @type {NextAction}
     * @memberof TimestampBotMessageDelay
     */
    'nextAction'?: NextAction;
}

export const TimestampBotMessageDelayTypeEnum = {
    Timestamp: 'timestamp'
} as const;

export type TimestampBotMessageDelayTypeEnum = typeof TimestampBotMessageDelayTypeEnum[keyof typeof TimestampBotMessageDelayTypeEnum];

/**
 * 
 * @export
 * @interface TimestampedTriggerMethod
 */
export interface TimestampedTriggerMethod {
    /**
     * 
     * @type {string}
     * @memberof TimestampedTriggerMethod
     */
    'type': TimestampedTriggerMethodTypeEnum;
    /**
     * 
     * @type {TimestampedTriggerMethodData}
     * @memberof TimestampedTriggerMethod
     */
    'data': TimestampedTriggerMethodData;
}

export const TimestampedTriggerMethodTypeEnum = {
    Timestamp: 'timestamp'
} as const;

export type TimestampedTriggerMethodTypeEnum = typeof TimestampedTriggerMethodTypeEnum[keyof typeof TimestampedTriggerMethodTypeEnum];

/**
 * 
 * @export
 * @interface TimestampedTriggerMethodData
 */
export interface TimestampedTriggerMethodData {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TimestampedTriggerMethodData
     */
    'startDate': string;
    /**
     * 
     * @type {TimestampedTriggerMethodDataRecurring}
     * @memberof TimestampedTriggerMethodData
     */
    'recurring'?: TimestampedTriggerMethodDataRecurring;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TimestampedTriggerMethodData
     */
    'nextExecutionDate'?: string;
}
/**
 * 
 * @export
 * @interface TimestampedTriggerMethodDataRecurring
 */
export interface TimestampedTriggerMethodDataRecurring {
    /**
     * 
     * @type {number}
     * @memberof TimestampedTriggerMethodDataRecurring
     */
    'intervalMinutes': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TimestampedTriggerMethodDataRecurring
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface TriggerAppConfig
 */
export interface TriggerAppConfig {
    /**
     * 
     * @type {string}
     * @memberof TriggerAppConfig
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof TriggerAppConfig
     */
    'description': string;
    /**
     * 
     * @type {DisplayIcon}
     * @memberof TriggerAppConfig
     */
    'icon'?: DisplayIcon;
    /**
     * 
     * @type {TriggersUIConfig}
     * @memberof TriggerAppConfig
     */
    'config': TriggersUIConfig;
    /**
     * Enable the feature for the specified domains. If empty, the feature will be enabled for all domains.
     * @type {Array<string>}
     * @memberof TriggerAppConfig
     */
    'domains'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TriggerAppConfig
     */
    'appId': string;
    /**
     * 
     * @type {Array<DataProperty>}
     * @memberof TriggerAppConfig
     */
    'registrationOutputProperties': Array<DataProperty>;
    /**
     * Article ID of helpkit article to be linked
     * @type {string}
     * @memberof TriggerAppConfig
     */
    'helpkitId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TriggerAppConfig
     */
    'appGroupId'?: string;
}
/**
 * 
 * @export
 * @interface TriggerAppConfigAllOf
 */
export interface TriggerAppConfigAllOf {
    /**
     * 
     * @type {string}
     * @memberof TriggerAppConfigAllOf
     */
    'appId': string;
    /**
     * 
     * @type {Array<DataProperty>}
     * @memberof TriggerAppConfigAllOf
     */
    'registrationOutputProperties': Array<DataProperty>;
    /**
     * Article ID of helpkit article to be linked
     * @type {string}
     * @memberof TriggerAppConfigAllOf
     */
    'helpkitId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TriggerAppConfigAllOf
     */
    'appGroupId'?: string;
}
/**
 * @type TriggerDelay
 * @export
 */
export type TriggerDelay = TriggerDelayOneOf | TriggerDelayOneOf1 | TriggerDelayOneOf2;

/**
 * 
 * @export
 * @interface TriggerDelayOneOf
 */
export interface TriggerDelayOneOf {
    /**
     * 
     * @type {string}
     * @memberof TriggerDelayOneOf
     */
    'type': TriggerDelayOneOfTypeEnum;
    /**
     * The delay in seconds before the action is triggered
     * @type {number}
     * @memberof TriggerDelayOneOf
     */
    'value': number;
    /**
     * 
     * @type {Position}
     * @memberof TriggerDelayOneOf
     */
    'position'?: Position | null;
}

export const TriggerDelayOneOfTypeEnum = {
    DelaySeconds: 'delay_seconds'
} as const;

export type TriggerDelayOneOfTypeEnum = typeof TriggerDelayOneOfTypeEnum[keyof typeof TriggerDelayOneOfTypeEnum];

/**
 * Specify a property path to extract the delay from the payload data, or an exact timestamp value. The property path is relative to the \"payload data\".
 * @export
 * @interface TriggerDelayOneOf1
 */
export interface TriggerDelayOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof TriggerDelayOneOf1
     */
    'type': TriggerDelayOneOf1TypeEnum;
    /**
     * 
     * @type {PropertyPathValue}
     * @memberof TriggerDelayOneOf1
     */
    'value': PropertyPathValue;
    /**
     * 
     * @type {Position}
     * @memberof TriggerDelayOneOf1
     */
    'position'?: Position | null;
}

export const TriggerDelayOneOf1TypeEnum = {
    Timestamp: 'timestamp'
} as const;

export type TriggerDelayOneOf1TypeEnum = typeof TriggerDelayOneOf1TypeEnum[keyof typeof TriggerDelayOneOf1TypeEnum];

/**
 * Specify a weekday with time to set the delay to that particualar days
 * @export
 * @interface TriggerDelayOneOf2
 */
export interface TriggerDelayOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof TriggerDelayOneOf2
     */
    'type': TriggerDelayOneOf2TypeEnum;
    /**
     * 
     * @type {WeekdayDelayValue}
     * @memberof TriggerDelayOneOf2
     */
    'value': WeekdayDelayValue;
    /**
     * 
     * @type {Position}
     * @memberof TriggerDelayOneOf2
     */
    'position'?: Position | null;
}

export const TriggerDelayOneOf2TypeEnum = {
    Weekday: 'weekday'
} as const;

export type TriggerDelayOneOf2TypeEnum = typeof TriggerDelayOneOf2TypeEnum[keyof typeof TriggerDelayOneOf2TypeEnum];

/**
 * @type TriggerMethod
 * @export
 */
export type TriggerMethod = AppTriggerMethod | InternalEventTriggerMethod | TimestampedTriggerMethod;

/**
 * @type TriggerMethodFilter
 * @export
 */
export type TriggerMethodFilter = AppTriggerMethod | InternalEventTriggerMethod | TriggerMethodFilterOneOf;

/**
 * 
 * @export
 * @interface TriggerMethodFilterOneOf
 */
export interface TriggerMethodFilterOneOf {
    /**
     * 
     * @type {string}
     * @memberof TriggerMethodFilterOneOf
     */
    'type': TriggerMethodFilterOneOfTypeEnum;
}

export const TriggerMethodFilterOneOfTypeEnum = {
    Timestamp: 'timestamp'
} as const;

export type TriggerMethodFilterOneOfTypeEnum = typeof TriggerMethodFilterOneOfTypeEnum[keyof typeof TriggerMethodFilterOneOfTypeEnum];

/**
 * 
 * @export
 * @interface TriggerUpsert
 */
export interface TriggerUpsert {
    /**
     * 
     * @type {string}
     * @memberof TriggerUpsert
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TriggerUpsert
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TriggerUpsert
     */
    'name'?: string;
    /**
     * 
     * @type {NextAction}
     * @memberof TriggerUpsert
     */
    'action'?: NextAction;
    /**
     * 
     * @type {BotTriggerTarget}
     * @memberof TriggerUpsert
     */
    'target'?: BotTriggerTarget;
    /**
     * 
     * @type {BotTriggerOptions}
     * @memberof TriggerUpsert
     */
    'options'?: BotTriggerOptions;
    /**
     * 
     * @type {TriggerMethod}
     * @memberof TriggerUpsert
     */
    'method'?: TriggerMethod;
    /**
     * 
     * @type {boolean}
     * @memberof TriggerUpsert
     */
    'remove'?: boolean;
    /**
     * 
     * @type {Position}
     * @memberof TriggerUpsert
     */
    'position'?: Position | null;
}
/**
 * 
 * @export
 * @interface TriggersDisplayConfiguration
 */
export interface TriggersDisplayConfiguration {
    /**
     * 
     * @type {TriggersUIConfig}
     * @memberof TriggersDisplayConfiguration
     */
    'contact': TriggersUIConfig;
    /**
     * 
     * @type {TriggersUIConfig}
     * @memberof TriggersDisplayConfiguration
     */
    'context': TriggersUIConfig;
    /**
     * 
     * @type {Array<InternalEventUIConfig>}
     * @memberof TriggersDisplayConfiguration
     */
    'internalEventConfigs': Array<InternalEventUIConfig>;
    /**
     * 
     * @type {Array<ActionAppConfig>}
     * @memberof TriggersDisplayConfiguration
     */
    'actionApps': Array<ActionAppConfig>;
    /**
     * 
     * @type {Array<TriggerAppConfig>}
     * @memberof TriggersDisplayConfiguration
     */
    'triggerApps': Array<TriggerAppConfig>;
    /**
     * 
     * @type {Array<AppGroupConfig>}
     * @memberof TriggersDisplayConfiguration
     */
    'appGroups': Array<AppGroupConfig>;
}
/**
 * 
 * @export
 * @interface TriggersUIConfig
 */
export interface TriggersUIConfig {
    /**
     * 
     * @type {TriggersUIConfigDefaults}
     * @memberof TriggersUIConfig
     */
    'defaults'?: TriggersUIConfigDefaults;
    /**
     * 
     * @type {Array<DataProperty>}
     * @memberof TriggersUIConfig
     */
    'conditionableProperties': Array<DataProperty>;
}
/**
 * Default values for the triggers. These values will be used when creating a new trigger
 * @export
 * @interface TriggersUIConfigDefaults
 */
export interface TriggersUIConfigDefaults {
    /**
     * 
     * @type {BotTriggerTarget}
     * @memberof TriggersUIConfigDefaults
     */
    'target'?: BotTriggerTarget;
    /**
     * 
     * @type {BotTriggerOptions}
     * @memberof TriggersUIConfigDefaults
     */
    'options'?: BotTriggerOptions;
}
/**
 * 
 * @export
 * @interface UnlinkExternalTemplateCommand
 */
export interface UnlinkExternalTemplateCommand {
    /**
     * 
     * @type {string}
     * @memberof UnlinkExternalTemplateCommand
     */
    'type': UnlinkExternalTemplateCommandTypeEnum;
}

export const UnlinkExternalTemplateCommandTypeEnum = {
    Unlink: 'unlink'
} as const;

export type UnlinkExternalTemplateCommandTypeEnum = typeof UnlinkExternalTemplateCommandTypeEnum[keyof typeof UnlinkExternalTemplateCommandTypeEnum];

/**
 * Type of the user identity to whom the slug was shared like email/phone. Will be null if type is public
 * @export
 * @enum {string}
 */

export const UserIdentityType = {
    Email: 'email',
    Phone: 'phone'
} as const;

export type UserIdentityType = typeof UserIdentityType[keyof typeof UserIdentityType];


/**
 * 
 * @export
 * @interface WebhookItem
 */
export interface WebhookItem {
    /**
     * 
     * @type {string}
     * @memberof WebhookItem
     */
    'method': WebhookItemMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookItem
     */
    'url': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WebhookItem
     */
    'headers': { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WebhookItem
     */
    'body'?: string;
}

export const WebhookItemMethodEnum = {
    Get: 'GET',
    Post: 'POST'
} as const;

export type WebhookItemMethodEnum = typeof WebhookItemMethodEnum[keyof typeof WebhookItemMethodEnum];

/**
 * 
 * @export
 * @interface WeekdayBotMessageDelay
 */
export interface WeekdayBotMessageDelay {
    /**
     * 
     * @type {string}
     * @memberof WeekdayBotMessageDelay
     */
    'type': WeekdayBotMessageDelayTypeEnum;
    /**
     * 
     * @type {WeekdayDelayValue}
     * @memberof WeekdayBotMessageDelay
     */
    'value': WeekdayDelayValue;
    /**
     * 
     * @type {Position}
     * @memberof WeekdayBotMessageDelay
     */
    'position'?: Position | null;
    /**
     * Simulate typing
     * @type {boolean}
     * @memberof WeekdayBotMessageDelay
     */
    'simulateTyping'?: boolean;
    /**
     * If true, the message will be cancelled if a reply is received
     * @type {boolean}
     * @memberof WeekdayBotMessageDelay
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * 
     * @type {NextAction}
     * @memberof WeekdayBotMessageDelay
     */
    'nextAction'?: NextAction;
}

export const WeekdayBotMessageDelayTypeEnum = {
    Weekday: 'weekday'
} as const;

export type WeekdayBotMessageDelayTypeEnum = typeof WeekdayBotMessageDelayTypeEnum[keyof typeof WeekdayBotMessageDelayTypeEnum];

/**
 * Provide a weekday value with time to set the delay
 * @export
 * @interface WeekdayDelayValue
 */
export interface WeekdayDelayValue {
    /**
     * 
     * @type {WeekdayDelayValueDay}
     * @memberof WeekdayDelayValue
     */
    'day': WeekdayDelayValueDay;
    /**
     * 
     * @type {string}
     * @memberof WeekdayDelayValue
     */
    'time': string;
    /**
     * 
     * @type {string}
     * @memberof WeekdayDelayValue
     */
    'timezone': string;
}
/**
 * @type WeekdayDelayValueDay
 * @export
 */
export type WeekdayDelayValueDay = DayOfWeek | string;


/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Either submit for review, unlink from the external template provider or link with an existing template ID
         * @summary Execute a command to update the status for the external template
         * @param {string} botId 
         * @param {string} accountId 
         * @param {ActionExternalTemplateCommand} [actionExternalTemplateCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionExternalTemplateCommand: async (botId: string, accountId: string, actionExternalTemplateCommand?: ActionExternalTemplateCommand, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('actionExternalTemplateCommand', 'botId', botId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('actionExternalTemplateCommand', 'accountId', accountId)
            const localVarPath = `/actions/{botId}/execute-external-template-cmd/{accountId}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(actionExternalTemplateCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all actions related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsGet: async (count?: number, before?: string, q?: string, botId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (botId !== undefined) {
                localVarQueryParameter['botId'] = botId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate Actions using GPT
         * @param {ActionsGptGenerateRequest} [actionsGptGenerateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsGptGenerate: async (actionsGptGenerateRequest?: ActionsGptGenerateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actions/gpt-generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(actionsGptGenerateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Either submit for review, unlink from the external template provider or link with an existing template ID
         * @summary Execute a command to update the status for the external template
         * @param {string} botId 
         * @param {string} accountId 
         * @param {ActionExternalTemplateCommand} [actionExternalTemplateCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionExternalTemplateCommand(botId: string, accountId: string, actionExternalTemplateCommand?: ActionExternalTemplateCommand, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Action>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionExternalTemplateCommand(botId, accountId, actionExternalTemplateCommand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets all actions related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionsGet(count?: number, before?: string, q?: string, botId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionsGet(count, before, q, botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate Actions using GPT
         * @param {ActionsGptGenerateRequest} [actionsGptGenerateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionsGptGenerate(actionsGptGenerateRequest?: ActionsGptGenerateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionsGptGenerate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionsGptGenerate(actionsGptGenerateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActionsApiFp(configuration)
    return {
        /**
         * Either submit for review, unlink from the external template provider or link with an existing template ID
         * @summary Execute a command to update the status for the external template
         * @param {ActionsApiActionExternalTemplateCommandRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionExternalTemplateCommand(requestParameters: ActionsApiActionExternalTemplateCommandRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Action>> {
            return localVarFp.actionExternalTemplateCommand(requestParameters.botId, requestParameters.accountId, requestParameters.actionExternalTemplateCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all actions related to account/team
         * @param {ActionsApiActionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsGet(requestParameters: ActionsApiActionsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ActionsGet200Response> {
            return localVarFp.actionsGet(requestParameters.count, requestParameters.before, requestParameters.q, requestParameters.botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate Actions using GPT
         * @param {ActionsApiActionsGptGenerateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsGptGenerate(requestParameters: ActionsApiActionsGptGenerateRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ActionsGptGenerate200Response> {
            return localVarFp.actionsGptGenerate(requestParameters.actionsGptGenerateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for actionExternalTemplateCommand operation in ActionsApi.
 * @export
 * @interface ActionsApiActionExternalTemplateCommandRequest
 */
export interface ActionsApiActionExternalTemplateCommandRequest {
    /**
     * 
     * @type {string}
     * @memberof ActionsApiActionExternalTemplateCommand
     */
    readonly botId: string

    /**
     * 
     * @type {string}
     * @memberof ActionsApiActionExternalTemplateCommand
     */
    readonly accountId: string

    /**
     * 
     * @type {ActionExternalTemplateCommand}
     * @memberof ActionsApiActionExternalTemplateCommand
     */
    readonly actionExternalTemplateCommand?: ActionExternalTemplateCommand
}

/**
 * Request parameters for actionsGet operation in ActionsApi.
 * @export
 * @interface ActionsApiActionsGetRequest
 */
export interface ActionsApiActionsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ActionsApiActionsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof ActionsApiActionsGet
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof ActionsApiActionsGet
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof ActionsApiActionsGet
     */
    readonly botId?: string
}

/**
 * Request parameters for actionsGptGenerate operation in ActionsApi.
 * @export
 * @interface ActionsApiActionsGptGenerateRequest
 */
export interface ActionsApiActionsGptGenerateRequest {
    /**
     * 
     * @type {ActionsGptGenerateRequest}
     * @memberof ActionsApiActionsGptGenerate
     */
    readonly actionsGptGenerateRequest?: ActionsGptGenerateRequest
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI {
    /**
     * Either submit for review, unlink from the external template provider or link with an existing template ID
     * @summary Execute a command to update the status for the external template
     * @param {ActionsApiActionExternalTemplateCommandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public actionExternalTemplateCommand(requestParameters: ActionsApiActionExternalTemplateCommandRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration).actionExternalTemplateCommand(requestParameters.botId, requestParameters.accountId, requestParameters.actionExternalTemplateCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all actions related to account/team
     * @param {ActionsApiActionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public actionsGet(requestParameters: ActionsApiActionsGetRequest = {}, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration).actionsGet(requestParameters.count, requestParameters.before, requestParameters.q, requestParameters.botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate Actions using GPT
     * @param {ActionsApiActionsGptGenerateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public actionsGptGenerate(requestParameters: ActionsApiActionsGptGenerateRequest = {}, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration).actionsGptGenerate(requestParameters.actionsGptGenerateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AppIntegrationApi - axios parameter creator
 * @export
 */
export const AppIntegrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get refresh token for google OAuth
         * @param {string} authCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calendarAuth: async (authCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authCode' is not null or undefined
            assertParamExists('calendarAuth', 'authCode', authCode)
            const localVarPath = `/calendar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authCode !== undefined) {
                localVarQueryParameter['authCode'] = authCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create a new user integration
         * @param {AppIntegrationCreate} [appIntegrationCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationCreate: async (appIntegrationCreate?: AppIntegrationCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appIntegrationCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user integration
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('integrationDelete', 'id', id)
            const localVarPath = `/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of app integrations in a team
         * @param {string} [appGroupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsGet: async (appGroupId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (appGroupId !== undefined) {
                localVarQueryParameter['appGroupId'] = appGroupId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppIntegrationApi - functional programming interface
 * @export
 */
export const AppIntegrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppIntegrationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get refresh token for google OAuth
         * @param {string} authCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calendarAuth(authCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CalendarAuth200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calendarAuth(authCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary create a new user integration
         * @param {AppIntegrationCreate} [appIntegrationCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationCreate(appIntegrationCreate?: AppIntegrationCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppIntegration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationCreate(appIntegrationCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a user integration
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of app integrations in a team
         * @param {string} [appGroupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationsGet(appGroupId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationsGet(appGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AppIntegrationApi - factory interface
 * @export
 */
export const AppIntegrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppIntegrationApiFp(configuration)
    return {
        /**
         * 
         * @summary Get refresh token for google OAuth
         * @param {AppIntegrationApiCalendarAuthRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calendarAuth(requestParameters: AppIntegrationApiCalendarAuthRequest, options?: AxiosRequestConfig): AxiosPromise<CalendarAuth200Response> {
            return localVarFp.calendarAuth(requestParameters.authCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create a new user integration
         * @param {AppIntegrationApiIntegrationCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationCreate(requestParameters: AppIntegrationApiIntegrationCreateRequest = {}, options?: AxiosRequestConfig): AxiosPromise<AppIntegration> {
            return localVarFp.integrationCreate(requestParameters.appIntegrationCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user integration
         * @param {AppIntegrationApiIntegrationDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationDelete(requestParameters: AppIntegrationApiIntegrationDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.integrationDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of app integrations in a team
         * @param {AppIntegrationApiIntegrationsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsGet(requestParameters: AppIntegrationApiIntegrationsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<IntegrationsGet200Response> {
            return localVarFp.integrationsGet(requestParameters.appGroupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for calendarAuth operation in AppIntegrationApi.
 * @export
 * @interface AppIntegrationApiCalendarAuthRequest
 */
export interface AppIntegrationApiCalendarAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof AppIntegrationApiCalendarAuth
     */
    readonly authCode: string
}

/**
 * Request parameters for integrationCreate operation in AppIntegrationApi.
 * @export
 * @interface AppIntegrationApiIntegrationCreateRequest
 */
export interface AppIntegrationApiIntegrationCreateRequest {
    /**
     * 
     * @type {AppIntegrationCreate}
     * @memberof AppIntegrationApiIntegrationCreate
     */
    readonly appIntegrationCreate?: AppIntegrationCreate
}

/**
 * Request parameters for integrationDelete operation in AppIntegrationApi.
 * @export
 * @interface AppIntegrationApiIntegrationDeleteRequest
 */
export interface AppIntegrationApiIntegrationDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof AppIntegrationApiIntegrationDelete
     */
    readonly id: string
}

/**
 * Request parameters for integrationsGet operation in AppIntegrationApi.
 * @export
 * @interface AppIntegrationApiIntegrationsGetRequest
 */
export interface AppIntegrationApiIntegrationsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AppIntegrationApiIntegrationsGet
     */
    readonly appGroupId?: string
}

/**
 * AppIntegrationApi - object-oriented interface
 * @export
 * @class AppIntegrationApi
 * @extends {BaseAPI}
 */
export class AppIntegrationApi extends BaseAPI {
    /**
     * 
     * @summary Get refresh token for google OAuth
     * @param {AppIntegrationApiCalendarAuthRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppIntegrationApi
     */
    public calendarAuth(requestParameters: AppIntegrationApiCalendarAuthRequest, options?: AxiosRequestConfig) {
        return AppIntegrationApiFp(this.configuration).calendarAuth(requestParameters.authCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create a new user integration
     * @param {AppIntegrationApiIntegrationCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppIntegrationApi
     */
    public integrationCreate(requestParameters: AppIntegrationApiIntegrationCreateRequest = {}, options?: AxiosRequestConfig) {
        return AppIntegrationApiFp(this.configuration).integrationCreate(requestParameters.appIntegrationCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user integration
     * @param {AppIntegrationApiIntegrationDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppIntegrationApi
     */
    public integrationDelete(requestParameters: AppIntegrationApiIntegrationDeleteRequest, options?: AxiosRequestConfig) {
        return AppIntegrationApiFp(this.configuration).integrationDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of app integrations in a team
     * @param {AppIntegrationApiIntegrationsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppIntegrationApi
     */
    public integrationsGet(requestParameters: AppIntegrationApiIntegrationsGetRequest = {}, options?: AxiosRequestConfig) {
        return AppIntegrationApiFp(this.configuration).integrationsGet(requestParameters.appGroupId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BotAnalyticsApi - axios parameter creator
 * @export
 */
export const BotAnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint fetches analytics for a bot based on provided botId parameters
         * @summary Get analytics for a bot
         * @param {string} botId The ID of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsAnalyticsGet: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsAnalyticsGet', 'botId', botId)
            const localVarPath = `/bot/analytics/{botId}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotAnalyticsApi - functional programming interface
 * @export
 */
export const BotAnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BotAnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint fetches analytics for a bot based on provided botId parameters
         * @summary Get analytics for a bot
         * @param {string} botId The ID of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsAnalyticsGet(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotsAnalyticsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsAnalyticsGet(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BotAnalyticsApi - factory interface
 * @export
 */
export const BotAnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BotAnalyticsApiFp(configuration)
    return {
        /**
         * This endpoint fetches analytics for a bot based on provided botId parameters
         * @summary Get analytics for a bot
         * @param {BotAnalyticsApiBotsAnalyticsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsAnalyticsGet(requestParameters: BotAnalyticsApiBotsAnalyticsGetRequest, options?: AxiosRequestConfig): AxiosPromise<BotsAnalyticsGet200Response> {
            return localVarFp.botsAnalyticsGet(requestParameters.botId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for botsAnalyticsGet operation in BotAnalyticsApi.
 * @export
 * @interface BotAnalyticsApiBotsAnalyticsGetRequest
 */
export interface BotAnalyticsApiBotsAnalyticsGetRequest {
    /**
     * The ID of the bot
     * @type {string}
     * @memberof BotAnalyticsApiBotsAnalyticsGet
     */
    readonly botId: string
}

/**
 * BotAnalyticsApi - object-oriented interface
 * @export
 * @class BotAnalyticsApi
 * @extends {BaseAPI}
 */
export class BotAnalyticsApi extends BaseAPI {
    /**
     * This endpoint fetches analytics for a bot based on provided botId parameters
     * @summary Get analytics for a bot
     * @param {BotAnalyticsApiBotsAnalyticsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotAnalyticsApi
     */
    public botsAnalyticsGet(requestParameters: BotAnalyticsApiBotsAnalyticsGetRequest, options?: AxiosRequestConfig) {
        return BotAnalyticsApiFp(this.configuration).botsAnalyticsGet(requestParameters.botId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BotRecordsApi - axios parameter creator
 * @export
 */
export const BotRecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint fetches records for a bot based on provided botId parameters
         * @summary Get records for a bot
         * @param {string} [botId] The ID of the bot
         * @param {GetBotFireRecordsContactsParameter} [contacts] 
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {{ [key: string]: ActionInteractionQueryItem; }} [interactions] 
         * @param {ActionInteractionQueryItem} [scheduledActionInteraction] 
         * @param {boolean} [returnTotal] 
         * @param {string} [instanceId] 
         * @param {string} [triggerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotFireRecords: async (botId?: string, contacts?: GetBotFireRecordsContactsParameter, count?: number, cursor?: string, interactions?: { [key: string]: ActionInteractionQueryItem; }, scheduledActionInteraction?: ActionInteractionQueryItem, returnTotal?: boolean, instanceId?: string, triggerId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bot/records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (botId !== undefined) {
                localVarQueryParameter['botId'] = botId;
            }

            if (contacts !== undefined) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (interactions !== undefined) {
                localVarQueryParameter['interactions'] = interactions;
            }

            if (scheduledActionInteraction !== undefined) {
                localVarQueryParameter['scheduledActionInteraction'] = scheduledActionInteraction;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }

            if (instanceId !== undefined) {
                localVarQueryParameter['instanceId'] = instanceId;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint simulates the result of an action execution based on the provided parameters
         * @summary Simulate action execute result
         * @param {string} botId The ID of the bot
         * @param {string} actionId The ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateActionExecuteResult: async (botId: string, actionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('simulateActionExecuteResult', 'botId', botId)
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('simulateActionExecuteResult', 'actionId', actionId)
            const localVarPath = `/bot/simulate-action-execute-result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (botId !== undefined) {
                localVarQueryParameter['botId'] = botId;
            }

            if (actionId !== undefined) {
                localVarQueryParameter['actionId'] = actionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotRecordsApi - functional programming interface
 * @export
 */
export const BotRecordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BotRecordsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint fetches records for a bot based on provided botId parameters
         * @summary Get records for a bot
         * @param {string} [botId] The ID of the bot
         * @param {GetBotFireRecordsContactsParameter} [contacts] 
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {{ [key: string]: ActionInteractionQueryItem; }} [interactions] 
         * @param {ActionInteractionQueryItem} [scheduledActionInteraction] 
         * @param {boolean} [returnTotal] 
         * @param {string} [instanceId] 
         * @param {string} [triggerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBotFireRecords(botId?: string, contacts?: GetBotFireRecordsContactsParameter, count?: number, cursor?: string, interactions?: { [key: string]: ActionInteractionQueryItem; }, scheduledActionInteraction?: ActionInteractionQueryItem, returnTotal?: boolean, instanceId?: string, triggerId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBotFireRecords200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBotFireRecords(botId, contacts, count, cursor, interactions, scheduledActionInteraction, returnTotal, instanceId, triggerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint simulates the result of an action execution based on the provided parameters
         * @summary Simulate action execute result
         * @param {string} botId The ID of the bot
         * @param {string} actionId The ID of the action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateActionExecuteResult(botId: string, actionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulateActionExecuteResult200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateActionExecuteResult(botId, actionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BotRecordsApi - factory interface
 * @export
 */
export const BotRecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BotRecordsApiFp(configuration)
    return {
        /**
         * This endpoint fetches records for a bot based on provided botId parameters
         * @summary Get records for a bot
         * @param {BotRecordsApiGetBotFireRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotFireRecords(requestParameters: BotRecordsApiGetBotFireRecordsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetBotFireRecords200Response> {
            return localVarFp.getBotFireRecords(requestParameters.botId, requestParameters.contacts, requestParameters.count, requestParameters.cursor, requestParameters.interactions, requestParameters.scheduledActionInteraction, requestParameters.returnTotal, requestParameters.instanceId, requestParameters.triggerId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint simulates the result of an action execution based on the provided parameters
         * @summary Simulate action execute result
         * @param {BotRecordsApiSimulateActionExecuteResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateActionExecuteResult(requestParameters: BotRecordsApiSimulateActionExecuteResultRequest, options?: AxiosRequestConfig): AxiosPromise<SimulateActionExecuteResult200Response> {
            return localVarFp.simulateActionExecuteResult(requestParameters.botId, requestParameters.actionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getBotFireRecords operation in BotRecordsApi.
 * @export
 * @interface BotRecordsApiGetBotFireRecordsRequest
 */
export interface BotRecordsApiGetBotFireRecordsRequest {
    /**
     * The ID of the bot
     * @type {string}
     * @memberof BotRecordsApiGetBotFireRecords
     */
    readonly botId?: string

    /**
     * 
     * @type {GetBotFireRecordsContactsParameter}
     * @memberof BotRecordsApiGetBotFireRecords
     */
    readonly contacts?: GetBotFireRecordsContactsParameter

    /**
     * 
     * @type {number}
     * @memberof BotRecordsApiGetBotFireRecords
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof BotRecordsApiGetBotFireRecords
     */
    readonly cursor?: string

    /**
     * 
     * @type {{ [key: string]: ActionInteractionQueryItem; }}
     * @memberof BotRecordsApiGetBotFireRecords
     */
    readonly interactions?: { [key: string]: ActionInteractionQueryItem; }

    /**
     * 
     * @type {ActionInteractionQueryItem}
     * @memberof BotRecordsApiGetBotFireRecords
     */
    readonly scheduledActionInteraction?: ActionInteractionQueryItem

    /**
     * 
     * @type {boolean}
     * @memberof BotRecordsApiGetBotFireRecords
     */
    readonly returnTotal?: boolean

    /**
     * 
     * @type {string}
     * @memberof BotRecordsApiGetBotFireRecords
     */
    readonly instanceId?: string

    /**
     * 
     * @type {string}
     * @memberof BotRecordsApiGetBotFireRecords
     */
    readonly triggerId?: string
}

/**
 * Request parameters for simulateActionExecuteResult operation in BotRecordsApi.
 * @export
 * @interface BotRecordsApiSimulateActionExecuteResultRequest
 */
export interface BotRecordsApiSimulateActionExecuteResultRequest {
    /**
     * The ID of the bot
     * @type {string}
     * @memberof BotRecordsApiSimulateActionExecuteResult
     */
    readonly botId: string

    /**
     * The ID of the action
     * @type {string}
     * @memberof BotRecordsApiSimulateActionExecuteResult
     */
    readonly actionId: string
}

/**
 * BotRecordsApi - object-oriented interface
 * @export
 * @class BotRecordsApi
 * @extends {BaseAPI}
 */
export class BotRecordsApi extends BaseAPI {
    /**
     * This endpoint fetches records for a bot based on provided botId parameters
     * @summary Get records for a bot
     * @param {BotRecordsApiGetBotFireRecordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotRecordsApi
     */
    public getBotFireRecords(requestParameters: BotRecordsApiGetBotFireRecordsRequest = {}, options?: AxiosRequestConfig) {
        return BotRecordsApiFp(this.configuration).getBotFireRecords(requestParameters.botId, requestParameters.contacts, requestParameters.count, requestParameters.cursor, requestParameters.interactions, requestParameters.scheduledActionInteraction, requestParameters.returnTotal, requestParameters.instanceId, requestParameters.triggerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint simulates the result of an action execution based on the provided parameters
     * @summary Simulate action execute result
     * @param {BotRecordsApiSimulateActionExecuteResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotRecordsApi
     */
    public simulateActionExecuteResult(requestParameters: BotRecordsApiSimulateActionExecuteResultRequest, options?: AxiosRequestConfig) {
        return BotRecordsApiFp(this.configuration).simulateActionExecuteResult(requestParameters.botId, requestParameters.actionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BotTriggersApi - axios parameter creator
 * @export
 */
export const BotTriggersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint is used to fire a trigger via a webhook. The secret is used to authenticate the request. The endpoint will throw an error if:   - the trigger is disabled   - no recipients were obtained from the trigger config or req body   - throttle limit is reached for the trigger/all recipients
         * @summary Fire a trigger via a webhook
         * @param {string} secret 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireTriggerWebhook: async (secret: string, requestBody?: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secret' is not null or undefined
            assertParamExists('fireTriggerWebhook', 'secret', secret)
            const localVarPath = `/triggers/app-webhook/{secret}`
                .replace(`{${"secret"}}`, encodeURIComponent(String(secret)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get trigger display configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisplayConfiguration: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/triggers/display-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all instances of a bot trigger
         * @param {string} [triggerId] 
         * @param {number} [count] 
         * @param {Array<BotTriggerInstanceStatus>} [status] 
         * @param {string} [cursor] 
         * @param {string} [id] 
         * @param {boolean} [returnTotalCount] 
         * @param {Array<string>} [botId] 
         * @param {string} [q] 
         * @param {GetTriggerInstancesDateRageParameter} [dateRage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggerInstances: async (triggerId?: string, count?: number, status?: Array<BotTriggerInstanceStatus>, cursor?: string, id?: string, returnTotalCount?: boolean, botId?: Array<string>, q?: string, dateRage?: GetTriggerInstancesDateRageParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/trigger-instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }

            if (botId) {
                localVarQueryParameter['botId'] = botId;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (dateRage !== undefined) {
                localVarQueryParameter['dateRage'] = dateRage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stops a bot trigger instance
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTriggerInstance: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stopTriggerInstance', 'id', id)
            const localVarPath = `/trigger-instances/{id}/stop`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotTriggersApi - functional programming interface
 * @export
 */
export const BotTriggersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BotTriggersApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint is used to fire a trigger via a webhook. The secret is used to authenticate the request. The endpoint will throw an error if:   - the trigger is disabled   - no recipients were obtained from the trigger config or req body   - throttle limit is reached for the trigger/all recipients
         * @summary Fire a trigger via a webhook
         * @param {string} secret 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fireTriggerWebhook(secret: string, requestBody?: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FireTriggerWebhook200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fireTriggerWebhook(secret, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get trigger display configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDisplayConfiguration(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TriggersDisplayConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDisplayConfiguration(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all instances of a bot trigger
         * @param {string} [triggerId] 
         * @param {number} [count] 
         * @param {Array<BotTriggerInstanceStatus>} [status] 
         * @param {string} [cursor] 
         * @param {string} [id] 
         * @param {boolean} [returnTotalCount] 
         * @param {Array<string>} [botId] 
         * @param {string} [q] 
         * @param {GetTriggerInstancesDateRageParameter} [dateRage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTriggerInstances(triggerId?: string, count?: number, status?: Array<BotTriggerInstanceStatus>, cursor?: string, id?: string, returnTotalCount?: boolean, botId?: Array<string>, q?: string, dateRage?: GetTriggerInstancesDateRageParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTriggerInstances200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTriggerInstances(triggerId, count, status, cursor, id, returnTotalCount, botId, q, dateRage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stops a bot trigger instance
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopTriggerInstance(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopTriggerInstance(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BotTriggersApi - factory interface
 * @export
 */
export const BotTriggersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BotTriggersApiFp(configuration)
    return {
        /**
         * This endpoint is used to fire a trigger via a webhook. The secret is used to authenticate the request. The endpoint will throw an error if:   - the trigger is disabled   - no recipients were obtained from the trigger config or req body   - throttle limit is reached for the trigger/all recipients
         * @summary Fire a trigger via a webhook
         * @param {BotTriggersApiFireTriggerWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fireTriggerWebhook(requestParameters: BotTriggersApiFireTriggerWebhookRequest, options?: AxiosRequestConfig): AxiosPromise<FireTriggerWebhook200Response> {
            return localVarFp.fireTriggerWebhook(requestParameters.secret, requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get trigger display configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisplayConfiguration(options?: AxiosRequestConfig): AxiosPromise<TriggersDisplayConfiguration> {
            return localVarFp.getDisplayConfiguration(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all instances of a bot trigger
         * @param {BotTriggersApiGetTriggerInstancesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggerInstances(requestParameters: BotTriggersApiGetTriggerInstancesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetTriggerInstances200Response> {
            return localVarFp.getTriggerInstances(requestParameters.triggerId, requestParameters.count, requestParameters.status, requestParameters.cursor, requestParameters.id, requestParameters.returnTotalCount, requestParameters.botId, requestParameters.q, requestParameters.dateRage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stops a bot trigger instance
         * @param {BotTriggersApiStopTriggerInstanceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTriggerInstance(requestParameters: BotTriggersApiStopTriggerInstanceRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stopTriggerInstance(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for fireTriggerWebhook operation in BotTriggersApi.
 * @export
 * @interface BotTriggersApiFireTriggerWebhookRequest
 */
export interface BotTriggersApiFireTriggerWebhookRequest {
    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiFireTriggerWebhook
     */
    readonly secret: string

    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BotTriggersApiFireTriggerWebhook
     */
    readonly requestBody?: { [key: string]: any; }
}

/**
 * Request parameters for getTriggerInstances operation in BotTriggersApi.
 * @export
 * @interface BotTriggersApiGetTriggerInstancesRequest
 */
export interface BotTriggersApiGetTriggerInstancesRequest {
    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiGetTriggerInstances
     */
    readonly triggerId?: string

    /**
     * 
     * @type {number}
     * @memberof BotTriggersApiGetTriggerInstances
     */
    readonly count?: number

    /**
     * 
     * @type {Array<BotTriggerInstanceStatus>}
     * @memberof BotTriggersApiGetTriggerInstances
     */
    readonly status?: Array<BotTriggerInstanceStatus>

    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiGetTriggerInstances
     */
    readonly cursor?: string

    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiGetTriggerInstances
     */
    readonly id?: string

    /**
     * 
     * @type {boolean}
     * @memberof BotTriggersApiGetTriggerInstances
     */
    readonly returnTotalCount?: boolean

    /**
     * 
     * @type {Array<string>}
     * @memberof BotTriggersApiGetTriggerInstances
     */
    readonly botId?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiGetTriggerInstances
     */
    readonly q?: string

    /**
     * 
     * @type {GetTriggerInstancesDateRageParameter}
     * @memberof BotTriggersApiGetTriggerInstances
     */
    readonly dateRage?: GetTriggerInstancesDateRageParameter
}

/**
 * Request parameters for stopTriggerInstance operation in BotTriggersApi.
 * @export
 * @interface BotTriggersApiStopTriggerInstanceRequest
 */
export interface BotTriggersApiStopTriggerInstanceRequest {
    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiStopTriggerInstance
     */
    readonly id: string
}

/**
 * BotTriggersApi - object-oriented interface
 * @export
 * @class BotTriggersApi
 * @extends {BaseAPI}
 */
export class BotTriggersApi extends BaseAPI {
    /**
     * This endpoint is used to fire a trigger via a webhook. The secret is used to authenticate the request. The endpoint will throw an error if:   - the trigger is disabled   - no recipients were obtained from the trigger config or req body   - throttle limit is reached for the trigger/all recipients
     * @summary Fire a trigger via a webhook
     * @param {BotTriggersApiFireTriggerWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotTriggersApi
     */
    public fireTriggerWebhook(requestParameters: BotTriggersApiFireTriggerWebhookRequest, options?: AxiosRequestConfig) {
        return BotTriggersApiFp(this.configuration).fireTriggerWebhook(requestParameters.secret, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get trigger display configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotTriggersApi
     */
    public getDisplayConfiguration(options?: AxiosRequestConfig) {
        return BotTriggersApiFp(this.configuration).getDisplayConfiguration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all instances of a bot trigger
     * @param {BotTriggersApiGetTriggerInstancesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotTriggersApi
     */
    public getTriggerInstances(requestParameters: BotTriggersApiGetTriggerInstancesRequest = {}, options?: AxiosRequestConfig) {
        return BotTriggersApiFp(this.configuration).getTriggerInstances(requestParameters.triggerId, requestParameters.count, requestParameters.status, requestParameters.cursor, requestParameters.id, requestParameters.returnTotalCount, requestParameters.botId, requestParameters.q, requestParameters.dateRage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stops a bot trigger instance
     * @param {BotTriggersApiStopTriggerInstanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotTriggersApi
     */
    public stopTriggerInstance(requestParameters: BotTriggersApiStopTriggerInstanceRequest, options?: AxiosRequestConfig) {
        return BotTriggersApiFp(this.configuration).stopTriggerInstance(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BotsApi - axios parameter creator
 * @export
 */
export const BotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fires the starting action ID
         * @summary Initiates a bot sequence onto 1 or more contacts.
         * @param {string} id 
         * @param {BotsBulkFireRequest} [botsBulkFireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBulkFire: async (id: string, botsBulkFireRequest?: BotsBulkFireRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('botsBulkFire', 'id', id)
            const localVarPath = `/bots/{id}/bulk-fire`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL", "MESSAGES_SEND_TO_ASSIGNED"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botsBulkFireRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new bot
         * @param {BotsCreateRequest} [botsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsCreate: async (botsCreateRequest?: BotsCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint fetches bot data based on provided botId parameters
         * @summary Retrieves bot data including triggers, notes and actions
         * @param {string} botId The ID of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDataGet: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsDataGet', 'botId', botId)
            const localVarPath = `/bots/{botId}/data`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes list of bots
         * @param {Array<string>} bots 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDeletes: async (bots: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bots' is not null or undefined
            assertParamExists('botsDeletes', 'bots', bots)
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_DELETE"], configuration)

            if (bots) {
                localVarQueryParameter['bots'] = bots;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Either submit for review, unlink from the external template provider or link with an existing template ID. Note: this is deprecated, use \"actionExternalTemplateCommand\" instead
         * @summary Execute a command to update the status for the external template
         * @param {string} id 
         * @param {string} accountId 
         * @param {TemplateCommand} command 
         * @param {string} [language] ISO code of the language, required for WA business templates
         * @param {string} [category] 
         * @param {string} [templateId] The external ID of the template to link with, only valid for the \&quot;link\&quot; command
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        botsExternalTemplateCommand: async (id: string, accountId: string, command: TemplateCommand, language?: string, category?: string, templateId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('botsExternalTemplateCommand', 'id', id)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('botsExternalTemplateCommand', 'accountId', accountId)
            // verify required parameter 'command' is not null or undefined
            assertParamExists('botsExternalTemplateCommand', 'command', command)
            const localVarPath = `/bots/{id}/external-template/{accountId}/{command}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (templateId !== undefined) {
                localVarQueryParameter['templateId'] = templateId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will throw a 400 if there is no starting action ID
         * @summary Initiates a bot sequence. Fires the starting action ID
         * @param {string} id 
         * @param {BotsFireRequest} [botsFireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsFire: async (id: string, botsFireRequest?: BotsFireRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('botsFire', 'id', id)
            const localVarPath = `/bots/{id}/fire`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL", "MESSAGES_SEND_TO_ASSIGNED"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botsFireRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of bots
         * @param {string} [q] 
         * @param {boolean} [isForm] If true, only bots that are a form will be returned. If false, only bots are not forms will be returned
         * @param {string} [before] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {'name' | 'updatedAt'} [sortBy] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {string} [folderId] 
         * @param {string} [language] 
         * @param {string} [industry] 
         * @param {boolean} [returnTotalCount] 
         * @param {BotsGetsTriggerTypesParameter} [triggerTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsGets: async (q?: string, isForm?: boolean, before?: string, count?: number, id?: Array<string>, sortBy?: 'name' | 'updatedAt', order?: 'ASC' | 'DESC', folderId?: string, language?: string, industry?: string, returnTotalCount?: boolean, triggerTypes?: BotsGetsTriggerTypesParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (isForm !== undefined) {
                localVarQueryParameter['isForm'] = isForm;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (folderId !== undefined) {
                localVarQueryParameter['folderId'] = folderId;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (industry !== undefined) {
                localVarQueryParameter['industry'] = industry;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }

            if (triggerTypes !== undefined) {
                localVarQueryParameter['triggerTypes'] = triggerTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an action
         * @param {string} id 
         * @param {BotPatch} [botPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsPatch: async (id: string, botPatch?: BotPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('botsPatch', 'id', id)
            const localVarPath = `/bots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update status of some templates
         * @param {TemplateStatusUpdateRequest} [templateStatusUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalTemplateStatusUpdate: async (templateStatusUpdateRequest?: TemplateStatusUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/external-template-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templateStatusUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns list of action fire records
         * @param {number} [count] 
         * @param {number} [beforeId] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionFireRecords: async (count?: number, beforeId?: number, botId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actions/records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (beforeId !== undefined) {
                localVarQueryParameter['beforeId'] = beforeId;
            }

            if (botId !== undefined) {
                localVarQueryParameter['botId'] = botId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotsApi - functional programming interface
 * @export
 */
export const BotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BotsApiAxiosParamCreator(configuration)
    return {
        /**
         * Fires the starting action ID
         * @summary Initiates a bot sequence onto 1 or more contacts.
         * @param {string} id 
         * @param {BotsBulkFireRequest} [botsBulkFireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsBulkFire(id: string, botsBulkFireRequest?: BotsBulkFireRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotsBulkFire200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsBulkFire(id, botsBulkFireRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates new bot
         * @param {BotsCreateRequest} [botsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsCreate(botsCreateRequest?: BotsCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsCreate(botsCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint fetches bot data based on provided botId parameters
         * @summary Retrieves bot data including triggers, notes and actions
         * @param {string} botId The ID of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsDataGet(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsDataGet(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes list of bots
         * @param {Array<string>} bots 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsDeletes(bots: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsDeletes(bots, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Either submit for review, unlink from the external template provider or link with an existing template ID. Note: this is deprecated, use \"actionExternalTemplateCommand\" instead
         * @summary Execute a command to update the status for the external template
         * @param {string} id 
         * @param {string} accountId 
         * @param {TemplateCommand} command 
         * @param {string} [language] ISO code of the language, required for WA business templates
         * @param {string} [category] 
         * @param {string} [templateId] The external ID of the template to link with, only valid for the \&quot;link\&quot; command
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async botsExternalTemplateCommand(id: string, accountId: string, command: TemplateCommand, language?: string, category?: string, templateId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotsExternalTemplateCommand200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsExternalTemplateCommand(id, accountId, command, language, category, templateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Will throw a 400 if there is no starting action ID
         * @summary Initiates a bot sequence. Fires the starting action ID
         * @param {string} id 
         * @param {BotsFireRequest} [botsFireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsFire(id: string, botsFireRequest?: BotsFireRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionFireRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsFire(id, botsFireRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of bots
         * @param {string} [q] 
         * @param {boolean} [isForm] If true, only bots that are a form will be returned. If false, only bots are not forms will be returned
         * @param {string} [before] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {'name' | 'updatedAt'} [sortBy] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {string} [folderId] 
         * @param {string} [language] 
         * @param {string} [industry] 
         * @param {boolean} [returnTotalCount] 
         * @param {BotsGetsTriggerTypesParameter} [triggerTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsGets(q?: string, isForm?: boolean, before?: string, count?: number, id?: Array<string>, sortBy?: 'name' | 'updatedAt', order?: 'ASC' | 'DESC', folderId?: string, language?: string, industry?: string, returnTotalCount?: boolean, triggerTypes?: BotsGetsTriggerTypesParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotsGets200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsGets(q, isForm, before, count, id, sortBy, order, folderId, language, industry, returnTotalCount, triggerTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an action
         * @param {string} id 
         * @param {BotPatch} [botPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsPatch(id: string, botPatch?: BotPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsPatch(id, botPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update status of some templates
         * @param {TemplateStatusUpdateRequest} [templateStatusUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalTemplateStatusUpdate(templateStatusUpdateRequest?: TemplateStatusUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalTemplateStatusUpdate(templateStatusUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns list of action fire records
         * @param {number} [count] 
         * @param {number} [beforeId] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActionFireRecords(count?: number, beforeId?: number, botId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetActionFireRecords200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActionFireRecords(count, beforeId, botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BotsApi - factory interface
 * @export
 */
export const BotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BotsApiFp(configuration)
    return {
        /**
         * Fires the starting action ID
         * @summary Initiates a bot sequence onto 1 or more contacts.
         * @param {BotsApiBotsBulkFireRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBulkFire(requestParameters: BotsApiBotsBulkFireRequest, options?: AxiosRequestConfig): AxiosPromise<BotsBulkFire200Response> {
            return localVarFp.botsBulkFire(requestParameters.id, requestParameters.botsBulkFireRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates new bot
         * @param {BotsApiBotsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsCreate(requestParameters: BotsApiBotsCreateRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Bot> {
            return localVarFp.botsCreate(requestParameters.botsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint fetches bot data based on provided botId parameters
         * @summary Retrieves bot data including triggers, notes and actions
         * @param {BotsApiBotsDataGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDataGet(requestParameters: BotsApiBotsDataGetRequest, options?: AxiosRequestConfig): AxiosPromise<BotData> {
            return localVarFp.botsDataGet(requestParameters.botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes list of bots
         * @param {BotsApiBotsDeletesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDeletes(requestParameters: BotsApiBotsDeletesRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.botsDeletes(requestParameters.bots, options).then((request) => request(axios, basePath));
        },
        /**
         * Either submit for review, unlink from the external template provider or link with an existing template ID. Note: this is deprecated, use \"actionExternalTemplateCommand\" instead
         * @summary Execute a command to update the status for the external template
         * @param {BotsApiBotsExternalTemplateCommandRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        botsExternalTemplateCommand(requestParameters: BotsApiBotsExternalTemplateCommandRequest, options?: AxiosRequestConfig): AxiosPromise<BotsExternalTemplateCommand200Response> {
            return localVarFp.botsExternalTemplateCommand(requestParameters.id, requestParameters.accountId, requestParameters.command, requestParameters.language, requestParameters.category, requestParameters.templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Will throw a 400 if there is no starting action ID
         * @summary Initiates a bot sequence. Fires the starting action ID
         * @param {BotsApiBotsFireRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsFire(requestParameters: BotsApiBotsFireRequest, options?: AxiosRequestConfig): AxiosPromise<ActionFireRecord> {
            return localVarFp.botsFire(requestParameters.id, requestParameters.botsFireRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of bots
         * @param {BotsApiBotsGetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsGets(requestParameters: BotsApiBotsGetsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<BotsGets200Response> {
            return localVarFp.botsGets(requestParameters.q, requestParameters.isForm, requestParameters.before, requestParameters.count, requestParameters.id, requestParameters.sortBy, requestParameters.order, requestParameters.folderId, requestParameters.language, requestParameters.industry, requestParameters.returnTotalCount, requestParameters.triggerTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an action
         * @param {BotsApiBotsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsPatch(requestParameters: BotsApiBotsPatchRequest, options?: AxiosRequestConfig): AxiosPromise<BotData> {
            return localVarFp.botsPatch(requestParameters.id, requestParameters.botPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update status of some templates
         * @param {BotsApiExternalTemplateStatusUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalTemplateStatusUpdate(requestParameters: BotsApiExternalTemplateStatusUpdateRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.externalTemplateStatusUpdate(requestParameters.templateStatusUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns list of action fire records
         * @param {BotsApiGetActionFireRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionFireRecords(requestParameters: BotsApiGetActionFireRecordsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetActionFireRecords200Response> {
            return localVarFp.getActionFireRecords(requestParameters.count, requestParameters.beforeId, requestParameters.botId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for botsBulkFire operation in BotsApi.
 * @export
 * @interface BotsApiBotsBulkFireRequest
 */
export interface BotsApiBotsBulkFireRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsBulkFire
     */
    readonly id: string

    /**
     * 
     * @type {BotsBulkFireRequest}
     * @memberof BotsApiBotsBulkFire
     */
    readonly botsBulkFireRequest?: BotsBulkFireRequest
}

/**
 * Request parameters for botsCreate operation in BotsApi.
 * @export
 * @interface BotsApiBotsCreateRequest
 */
export interface BotsApiBotsCreateRequest {
    /**
     * 
     * @type {BotsCreateRequest}
     * @memberof BotsApiBotsCreate
     */
    readonly botsCreateRequest?: BotsCreateRequest
}

/**
 * Request parameters for botsDataGet operation in BotsApi.
 * @export
 * @interface BotsApiBotsDataGetRequest
 */
export interface BotsApiBotsDataGetRequest {
    /**
     * The ID of the bot
     * @type {string}
     * @memberof BotsApiBotsDataGet
     */
    readonly botId: string
}

/**
 * Request parameters for botsDeletes operation in BotsApi.
 * @export
 * @interface BotsApiBotsDeletesRequest
 */
export interface BotsApiBotsDeletesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof BotsApiBotsDeletes
     */
    readonly bots: Array<string>
}

/**
 * Request parameters for botsExternalTemplateCommand operation in BotsApi.
 * @export
 * @interface BotsApiBotsExternalTemplateCommandRequest
 */
export interface BotsApiBotsExternalTemplateCommandRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly accountId: string

    /**
     * 
     * @type {TemplateCommand}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly command: TemplateCommand

    /**
     * ISO code of the language, required for WA business templates
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly language?: string

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly category?: string

    /**
     * The external ID of the template to link with, only valid for the \&quot;link\&quot; command
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly templateId?: string
}

/**
 * Request parameters for botsFire operation in BotsApi.
 * @export
 * @interface BotsApiBotsFireRequest
 */
export interface BotsApiBotsFireRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsFire
     */
    readonly id: string

    /**
     * 
     * @type {BotsFireRequest}
     * @memberof BotsApiBotsFire
     */
    readonly botsFireRequest?: BotsFireRequest
}

/**
 * Request parameters for botsGets operation in BotsApi.
 * @export
 * @interface BotsApiBotsGetsRequest
 */
export interface BotsApiBotsGetsRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly q?: string

    /**
     * If true, only bots that are a form will be returned. If false, only bots are not forms will be returned
     * @type {boolean}
     * @memberof BotsApiBotsGets
     */
    readonly isForm?: boolean

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly before?: string

    /**
     * 
     * @type {number}
     * @memberof BotsApiBotsGets
     */
    readonly count?: number

    /**
     * 
     * @type {Array<string>}
     * @memberof BotsApiBotsGets
     */
    readonly id?: Array<string>

    /**
     * 
     * @type {'name' | 'updatedAt'}
     * @memberof BotsApiBotsGets
     */
    readonly sortBy?: 'name' | 'updatedAt'

    /**
     * 
     * @type {'ASC' | 'DESC'}
     * @memberof BotsApiBotsGets
     */
    readonly order?: 'ASC' | 'DESC'

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly folderId?: string

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly language?: string

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly industry?: string

    /**
     * 
     * @type {boolean}
     * @memberof BotsApiBotsGets
     */
    readonly returnTotalCount?: boolean

    /**
     * 
     * @type {BotsGetsTriggerTypesParameter}
     * @memberof BotsApiBotsGets
     */
    readonly triggerTypes?: BotsGetsTriggerTypesParameter
}

/**
 * Request parameters for botsPatch operation in BotsApi.
 * @export
 * @interface BotsApiBotsPatchRequest
 */
export interface BotsApiBotsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsPatch
     */
    readonly id: string

    /**
     * 
     * @type {BotPatch}
     * @memberof BotsApiBotsPatch
     */
    readonly botPatch?: BotPatch
}

/**
 * Request parameters for externalTemplateStatusUpdate operation in BotsApi.
 * @export
 * @interface BotsApiExternalTemplateStatusUpdateRequest
 */
export interface BotsApiExternalTemplateStatusUpdateRequest {
    /**
     * 
     * @type {TemplateStatusUpdateRequest}
     * @memberof BotsApiExternalTemplateStatusUpdate
     */
    readonly templateStatusUpdateRequest?: TemplateStatusUpdateRequest
}

/**
 * Request parameters for getActionFireRecords operation in BotsApi.
 * @export
 * @interface BotsApiGetActionFireRecordsRequest
 */
export interface BotsApiGetActionFireRecordsRequest {
    /**
     * 
     * @type {number}
     * @memberof BotsApiGetActionFireRecords
     */
    readonly count?: number

    /**
     * 
     * @type {number}
     * @memberof BotsApiGetActionFireRecords
     */
    readonly beforeId?: number

    /**
     * 
     * @type {string}
     * @memberof BotsApiGetActionFireRecords
     */
    readonly botId?: string
}

/**
 * BotsApi - object-oriented interface
 * @export
 * @class BotsApi
 * @extends {BaseAPI}
 */
export class BotsApi extends BaseAPI {
    /**
     * Fires the starting action ID
     * @summary Initiates a bot sequence onto 1 or more contacts.
     * @param {BotsApiBotsBulkFireRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsBulkFire(requestParameters: BotsApiBotsBulkFireRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsBulkFire(requestParameters.id, requestParameters.botsBulkFireRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates new bot
     * @param {BotsApiBotsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsCreate(requestParameters: BotsApiBotsCreateRequest = {}, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsCreate(requestParameters.botsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint fetches bot data based on provided botId parameters
     * @summary Retrieves bot data including triggers, notes and actions
     * @param {BotsApiBotsDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsDataGet(requestParameters: BotsApiBotsDataGetRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsDataGet(requestParameters.botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes list of bots
     * @param {BotsApiBotsDeletesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsDeletes(requestParameters: BotsApiBotsDeletesRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsDeletes(requestParameters.bots, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Either submit for review, unlink from the external template provider or link with an existing template ID. Note: this is deprecated, use \"actionExternalTemplateCommand\" instead
     * @summary Execute a command to update the status for the external template
     * @param {BotsApiBotsExternalTemplateCommandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsExternalTemplateCommand(requestParameters: BotsApiBotsExternalTemplateCommandRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsExternalTemplateCommand(requestParameters.id, requestParameters.accountId, requestParameters.command, requestParameters.language, requestParameters.category, requestParameters.templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Will throw a 400 if there is no starting action ID
     * @summary Initiates a bot sequence. Fires the starting action ID
     * @param {BotsApiBotsFireRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsFire(requestParameters: BotsApiBotsFireRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsFire(requestParameters.id, requestParameters.botsFireRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of bots
     * @param {BotsApiBotsGetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsGets(requestParameters: BotsApiBotsGetsRequest = {}, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsGets(requestParameters.q, requestParameters.isForm, requestParameters.before, requestParameters.count, requestParameters.id, requestParameters.sortBy, requestParameters.order, requestParameters.folderId, requestParameters.language, requestParameters.industry, requestParameters.returnTotalCount, requestParameters.triggerTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an action
     * @param {BotsApiBotsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsPatch(requestParameters: BotsApiBotsPatchRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsPatch(requestParameters.id, requestParameters.botPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update status of some templates
     * @param {BotsApiExternalTemplateStatusUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public externalTemplateStatusUpdate(requestParameters: BotsApiExternalTemplateStatusUpdateRequest = {}, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).externalTemplateStatusUpdate(requestParameters.templateStatusUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns list of action fire records
     * @param {BotsApiGetActionFireRecordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public getActionFireRecords(requestParameters: BotsApiGetActionFireRecordsRequest = {}, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).getActionFireRecords(requestParameters.count, requestParameters.beforeId, requestParameters.botId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FoldersApi - axios parameter creator
 * @export
 */
export const FoldersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create folder
         * @param {FolderCreateRequest} [folderCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderCreate: async (folderCreateRequest?: FolderCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folderCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes list of folders
         * @param {Array<string>} folders 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderDelete: async (folders: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folders' is not null or undefined
            assertParamExists('folderDelete', 'folders', folders)
            const localVarPath = `/folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_DELETE"], configuration)

            if (folders) {
                localVarQueryParameter['folders'] = folders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all folders related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderGet: async (count?: number, before?: string, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update folder
         * @param {string} folderId 
         * @param {FolderUpdateRequest} [folderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderUpdate: async (folderId: string, folderUpdateRequest?: FolderUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('folderUpdate', 'folderId', folderId)
            const localVarPath = `/folder/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folderUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoldersApi - functional programming interface
 * @export
 */
export const FoldersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoldersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create folder
         * @param {FolderCreateRequest} [folderCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async folderCreate(folderCreateRequest?: FolderCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Folder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.folderCreate(folderCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes list of folders
         * @param {Array<string>} folders 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async folderDelete(folders: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.folderDelete(folders, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets all folders related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async folderGet(count?: number, before?: string, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.folderGet(count, before, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update folder
         * @param {string} folderId 
         * @param {FolderUpdateRequest} [folderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async folderUpdate(folderId: string, folderUpdateRequest?: FolderUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.folderUpdate(folderId, folderUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FoldersApi - factory interface
 * @export
 */
export const FoldersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoldersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create folder
         * @param {FoldersApiFolderCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderCreate(requestParameters: FoldersApiFolderCreateRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Folder> {
            return localVarFp.folderCreate(requestParameters.folderCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes list of folders
         * @param {FoldersApiFolderDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderDelete(requestParameters: FoldersApiFolderDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.folderDelete(requestParameters.folders, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all folders related to account/team
         * @param {FoldersApiFolderGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderGet(requestParameters: FoldersApiFolderGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FolderGet200Response> {
            return localVarFp.folderGet(requestParameters.count, requestParameters.before, requestParameters.q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update folder
         * @param {FoldersApiFolderUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderUpdate(requestParameters: FoldersApiFolderUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.folderUpdate(requestParameters.folderId, requestParameters.folderUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for folderCreate operation in FoldersApi.
 * @export
 * @interface FoldersApiFolderCreateRequest
 */
export interface FoldersApiFolderCreateRequest {
    /**
     * 
     * @type {FolderCreateRequest}
     * @memberof FoldersApiFolderCreate
     */
    readonly folderCreateRequest?: FolderCreateRequest
}

/**
 * Request parameters for folderDelete operation in FoldersApi.
 * @export
 * @interface FoldersApiFolderDeleteRequest
 */
export interface FoldersApiFolderDeleteRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof FoldersApiFolderDelete
     */
    readonly folders: Array<string>
}

/**
 * Request parameters for folderGet operation in FoldersApi.
 * @export
 * @interface FoldersApiFolderGetRequest
 */
export interface FoldersApiFolderGetRequest {
    /**
     * 
     * @type {number}
     * @memberof FoldersApiFolderGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof FoldersApiFolderGet
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiFolderGet
     */
    readonly q?: string
}

/**
 * Request parameters for folderUpdate operation in FoldersApi.
 * @export
 * @interface FoldersApiFolderUpdateRequest
 */
export interface FoldersApiFolderUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiFolderUpdate
     */
    readonly folderId: string

    /**
     * 
     * @type {FolderUpdateRequest}
     * @memberof FoldersApiFolderUpdate
     */
    readonly folderUpdateRequest?: FolderUpdateRequest
}

/**
 * FoldersApi - object-oriented interface
 * @export
 * @class FoldersApi
 * @extends {BaseAPI}
 */
export class FoldersApi extends BaseAPI {
    /**
     * 
     * @summary Create folder
     * @param {FoldersApiFolderCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public folderCreate(requestParameters: FoldersApiFolderCreateRequest = {}, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).folderCreate(requestParameters.folderCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes list of folders
     * @param {FoldersApiFolderDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public folderDelete(requestParameters: FoldersApiFolderDeleteRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).folderDelete(requestParameters.folders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all folders related to account/team
     * @param {FoldersApiFolderGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public folderGet(requestParameters: FoldersApiFolderGetRequest = {}, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).folderGet(requestParameters.count, requestParameters.before, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update folder
     * @param {FoldersApiFolderUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public folderUpdate(requestParameters: FoldersApiFolderUpdateRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).folderUpdate(requestParameters.folderId, requestParameters.folderUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FormsApi - axios parameter creator
 * @export
 */
export const FormsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get form actions and submission data
         * @param {string} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formDataGet: async (submissionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionId' is not null or undefined
            assertParamExists('formDataGet', 'submissionId', submissionId)
            const localVarPath = `/form-data/{submissionId}`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create form submissions
         * @param {string} botId 
         * @param {FormSubmissionCreateRequest} [formSubmissionCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formSubmissionCreate: async (botId: string, formSubmissionCreateRequest?: FormSubmissionCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('formSubmissionCreate', 'botId', botId)
            const localVarPath = `/form-submissions/{botId}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(formSubmissionCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete form submissions
         * @param {string} botId 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formSubmissionDelete: async (botId: string, ids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('formSubmissionDelete', 'botId', botId)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('formSubmissionDelete', 'ids', ids)
            const localVarPath = `/form-submissions/{botId}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_DELETE"], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a form submission
         * @param {string} submissionId 
         * @param {FormSubmissionUpdate} [formSubmissionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formSubmissionUpdate: async (submissionId: string, formSubmissionUpdate?: FormSubmissionUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionId' is not null or undefined
            assertParamExists('formSubmissionUpdate', 'submissionId', submissionId)
            const localVarPath = `/form-submission/{submissionId}`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(formSubmissionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get form submissions
         * @param {string} botId 
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formSubmissionsGet: async (botId: string, count?: number, before?: string, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('formSubmissionsGet', 'botId', botId)
            const localVarPath = `/form-submissions/{botId}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit a form
         * @param {string} submissionId 
         * @param {SubmitFormRequest} [submitFormRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm: async (submissionId: string, submitFormRequest?: SubmitFormRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionId' is not null or undefined
            assertParamExists('submitForm', 'submissionId', submissionId)
            const localVarPath = `/form-submission/{submissionId}/submit`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitFormRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FormsApi - functional programming interface
 * @export
 */
export const FormsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FormsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get form actions and submission data
         * @param {string} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formDataGet(submissionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormDataGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formDataGet(submissionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create form submissions
         * @param {string} botId 
         * @param {FormSubmissionCreateRequest} [formSubmissionCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formSubmissionCreate(botId: string, formSubmissionCreateRequest?: FormSubmissionCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormSubmissionCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formSubmissionCreate(botId, formSubmissionCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete form submissions
         * @param {string} botId 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formSubmissionDelete(botId: string, ids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formSubmissionDelete(botId, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a form submission
         * @param {string} submissionId 
         * @param {FormSubmissionUpdate} [formSubmissionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formSubmissionUpdate(submissionId: string, formSubmissionUpdate?: FormSubmissionUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formSubmissionUpdate(submissionId, formSubmissionUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get form submissions
         * @param {string} botId 
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formSubmissionsGet(botId: string, count?: number, before?: string, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormSubmissionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formSubmissionsGet(botId, count, before, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit a form
         * @param {string} submissionId 
         * @param {SubmitFormRequest} [submitFormRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitForm(submissionId: string, submitFormRequest?: SubmitFormRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitForm(submissionId, submitFormRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FormsApi - factory interface
 * @export
 */
export const FormsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FormsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get form actions and submission data
         * @param {FormsApiFormDataGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formDataGet(requestParameters: FormsApiFormDataGetRequest, options?: AxiosRequestConfig): AxiosPromise<FormDataGet200Response> {
            return localVarFp.formDataGet(requestParameters.submissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create form submissions
         * @param {FormsApiFormSubmissionCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formSubmissionCreate(requestParameters: FormsApiFormSubmissionCreateRequest, options?: AxiosRequestConfig): AxiosPromise<FormSubmissionCreate200Response> {
            return localVarFp.formSubmissionCreate(requestParameters.botId, requestParameters.formSubmissionCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete form submissions
         * @param {FormsApiFormSubmissionDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formSubmissionDelete(requestParameters: FormsApiFormSubmissionDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.formSubmissionDelete(requestParameters.botId, requestParameters.ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a form submission
         * @param {FormsApiFormSubmissionUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formSubmissionUpdate(requestParameters: FormsApiFormSubmissionUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.formSubmissionUpdate(requestParameters.submissionId, requestParameters.formSubmissionUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get form submissions
         * @param {FormsApiFormSubmissionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formSubmissionsGet(requestParameters: FormsApiFormSubmissionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<FormSubmissionsGet200Response> {
            return localVarFp.formSubmissionsGet(requestParameters.botId, requestParameters.count, requestParameters.before, requestParameters.q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit a form
         * @param {FormsApiSubmitFormRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm(requestParameters: FormsApiSubmitFormRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.submitForm(requestParameters.submissionId, requestParameters.submitFormRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for formDataGet operation in FormsApi.
 * @export
 * @interface FormsApiFormDataGetRequest
 */
export interface FormsApiFormDataGetRequest {
    /**
     * 
     * @type {string}
     * @memberof FormsApiFormDataGet
     */
    readonly submissionId: string
}

/**
 * Request parameters for formSubmissionCreate operation in FormsApi.
 * @export
 * @interface FormsApiFormSubmissionCreateRequest
 */
export interface FormsApiFormSubmissionCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof FormsApiFormSubmissionCreate
     */
    readonly botId: string

    /**
     * 
     * @type {FormSubmissionCreateRequest}
     * @memberof FormsApiFormSubmissionCreate
     */
    readonly formSubmissionCreateRequest?: FormSubmissionCreateRequest
}

/**
 * Request parameters for formSubmissionDelete operation in FormsApi.
 * @export
 * @interface FormsApiFormSubmissionDeleteRequest
 */
export interface FormsApiFormSubmissionDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof FormsApiFormSubmissionDelete
     */
    readonly botId: string

    /**
     * 
     * @type {Array<string>}
     * @memberof FormsApiFormSubmissionDelete
     */
    readonly ids: Array<string>
}

/**
 * Request parameters for formSubmissionUpdate operation in FormsApi.
 * @export
 * @interface FormsApiFormSubmissionUpdateRequest
 */
export interface FormsApiFormSubmissionUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof FormsApiFormSubmissionUpdate
     */
    readonly submissionId: string

    /**
     * 
     * @type {FormSubmissionUpdate}
     * @memberof FormsApiFormSubmissionUpdate
     */
    readonly formSubmissionUpdate?: FormSubmissionUpdate
}

/**
 * Request parameters for formSubmissionsGet operation in FormsApi.
 * @export
 * @interface FormsApiFormSubmissionsGetRequest
 */
export interface FormsApiFormSubmissionsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof FormsApiFormSubmissionsGet
     */
    readonly botId: string

    /**
     * 
     * @type {number}
     * @memberof FormsApiFormSubmissionsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof FormsApiFormSubmissionsGet
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof FormsApiFormSubmissionsGet
     */
    readonly q?: string
}

/**
 * Request parameters for submitForm operation in FormsApi.
 * @export
 * @interface FormsApiSubmitFormRequest
 */
export interface FormsApiSubmitFormRequest {
    /**
     * 
     * @type {string}
     * @memberof FormsApiSubmitForm
     */
    readonly submissionId: string

    /**
     * 
     * @type {SubmitFormRequest}
     * @memberof FormsApiSubmitForm
     */
    readonly submitFormRequest?: SubmitFormRequest
}

/**
 * FormsApi - object-oriented interface
 * @export
 * @class FormsApi
 * @extends {BaseAPI}
 */
export class FormsApi extends BaseAPI {
    /**
     * 
     * @summary Get form actions and submission data
     * @param {FormsApiFormDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formDataGet(requestParameters: FormsApiFormDataGetRequest, options?: AxiosRequestConfig) {
        return FormsApiFp(this.configuration).formDataGet(requestParameters.submissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create form submissions
     * @param {FormsApiFormSubmissionCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formSubmissionCreate(requestParameters: FormsApiFormSubmissionCreateRequest, options?: AxiosRequestConfig) {
        return FormsApiFp(this.configuration).formSubmissionCreate(requestParameters.botId, requestParameters.formSubmissionCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete form submissions
     * @param {FormsApiFormSubmissionDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formSubmissionDelete(requestParameters: FormsApiFormSubmissionDeleteRequest, options?: AxiosRequestConfig) {
        return FormsApiFp(this.configuration).formSubmissionDelete(requestParameters.botId, requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a form submission
     * @param {FormsApiFormSubmissionUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formSubmissionUpdate(requestParameters: FormsApiFormSubmissionUpdateRequest, options?: AxiosRequestConfig) {
        return FormsApiFp(this.configuration).formSubmissionUpdate(requestParameters.submissionId, requestParameters.formSubmissionUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get form submissions
     * @param {FormsApiFormSubmissionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formSubmissionsGet(requestParameters: FormsApiFormSubmissionsGetRequest, options?: AxiosRequestConfig) {
        return FormsApiFp(this.configuration).formSubmissionsGet(requestParameters.botId, requestParameters.count, requestParameters.before, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit a form
     * @param {FormsApiSubmitFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public submitForm(requestParameters: FormsApiSubmitFormRequest, options?: AxiosRequestConfig) {
        return FormsApiFp(this.configuration).submitForm(requestParameters.submissionId, requestParameters.submitFormRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShareBotApi - axios parameter creator
 * @export
 */
export const ShareBotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new slug, which is used the share the bot
         * @param {BotShareRequest} [botShareRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botShare: async (botShareRequest?: BotShareRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bot/share`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botShareRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a slug
         * @param {string} slug 
         * @param {BotSharePatchRequest} [botSharePatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botSharePatch: async (slug: string, botSharePatchRequest?: BotSharePatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('botSharePatch', 'slug', slug)
            const localVarPath = `/bot/share`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botSharePatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint fetches bot data based on provided slug parameters
         * @summary Retrieves bot data including triggers, notes and actions
         * @param {string} slug The shared sulg of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDataGetBySlug: async (slug: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('botsDataGetBySlug', 'slug', slug)
            const localVarPath = `/bot/share/{slug}/data`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the bot which is associated with token
         * @param {string} slug The slug of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShareBot: async (slug: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('getShareBot', 'slug', slug)
            const localVarPath = `/bot/share/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a bot by slug
         * @param {string} slug The shared slug of the bot
         * @param {PatchBotBySlugRequest} [patchBotBySlugRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBotBySlug: async (slug: string, patchBotBySlugRequest?: PatchBotBySlugRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('patchBotBySlug', 'slug', slug)
            const localVarPath = `/bot/share/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchBotBySlugRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes list of slugs
         * @param {Array<string>} slugs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slugsDelete: async (slugs: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slugs' is not null or undefined
            assertParamExists('slugsDelete', 'slugs', slugs)
            const localVarPath = `/bot/share`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_DELETE"], configuration)

            if (slugs) {
                localVarQueryParameter['slugs'] = slugs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShareBotApi - functional programming interface
 * @export
 */
export const ShareBotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShareBotApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new slug, which is used the share the bot
         * @param {BotShareRequest} [botShareRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botShare(botShareRequest?: BotShareRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedSlug>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botShare(botShareRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a slug
         * @param {string} slug 
         * @param {BotSharePatchRequest} [botSharePatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botSharePatch(slug: string, botSharePatchRequest?: BotSharePatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botSharePatch(slug, botSharePatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint fetches bot data based on provided slug parameters
         * @summary Retrieves bot data including triggers, notes and actions
         * @param {string} slug The shared sulg of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsDataGetBySlug(slug: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsDataGetBySlug(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the bot which is associated with token
         * @param {string} slug The slug of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShareBot(slug: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShareBot(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a bot by slug
         * @param {string} slug The shared slug of the bot
         * @param {PatchBotBySlugRequest} [patchBotBySlugRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchBotBySlug(slug: string, patchBotBySlugRequest?: PatchBotBySlugRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchBotBySlug(slug, patchBotBySlugRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes list of slugs
         * @param {Array<string>} slugs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slugsDelete(slugs: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slugsDelete(slugs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShareBotApi - factory interface
 * @export
 */
export const ShareBotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShareBotApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new slug, which is used the share the bot
         * @param {ShareBotApiBotShareRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botShare(requestParameters: ShareBotApiBotShareRequest = {}, options?: AxiosRequestConfig): AxiosPromise<SharedSlug> {
            return localVarFp.botShare(requestParameters.botShareRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a slug
         * @param {ShareBotApiBotSharePatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botSharePatch(requestParameters: ShareBotApiBotSharePatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.botSharePatch(requestParameters.slug, requestParameters.botSharePatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint fetches bot data based on provided slug parameters
         * @summary Retrieves bot data including triggers, notes and actions
         * @param {ShareBotApiBotsDataGetBySlugRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDataGetBySlug(requestParameters: ShareBotApiBotsDataGetBySlugRequest, options?: AxiosRequestConfig): AxiosPromise<BotData> {
            return localVarFp.botsDataGetBySlug(requestParameters.slug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the bot which is associated with token
         * @param {ShareBotApiGetShareBotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShareBot(requestParameters: ShareBotApiGetShareBotRequest, options?: AxiosRequestConfig): AxiosPromise<Bot> {
            return localVarFp.getShareBot(requestParameters.slug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a bot by slug
         * @param {ShareBotApiPatchBotBySlugRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchBotBySlug(requestParameters: ShareBotApiPatchBotBySlugRequest, options?: AxiosRequestConfig): AxiosPromise<BotData> {
            return localVarFp.patchBotBySlug(requestParameters.slug, requestParameters.patchBotBySlugRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes list of slugs
         * @param {ShareBotApiSlugsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slugsDelete(requestParameters: ShareBotApiSlugsDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.slugsDelete(requestParameters.slugs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for botShare operation in ShareBotApi.
 * @export
 * @interface ShareBotApiBotShareRequest
 */
export interface ShareBotApiBotShareRequest {
    /**
     * 
     * @type {BotShareRequest}
     * @memberof ShareBotApiBotShare
     */
    readonly botShareRequest?: BotShareRequest
}

/**
 * Request parameters for botSharePatch operation in ShareBotApi.
 * @export
 * @interface ShareBotApiBotSharePatchRequest
 */
export interface ShareBotApiBotSharePatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ShareBotApiBotSharePatch
     */
    readonly slug: string

    /**
     * 
     * @type {BotSharePatchRequest}
     * @memberof ShareBotApiBotSharePatch
     */
    readonly botSharePatchRequest?: BotSharePatchRequest
}

/**
 * Request parameters for botsDataGetBySlug operation in ShareBotApi.
 * @export
 * @interface ShareBotApiBotsDataGetBySlugRequest
 */
export interface ShareBotApiBotsDataGetBySlugRequest {
    /**
     * The shared sulg of the bot
     * @type {string}
     * @memberof ShareBotApiBotsDataGetBySlug
     */
    readonly slug: string
}

/**
 * Request parameters for getShareBot operation in ShareBotApi.
 * @export
 * @interface ShareBotApiGetShareBotRequest
 */
export interface ShareBotApiGetShareBotRequest {
    /**
     * The slug of the bot
     * @type {string}
     * @memberof ShareBotApiGetShareBot
     */
    readonly slug: string
}

/**
 * Request parameters for patchBotBySlug operation in ShareBotApi.
 * @export
 * @interface ShareBotApiPatchBotBySlugRequest
 */
export interface ShareBotApiPatchBotBySlugRequest {
    /**
     * The shared slug of the bot
     * @type {string}
     * @memberof ShareBotApiPatchBotBySlug
     */
    readonly slug: string

    /**
     * 
     * @type {PatchBotBySlugRequest}
     * @memberof ShareBotApiPatchBotBySlug
     */
    readonly patchBotBySlugRequest?: PatchBotBySlugRequest
}

/**
 * Request parameters for slugsDelete operation in ShareBotApi.
 * @export
 * @interface ShareBotApiSlugsDeleteRequest
 */
export interface ShareBotApiSlugsDeleteRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ShareBotApiSlugsDelete
     */
    readonly slugs: Array<string>
}

/**
 * ShareBotApi - object-oriented interface
 * @export
 * @class ShareBotApi
 * @extends {BaseAPI}
 */
export class ShareBotApi extends BaseAPI {
    /**
     * 
     * @summary Create new slug, which is used the share the bot
     * @param {ShareBotApiBotShareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareBotApi
     */
    public botShare(requestParameters: ShareBotApiBotShareRequest = {}, options?: AxiosRequestConfig) {
        return ShareBotApiFp(this.configuration).botShare(requestParameters.botShareRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a slug
     * @param {ShareBotApiBotSharePatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareBotApi
     */
    public botSharePatch(requestParameters: ShareBotApiBotSharePatchRequest, options?: AxiosRequestConfig) {
        return ShareBotApiFp(this.configuration).botSharePatch(requestParameters.slug, requestParameters.botSharePatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint fetches bot data based on provided slug parameters
     * @summary Retrieves bot data including triggers, notes and actions
     * @param {ShareBotApiBotsDataGetBySlugRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareBotApi
     */
    public botsDataGetBySlug(requestParameters: ShareBotApiBotsDataGetBySlugRequest, options?: AxiosRequestConfig) {
        return ShareBotApiFp(this.configuration).botsDataGetBySlug(requestParameters.slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the bot which is associated with token
     * @param {ShareBotApiGetShareBotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareBotApi
     */
    public getShareBot(requestParameters: ShareBotApiGetShareBotRequest, options?: AxiosRequestConfig) {
        return ShareBotApiFp(this.configuration).getShareBot(requestParameters.slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a bot by slug
     * @param {ShareBotApiPatchBotBySlugRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareBotApi
     */
    public patchBotBySlug(requestParameters: ShareBotApiPatchBotBySlugRequest, options?: AxiosRequestConfig) {
        return ShareBotApiFp(this.configuration).patchBotBySlug(requestParameters.slug, requestParameters.patchBotBySlugRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes list of slugs
     * @param {ShareBotApiSlugsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareBotApi
     */
    public slugsDelete(requestParameters: ShareBotApiSlugsDeleteRequest, options?: AxiosRequestConfig) {
        return ShareBotApiFp(this.configuration).slugsDelete(requestParameters.slugs, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StoreApi - axios parameter creator
 * @export
 */
export const StoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create options in the store
         * @param {StoreCreateRequest} [storeCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCreate: async (storeCreateRequest?: StoreCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get options in the store
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [language] 
         * @param {Array<string>} [categoryKeyValue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeGet: async (count?: number, before?: string, q?: string, language?: string, categoryKeyValue?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (categoryKeyValue) {
                localVarQueryParameter['categoryKeyValue'] = categoryKeyValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreApi - functional programming interface
 * @export
 */
export const StoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoreApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create options in the store
         * @param {StoreCreateRequest} [storeCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeCreate(storeCreateRequest?: StoreCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeCreate(storeCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get options in the store
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [language] 
         * @param {Array<string>} [categoryKeyValue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeGet(count?: number, before?: string, q?: string, language?: string, categoryKeyValue?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeGet(count, before, q, language, categoryKeyValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StoreApi - factory interface
 * @export
 */
export const StoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoreApiFp(configuration)
    return {
        /**
         * 
         * @summary Create options in the store
         * @param {StoreApiStoreCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCreate(requestParameters: StoreApiStoreCreateRequest = {}, options?: AxiosRequestConfig): AxiosPromise<TemplateItem> {
            return localVarFp.storeCreate(requestParameters.storeCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get options in the store
         * @param {StoreApiStoreGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeGet(requestParameters: StoreApiStoreGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<StoreGet200Response> {
            return localVarFp.storeGet(requestParameters.count, requestParameters.before, requestParameters.q, requestParameters.language, requestParameters.categoryKeyValue, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for storeCreate operation in StoreApi.
 * @export
 * @interface StoreApiStoreCreateRequest
 */
export interface StoreApiStoreCreateRequest {
    /**
     * 
     * @type {StoreCreateRequest}
     * @memberof StoreApiStoreCreate
     */
    readonly storeCreateRequest?: StoreCreateRequest
}

/**
 * Request parameters for storeGet operation in StoreApi.
 * @export
 * @interface StoreApiStoreGetRequest
 */
export interface StoreApiStoreGetRequest {
    /**
     * 
     * @type {number}
     * @memberof StoreApiStoreGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof StoreApiStoreGet
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof StoreApiStoreGet
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof StoreApiStoreGet
     */
    readonly language?: string

    /**
     * 
     * @type {Array<string>}
     * @memberof StoreApiStoreGet
     */
    readonly categoryKeyValue?: Array<string>
}

/**
 * StoreApi - object-oriented interface
 * @export
 * @class StoreApi
 * @extends {BaseAPI}
 */
export class StoreApi extends BaseAPI {
    /**
     * 
     * @summary Create options in the store
     * @param {StoreApiStoreCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeCreate(requestParameters: StoreApiStoreCreateRequest = {}, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeCreate(requestParameters.storeCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get options in the store
     * @param {StoreApiStoreGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeGet(requestParameters: StoreApiStoreGetRequest = {}, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeGet(requestParameters.count, requestParameters.before, requestParameters.q, requestParameters.language, requestParameters.categoryKeyValue, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VisitURLApi - axios parameter creator
 * @export
 */
export const VisitURLApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Visit a URL
         * @param {string} actionFireRecordId 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        visitUrl: async (actionFireRecordId: string, url: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionFireRecordId' is not null or undefined
            assertParamExists('visitUrl', 'actionFireRecordId', actionFireRecordId)
            // verify required parameter 'url' is not null or undefined
            assertParamExists('visitUrl', 'url', url)
            const localVarPath = `/visit/{actionFireRecordId}`
                .replace(`{${"actionFireRecordId"}}`, encodeURIComponent(String(actionFireRecordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VisitURLApi - functional programming interface
 * @export
 */
export const VisitURLApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VisitURLApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Visit a URL
         * @param {string} actionFireRecordId 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async visitUrl(actionFireRecordId: string, url: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.visitUrl(actionFireRecordId, url, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VisitURLApi - factory interface
 * @export
 */
export const VisitURLApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VisitURLApiFp(configuration)
    return {
        /**
         * 
         * @summary Visit a URL
         * @param {VisitURLApiVisitUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        visitUrl(requestParameters: VisitURLApiVisitUrlRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.visitUrl(requestParameters.actionFireRecordId, requestParameters.url, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for visitUrl operation in VisitURLApi.
 * @export
 * @interface VisitURLApiVisitUrlRequest
 */
export interface VisitURLApiVisitUrlRequest {
    /**
     * 
     * @type {string}
     * @memberof VisitURLApiVisitUrl
     */
    readonly actionFireRecordId: string

    /**
     * 
     * @type {string}
     * @memberof VisitURLApiVisitUrl
     */
    readonly url: string
}

/**
 * VisitURLApi - object-oriented interface
 * @export
 * @class VisitURLApi
 * @extends {BaseAPI}
 */
export class VisitURLApi extends BaseAPI {
    /**
     * 
     * @summary Visit a URL
     * @param {VisitURLApiVisitUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisitURLApi
     */
    public visitUrl(requestParameters: VisitURLApiVisitUrlRequest, options?: AxiosRequestConfig) {
        return VisitURLApiFp(this.configuration).visitUrl(requestParameters.actionFireRecordId, requestParameters.url, options).then((request) => request(this.axios, this.basePath));
    }
}


