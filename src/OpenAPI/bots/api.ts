const BASE_PATH = "https://api-bots.chatdaddy.tech".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Bots Service
 * Make, Get & Execute Bots
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError } from '../base';

/**
 * @type AccountIDSelector
 * @export
 */
export type AccountIDSelector = AccountIDSelectorOneOf | AccountIDSelectorOneOf1;

/**
 * Specify the exact accountID. Specify an array to round robin between the accounts
 * @export
 * @interface AccountIDSelectorOneOf
 */
export interface AccountIDSelectorOneOf {
    /**
     * 
     * @type {string}
     * @memberof AccountIDSelectorOneOf
     */
    'type': AccountIDSelectorOneOfTypeEnum;
    /**
     * 
     * @type {AccountIDSelectorOneOfValue}
     * @memberof AccountIDSelectorOneOf
     */
    'value': AccountIDSelectorOneOfValue;
}

export const AccountIDSelectorOneOfTypeEnum = {
    Exact: 'exact'
} as const;

export type AccountIDSelectorOneOfTypeEnum = typeof AccountIDSelectorOneOfTypeEnum[keyof typeof AccountIDSelectorOneOfTypeEnum];

/**
 * 
 * @export
 * @interface AccountIDSelectorOneOf1
 */
export interface AccountIDSelectorOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof AccountIDSelectorOneOf1
     */
    'type': AccountIDSelectorOneOf1TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountIDSelectorOneOf1
     */
    'value': string;
}

export const AccountIDSelectorOneOf1TypeEnum = {
    PropertyPath: 'propertyPath'
} as const;

export type AccountIDSelectorOneOf1TypeEnum = typeof AccountIDSelectorOneOf1TypeEnum[keyof typeof AccountIDSelectorOneOf1TypeEnum];

/**
 * @type AccountIDSelectorOneOfValue
 * @export
 */
export type AccountIDSelectorOneOfValue = Array<string> | string;

/**
 * 
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Action
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Action
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    'id': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof Action
     */
    'botId'?: string;
    /**
     * Name of the template
     * @type {string}
     * @memberof Action
     */
    'name': string;
    /**
     * 
     * @type {MessageObj}
     * @memberof Action
     */
    'message'?: MessageObj | null;
    /**
     * set the assignee on the contact
     * @type {string}
     * @memberof Action
     */
    'assignee'?: string | null;
    /**
     * Tags to set on this contact.
     * @type {Array<ActionContentTagsInner>}
     * @memberof Action
     */
    'tags'?: Array<ActionContentTagsInner> | null;
    /**
     * Array of UserId
     * @type {Array<string>}
     * @memberof Action
     */
    'notifyUsers'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Action
     * @deprecated
     */
    'webhooks'?: Array<string> | null;
    /**
     * 
     * @type {Array<WebhookItem>}
     * @memberof Action
     */
    'httpRequest'?: Array<WebhookItem> | null;
    /**
     * 
     * @type {Position}
     * @memberof Action
     */
    'position'?: Position | null;
    /**
     * 
     * @type {Position}
     * @memberof Action
     */
    'actionPosition'?: Position | null;
    /**
     * send in to remove the action
     * @type {boolean}
     * @memberof Action
     */
    'remove'?: boolean;
    /**
     * 
     * @type {FormRef}
     * @memberof Action
     */
    'formRef'?: FormRef | null;
    /**
     * 
     * @type {FormActionMetadata}
     * @memberof Action
     */
    'formActionMetadata'?: FormActionMetadata | null;
    /**
     * Type of the message being sent
     * @type {string}
     * @memberof Action
     */
    'messageType'?: ActionMessageTypeEnum;
    /**
     * Account ID of the sender
     * @type {string}
     * @memberof Action
     */
    'accountId'?: string;
    /**
     * 
     * @type {ActionContentZapierAction}
     * @memberof Action
     */
    'zapierAction'?: ActionContentZapierAction | null;
}

export const ActionMessageTypeEnum = {
    Message: 'message',
    Email: 'email'
} as const;

export type ActionMessageTypeEnum = typeof ActionMessageTypeEnum[keyof typeof ActionMessageTypeEnum];

/**
 * 
 * @export
 * @interface ActionAllOf
 */
export interface ActionAllOf {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionAllOf
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionAllOf
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface ActionContent
 */
export interface ActionContent {
    /**
     * 
     * @type {string}
     * @memberof ActionContent
     */
    'id'?: string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof ActionContent
     */
    'botId'?: string;
    /**
     * Name of the template
     * @type {string}
     * @memberof ActionContent
     */
    'name'?: string;
    /**
     * 
     * @type {MessageObj}
     * @memberof ActionContent
     */
    'message'?: MessageObj | null;
    /**
     * set the assignee on the contact
     * @type {string}
     * @memberof ActionContent
     */
    'assignee'?: string | null;
    /**
     * Tags to set on this contact.
     * @type {Array<ActionContentTagsInner>}
     * @memberof ActionContent
     */
    'tags'?: Array<ActionContentTagsInner> | null;
    /**
     * Array of UserId
     * @type {Array<string>}
     * @memberof ActionContent
     */
    'notifyUsers'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ActionContent
     * @deprecated
     */
    'webhooks'?: Array<string> | null;
    /**
     * 
     * @type {Array<WebhookItem>}
     * @memberof ActionContent
     */
    'httpRequest'?: Array<WebhookItem> | null;
    /**
     * 
     * @type {Position}
     * @memberof ActionContent
     */
    'position'?: Position | null;
    /**
     * 
     * @type {Position}
     * @memberof ActionContent
     */
    'actionPosition'?: Position | null;
    /**
     * send in to remove the action
     * @type {boolean}
     * @memberof ActionContent
     */
    'remove'?: boolean;
    /**
     * 
     * @type {FormRef}
     * @memberof ActionContent
     */
    'formRef'?: FormRef | null;
    /**
     * 
     * @type {FormActionMetadata}
     * @memberof ActionContent
     */
    'formActionMetadata'?: FormActionMetadata | null;
    /**
     * Type of the message being sent
     * @type {string}
     * @memberof ActionContent
     */
    'messageType'?: ActionContentMessageTypeEnum;
    /**
     * Account ID of the sender
     * @type {string}
     * @memberof ActionContent
     */
    'accountId'?: string;
    /**
     * 
     * @type {ActionContentZapierAction}
     * @memberof ActionContent
     */
    'zapierAction'?: ActionContentZapierAction | null;
}

export const ActionContentMessageTypeEnum = {
    Message: 'message',
    Email: 'email'
} as const;

export type ActionContentMessageTypeEnum = typeof ActionContentMessageTypeEnum[keyof typeof ActionContentMessageTypeEnum];

/**
 * 
 * @export
 * @interface ActionContentTagsInner
 */
export interface ActionContentTagsInner {
    /**
     * 
     * @type {string}
     * @memberof ActionContentTagsInner
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ActionContentTagsInner
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface ActionContentZapierAction
 */
export interface ActionContentZapierAction {
    /**
     * 
     * @type {string}
     * @memberof ActionContentZapierAction
     */
    'editZapPopupURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionContentZapierAction
     */
    'zapId'?: string;
}
/**
 * 
 * @export
 * @interface ActionExecuteCount
 */
export interface ActionExecuteCount {
    /**
     * ID of the action
     * @type {string}
     * @memberof ActionExecuteCount
     */
    'actionId': string;
    /**
     * ID of the previous action triggered before this action
     * @type {string}
     * @memberof ActionExecuteCount
     */
    'previousActionId': string;
    /**
     * Number of time this action is sent out to contacts
     * @type {number}
     * @memberof ActionExecuteCount
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface ActionFireRecord
 */
export interface ActionFireRecord {
    /**
     * 
     * @type {number}
     * @memberof ActionFireRecord
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'actionId': string;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'botId': string;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'status'?: ActionFireRecordStatusEnum;
    /**
     * ID of the contact
     * @type {string}
     * @memberof ActionFireRecord
     */
    'contactId'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ActionFireRecord
     */
    'inputParameters'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'accountId'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionFireRecord
     */
    'createdAt'?: string;
    /**
     * 
     * @type {Array<ServiceResponse>}
     * @memberof ActionFireRecord
     */
    'messages'?: Array<ServiceResponse>;
    /**
     * 
     * @type {Array<ServiceResponse>}
     * @memberof ActionFireRecord
     */
    'webhooks'?: Array<ServiceResponse>;
    /**
     * 
     * @type {ServiceResponse}
     * @memberof ActionFireRecord
     */
    'contact'?: ServiceResponse;
    /**
     * 
     * @type {boolean}
     * @memberof ActionFireRecord
     */
    'isStart'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ActionFireRecord
     */
    'isFinal'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ActionFireRecord
     */
    'previousActionId'?: string;
}

export const ActionFireRecordStatusEnum = {
    Pending: 'pending',
    Sent: 'sent',
    Failed: 'failed',
    Cancelled: 'cancelled'
} as const;

export type ActionFireRecordStatusEnum = typeof ActionFireRecordStatusEnum[keyof typeof ActionFireRecordStatusEnum];

/**
 * @type ActionInteraction
 * @export
 */
export type ActionInteraction = ActionInteractionOneOf | ActionInteractionOneOf1 | ActionInteractionOneOf2 | ActionInteractionOneOf3;

/**
 * 
 * @export
 * @interface ActionInteractionBase
 */
export interface ActionInteractionBase {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionInteractionBase
     */
    'doneAt': string;
}
/**
 * 
 * @export
 * @interface ActionInteractionOneOf
 */
export interface ActionInteractionOneOf {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionInteractionOneOf
     */
    'doneAt': string;
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionOneOf
     */
    'type': ActionInteractionOneOfTypeEnum;
    /**
     * Error message
     * @type {string}
     * @memberof ActionInteractionOneOf
     */
    'message'?: string;
}

export const ActionInteractionOneOfTypeEnum = {
    Error: 'error'
} as const;

export type ActionInteractionOneOfTypeEnum = typeof ActionInteractionOneOfTypeEnum[keyof typeof ActionInteractionOneOfTypeEnum];

/**
 * 
 * @export
 * @interface ActionInteractionOneOf1
 */
export interface ActionInteractionOneOf1 {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionInteractionOneOf1
     */
    'doneAt': string;
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionOneOf1
     */
    'type': ActionInteractionOneOf1TypeEnum;
}

export const ActionInteractionOneOf1TypeEnum = {
    Sent: 'sent',
    Delivered: 'delivered'
} as const;

export type ActionInteractionOneOf1TypeEnum = typeof ActionInteractionOneOf1TypeEnum[keyof typeof ActionInteractionOneOf1TypeEnum];

/**
 * Action was simply sent out, no further interaction recorded
 * @export
 * @interface ActionInteractionOneOf1AllOf
 */
export interface ActionInteractionOneOf1AllOf {
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionOneOf1AllOf
     */
    'type': ActionInteractionOneOf1AllOfTypeEnum;
}

export const ActionInteractionOneOf1AllOfTypeEnum = {
    Sent: 'sent',
    Delivered: 'delivered'
} as const;

export type ActionInteractionOneOf1AllOfTypeEnum = typeof ActionInteractionOneOf1AllOfTypeEnum[keyof typeof ActionInteractionOneOf1AllOfTypeEnum];

/**
 * 
 * @export
 * @interface ActionInteractionOneOf2
 */
export interface ActionInteractionOneOf2 {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionInteractionOneOf2
     */
    'doneAt': string;
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionOneOf2
     */
    'type': ActionInteractionOneOf2TypeEnum;
    /**
     * Text of the button or list item that was clicked
     * @type {string}
     * @memberof ActionInteractionOneOf2
     */
    'text': string;
}

export const ActionInteractionOneOf2TypeEnum = {
    Click: 'click'
} as const;

export type ActionInteractionOneOf2TypeEnum = typeof ActionInteractionOneOf2TypeEnum[keyof typeof ActionInteractionOneOf2TypeEnum];

/**
 * Action was sent out and a button/list item was clicked
 * @export
 * @interface ActionInteractionOneOf2AllOf
 */
export interface ActionInteractionOneOf2AllOf {
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionOneOf2AllOf
     */
    'type': ActionInteractionOneOf2AllOfTypeEnum;
    /**
     * Text of the button or list item that was clicked
     * @type {string}
     * @memberof ActionInteractionOneOf2AllOf
     */
    'text': string;
}

export const ActionInteractionOneOf2AllOfTypeEnum = {
    Click: 'click'
} as const;

export type ActionInteractionOneOf2AllOfTypeEnum = typeof ActionInteractionOneOf2AllOfTypeEnum[keyof typeof ActionInteractionOneOf2AllOfTypeEnum];

/**
 * 
 * @export
 * @interface ActionInteractionOneOf3
 */
export interface ActionInteractionOneOf3 {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ActionInteractionOneOf3
     */
    'doneAt': string;
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionOneOf3
     */
    'type': ActionInteractionOneOf3TypeEnum;
    /**
     * 
     * @type {ActionInteractionOneOf3AllOfContent}
     * @memberof ActionInteractionOneOf3
     */
    'content': ActionInteractionOneOf3AllOfContent;
}

export const ActionInteractionOneOf3TypeEnum = {
    UserInput: 'user_input'
} as const;

export type ActionInteractionOneOf3TypeEnum = typeof ActionInteractionOneOf3TypeEnum[keyof typeof ActionInteractionOneOf3TypeEnum];

/**
 * Action was sent out and a user input was submitted
 * @export
 * @interface ActionInteractionOneOf3AllOf
 */
export interface ActionInteractionOneOf3AllOf {
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionOneOf3AllOf
     */
    'type': ActionInteractionOneOf3AllOfTypeEnum;
    /**
     * 
     * @type {ActionInteractionOneOf3AllOfContent}
     * @memberof ActionInteractionOneOf3AllOf
     */
    'content': ActionInteractionOneOf3AllOfContent;
}

export const ActionInteractionOneOf3AllOfTypeEnum = {
    UserInput: 'user_input'
} as const;

export type ActionInteractionOneOf3AllOfTypeEnum = typeof ActionInteractionOneOf3AllOfTypeEnum[keyof typeof ActionInteractionOneOf3AllOfTypeEnum];

/**
 * Content of the user input that was submitted
 * @export
 * @interface ActionInteractionOneOf3AllOfContent
 */
export interface ActionInteractionOneOf3AllOfContent {
    /**
     * Text of the user input
     * @type {string}
     * @memberof ActionInteractionOneOf3AllOfContent
     */
    'text'?: string;
    /**
     * Attachments of the user input
     * @type {Array<IMMessageAttachment>}
     * @memberof ActionInteractionOneOf3AllOfContent
     */
    'attachments'?: Array<IMMessageAttachment>;
}
/**
 * Action was simply sent out, no further interaction recorded
 * @export
 * @interface ActionInteractionOneOfAllOf
 */
export interface ActionInteractionOneOfAllOf {
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionOneOfAllOf
     */
    'type': ActionInteractionOneOfAllOfTypeEnum;
    /**
     * Error message
     * @type {string}
     * @memberof ActionInteractionOneOfAllOf
     */
    'message'?: string;
}

export const ActionInteractionOneOfAllOfTypeEnum = {
    Error: 'error'
} as const;

export type ActionInteractionOneOfAllOfTypeEnum = typeof ActionInteractionOneOfAllOfTypeEnum[keyof typeof ActionInteractionOneOfAllOfTypeEnum];

/**
 * 
 * @export
 * @interface ActionInteractionQueryValue
 */
export interface ActionInteractionQueryValue {
    /**
     * 
     * @type {ActionInteractionType}
     * @memberof ActionInteractionQueryValue
     */
    'type': ActionInteractionType;
    /**
     * 
     * @type {string}
     * @memberof ActionInteractionQueryValue
     */
    'text'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ActionInteractionType = {
    Sent: 'sent',
    Delivered: 'delivered',
    Click: 'click',
    UserInput: 'user_input',
    Error: 'error',
    Scheduled: 'scheduled',
    Exists: 'exists'
} as const;

export type ActionInteractionType = typeof ActionInteractionType[keyof typeof ActionInteractionType];


/**
 * 
 * @export
 * @interface ActionNode
 */
export interface ActionNode {
    /**
     * 
     * @type {string}
     * @memberof ActionNode
     */
    'type': ActionNodeTypeEnum;
    /**
     * 
     * @type {Action}
     * @memberof ActionNode
     */
    'data': Action;
    /**
     * 
     * @type {ActionNodeHandle}
     * @memberof ActionNode
     */
    'handle': ActionNodeHandle;
    /**
     * send in to remove the action
     * @type {boolean}
     * @memberof ActionNode
     */
    'remove'?: boolean;
}

export const ActionNodeTypeEnum = {
    Action: 'action'
} as const;

export type ActionNodeTypeEnum = typeof ActionNodeTypeEnum[keyof typeof ActionNodeTypeEnum];

/**
 * 
 * @export
 * @interface ActionNodeHandle
 */
export interface ActionNodeHandle {
    /**
     * 
     * @type {Array<string>}
     * @memberof ActionNodeHandle
     */
    'delay'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ActionNodeHandle
     */
    'userInput'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ActionTarget
 */
export interface ActionTarget {
    /**
     * 
     * @type {string}
     * @memberof ActionTarget
     */
    'triggerActionId': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof ActionTarget
     */
    'triggerBotId'?: string;
    /**
     * 
     * @type {Position}
     * @memberof ActionTarget
     */
    'position'?: Position | null;
}
/**
 * 
 * @export
 * @interface ActionsGet200Response
 */
export interface ActionsGet200Response {
    /**
     * 
     * @type {Array<Action>}
     * @memberof ActionsGet200Response
     */
    'actions': Array<Action>;
    /**
     * Name of the last record fetched
     * @type {string}
     * @memberof ActionsGet200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface ActionsGptGenerate200Response
 */
export interface ActionsGptGenerate200Response {
    /**
     * 
     * @type {Array<ActionContent>}
     * @memberof ActionsGptGenerate200Response
     */
    'actions': Array<ActionContent>;
}
/**
 * 
 * @export
 * @interface ActionsGptGenerateRequest
 */
export interface ActionsGptGenerateRequest {
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof ActionsGptGenerateRequest
     */
    'botId': string;
    /**
     * 
     * @type {string}
     * @memberof ActionsGptGenerateRequest
     */
    'actionId': string;
    /**
     * 
     * @type {Array<ActionContent>}
     * @memberof ActionsGptGenerateRequest
     */
    'actions': Array<ActionContent>;
    /**
     * 
     * @type {string}
     * @memberof ActionsGptGenerateRequest
     */
    'industry': string;
    /**
     * 
     * @type {string}
     * @memberof ActionsGptGenerateRequest
     */
    'additionalContext'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActionsGptGenerateRequest
     */
    'amount'?: number;
}
/**
 * 
 * @export
 * @interface Bot
 */
export interface Bot {
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'name': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof Bot
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'teamId': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof Bot
     */
    'defaultAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'startingActionId'?: string | null;
    /**
     * 
     * @type {Array<Action>}
     * @memberof Bot
     */
    'actions'?: Array<Action>;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    'folderId'?: string | null;
    /**
     * If true, this bot is treated as a form
     * @type {boolean}
     * @memberof Bot
     */
    'isForm'?: boolean;
    /**
     * 
     * @type {{ [key: string]: ExternalTemplateProvider; }}
     * @memberof Bot
     */
    'externalTemplate'?: { [key: string]: ExternalTemplateProvider; };
    /**
     * URL of the thumbnail image
     * @type {string}
     * @memberof Bot
     */
    'imageUrl'?: string;
    /**
     * Description of the bot
     * @type {string}
     * @memberof Bot
     */
    'description'?: string;
    /**
     * Industry of the bot
     * @type {string}
     * @memberof Bot
     */
    'industry'?: string;
    /**
     * Language of the bot
     * @type {string}
     * @memberof Bot
     */
    'language'?: string;
    /**
     * 
     * @type {Array<BotNote>}
     * @memberof Bot
     */
    'notes'?: Array<BotNote>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Bot
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Bot
     */
    'updatedAt': string;
    /**
     * ID of the user who created the bot
     * @type {string}
     * @memberof Bot
     */
    'createdBy': string;
    /**
     * Slugs which is generated and shared with other to view the message flow
     * @type {Array<SharedSlug>}
     * @memberof Bot
     */
    'sharedSlugs'?: Array<SharedSlug>;
}
/**
 * 
 * @export
 * @interface BotBoolCondition
 */
export interface BotBoolCondition {
    /**
     * 
     * @type {string}
     * @memberof BotBoolCondition
     */
    'propertyPath': string;
    /**
     * 
     * @type {string}
     * @memberof BotBoolCondition
     */
    'operator': BotBoolConditionOperatorEnum;
}

export const BotBoolConditionOperatorEnum = {
    IsTrue: 'isTrue',
    IsFalse: 'isFalse'
} as const;

export type BotBoolConditionOperatorEnum = typeof BotBoolConditionOperatorEnum[keyof typeof BotBoolConditionOperatorEnum];

/**
 * @type BotCondition
 * @export
 */
export type BotCondition = BotBoolCondition | BotEqualityCondition | BotLegacyCondition | BotNumericalCondition | BotTextCondition | BotTimeCondition | BotTimestampCondition;

/**
 * 
 * @export
 * @interface BotData
 */
export interface BotData {
    /**
     * 
     * @type {Array<BotTrigger>}
     * @memberof BotData
     */
    'triggers': Array<BotTrigger>;
    /**
     * 
     * @type {Array<Action>}
     * @memberof BotData
     */
    'actions': Array<Action>;
    /**
     * 
     * @type {Array<BotNote>}
     * @memberof BotData
     */
    'notes': Array<BotNote>;
}
/**
 * 
 * @export
 * @interface BotEqualityCondition
 */
export interface BotEqualityCondition {
    /**
     * 
     * @type {string}
     * @memberof BotEqualityCondition
     */
    'propertyPath': string;
    /**
     * 
     * @type {BotEqualityConditionValue}
     * @memberof BotEqualityCondition
     */
    'value': BotEqualityConditionValue;
    /**
     * 
     * @type {string}
     * @memberof BotEqualityCondition
     */
    'operator': BotEqualityConditionOperatorEnum;
}

export const BotEqualityConditionOperatorEnum = {
    Equals: 'equals',
    NotEquals: 'notEquals'
} as const;

export type BotEqualityConditionOperatorEnum = typeof BotEqualityConditionOperatorEnum[keyof typeof BotEqualityConditionOperatorEnum];

/**
 * @type BotEqualityConditionValue
 * @export
 */
export type BotEqualityConditionValue = Array<string> | number | string;

/**
 * Stores the record for whenever a bot is fired.
 * @export
 * @interface BotFireRecord
 */
export interface BotFireRecord {
    /**
     * 
     * @type {string}
     * @memberof BotFireRecord
     */
    'id': string;
    /**
     * ID of the contact
     * @type {string}
     * @memberof BotFireRecord
     */
    'contactId': string;
    /**
     * 
     * @type {string}
     * @memberof BotFireRecord
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof BotFireRecord
     */
    'botId': string;
    /**
     * 
     * @type {string}
     * @memberof BotFireRecord
     */
    'status': BotFireRecordStatusEnum;
    /**
     * ID of the user who fired the bot.
     * @type {string}
     * @memberof BotFireRecord
     */
    'createdBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotFireRecord
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotFireRecord
     */
    'updatedAt': string;
    /**
     * Map of all actions sent & interacted with during this instance. Keyed by action ID
     * @type {{ [key: string]: ActionInteraction; }}
     * @memberof BotFireRecord
     */
    'interactions': { [key: string]: ActionInteraction; };
    /**
     * 
     * @type {string}
     * @memberof BotFireRecord
     */
    'instanceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotFireRecord
     */
    'scheduledActionId'?: string;
}

export const BotFireRecordStatusEnum = {
    Scheduled: 'scheduled',
    Running: 'running',
    Completed: 'completed'
} as const;

export type BotFireRecordStatusEnum = typeof BotFireRecordStatusEnum[keyof typeof BotFireRecordStatusEnum];

/**
 * 
 * @export
 * @interface BotLegacyCondition
 */
export interface BotLegacyCondition {
    /**
     * 
     * @type {string}
     * @memberof BotLegacyCondition
     */
    'propertyPath': string;
    /**
     * 
     * @type {Array<BotLegacyConditionValuesInner>}
     * @memberof BotLegacyCondition
     */
    'values': Array<BotLegacyConditionValuesInner>;
    /**
     * 
     * @type {string}
     * @memberof BotLegacyCondition
     */
    'operator': BotLegacyConditionOperatorEnum;
}

export const BotLegacyConditionOperatorEnum = {
    NotEmpty: 'notEmpty',
    Equals: 'equals',
    NotEquals: 'notEquals',
    GreaterThan: 'greaterThan',
    LessThan: 'lessThan',
    GreaterThanOrEquals: 'greaterThanOrEquals',
    LessThanOrEquals: 'lessThanOrEquals',
    Contains: 'contains',
    NotContains: 'notContains',
    StartsWith: 'startsWith',
    EndsWith: 'endsWith'
} as const;

export type BotLegacyConditionOperatorEnum = typeof BotLegacyConditionOperatorEnum[keyof typeof BotLegacyConditionOperatorEnum];

/**
 * @type BotLegacyConditionValuesInner
 * @export
 */
export type BotLegacyConditionValuesInner = number | string;

/**
 * 
 * @export
 * @interface BotMessageButton
 */
export interface BotMessageButton {
    /**
     * 
     * @type {string}
     * @memberof BotMessageButton
     */
    'text': string;
    /**
     * Use \"nextAction\" instead
     * @type {string}
     * @memberof BotMessageButton
     * @deprecated
     */
    'triggerActionId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BotMessageButton
     */
    'triggerBotId'?: string | null;
    /**
     * Make a button with a link
     * @type {string}
     * @memberof BotMessageButton
     */
    'url'?: string;
    /**
     * Make a button with a phone number
     * @type {string}
     * @memberof BotMessageButton
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {Position}
     * @memberof BotMessageButton
     */
    'position'?: Position | null;
    /**
     * 
     * @type {NextAction}
     * @memberof BotMessageButton
     */
    'nextAction'?: NextAction;
}
/**
 * 
 * @export
 * @interface BotMessageDelay
 */
export interface BotMessageDelay {
    /**
     * Time delays on second
     * @type {number}
     * @memberof BotMessageDelay
     */
    'timeDelaySec': number;
    /**
     * Use \"nextAction\" instead
     * @type {string}
     * @memberof BotMessageDelay
     * @deprecated
     */
    'triggerActionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotMessageDelay
     */
    'triggerBotId'?: string | null;
    /**
     * Simulate typing
     * @type {boolean}
     * @memberof BotMessageDelay
     */
    'simulateTyping'?: boolean;
    /**
     * If true, the message will be cancelled if a reply is received
     * @type {boolean}
     * @memberof BotMessageDelay
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * 
     * @type {Position}
     * @memberof BotMessageDelay
     */
    'position'?: Position | null;
    /**
     * 
     * @type {NextAction}
     * @memberof BotMessageDelay
     */
    'nextAction'?: NextAction;
}
/**
 * 
 * @export
 * @interface BotMessageInput
 */
export interface BotMessageInput {
    /**
     * Name of the input
     * @type {string}
     * @memberof BotMessageInput
     */
    'name': string;
    /**
     * 
     * @type {BotMessageInputValidation}
     * @memberof BotMessageInput
     */
    'validation'?: BotMessageInputValidation;
    /**
     * Use \"nextAction\" instead
     * @type {string}
     * @memberof BotMessageInput
     * @deprecated
     */
    'triggerActionId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BotMessageInput
     */
    'triggerBotId'?: string | null;
    /**
     * 
     * @type {NextAction}
     * @memberof BotMessageInput
     */
    'nextAction'?: NextAction;
    /**
     * 
     * @type {Position}
     * @memberof BotMessageInput
     */
    'position'?: Position | null;
}
/**
 * 
 * @export
 * @interface BotMessageInputValidation
 */
export interface BotMessageInputValidation {
    /**
     * 
     * @type {string}
     * @memberof BotMessageInputValidation
     */
    'type': BotMessageInputValidationTypeEnum;
}

export const BotMessageInputValidationTypeEnum = {
    String: 'string',
    Integer: 'integer'
} as const;

export type BotMessageInputValidationTypeEnum = typeof BotMessageInputValidationTypeEnum[keyof typeof BotMessageInputValidationTypeEnum];

/**
 * 
 * @export
 * @interface BotMessageList
 */
export interface BotMessageList {
    /**
     * 
     * @type {string}
     * @memberof BotMessageList
     */
    'title'?: string;
    /**
     * 
     * @type {Array<BotMessageListSectionsInner>}
     * @memberof BotMessageList
     */
    'sections': Array<BotMessageListSectionsInner>;
    /**
     * 
     * @type {Position}
     * @memberof BotMessageList
     */
    'position'?: Position | null;
}
/**
 * 
 * @export
 * @interface BotMessageListSectionsInner
 */
export interface BotMessageListSectionsInner {
    /**
     * 
     * @type {string}
     * @memberof BotMessageListSectionsInner
     */
    'title': string;
    /**
     * 
     * @type {Array<BotMessageListSectionsInnerOptionsInner>}
     * @memberof BotMessageListSectionsInner
     */
    'options': Array<BotMessageListSectionsInnerOptionsInner>;
}
/**
 * 
 * @export
 * @interface BotMessageListSectionsInnerOptionsInner
 */
export interface BotMessageListSectionsInnerOptionsInner {
    /**
     * 
     * @type {string}
     * @memberof BotMessageListSectionsInnerOptionsInner
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof BotMessageListSectionsInnerOptionsInner
     */
    'description'?: string;
    /**
     * 
     * @type {NextAction}
     * @memberof BotMessageListSectionsInnerOptionsInner
     */
    'nextAction'?: NextAction;
}
/**
 * 
 * @export
 * @interface BotNote
 */
export interface BotNote {
    /**
     * 
     * @type {string}
     * @memberof BotNote
     */
    'id'?: string;
    /**
     * 
     * @type {Array<IMMessageAttachment>}
     * @memberof BotNote
     */
    'attachments'?: Array<IMMessageAttachment>;
    /**
     * 
     * @type {string}
     * @memberof BotNote
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotNote
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof BotNote
     */
    'height'?: number;
    /**
     * 
     * @type {number}
     * @memberof BotNote
     */
    'width'?: number;
    /**
     * 
     * @type {Array<BotNoteTargetsInner>}
     * @memberof BotNote
     */
    'targets'?: Array<BotNoteTargetsInner> | null;
    /**
     * 
     * @type {string}
     * @memberof BotNote
     */
    'color'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BotNote
     */
    'zIndex'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BotNote
     */
    'fillColor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BotNote
     */
    'shapeType'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BotNote
     */
    'textStyles'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {Position}
     * @memberof BotNote
     */
    'position': Position | null;
    /**
     * send in to remove the note
     * @type {boolean}
     * @memberof BotNote
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface BotNoteNode
 */
export interface BotNoteNode {
    /**
     * 
     * @type {string}
     * @memberof BotNoteNode
     */
    'type': BotNoteNodeTypeEnum;
    /**
     * 
     * @type {BotNote}
     * @memberof BotNoteNode
     */
    'data': BotNote;
    /**
     * send in to remove the note
     * @type {boolean}
     * @memberof BotNoteNode
     */
    'remove'?: boolean;
}

export const BotNoteNodeTypeEnum = {
    Note: 'note'
} as const;

export type BotNoteNodeTypeEnum = typeof BotNoteNodeTypeEnum[keyof typeof BotNoteNodeTypeEnum];

/**
 * 
 * @export
 * @interface BotNoteTargetsInner
 */
export interface BotNoteTargetsInner {
    /**
     * 
     * @type {string}
     * @memberof BotNoteTargetsInner
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof BotNoteTargetsInner
     */
    'sourceHandle': string;
    /**
     * 
     * @type {string}
     * @memberof BotNoteTargetsInner
     */
    'targetHandle': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BotNoteTargetsInner
     */
    'edgeStyles'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BotNumericalCondition
 */
export interface BotNumericalCondition {
    /**
     * 
     * @type {string}
     * @memberof BotNumericalCondition
     */
    'propertyPath': string;
    /**
     * 
     * @type {number}
     * @memberof BotNumericalCondition
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof BotNumericalCondition
     */
    'operator': BotNumericalConditionOperatorEnum;
}

export const BotNumericalConditionOperatorEnum = {
    GreaterThan: 'greaterThan',
    LessThan: 'lessThan',
    GreaterThanOrEquals: 'greaterThanOrEquals',
    LessThanOrEquals: 'lessThanOrEquals'
} as const;

export type BotNumericalConditionOperatorEnum = typeof BotNumericalConditionOperatorEnum[keyof typeof BotNumericalConditionOperatorEnum];

/**
 * 
 * @export
 * @interface BotPatch
 */
export interface BotPatch {
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'startingActionId'?: string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof BotPatch
     */
    'defaultAccountId'?: string;
    /**
     * List of actions to upsert. Do not specify the ID to add a new action
     * @type {Array<ActionContent>}
     * @memberof BotPatch
     */
    'actions'?: Array<ActionContent>;
    /**
     * 
     * @type {Array<BotNote>}
     * @memberof BotPatch
     */
    'notes'?: Array<BotNote>;
    /**
     * 
     * @type {Array<TriggerUpsert>}
     * @memberof BotPatch
     */
    'triggers'?: Array<TriggerUpsert>;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'industry'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof BotPatch
     */
    'folderId'?: string | null;
}
/**
 * 
 * @export
 * @interface BotShareRequest
 */
export interface BotShareRequest {
    /**
     * 
     * @type {string}
     * @memberof BotShareRequest
     */
    'botId': string;
    /**
     * 
     * @type {boolean}
     * @memberof BotShareRequest
     */
    'editable'?: boolean;
}
/**
 * 
 * @export
 * @interface BotTargetNode
 */
export interface BotTargetNode {
    /**
     * 
     * @type {string}
     * @memberof BotTargetNode
     */
    'type': BotTargetNodeTypeEnum;
    /**
     * 
     * @type {ActionTarget}
     * @memberof BotTargetNode
     */
    'data': ActionTarget;
    /**
     * 
     * @type {Action}
     * @memberof BotTargetNode
     */
    'sourceAction': Action;
    /**
     * 
     * @type {number}
     * @memberof BotTargetNode
     */
    'sourceIndex': number;
    /**
     * 
     * @type {ConditionSourceType}
     * @memberof BotTargetNode
     */
    'sourceType'?: ConditionSourceType;
    /**
     * 
     * @type {ConditionSource}
     * @memberof BotTargetNode
     */
    'conditionSource'?: ConditionSource;
    /**
     * send in to remove the bot target
     * @type {boolean}
     * @memberof BotTargetNode
     */
    'remove'?: boolean;
}

export const BotTargetNodeTypeEnum = {
    BotTarget: 'botTarget'
} as const;

export type BotTargetNodeTypeEnum = typeof BotTargetNodeTypeEnum[keyof typeof BotTargetNodeTypeEnum];

/**
 * 
 * @export
 * @interface BotTextCondition
 */
export interface BotTextCondition {
    /**
     * 
     * @type {string}
     * @memberof BotTextCondition
     */
    'propertyPath': string;
    /**
     * 
     * @type {string}
     * @memberof BotTextCondition
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof BotTextCondition
     */
    'operator': BotTextConditionOperatorEnum;
}

export const BotTextConditionOperatorEnum = {
    NotEmpty: 'notEmpty',
    Contains: 'contains',
    NotContains: 'notContains',
    StartsWith: 'startsWith',
    EndsWith: 'endsWith',
    ContainsPhrase: 'containsPhrase'
} as const;

export type BotTextConditionOperatorEnum = typeof BotTextConditionOperatorEnum[keyof typeof BotTextConditionOperatorEnum];

/**
 * 
 * @export
 * @interface BotTimeCondition
 */
export interface BotTimeCondition {
    /**
     * 
     * @type {string}
     * @memberof BotTimeCondition
     */
    'propertyPath': string;
    /**
     * 
     * @type {TimePeriodDescriptor}
     * @memberof BotTimeCondition
     */
    'value': TimePeriodDescriptor;
    /**
     * 
     * @type {string}
     * @memberof BotTimeCondition
     */
    'operator': BotTimeConditionOperatorEnum;
}

export const BotTimeConditionOperatorEnum = {
    Timestamp: 'timestamp'
} as const;

export type BotTimeConditionOperatorEnum = typeof BotTimeConditionOperatorEnum[keyof typeof BotTimeConditionOperatorEnum];

/**
 * 
 * @export
 * @interface BotTimestampCondition
 */
export interface BotTimestampCondition {
    /**
     * 
     * @type {string}
     * @memberof BotTimestampCondition
     */
    'propertyPath': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTimestampCondition
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof BotTimestampCondition
     */
    'operator': BotTimestampConditionOperatorEnum;
}

export const BotTimestampConditionOperatorEnum = {
    TimestampGreaterThan: 'timestampGreaterThan',
    TimestampLessThan: 'timestampLessThan'
} as const;

export type BotTimestampConditionOperatorEnum = typeof BotTimestampConditionOperatorEnum[keyof typeof BotTimestampConditionOperatorEnum];

/**
 * 
 * @export
 * @interface BotTrigger
 */
export interface BotTrigger {
    /**
     * 
     * @type {string}
     * @memberof BotTrigger
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof BotTrigger
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof BotTrigger
     */
    'name': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof BotTrigger
     */
    'botId': string;
    /**
     * 
     * @type {NextAction}
     * @memberof BotTrigger
     */
    'action': NextAction;
    /**
     * 
     * @type {BotTriggerTarget}
     * @memberof BotTrigger
     */
    'target': BotTriggerTarget;
    /**
     * 
     * @type {BotTriggerOptions}
     * @memberof BotTrigger
     */
    'options': BotTriggerOptions;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTrigger
     */
    'lastTriggered'?: string;
    /**
     * 
     * @type {number}
     * @memberof BotTrigger
     */
    'triggered': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTrigger
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTrigger
     */
    'updatedAt': string;
    /**
     * 
     * @type {TriggerMethod}
     * @memberof BotTrigger
     */
    'method': TriggerMethod;
    /**
     * 
     * @type {boolean}
     * @memberof BotTrigger
     */
    'remove'?: boolean;
    /**
     * 
     * @type {Position}
     * @memberof BotTrigger
     */
    'position'?: Position | null;
}
/**
 * 
 * @export
 * @interface BotTriggerAllOf
 */
export interface BotTriggerAllOf {
    /**
     * 
     * @type {Position}
     * @memberof BotTriggerAllOf
     */
    'position'?: Position | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTriggerAllOf
     */
    'lastTriggered'?: string;
    /**
     * 
     * @type {number}
     * @memberof BotTriggerAllOf
     */
    'triggered': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTriggerAllOf
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTriggerAllOf
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface BotTriggerContext
 */
export interface BotTriggerContext {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTriggerContext
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface BotTriggerInstance
 */
export interface BotTriggerInstance {
    /**
     * 
     * @type {string}
     * @memberof BotTriggerInstance
     */
    'id': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTriggerInstance
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BotTriggerInstance
     */
    'status': BotTriggerInstanceStatusEnum;
    /**
     * 
     * @type {InstanceFirstActionStatusCounts}
     * @memberof BotTriggerInstance
     */
    'firstActionCounts': InstanceFirstActionStatusCounts;
    /**
     * 
     * @type {string}
     * @memberof BotTriggerInstance
     */
    'triggerId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTriggerInstance
     */
    'nextScheduledAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof BotTriggerInstance
     */
    'completedAt'?: string;
}

export const BotTriggerInstanceStatusEnum = {
    Running: 'running',
    Completed: 'completed',
    Stopped: 'stopped'
} as const;

export type BotTriggerInstanceStatusEnum = typeof BotTriggerInstanceStatusEnum[keyof typeof BotTriggerInstanceStatusEnum];

/**
 * 
 * @export
 * @interface BotTriggerOptions
 */
export interface BotTriggerOptions {
    /**
     * 
     * @type {TriggerDelay}
     * @memberof BotTriggerOptions
     */
    'delay'?: TriggerDelay;
    /**
     * 
     * @type {MessageSendOptions}
     * @memberof BotTriggerOptions
     */
    'sendOptions'?: MessageSendOptions;
    /**
     * The interval in seconds between each message being sent.
     * @type {number}
     * @memberof BotTriggerOptions
     */
    'sendIntervalS'?: number;
    /**
     * 
     * @type {TimePeriodDescriptor}
     * @memberof BotTriggerOptions
     */
    'sendTimeRange'?: TimePeriodDescriptor;
}
/**
 * 
 * @export
 * @interface BotTriggerPayload
 */
export interface BotTriggerPayload {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BotTriggerPayload
     */
    'contact'?: { [key: string]: any; };
    /**
     * The data that is being sent to the bot. The data has the following properties
     * @type {{ [key: string]: any; }}
     * @memberof BotTriggerPayload
     */
    'data': { [key: string]: any; };
    /**
     * 
     * @type {BotTriggerContext}
     * @memberof BotTriggerPayload
     */
    'context': BotTriggerContext;
}
/**
 * @type BotTriggerTarget
 * @export
 */
export type BotTriggerTarget = ContactsQueryTarget | PropertyPathTarget;

/**
 * 
 * @export
 * @interface BotsAnalyticsGet200Response
 */
export interface BotsAnalyticsGet200Response {
    /**
     * 
     * @type {Array<ActionExecuteCount>}
     * @memberof BotsAnalyticsGet200Response
     */
    'counts': Array<ActionExecuteCount>;
}
/**
 * 
 * @export
 * @interface BotsBulkFire200Response
 */
export interface BotsBulkFire200Response {
    /**
     * 
     * @type {Array<ActionFireRecord>}
     * @memberof BotsBulkFire200Response
     */
    'records': Array<ActionFireRecord>;
}
/**
 * 
 * @export
 * @interface BotsBulkFireRequest
 */
export interface BotsBulkFireRequest {
    /**
     * Which account to use. If not specified here, it must be specified in each recipient
     * @type {string}
     * @memberof BotsBulkFireRequest
     */
    'accountId'?: string;
    /**
     * List of recipients to send the message to
     * @type {Array<Recipient>}
     * @memberof BotsBulkFireRequest
     */
    'recipients': Array<Recipient>;
    /**
     * 
     * @type {MessageSendOptions}
     * @memberof BotsBulkFireRequest
     */
    'messageSendOptions'?: MessageSendOptions;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BotsBulkFireRequest
     */
    'parameters'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BotsCreateRequest
 */
export interface BotsCreateRequest {
    /**
     * Specify the ID of the bot to be created. Has to be globally unique
     * @type {string}
     * @memberof BotsCreateRequest
     */
    'id'?: string;
    /**
     * The name of the bot to be created
     * @type {string}
     * @memberof BotsCreateRequest
     */
    'name'?: string;
    /**
     * If true, the bot will be a form. If false, the bot will not be a form
     * @type {boolean}
     * @memberof BotsCreateRequest
     */
    'isForm'?: boolean;
}
/**
 * 
 * @export
 * @interface BotsExternalTemplateCommand200Response
 */
export interface BotsExternalTemplateCommand200Response {
    /**
     * 
     * @type {ExternalTemplateProvider}
     * @memberof BotsExternalTemplateCommand200Response
     */
    'config'?: ExternalTemplateProvider;
}
/**
 * 
 * @export
 * @interface BotsFireRequest
 */
export interface BotsFireRequest {
    /**
     * Which account to use
     * @type {string}
     * @memberof BotsFireRequest
     */
    'accountId'?: string;
    /**
     * ID of the contact
     * @type {string}
     * @memberof BotsFireRequest
     */
    'toContact': string;
    /**
     * 
     * @type {MessageSendOptions}
     * @memberof BotsFireRequest
     */
    'messageSendOptions'?: MessageSendOptions;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BotsFireRequest
     */
    'parameters'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BotsGets200Response
 */
export interface BotsGets200Response {
    /**
     * 
     * @type {Array<Bot>}
     * @memberof BotsGets200Response
     */
    'bots': Array<Bot>;
    /**
     * Cursor to use to fetch next page of results
     * @type {string}
     * @memberof BotsGets200Response
     */
    'cursor'?: string;
    /**
     * total bots present with these filters. Only returned if returnTotalCount is true
     * @type {number}
     * @memberof BotsGets200Response
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface ConditionNode
 */
export interface ConditionNode {
    /**
     * 
     * @type {string}
     * @memberof ConditionNode
     */
    'type': ConditionNodeTypeEnum;
    /**
     * 
     * @type {NextAction}
     * @memberof ConditionNode
     */
    'data': NextAction;
    /**
     * 
     * @type {ConditionNodeHandle}
     * @memberof ConditionNode
     */
    'handle': ConditionNodeHandle;
    /**
     * 
     * @type {ConditionSourceType}
     * @memberof ConditionNode
     */
    'sourceType': ConditionSourceType;
    /**
     * 
     * @type {Action}
     * @memberof ConditionNode
     */
    'sourceAction': Action;
    /**
     * 
     * @type {number}
     * @memberof ConditionNode
     */
    'sourceIndex': number;
    /**
     * send in to remove the condition
     * @type {boolean}
     * @memberof ConditionNode
     */
    'remove'?: boolean;
}

export const ConditionNodeTypeEnum = {
    Condition: 'condition'
} as const;

export type ConditionNodeTypeEnum = typeof ConditionNodeTypeEnum[keyof typeof ConditionNodeTypeEnum];

/**
 * 
 * @export
 * @interface ConditionNodeHandle
 */
export interface ConditionNodeHandle {
    /**
     * 
     * @type {Array<string>}
     * @memberof ConditionNodeHandle
     */
    'default'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConditionNodeHandle
     */
    'group'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ConditionSource
 */
export interface ConditionSource {
    /**
     * 
     * @type {string}
     * @memberof ConditionSource
     */
    'target': ConditionSourceTargetEnum;
    /**
     * 
     * @type {number}
     * @memberof ConditionSource
     */
    'index': number;
}

export const ConditionSourceTargetEnum = {
    Default: 'default',
    Group: 'group'
} as const;

export type ConditionSourceTargetEnum = typeof ConditionSourceTargetEnum[keyof typeof ConditionSourceTargetEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const ConditionSourceType = {
    Button: 'button',
    Input: 'input',
    Delay: 'delay',
    List: 'list'
} as const;

export type ConditionSourceType = typeof ConditionSourceType[keyof typeof ConditionSourceType];


/**
 * Data structure that gives information to the frontend on how to render conditions for a property of a data object that has caused a Trigger to fire.
 * @export
 * @interface ConditionableProperty
 */
export interface ConditionableProperty {
    /**
     * 
     * @type {string}
     * @memberof ConditionableProperty
     */
    'propertyPath': string;
    /**
     * 
     * @type {string}
     * @memberof ConditionableProperty
     */
    'type': ConditionablePropertyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ConditionableProperty
     */
    'title': string;
    /**
     * 
     * @type {Array<ConditionalPropertyOption>}
     * @memberof ConditionableProperty
     */
    'options'?: Array<ConditionalPropertyOption>;
    /**
     * 
     * @type {DisplayIcon}
     * @memberof ConditionableProperty
     */
    'icon'?: DisplayIcon;
}

export const ConditionablePropertyTypeEnum = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean',
    Channel: 'channel',
    Tag: 'tag',
    Timestamp: 'timestamp',
    CountryCode: 'country_code',
    TeamMember: 'team_member'
} as const;

export type ConditionablePropertyTypeEnum = typeof ConditionablePropertyTypeEnum[keyof typeof ConditionablePropertyTypeEnum];

/**
 * Define a list of conditionable properties that are only made available to the user if the \"displayConditions\" are met
 * @export
 * @interface ConditionablePropertyGroup
 */
export interface ConditionablePropertyGroup {
    /**
     * 
     * @type {Array<ConditionableProperty>}
     * @memberof ConditionablePropertyGroup
     */
    'properties': Array<ConditionableProperty>;
    /**
     * Define under which conditions this group\'s conditions should be displayed to the user. Conditions will be applied to the Trigger itself. The conditions are ANDed together
     * @type {Array<BotCondition>}
     * @memberof ConditionablePropertyGroup
     */
    'displayConditions': Array<BotCondition>;
}
/**
 * 
 * @export
 * @interface ConditionalPropertyOption
 */
export interface ConditionalPropertyOption {
    /**
     * Stringified value of the option.
     * @type {string}
     * @memberof ConditionalPropertyOption
     */
    'valueStr': string;
    /**
     * 
     * @type {string}
     * @memberof ConditionalPropertyOption
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface ContactsQueryTarget
 */
export interface ContactsQueryTarget {
    /**
     * 
     * @type {string}
     * @memberof ContactsQueryTarget
     */
    'type': ContactsQueryTargetTypeEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ContactsQueryTarget
     */
    'query': { [key: string]: any; };
    /**
     * 
     * @type {AccountIDSelector}
     * @memberof ContactsQueryTarget
     */
    'accountId'?: AccountIDSelector;
}

export const ContactsQueryTargetTypeEnum = {
    Query: 'query'
} as const;

export type ContactsQueryTargetTypeEnum = typeof ContactsQueryTargetTypeEnum[keyof typeof ContactsQueryTargetTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const DayOfWeek = {
    Monday: 'Monday',
    Tuesday: 'Tuesday',
    Wednesday: 'Wednesday',
    Thursday: 'Thursday',
    Friday: 'Friday',
    Saturday: 'Saturday',
    Sunday: 'Sunday'
} as const;

export type DayOfWeek = typeof DayOfWeek[keyof typeof DayOfWeek];


/**
 * 
 * @export
 * @interface DelayNode
 */
export interface DelayNode {
    /**
     * 
     * @type {string}
     * @memberof DelayNode
     */
    'type': DelayNodeTypeEnum;
    /**
     * 
     * @type {BotMessageDelay}
     * @memberof DelayNode
     */
    'data': BotMessageDelay;
    /**
     * 
     * @type {string}
     * @memberof DelayNode
     */
    'handle': string;
    /**
     * 
     * @type {Action}
     * @memberof DelayNode
     */
    'sourceAction': Action;
    /**
     * 
     * @type {number}
     * @memberof DelayNode
     */
    'sourceIndex': number;
    /**
     * send in to remove the delay
     * @type {boolean}
     * @memberof DelayNode
     */
    'remove'?: boolean;
}

export const DelayNodeTypeEnum = {
    Delay: 'delay'
} as const;

export type DelayNodeTypeEnum = typeof DelayNodeTypeEnum[keyof typeof DelayNodeTypeEnum];

/**
 * 
 * @export
 * @interface DisplayIcon
 */
export interface DisplayIcon {
    /**
     * Material symbol name
     * @type {string}
     * @memberof DisplayIcon
     */
    'name': string;
    /**
     * Color name, hex code or theme color
     * @type {string}
     * @memberof DisplayIcon
     */
    'color'?: string;
}
/**
 * 
 * @export
 * @interface EmailNode
 */
export interface EmailNode {
    /**
     * 
     * @type {string}
     * @memberof EmailNode
     */
    'type': EmailNodeTypeEnum;
    /**
     * 
     * @type {Action}
     * @memberof EmailNode
     */
    'data': Action;
    /**
     * 
     * @type {EmailNodeHandle}
     * @memberof EmailNode
     */
    'handle': EmailNodeHandle;
    /**
     * send in to remove the email
     * @type {boolean}
     * @memberof EmailNode
     */
    'remove'?: boolean;
}

export const EmailNodeTypeEnum = {
    Email: 'email'
} as const;

export type EmailNodeTypeEnum = typeof EmailNodeTypeEnum[keyof typeof EmailNodeTypeEnum];

/**
 * 
 * @export
 * @interface EmailNodeHandle
 */
export interface EmailNodeHandle {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailNodeHandle
     */
    'delay'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailNodeHandle
     */
    'action'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailNodeHandle
     */
    'userInput'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ExternalTemplateProvider
 */
export interface ExternalTemplateProvider {
    /**
     * ID of the template on the provider
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'category': string;
    /**
     * Language of the template
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'language'?: string;
    /**
     * Status of the template on the provider
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'status': ExternalTemplateProviderStatusEnum;
    /**
     * Details of the rejection, if rejected
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'rejectionDetails'?: string;
    /**
     * ID of the user who submitted the template
     * @type {string}
     * @memberof ExternalTemplateProvider
     */
    'submittedBy': string;
}

export const ExternalTemplateProviderStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Rejected: 'rejected'
} as const;

export type ExternalTemplateProviderStatusEnum = typeof ExternalTemplateProviderStatusEnum[keyof typeof ExternalTemplateProviderStatusEnum];

/**
 * 
 * @export
 * @interface Folder
 */
export interface Folder {
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'teamId': string;
    /**
     * 
     * @type {number}
     * @memberof Folder
     */
    'botCount': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Folder
     */
    'createdAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Folder
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface FolderCreateRequest
 */
export interface FolderCreateRequest {
    /**
     * Folder name
     * @type {string}
     * @memberof FolderCreateRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface FolderGet200Response
 */
export interface FolderGet200Response {
    /**
     * 
     * @type {Array<Folder>}
     * @memberof FolderGet200Response
     */
    'folders': Array<Folder>;
    /**
     * Cursor to use to fetch next page of results
     * @type {string}
     * @memberof FolderGet200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface FolderUpdateRequest
 */
export interface FolderUpdateRequest {
    /**
     * Folder name
     * @type {string}
     * @memberof FolderUpdateRequest
     */
    'name'?: string;
    /**
     * Bot IDs to add to the folder
     * @type {Array<FolderUpdateRequestBotIdsInner>}
     * @memberof FolderUpdateRequest
     */
    'botIds'?: Array<FolderUpdateRequestBotIdsInner>;
}
/**
 * 
 * @export
 * @interface FolderUpdateRequestBotIdsInner
 */
export interface FolderUpdateRequestBotIdsInner {
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof FolderUpdateRequestBotIdsInner
     */
    'botId': string;
    /**
     * If true, remove the bot from the folder
     * @type {boolean}
     * @memberof FolderUpdateRequestBotIdsInner
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface FormActionMetadata
 */
export interface FormActionMetadata {
    /**
     * If true, the field is required
     * @type {boolean}
     * @memberof FormActionMetadata
     */
    'required'?: boolean;
    /**
     * Type of the field
     * @type {string}
     * @memberof FormActionMetadata
     */
    'type'?: FormActionMetadataTypeEnum;
    /**
     * Index of the field
     * @type {number}
     * @memberof FormActionMetadata
     */
    'index'?: number;
    /**
     * Custom field to save the value to
     * @type {string}
     * @memberof FormActionMetadata
     */
    'saveToCustomField'?: string;
}

export const FormActionMetadataTypeEnum = {
    Text: 'text',
    Number: 'number',
    Date: 'date',
    Select: 'select',
    Multiselect: 'multiselect',
    Rating: 'rating',
    Nps: 'nps',
    Time: 'time'
} as const;

export type FormActionMetadataTypeEnum = typeof FormActionMetadataTypeEnum[keyof typeof FormActionMetadataTypeEnum];

/**
 * 
 * @export
 * @interface FormActions
 */
export interface FormActions {
    /**
     * 
     * @type {NextAction}
     * @memberof FormActions
     */
    'onSubmit'?: NextAction;
    /**
     * 
     * @type {NextAction}
     * @memberof FormActions
     */
    'onAbandon'?: NextAction;
}
/**
 * 
 * @export
 * @interface FormDataGet200Response
 */
export interface FormDataGet200Response {
    /**
     * 
     * @type {Array<Action>}
     * @memberof FormDataGet200Response
     */
    'actions': Array<Action>;
    /**
     * 
     * @type {Bot}
     * @memberof FormDataGet200Response
     */
    'form'?: Bot;
    /**
     * 
     * @type {FormSubmission}
     * @memberof FormDataGet200Response
     */
    'submission': FormSubmission;
}
/**
 * 
 * @export
 * @interface FormRef
 */
export interface FormRef {
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof FormRef
     */
    'id': string;
    /**
     * 
     * @type {FormActions}
     * @memberof FormRef
     */
    'actions'?: FormActions;
    /**
     * 
     * @type {Position}
     * @memberof FormRef
     */
    'position'?: Position | null;
}
/**
 * 
 * @export
 * @interface FormSubmission
 */
export interface FormSubmission {
    /**
     * 
     * @type {string}
     * @memberof FormSubmission
     */
    'id': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof FormSubmission
     */
    'botId': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof FormSubmission
     */
    'accountId'?: string;
    /**
     * ID of the contact
     * @type {string}
     * @memberof FormSubmission
     */
    'contactId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof FormSubmission
     */
    'createdAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof FormSubmission
     */
    'startedAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof FormSubmission
     */
    'updatedAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof FormSubmission
     */
    'submittedAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof FormSubmission
     */
    'abandonedAt'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FormSubmission
     */
    'fields'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof FormSubmission
     */
    'lastSubmittedActionId'?: string;
    /**
     * 
     * @type {FormSubmissionSource}
     * @memberof FormSubmission
     */
    'source'?: FormSubmissionSource;
}
/**
 * 
 * @export
 * @interface FormSubmissionCreate200Response
 */
export interface FormSubmissionCreate200Response {
    /**
     * ID of the submission
     * @type {string}
     * @memberof FormSubmissionCreate200Response
     */
    'submissionId': string;
}
/**
 * 
 * @export
 * @interface FormSubmissionCreateRequest
 */
export interface FormSubmissionCreateRequest {
    /**
     * Phone number of the submitter
     * @type {string}
     * @memberof FormSubmissionCreateRequest
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof FormSubmissionCreateRequest
     */
    'captchaToken': string;
}
/**
 * 
 * @export
 * @interface FormSubmissionSource
 */
export interface FormSubmissionSource {
    /**
     * 
     * @type {string}
     * @memberof FormSubmissionSource
     */
    'actionId': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof FormSubmissionSource
     */
    'botId': string;
}
/**
 * 
 * @export
 * @interface FormSubmissionUpdate
 */
export interface FormSubmissionUpdate {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof FormSubmissionUpdate
     */
    'fields'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface FormSubmissionsGet200Response
 */
export interface FormSubmissionsGet200Response {
    /**
     * 
     * @type {Array<FormSubmission>}
     * @memberof FormSubmissionsGet200Response
     */
    'submissions': Array<FormSubmission>;
    /**
     * Cursor to use to fetch next page of results
     * @type {string}
     * @memberof FormSubmissionsGet200Response
     */
    'cursor'?: string;
    /**
     * total submissions present with these filters.
     * @type {number}
     * @memberof FormSubmissionsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface GetActionFireRecords200Response
 */
export interface GetActionFireRecords200Response {
    /**
     * 
     * @type {Array<ActionFireRecord>}
     * @memberof GetActionFireRecords200Response
     */
    'records': Array<ActionFireRecord>;
    /**
     * Name of the last record fetched
     * @type {string}
     * @memberof GetActionFireRecords200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface GetBotFireRecords200Response
 */
export interface GetBotFireRecords200Response {
    /**
     * 
     * @type {Array<BotFireRecord>}
     * @memberof GetBotFireRecords200Response
     */
    'items': Array<BotFireRecord>;
    /**
     * 
     * @type {string}
     * @memberof GetBotFireRecords200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetBotFireRecords200Response
     */
    'total'?: number;
}
/**
 * @type GetBotFireRecordsContactsParameter
 * @export
 */
export type GetBotFireRecordsContactsParameter = Array<IMUniqueContactID> | IMUniqueContactID;

/**
 * 
 * @export
 * @interface GetTriggerInstances200Response
 */
export interface GetTriggerInstances200Response {
    /**
     * 
     * @type {Array<BotTriggerInstance>}
     * @memberof GetTriggerInstances200Response
     */
    'items': Array<BotTriggerInstance>;
    /**
     * Cursor to use to fetch next page of results
     * @type {string}
     * @memberof GetTriggerInstances200Response
     */
    'nextPageCursor'?: string;
}
/**
 * 
 * @export
 * @interface IMMessageAttachment
 */
export interface IMMessageAttachment {
    /**
     * 
     * @type {IMMessageAttachmentType}
     * @memberof IMMessageAttachment
     */
    'type': IMMessageAttachmentType;
    /**
     * MIME type of the attachment
     * @type {string}
     * @memberof IMMessageAttachment
     */
    'mimetype': string;
    /**
     * Public URL of the attachment, also it will allow variable attachment which will start with \'{{\' and end with \'}}\' or \'data:;base64\'
     * @type {string}
     * @memberof IMMessageAttachment
     */
    'url': string;
    /**
     * thumbnail of sticker/video/image
     * @type {string}
     * @memberof IMMessageAttachment
     */
    'jpegThumbnail'?: string | null;
    /**
     * duration of audio/video message
     * @type {number}
     * @memberof IMMessageAttachment
     */
    'seconds'?: number;
    /**
     * name of the doc message
     * @type {string}
     * @memberof IMMessageAttachment
     */
    'filename'?: string;
    /**
     * push to text feature
     * @type {boolean}
     * @memberof IMMessageAttachment
     */
    'pttAudio'?: boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const IMMessageAttachmentType = {
    Image: 'image',
    Video: 'video',
    Contact: 'contact',
    Sticker: 'sticker',
    Audio: 'audio',
    Document: 'document',
    Location: 'location'
} as const;

export type IMMessageAttachmentType = typeof IMMessageAttachmentType[keyof typeof IMMessageAttachmentType];


/**
 * 
 * @export
 * @interface IMMessageProduct
 */
export interface IMMessageProduct {
    /**
     * 
     * @type {string}
     * @memberof IMMessageProduct
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof IMMessageProduct
     */
    'accountId': string;
}
/**
 * Optional context about the sender of the message
 * @export
 * @interface IMMessageSenderContext
 */
export interface IMMessageSenderContext {
    /**
     * 
     * @type {string}
     * @memberof IMMessageSenderContext
     */
    'type': IMMessageSenderContextTypeEnum;
    /**
     * ID of the object that sent the message. For example, the campaign ID or keyword reply ID
     * @type {string}
     * @memberof IMMessageSenderContext
     */
    'objectId': string;
    /**
     * Name of the object that sent the message. For example, the campaign name or keyword reply name
     * @type {string}
     * @memberof IMMessageSenderContext
     */
    'objectName'?: string;
}

export const IMMessageSenderContextTypeEnum = {
    KeywordReply: 'keyword-reply',
    DefaultReply: 'default-reply',
    Campaigns: 'campaigns',
    Notifications: 'notifications',
    Bot: 'bot',
    AiChatbot: 'ai-chatbot',
    Trigger: 'trigger'
} as const;

export type IMMessageSenderContextTypeEnum = typeof IMMessageSenderContextTypeEnum[keyof typeof IMMessageSenderContextTypeEnum];

/**
 * 
 * @export
 * @interface IMUniqueContactID
 */
export interface IMUniqueContactID {
    /**
     * ID of the contact
     * @type {string}
     * @memberof IMUniqueContactID
     */
    'id': string;
    /**
     * ID of the account
     * @type {string}
     * @memberof IMUniqueContactID
     */
    'accountId': string;
}
/**
 * Describes how many contacts are in each status for the first action sent in a trigger instance. Keyed by ActionInteractionType
 * @export
 * @interface InstanceFirstActionStatusCounts
 */
export interface InstanceFirstActionStatusCounts {
    /**
     * 
     * @type {number}
     * @memberof InstanceFirstActionStatusCounts
     */
    'scheduled'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceFirstActionStatusCounts
     */
    'sent'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceFirstActionStatusCounts
     */
    'delivered'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceFirstActionStatusCounts
     */
    'error'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceFirstActionStatusCounts
     */
    'click'?: number;
    /**
     * 
     * @type {number}
     * @memberof InstanceFirstActionStatusCounts
     */
    'user_input'?: number;
}
/**
 * 
 * @export
 * @interface InternalEventTriggerMethod
 */
export interface InternalEventTriggerMethod {
    /**
     * 
     * @type {string}
     * @memberof InternalEventTriggerMethod
     */
    'type': InternalEventTriggerMethodTypeEnum;
    /**
     * 
     * @type {InternalEventTriggerMethodData}
     * @memberof InternalEventTriggerMethod
     */
    'data': InternalEventTriggerMethodData;
}

export const InternalEventTriggerMethodTypeEnum = {
    InternalEvent: 'internal_event'
} as const;

export type InternalEventTriggerMethodTypeEnum = typeof InternalEventTriggerMethodTypeEnum[keyof typeof InternalEventTriggerMethodTypeEnum];

/**
 * 
 * @export
 * @interface InternalEventTriggerMethodData
 */
export interface InternalEventTriggerMethodData {
    /**
     * 
     * @type {string}
     * @memberof InternalEventTriggerMethodData
     */
    'event': string;
    /**
     * Useful for \'order-insert\' event, to specify the service type of the integration. This\'ll help distinguish which conditions to display in the UI
     * @type {string}
     * @memberof InternalEventTriggerMethodData
     */
    'serviceType'?: string;
}
/**
 * 
 * @export
 * @interface InternalEventUIConfig
 */
export interface InternalEventUIConfig {
    /**
     * 
     * @type {string}
     * @memberof InternalEventUIConfig
     */
    'event': string;
    /**
     * 
     * @type {string}
     * @memberof InternalEventUIConfig
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof InternalEventUIConfig
     */
    'description': string;
    /**
     * 
     * @type {DisplayIcon}
     * @memberof InternalEventUIConfig
     */
    'icon'?: DisplayIcon;
    /**
     * 
     * @type {TriggersUIConfig}
     * @memberof InternalEventUIConfig
     */
    'config': TriggersUIConfig;
    /**
     * Define under which conditions this group\'s conditions should be displayed to the user. Conditions will be applied to the Trigger itself. The conditions are ANDed together
     * @type {Array<BotCondition>}
     * @memberof InternalEventUIConfig
     */
    'displayConditions'?: Array<BotCondition>;
}
/**
 * 
 * @export
 * @interface MessageNode
 */
export interface MessageNode {
    /**
     * 
     * @type {string}
     * @memberof MessageNode
     */
    'type': MessageNodeTypeEnum;
    /**
     * 
     * @type {Action}
     * @memberof MessageNode
     */
    'data': Action;
    /**
     * 
     * @type {MessageNodeHandle}
     * @memberof MessageNode
     */
    'handle': MessageNodeHandle;
    /**
     * send in to remove the message
     * @type {boolean}
     * @memberof MessageNode
     */
    'remove'?: boolean;
}

export const MessageNodeTypeEnum = {
    Message: 'message'
} as const;

export type MessageNodeTypeEnum = typeof MessageNodeTypeEnum[keyof typeof MessageNodeTypeEnum];

/**
 * 
 * @export
 * @interface MessageNodeHandle
 */
export interface MessageNodeHandle {
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageNodeHandle
     */
    'button'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageNodeHandle
     */
    'delay'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageNodeHandle
     */
    'list'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageNodeHandle
     */
    'action'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageNodeHandle
     */
    'userInput'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MessageObj
 */
export interface MessageObj {
    /**
     * the template message itself
     * @type {string}
     * @memberof MessageObj
     */
    'text': string | null;
    /**
     * array of attachments for the template
     * @type {Array<IMMessageAttachment>}
     * @memberof MessageObj
     */
    'attachments'?: Array<IMMessageAttachment>;
    /**
     * 
     * @type {Array<BotMessageButton>}
     * @memberof MessageObj
     */
    'buttons'?: Array<BotMessageButton>;
    /**
     * 
     * @type {Array<BotMessageDelay>}
     * @memberof MessageObj
     */
    'delays'?: Array<BotMessageDelay>;
    /**
     * 
     * @type {BotMessageInput}
     * @memberof MessageObj
     */
    'input'?: BotMessageInput;
    /**
     * 
     * @type {BotMessageList}
     * @memberof MessageObj
     */
    'list'?: BotMessageList;
    /**
     * 
     * @type {string}
     * @memberof MessageObj
     */
    'quoted'?: string;
    /**
     * 
     * @type {Array<IMMessageProduct>}
     * @memberof MessageObj
     */
    'products'?: Array<IMMessageProduct>;
    /**
     * the subject of the message, if applicable
     * @type {string}
     * @memberof MessageObj
     */
    'subject'?: string;
}
/**
 * Optional parameters to send a message
 * @export
 * @interface MessageSendOptions
 */
export interface MessageSendOptions {
    /**
     * 
     * @type {string}
     * @memberof MessageSendOptions
     */
    'messageId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MessageSendOptions
     */
    'simulateTyping'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MessageSendOptions
     */
    'requireOpenAccount'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MessageSendOptions
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MessageSendOptions
     */
    'scheduleAt'?: string;
    /**
     * Forwards option to IM service
     * @type {boolean}
     * @memberof MessageSendOptions
     */
    'includeMarketingMessage'?: boolean;
    /**
     * 
     * @type {MessageSendOptionsQuoted}
     * @memberof MessageSendOptions
     */
    'quoted'?: MessageSendOptionsQuoted;
    /**
     * 
     * @type {MessageSendOptionsSender}
     * @memberof MessageSendOptions
     */
    'sender'?: MessageSendOptionsSender;
}
/**
 * 
 * @export
 * @interface MessageSendOptionsQuoted
 */
export interface MessageSendOptionsQuoted {
    /**
     * 
     * @type {string}
     * @memberof MessageSendOptionsQuoted
     */
    'chatId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageSendOptionsQuoted
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface MessageSendOptionsSender
 */
export interface MessageSendOptionsSender {
    /**
     * 
     * @type {IMMessageSenderContext}
     * @memberof MessageSendOptionsSender
     */
    'context': IMMessageSenderContext;
}
/**
 * Specify the next action to be fired
 * @export
 * @interface NextAction
 */
export interface NextAction {
    /**
     * 
     * @type {NextActionDefaultAction}
     * @memberof NextAction
     */
    'defaultAction'?: NextActionDefaultAction;
    /**
     * List of conditions to validate
     * @type {Array<NextActionGroupsInner>}
     * @memberof NextAction
     */
    'groups'?: Array<NextActionGroupsInner>;
    /**
     * 
     * @type {Position}
     * @memberof NextAction
     */
    'position'?: Position | null;
}
/**
 * Fired if all validations failed or no validations are provided
 * @export
 * @interface NextActionDefaultAction
 */
export interface NextActionDefaultAction {
    /**
     * 
     * @type {string}
     * @memberof NextActionDefaultAction
     */
    'triggerActionId': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof NextActionDefaultAction
     */
    'triggerBotId'?: string;
    /**
     * 
     * @type {Position}
     * @memberof NextActionDefaultAction
     */
    'position'?: Position | null;
}
/**
 * 
 * @export
 * @interface NextActionGroupsInner
 */
export interface NextActionGroupsInner {
    /**
     * Operator for all validations
     * @type {string}
     * @memberof NextActionGroupsInner
     */
    'operator': NextActionGroupsInnerOperatorEnum;
    /**
     * Fields to validate
     * @type {Array<BotCondition>}
     * @memberof NextActionGroupsInner
     */
    'validation': Array<BotCondition>;
    /**
     * 
     * @type {NextActionGroupsInnerTarget}
     * @memberof NextActionGroupsInner
     */
    'target': NextActionGroupsInnerTarget;
}

export const NextActionGroupsInnerOperatorEnum = {
    And: 'and',
    Or: 'or'
} as const;

export type NextActionGroupsInnerOperatorEnum = typeof NextActionGroupsInnerOperatorEnum[keyof typeof NextActionGroupsInnerOperatorEnum];

/**
 * Action to fire if all validations pass
 * @export
 * @interface NextActionGroupsInnerTarget
 */
export interface NextActionGroupsInnerTarget {
    /**
     * 
     * @type {string}
     * @memberof NextActionGroupsInnerTarget
     */
    'triggerActionId': string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof NextActionGroupsInnerTarget
     */
    'triggerBotId'?: string;
    /**
     * 
     * @type {Position}
     * @memberof NextActionGroupsInnerTarget
     */
    'position'?: Position | null;
}
/**
 * @type NodeData
 * @export
 */
export type NodeData = ActionNode | BotNoteNode | BotTargetNode | ConditionNode | DelayNode | EmailNode | MessageNode | PhoneNumberNode | UrlNode | UserInputNode;

/**
 * 
 * @export
 * @interface PhoneNumberNode
 */
export interface PhoneNumberNode {
    /**
     * 
     * @type {string}
     * @memberof PhoneNumberNode
     */
    'type': PhoneNumberNodeTypeEnum;
    /**
     * 
     * @type {PhoneNumberNodeData}
     * @memberof PhoneNumberNode
     */
    'data': PhoneNumberNodeData;
    /**
     * 
     * @type {Action}
     * @memberof PhoneNumberNode
     */
    'sourceAction': Action;
    /**
     * 
     * @type {number}
     * @memberof PhoneNumberNode
     */
    'sourceIndex': number;
    /**
     * send in to remove the phone number
     * @type {boolean}
     * @memberof PhoneNumberNode
     */
    'remove'?: boolean;
}

export const PhoneNumberNodeTypeEnum = {
    PhoneNumber: 'phoneNumber'
} as const;

export type PhoneNumberNodeTypeEnum = typeof PhoneNumberNodeTypeEnum[keyof typeof PhoneNumberNodeTypeEnum];

/**
 * 
 * @export
 * @interface PhoneNumberNodeData
 */
export interface PhoneNumberNodeData {
    /**
     * Phone number to call
     * @type {string}
     * @memberof PhoneNumberNodeData
     */
    'phoneNumber': string;
    /**
     * 
     * @type {Position}
     * @memberof PhoneNumberNodeData
     */
    'position'?: Position | null;
}
/**
 * position in x-y coordinate space
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'y': number;
}
/**
 * Target a property in the payload data. Use dot notation for nested properties. Please note, this is inside the `data` object of the payload, so avoid the `data.` prefix.
 * @export
 * @interface PropertyPathTarget
 */
export interface PropertyPathTarget {
    /**
     * 
     * @type {string}
     * @memberof PropertyPathTarget
     */
    'type': PropertyPathTargetTypeEnum;
    /**
     * Path of the property to access in the payload data. Use dot notation for nested properties. Please note, this is inside the `data` object of the payload, so avoid the `data.` prefix.
     * @type {string}
     * @memberof PropertyPathTarget
     */
    'propertyPath': string;
    /**
     * 
     * @type {AccountIDSelector}
     * @memberof PropertyPathTarget
     */
    'accountId'?: AccountIDSelector;
}

export const PropertyPathTargetTypeEnum = {
    PropertyPath: 'propertyPath'
} as const;

export type PropertyPathTargetTypeEnum = typeof PropertyPathTargetTypeEnum[keyof typeof PropertyPathTargetTypeEnum];

/**
 * Provide either a property path to extract from the payload /payload data or an exact value
 * @export
 * @interface PropertyPathValue
 */
export interface PropertyPathValue {
    /**
     * 
     * @type {string}
     * @memberof PropertyPathValue
     */
    'type': PropertyPathValueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PropertyPathValue
     */
    'value': string;
}

export const PropertyPathValueTypeEnum = {
    PropertyPath: 'propertyPath',
    Exact: 'exact'
} as const;

export type PropertyPathValueTypeEnum = typeof PropertyPathValueTypeEnum[keyof typeof PropertyPathValueTypeEnum];

/**
 * Options provided here will override the global options provided in the botsFire request
 * @export
 * @interface Recipient
 */
export interface Recipient {
    /**
     * ID of the account to send from
     * @type {string}
     * @memberof Recipient
     */
    'accountId'?: string;
    /**
     * ID of the contact
     * @type {string}
     * @memberof Recipient
     */
    'id': string;
    /**
     * 
     * @type {MessageSendOptions}
     * @memberof Recipient
     */
    'sendOptions'?: MessageSendOptions;
    /**
     * parameters to replace in text
     * @type {{ [key: string]: any; }}
     * @memberof Recipient
     */
    'parameters'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ServiceResponse
 */
export interface ServiceResponse {
    /**
     * 
     * @type {number}
     * @memberof ServiceResponse
     */
    'statusCode': number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ServiceResponse
     */
    'body'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface SharedSlug
 */
export interface SharedSlug {
    /**
     * 
     * @type {string}
     * @memberof SharedSlug
     */
    'slug': string;
    /**
     * 
     * @type {boolean}
     * @memberof SharedSlug
     */
    'editable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SharedSlug
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface StoreCreateRequest
 */
export interface StoreCreateRequest {
    /**
     * 
     * @type {StoreCreateRequestValues}
     * @memberof StoreCreateRequest
     */
    'values': StoreCreateRequestValues;
    /**
     * yaml file of boat
     * @type {string}
     * @memberof StoreCreateRequest
     */
    'botFileUrl': string;
    /**
     * User Name for the store
     * @type {string}
     * @memberof StoreCreateRequest
     */
    'userName': string;
    /**
     * Language for the store
     * @type {string}
     * @memberof StoreCreateRequest
     */
    'language': string;
    /**
     * Image Url for the store
     * @type {string}
     * @memberof StoreCreateRequest
     */
    'imageUrl': string;
}
/**
 * 
 * @export
 * @interface StoreCreateRequestValues
 */
export interface StoreCreateRequestValues {
    /**
     * Name of Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'templateName': string;
    /**
     * Category of Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'templateCategory': string;
    /**
     * Name of Bot Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'botTemplate': string;
    /**
     * Image of Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'image': string;
    /**
     * Description of Template
     * @type {string}
     * @memberof StoreCreateRequestValues
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface StoreGet200Response
 */
export interface StoreGet200Response {
    /**
     * 
     * @type {Array<TemplateItem>}
     * @memberof StoreGet200Response
     */
    'templates': Array<TemplateItem>;
    /**
     * Cursor to fetch the next page
     * @type {string}
     * @memberof StoreGet200Response
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface SubmitFormRequest
 */
export interface SubmitFormRequest {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SubmitFormRequest
     */
    'fields': { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof SubmitFormRequest
     */
    'finalizeSubmission'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TemplateCommand = {
    SubmitForReview: 'submit-for-review',
    Link: 'link',
    Unlink: 'unlink'
} as const;

export type TemplateCommand = typeof TemplateCommand[keyof typeof TemplateCommand];


/**
 * 
 * @export
 * @interface TemplateItem
 */
export interface TemplateItem {
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TemplateItem
     */
    'yamlFileUrl': string;
}
/**
 * 
 * @export
 * @interface TemplateStatusUpdateRequest
 */
export interface TemplateStatusUpdateRequest {
    /**
     * 
     * @type {Array<TemplateStatusUpdateRequestTemplatesInner>}
     * @memberof TemplateStatusUpdateRequest
     */
    'templates': Array<TemplateStatusUpdateRequestTemplatesInner>;
}
/**
 * 
 * @export
 * @interface TemplateStatusUpdateRequestTemplatesInner
 */
export interface TemplateStatusUpdateRequestTemplatesInner {
    /**
     * ID of the template
     * @type {string}
     * @memberof TemplateStatusUpdateRequestTemplatesInner
     */
    'id': string;
    /**
     * Status of the template
     * @type {string}
     * @memberof TemplateStatusUpdateRequestTemplatesInner
     */
    'status': TemplateStatusUpdateRequestTemplatesInnerStatusEnum;
    /**
     * Reason for rejection of the template
     * @type {string}
     * @memberof TemplateStatusUpdateRequestTemplatesInner
     */
    'rejectionReason': string;
}

export const TemplateStatusUpdateRequestTemplatesInnerStatusEnum = {
    Fail: 'fail',
    Pass: 'pass'
} as const;

export type TemplateStatusUpdateRequestTemplatesInnerStatusEnum = typeof TemplateStatusUpdateRequestTemplatesInnerStatusEnum[keyof typeof TemplateStatusUpdateRequestTemplatesInnerStatusEnum];

/**
 * 
 * @export
 * @interface TimePeriodDescriptor
 */
export interface TimePeriodDescriptor {
    /**
     * 
     * @type {Array<DayOfWeek>}
     * @memberof TimePeriodDescriptor
     */
    'days'?: Array<DayOfWeek>;
    /**
     * 
     * @type {string}
     * @memberof TimePeriodDescriptor
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof TimePeriodDescriptor
     */
    'endTime': string;
    /**
     * 
     * @type {string}
     * @memberof TimePeriodDescriptor
     */
    'timezone': string;
}
/**
 * 
 * @export
 * @interface TimestampedTriggerMethod
 */
export interface TimestampedTriggerMethod {
    /**
     * 
     * @type {string}
     * @memberof TimestampedTriggerMethod
     */
    'type': TimestampedTriggerMethodTypeEnum;
    /**
     * 
     * @type {TimestampedTriggerMethodData}
     * @memberof TimestampedTriggerMethod
     */
    'data': TimestampedTriggerMethodData;
}

export const TimestampedTriggerMethodTypeEnum = {
    Timestamp: 'timestamp'
} as const;

export type TimestampedTriggerMethodTypeEnum = typeof TimestampedTriggerMethodTypeEnum[keyof typeof TimestampedTriggerMethodTypeEnum];

/**
 * 
 * @export
 * @interface TimestampedTriggerMethodData
 */
export interface TimestampedTriggerMethodData {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TimestampedTriggerMethodData
     */
    'startDate': string;
    /**
     * 
     * @type {TimestampedTriggerMethodDataRecurring}
     * @memberof TimestampedTriggerMethodData
     */
    'recurring'?: TimestampedTriggerMethodDataRecurring;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TimestampedTriggerMethodData
     */
    'nextExecutionDate'?: string;
}
/**
 * 
 * @export
 * @interface TimestampedTriggerMethodDataRecurring
 */
export interface TimestampedTriggerMethodDataRecurring {
    /**
     * 
     * @type {number}
     * @memberof TimestampedTriggerMethodDataRecurring
     */
    'intervalMinutes': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TimestampedTriggerMethodDataRecurring
     */
    'endDate'?: string;
}
/**
 * @type TriggerDelay
 * @export
 */
export type TriggerDelay = TriggerDelayOneOf | TriggerDelayOneOf1;

/**
 * 
 * @export
 * @interface TriggerDelayOneOf
 */
export interface TriggerDelayOneOf {
    /**
     * 
     * @type {string}
     * @memberof TriggerDelayOneOf
     */
    'type': TriggerDelayOneOfTypeEnum;
    /**
     * The delay in seconds before the action is triggered
     * @type {number}
     * @memberof TriggerDelayOneOf
     */
    'value': number;
}

export const TriggerDelayOneOfTypeEnum = {
    DelaySeconds: 'delay_seconds'
} as const;

export type TriggerDelayOneOfTypeEnum = typeof TriggerDelayOneOfTypeEnum[keyof typeof TriggerDelayOneOfTypeEnum];

/**
 * 
 * @export
 * @interface TriggerDelayOneOf1
 */
export interface TriggerDelayOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof TriggerDelayOneOf1
     */
    'type': TriggerDelayOneOf1TypeEnum;
    /**
     * 
     * @type {PropertyPathValue}
     * @memberof TriggerDelayOneOf1
     */
    'value': PropertyPathValue;
}

export const TriggerDelayOneOf1TypeEnum = {
    Timestamp: 'timestamp'
} as const;

export type TriggerDelayOneOf1TypeEnum = typeof TriggerDelayOneOf1TypeEnum[keyof typeof TriggerDelayOneOf1TypeEnum];

/**
 * @type TriggerMethod
 * @export
 */
export type TriggerMethod = InternalEventTriggerMethod | TimestampedTriggerMethod;

/**
 * 
 * @export
 * @interface TriggerUpsert
 */
export interface TriggerUpsert {
    /**
     * 
     * @type {string}
     * @memberof TriggerUpsert
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TriggerUpsert
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TriggerUpsert
     */
    'name'?: string;
    /**
     * ID of the bot sequence
     * @type {string}
     * @memberof TriggerUpsert
     */
    'botId'?: string;
    /**
     * 
     * @type {NextAction}
     * @memberof TriggerUpsert
     */
    'action'?: NextAction;
    /**
     * 
     * @type {BotTriggerTarget}
     * @memberof TriggerUpsert
     */
    'target'?: BotTriggerTarget;
    /**
     * 
     * @type {BotTriggerOptions}
     * @memberof TriggerUpsert
     */
    'options'?: BotTriggerOptions;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TriggerUpsert
     */
    'lastTriggered'?: string;
    /**
     * 
     * @type {number}
     * @memberof TriggerUpsert
     */
    'triggered'?: number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TriggerUpsert
     */
    'createdAt'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TriggerUpsert
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {TriggerMethod}
     * @memberof TriggerUpsert
     */
    'method'?: TriggerMethod;
    /**
     * 
     * @type {boolean}
     * @memberof TriggerUpsert
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface TriggersDisplayConfiguration
 */
export interface TriggersDisplayConfiguration {
    /**
     * 
     * @type {TriggersUIConfig}
     * @memberof TriggersDisplayConfiguration
     */
    'contact': TriggersUIConfig;
    /**
     * 
     * @type {TriggersUIConfig}
     * @memberof TriggersDisplayConfiguration
     */
    'context': TriggersUIConfig;
    /**
     * 
     * @type {Array<InternalEventUIConfig>}
     * @memberof TriggersDisplayConfiguration
     */
    'internalEventConfigs': Array<InternalEventUIConfig>;
}
/**
 * 
 * @export
 * @interface TriggersUIConfig
 */
export interface TriggersUIConfig {
    /**
     * 
     * @type {TriggersUIConfigDefaults}
     * @memberof TriggersUIConfig
     */
    'defaults'?: TriggersUIConfigDefaults;
    /**
     * 
     * @type {Array<TriggersUIConfigConditionablePropertiesInner>}
     * @memberof TriggersUIConfig
     */
    'conditionableProperties': Array<TriggersUIConfigConditionablePropertiesInner>;
}
/**
 * @type TriggersUIConfigConditionablePropertiesInner
 * @export
 */
export type TriggersUIConfigConditionablePropertiesInner = ConditionableProperty | ConditionablePropertyGroup;

/**
 * Default values for the triggers. These values will be used when creating a new trigger
 * @export
 * @interface TriggersUIConfigDefaults
 */
export interface TriggersUIConfigDefaults {
    /**
     * 
     * @type {BotTriggerTarget}
     * @memberof TriggersUIConfigDefaults
     */
    'target'?: BotTriggerTarget;
    /**
     * 
     * @type {BotTriggerOptions}
     * @memberof TriggersUIConfigDefaults
     */
    'options'?: BotTriggerOptions;
}
/**
 * 
 * @export
 * @interface UrlNode
 */
export interface UrlNode {
    /**
     * 
     * @type {string}
     * @memberof UrlNode
     */
    'type': UrlNodeTypeEnum;
    /**
     * 
     * @type {UrlNodeData}
     * @memberof UrlNode
     */
    'data': UrlNodeData;
    /**
     * 
     * @type {Action}
     * @memberof UrlNode
     */
    'sourceAction': Action;
    /**
     * 
     * @type {number}
     * @memberof UrlNode
     */
    'sourceIndex': number;
    /**
     * send in to remove the url
     * @type {boolean}
     * @memberof UrlNode
     */
    'remove'?: boolean;
}

export const UrlNodeTypeEnum = {
    Url: 'url'
} as const;

export type UrlNodeTypeEnum = typeof UrlNodeTypeEnum[keyof typeof UrlNodeTypeEnum];

/**
 * 
 * @export
 * @interface UrlNodeData
 */
export interface UrlNodeData {
    /**
     * 
     * @type {string}
     * @memberof UrlNodeData
     */
    'url': string;
    /**
     * 
     * @type {Position}
     * @memberof UrlNodeData
     */
    'position'?: Position | null;
}
/**
 * 
 * @export
 * @interface UserInputNode
 */
export interface UserInputNode {
    /**
     * 
     * @type {string}
     * @memberof UserInputNode
     */
    'type': UserInputNodeTypeEnum;
    /**
     * 
     * @type {BotMessageInput}
     * @memberof UserInputNode
     */
    'data': BotMessageInput;
    /**
     * 
     * @type {string}
     * @memberof UserInputNode
     */
    'handle': string;
    /**
     * 
     * @type {Action}
     * @memberof UserInputNode
     */
    'sourceAction': Action;
    /**
     * 
     * @type {number}
     * @memberof UserInputNode
     */
    'sourceIndex': number;
    /**
     * send in to remove the user input
     * @type {boolean}
     * @memberof UserInputNode
     */
    'remove'?: boolean;
}

export const UserInputNodeTypeEnum = {
    UserInput: 'userInput'
} as const;

export type UserInputNodeTypeEnum = typeof UserInputNodeTypeEnum[keyof typeof UserInputNodeTypeEnum];

/**
 * 
 * @export
 * @interface WebhookItem
 */
export interface WebhookItem {
    /**
     * 
     * @type {string}
     * @memberof WebhookItem
     */
    'method': WebhookItemMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookItem
     */
    'url': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WebhookItem
     */
    'headers': { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WebhookItem
     */
    'body'?: string;
}

export const WebhookItemMethodEnum = {
    Get: 'GET',
    Post: 'POST'
} as const;

export type WebhookItemMethodEnum = typeof WebhookItemMethodEnum[keyof typeof WebhookItemMethodEnum];


/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets all actions related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsGet: async (count?: number, before?: string, q?: string, botId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (botId !== undefined) {
                localVarQueryParameter['botId'] = botId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate Actions using GPT
         * @param {ActionsGptGenerateRequest} [actionsGptGenerateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsGptGenerate: async (actionsGptGenerateRequest?: ActionsGptGenerateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actions/gpt-generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(actionsGptGenerateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets all actions related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionsGet(count?: number, before?: string, q?: string, botId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionsGet(count, before, q, botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate Actions using GPT
         * @param {ActionsGptGenerateRequest} [actionsGptGenerateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionsGptGenerate(actionsGptGenerateRequest?: ActionsGptGenerateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionsGptGenerate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionsGptGenerate(actionsGptGenerateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets all actions related to account/team
         * @param {ActionsApiActionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsGet(requestParameters: ActionsApiActionsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ActionsGet200Response> {
            return localVarFp.actionsGet(requestParameters.count, requestParameters.before, requestParameters.q, requestParameters.botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate Actions using GPT
         * @param {ActionsApiActionsGptGenerateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsGptGenerate(requestParameters: ActionsApiActionsGptGenerateRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ActionsGptGenerate200Response> {
            return localVarFp.actionsGptGenerate(requestParameters.actionsGptGenerateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for actionsGet operation in ActionsApi.
 * @export
 * @interface ActionsApiActionsGetRequest
 */
export interface ActionsApiActionsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ActionsApiActionsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof ActionsApiActionsGet
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof ActionsApiActionsGet
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof ActionsApiActionsGet
     */
    readonly botId?: string
}

/**
 * Request parameters for actionsGptGenerate operation in ActionsApi.
 * @export
 * @interface ActionsApiActionsGptGenerateRequest
 */
export interface ActionsApiActionsGptGenerateRequest {
    /**
     * 
     * @type {ActionsGptGenerateRequest}
     * @memberof ActionsApiActionsGptGenerate
     */
    readonly actionsGptGenerateRequest?: ActionsGptGenerateRequest
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI {
    /**
     * 
     * @summary Gets all actions related to account/team
     * @param {ActionsApiActionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public actionsGet(requestParameters: ActionsApiActionsGetRequest = {}, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration).actionsGet(requestParameters.count, requestParameters.before, requestParameters.q, requestParameters.botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate Actions using GPT
     * @param {ActionsApiActionsGptGenerateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public actionsGptGenerate(requestParameters: ActionsApiActionsGptGenerateRequest = {}, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration).actionsGptGenerate(requestParameters.actionsGptGenerateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BotAnalyticsApi - axios parameter creator
 * @export
 */
export const BotAnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint fetches analytics for a bot based on provided botId parameters
         * @summary Get analytics for a bot
         * @param {string} botId The ID of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsAnalyticsGet: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsAnalyticsGet', 'botId', botId)
            const localVarPath = `/bot/analytics/{botId}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotAnalyticsApi - functional programming interface
 * @export
 */
export const BotAnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BotAnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint fetches analytics for a bot based on provided botId parameters
         * @summary Get analytics for a bot
         * @param {string} botId The ID of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsAnalyticsGet(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotsAnalyticsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsAnalyticsGet(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BotAnalyticsApi - factory interface
 * @export
 */
export const BotAnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BotAnalyticsApiFp(configuration)
    return {
        /**
         * This endpoint fetches analytics for a bot based on provided botId parameters
         * @summary Get analytics for a bot
         * @param {BotAnalyticsApiBotsAnalyticsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsAnalyticsGet(requestParameters: BotAnalyticsApiBotsAnalyticsGetRequest, options?: AxiosRequestConfig): AxiosPromise<BotsAnalyticsGet200Response> {
            return localVarFp.botsAnalyticsGet(requestParameters.botId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for botsAnalyticsGet operation in BotAnalyticsApi.
 * @export
 * @interface BotAnalyticsApiBotsAnalyticsGetRequest
 */
export interface BotAnalyticsApiBotsAnalyticsGetRequest {
    /**
     * The ID of the bot
     * @type {string}
     * @memberof BotAnalyticsApiBotsAnalyticsGet
     */
    readonly botId: string
}

/**
 * BotAnalyticsApi - object-oriented interface
 * @export
 * @class BotAnalyticsApi
 * @extends {BaseAPI}
 */
export class BotAnalyticsApi extends BaseAPI {
    /**
     * This endpoint fetches analytics for a bot based on provided botId parameters
     * @summary Get analytics for a bot
     * @param {BotAnalyticsApiBotsAnalyticsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotAnalyticsApi
     */
    public botsAnalyticsGet(requestParameters: BotAnalyticsApiBotsAnalyticsGetRequest, options?: AxiosRequestConfig) {
        return BotAnalyticsApiFp(this.configuration).botsAnalyticsGet(requestParameters.botId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BotRecordsApi - axios parameter creator
 * @export
 */
export const BotRecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint fetches records for a bot based on provided botId parameters
         * @summary Get records for a bot
         * @param {string} [botId] The ID of the bot
         * @param {GetBotFireRecordsContactsParameter} [contacts] 
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {{ [key: string]: ActionInteractionQueryValue; }} [interactions] 
         * @param {boolean} [returnTotal] 
         * @param {string} [instanceId] 
         * @param {string} [triggerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotFireRecords: async (botId?: string, contacts?: GetBotFireRecordsContactsParameter, count?: number, cursor?: string, interactions?: { [key: string]: ActionInteractionQueryValue; }, returnTotal?: boolean, instanceId?: string, triggerId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bot/records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (botId !== undefined) {
                localVarQueryParameter['botId'] = botId;
            }

            if (contacts !== undefined) {
                localVarQueryParameter['contacts'] = contacts;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (interactions !== undefined) {
                localVarQueryParameter['interactions'] = interactions;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }

            if (instanceId !== undefined) {
                localVarQueryParameter['instanceId'] = instanceId;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotRecordsApi - functional programming interface
 * @export
 */
export const BotRecordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BotRecordsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint fetches records for a bot based on provided botId parameters
         * @summary Get records for a bot
         * @param {string} [botId] The ID of the bot
         * @param {GetBotFireRecordsContactsParameter} [contacts] 
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {{ [key: string]: ActionInteractionQueryValue; }} [interactions] 
         * @param {boolean} [returnTotal] 
         * @param {string} [instanceId] 
         * @param {string} [triggerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBotFireRecords(botId?: string, contacts?: GetBotFireRecordsContactsParameter, count?: number, cursor?: string, interactions?: { [key: string]: ActionInteractionQueryValue; }, returnTotal?: boolean, instanceId?: string, triggerId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBotFireRecords200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBotFireRecords(botId, contacts, count, cursor, interactions, returnTotal, instanceId, triggerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BotRecordsApi - factory interface
 * @export
 */
export const BotRecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BotRecordsApiFp(configuration)
    return {
        /**
         * This endpoint fetches records for a bot based on provided botId parameters
         * @summary Get records for a bot
         * @param {BotRecordsApiGetBotFireRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotFireRecords(requestParameters: BotRecordsApiGetBotFireRecordsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetBotFireRecords200Response> {
            return localVarFp.getBotFireRecords(requestParameters.botId, requestParameters.contacts, requestParameters.count, requestParameters.cursor, requestParameters.interactions, requestParameters.returnTotal, requestParameters.instanceId, requestParameters.triggerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getBotFireRecords operation in BotRecordsApi.
 * @export
 * @interface BotRecordsApiGetBotFireRecordsRequest
 */
export interface BotRecordsApiGetBotFireRecordsRequest {
    /**
     * The ID of the bot
     * @type {string}
     * @memberof BotRecordsApiGetBotFireRecords
     */
    readonly botId?: string

    /**
     * 
     * @type {GetBotFireRecordsContactsParameter}
     * @memberof BotRecordsApiGetBotFireRecords
     */
    readonly contacts?: GetBotFireRecordsContactsParameter

    /**
     * 
     * @type {number}
     * @memberof BotRecordsApiGetBotFireRecords
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof BotRecordsApiGetBotFireRecords
     */
    readonly cursor?: string

    /**
     * 
     * @type {{ [key: string]: ActionInteractionQueryValue; }}
     * @memberof BotRecordsApiGetBotFireRecords
     */
    readonly interactions?: { [key: string]: ActionInteractionQueryValue; }

    /**
     * 
     * @type {boolean}
     * @memberof BotRecordsApiGetBotFireRecords
     */
    readonly returnTotal?: boolean

    /**
     * 
     * @type {string}
     * @memberof BotRecordsApiGetBotFireRecords
     */
    readonly instanceId?: string

    /**
     * 
     * @type {string}
     * @memberof BotRecordsApiGetBotFireRecords
     */
    readonly triggerId?: string
}

/**
 * BotRecordsApi - object-oriented interface
 * @export
 * @class BotRecordsApi
 * @extends {BaseAPI}
 */
export class BotRecordsApi extends BaseAPI {
    /**
     * This endpoint fetches records for a bot based on provided botId parameters
     * @summary Get records for a bot
     * @param {BotRecordsApiGetBotFireRecordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotRecordsApi
     */
    public getBotFireRecords(requestParameters: BotRecordsApiGetBotFireRecordsRequest = {}, options?: AxiosRequestConfig) {
        return BotRecordsApiFp(this.configuration).getBotFireRecords(requestParameters.botId, requestParameters.contacts, requestParameters.count, requestParameters.cursor, requestParameters.interactions, requestParameters.returnTotal, requestParameters.instanceId, requestParameters.triggerId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BotTriggersApi - axios parameter creator
 * @export
 */
export const BotTriggersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get trigger display configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisplayConfiguration: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/triggers/display-configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all instances of a bot trigger
         * @param {string} [triggerId] 
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggerInstances: async (triggerId?: string, count?: number, cursor?: string, id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/trigger-instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stops a bot trigger instance
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTriggerInstance: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stopTriggerInstance', 'id', id)
            const localVarPath = `/trigger-instances/{id}/stop`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotTriggersApi - functional programming interface
 * @export
 */
export const BotTriggersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BotTriggersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get trigger display configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDisplayConfiguration(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TriggersDisplayConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDisplayConfiguration(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all instances of a bot trigger
         * @param {string} [triggerId] 
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTriggerInstances(triggerId?: string, count?: number, cursor?: string, id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTriggerInstances200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTriggerInstances(triggerId, count, cursor, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stops a bot trigger instance
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopTriggerInstance(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopTriggerInstance(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BotTriggersApi - factory interface
 * @export
 */
export const BotTriggersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BotTriggersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get trigger display configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisplayConfiguration(options?: AxiosRequestConfig): AxiosPromise<TriggersDisplayConfiguration> {
            return localVarFp.getDisplayConfiguration(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all instances of a bot trigger
         * @param {BotTriggersApiGetTriggerInstancesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggerInstances(requestParameters: BotTriggersApiGetTriggerInstancesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetTriggerInstances200Response> {
            return localVarFp.getTriggerInstances(requestParameters.triggerId, requestParameters.count, requestParameters.cursor, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stops a bot trigger instance
         * @param {BotTriggersApiStopTriggerInstanceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTriggerInstance(requestParameters: BotTriggersApiStopTriggerInstanceRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stopTriggerInstance(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getTriggerInstances operation in BotTriggersApi.
 * @export
 * @interface BotTriggersApiGetTriggerInstancesRequest
 */
export interface BotTriggersApiGetTriggerInstancesRequest {
    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiGetTriggerInstances
     */
    readonly triggerId?: string

    /**
     * 
     * @type {number}
     * @memberof BotTriggersApiGetTriggerInstances
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiGetTriggerInstances
     */
    readonly cursor?: string

    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiGetTriggerInstances
     */
    readonly id?: string
}

/**
 * Request parameters for stopTriggerInstance operation in BotTriggersApi.
 * @export
 * @interface BotTriggersApiStopTriggerInstanceRequest
 */
export interface BotTriggersApiStopTriggerInstanceRequest {
    /**
     * 
     * @type {string}
     * @memberof BotTriggersApiStopTriggerInstance
     */
    readonly id: string
}

/**
 * BotTriggersApi - object-oriented interface
 * @export
 * @class BotTriggersApi
 * @extends {BaseAPI}
 */
export class BotTriggersApi extends BaseAPI {
    /**
     * 
     * @summary Get trigger display configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotTriggersApi
     */
    public getDisplayConfiguration(options?: AxiosRequestConfig) {
        return BotTriggersApiFp(this.configuration).getDisplayConfiguration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all instances of a bot trigger
     * @param {BotTriggersApiGetTriggerInstancesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotTriggersApi
     */
    public getTriggerInstances(requestParameters: BotTriggersApiGetTriggerInstancesRequest = {}, options?: AxiosRequestConfig) {
        return BotTriggersApiFp(this.configuration).getTriggerInstances(requestParameters.triggerId, requestParameters.count, requestParameters.cursor, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stops a bot trigger instance
     * @param {BotTriggersApiStopTriggerInstanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotTriggersApi
     */
    public stopTriggerInstance(requestParameters: BotTriggersApiStopTriggerInstanceRequest, options?: AxiosRequestConfig) {
        return BotTriggersApiFp(this.configuration).stopTriggerInstance(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BotsApi - axios parameter creator
 * @export
 */
export const BotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fires the starting action ID
         * @summary Initiates a bot sequence onto 1 or more contacts.
         * @param {string} id 
         * @param {BotsBulkFireRequest} [botsBulkFireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBulkFire: async (id: string, botsBulkFireRequest?: BotsBulkFireRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('botsBulkFire', 'id', id)
            const localVarPath = `/bots/{id}/bulk-fire`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL", "MESSAGES_SEND_TO_ASSIGNED"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botsBulkFireRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new bot
         * @param {BotsCreateRequest} [botsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsCreate: async (botsCreateRequest?: BotsCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint fetches bot data based on provided botId parameters
         * @summary Retrieves bot data including triggers, notes and actions
         * @param {string} botId The ID of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDataGet: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botsDataGet', 'botId', botId)
            const localVarPath = `/bots/{botId}/data`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes list of bots
         * @param {Array<string>} bots 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDeletes: async (bots: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bots' is not null or undefined
            assertParamExists('botsDeletes', 'bots', bots)
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_DELETE"], configuration)

            if (bots) {
                localVarQueryParameter['bots'] = bots;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Either submit for review, unlink from the external template provider or link with an existing template ID
         * @summary Execute a command to update the status for the external template
         * @param {string} id 
         * @param {string} accountId 
         * @param {TemplateCommand} command 
         * @param {string} [language] ISO code of the language, required for WA business templates
         * @param {string} [category] 
         * @param {string} [templateId] The external ID of the template to link with, only valid for the \&quot;link\&quot; command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsExternalTemplateCommand: async (id: string, accountId: string, command: TemplateCommand, language?: string, category?: string, templateId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('botsExternalTemplateCommand', 'id', id)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('botsExternalTemplateCommand', 'accountId', accountId)
            // verify required parameter 'command' is not null or undefined
            assertParamExists('botsExternalTemplateCommand', 'command', command)
            const localVarPath = `/bots/{id}/external-template/{accountId}/{command}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (templateId !== undefined) {
                localVarQueryParameter['templateId'] = templateId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will throw a 400 if there is no starting action ID
         * @summary Initiates a bot sequence. Fires the starting action ID
         * @param {string} id 
         * @param {BotsFireRequest} [botsFireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsFire: async (id: string, botsFireRequest?: BotsFireRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('botsFire', 'id', id)
            const localVarPath = `/bots/{id}/fire`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL", "MESSAGES_SEND_TO_ASSIGNED"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botsFireRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of bots
         * @param {string} [q] 
         * @param {boolean} [isForm] If true, only bots that are a form will be returned. If false, only bots are not forms will be returned
         * @param {string} [before] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {'name' | 'updatedAt'} [sortBy] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {string} [folderId] 
         * @param {string} [language] 
         * @param {string} [industry] 
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsGets: async (q?: string, isForm?: boolean, before?: string, count?: number, id?: Array<string>, sortBy?: 'name' | 'updatedAt', order?: 'ASC' | 'DESC', folderId?: string, language?: string, industry?: string, returnTotalCount?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (isForm !== undefined) {
                localVarQueryParameter['isForm'] = isForm;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (folderId !== undefined) {
                localVarQueryParameter['folderId'] = folderId;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (industry !== undefined) {
                localVarQueryParameter['industry'] = industry;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an action
         * @param {string} id 
         * @param {BotPatch} [botPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsPatch: async (id: string, botPatch?: BotPatch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('botsPatch', 'id', id)
            const localVarPath = `/bots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update status of some templates
         * @param {TemplateStatusUpdateRequest} [templateStatusUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalTemplateStatusUpdate: async (templateStatusUpdateRequest?: TemplateStatusUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/external-template-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templateStatusUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns list of action fire records
         * @param {number} [count] 
         * @param {number} [beforeId] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionFireRecords: async (count?: number, beforeId?: number, botId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actions/records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (beforeId !== undefined) {
                localVarQueryParameter['beforeId'] = beforeId;
            }

            if (botId !== undefined) {
                localVarQueryParameter['botId'] = botId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotsApi - functional programming interface
 * @export
 */
export const BotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BotsApiAxiosParamCreator(configuration)
    return {
        /**
         * Fires the starting action ID
         * @summary Initiates a bot sequence onto 1 or more contacts.
         * @param {string} id 
         * @param {BotsBulkFireRequest} [botsBulkFireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsBulkFire(id: string, botsBulkFireRequest?: BotsBulkFireRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotsBulkFire200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsBulkFire(id, botsBulkFireRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates new bot
         * @param {BotsCreateRequest} [botsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsCreate(botsCreateRequest?: BotsCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsCreate(botsCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint fetches bot data based on provided botId parameters
         * @summary Retrieves bot data including triggers, notes and actions
         * @param {string} botId The ID of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsDataGet(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsDataGet(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes list of bots
         * @param {Array<string>} bots 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsDeletes(bots: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsDeletes(bots, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Either submit for review, unlink from the external template provider or link with an existing template ID
         * @summary Execute a command to update the status for the external template
         * @param {string} id 
         * @param {string} accountId 
         * @param {TemplateCommand} command 
         * @param {string} [language] ISO code of the language, required for WA business templates
         * @param {string} [category] 
         * @param {string} [templateId] The external ID of the template to link with, only valid for the \&quot;link\&quot; command
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsExternalTemplateCommand(id: string, accountId: string, command: TemplateCommand, language?: string, category?: string, templateId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotsExternalTemplateCommand200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsExternalTemplateCommand(id, accountId, command, language, category, templateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Will throw a 400 if there is no starting action ID
         * @summary Initiates a bot sequence. Fires the starting action ID
         * @param {string} id 
         * @param {BotsFireRequest} [botsFireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsFire(id: string, botsFireRequest?: BotsFireRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActionFireRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsFire(id, botsFireRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of bots
         * @param {string} [q] 
         * @param {boolean} [isForm] If true, only bots that are a form will be returned. If false, only bots are not forms will be returned
         * @param {string} [before] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {'name' | 'updatedAt'} [sortBy] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {string} [folderId] 
         * @param {string} [language] 
         * @param {string} [industry] 
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsGets(q?: string, isForm?: boolean, before?: string, count?: number, id?: Array<string>, sortBy?: 'name' | 'updatedAt', order?: 'ASC' | 'DESC', folderId?: string, language?: string, industry?: string, returnTotalCount?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotsGets200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsGets(q, isForm, before, count, id, sortBy, order, folderId, language, industry, returnTotalCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an action
         * @param {string} id 
         * @param {BotPatch} [botPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsPatch(id: string, botPatch?: BotPatch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsPatch(id, botPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update status of some templates
         * @param {TemplateStatusUpdateRequest} [templateStatusUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalTemplateStatusUpdate(templateStatusUpdateRequest?: TemplateStatusUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalTemplateStatusUpdate(templateStatusUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns list of action fire records
         * @param {number} [count] 
         * @param {number} [beforeId] 
         * @param {string} [botId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActionFireRecords(count?: number, beforeId?: number, botId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetActionFireRecords200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActionFireRecords(count, beforeId, botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BotsApi - factory interface
 * @export
 */
export const BotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BotsApiFp(configuration)
    return {
        /**
         * Fires the starting action ID
         * @summary Initiates a bot sequence onto 1 or more contacts.
         * @param {BotsApiBotsBulkFireRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsBulkFire(requestParameters: BotsApiBotsBulkFireRequest, options?: AxiosRequestConfig): AxiosPromise<BotsBulkFire200Response> {
            return localVarFp.botsBulkFire(requestParameters.id, requestParameters.botsBulkFireRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates new bot
         * @param {BotsApiBotsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsCreate(requestParameters: BotsApiBotsCreateRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Bot> {
            return localVarFp.botsCreate(requestParameters.botsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint fetches bot data based on provided botId parameters
         * @summary Retrieves bot data including triggers, notes and actions
         * @param {BotsApiBotsDataGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDataGet(requestParameters: BotsApiBotsDataGetRequest, options?: AxiosRequestConfig): AxiosPromise<BotData> {
            return localVarFp.botsDataGet(requestParameters.botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes list of bots
         * @param {BotsApiBotsDeletesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDeletes(requestParameters: BotsApiBotsDeletesRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.botsDeletes(requestParameters.bots, options).then((request) => request(axios, basePath));
        },
        /**
         * Either submit for review, unlink from the external template provider or link with an existing template ID
         * @summary Execute a command to update the status for the external template
         * @param {BotsApiBotsExternalTemplateCommandRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsExternalTemplateCommand(requestParameters: BotsApiBotsExternalTemplateCommandRequest, options?: AxiosRequestConfig): AxiosPromise<BotsExternalTemplateCommand200Response> {
            return localVarFp.botsExternalTemplateCommand(requestParameters.id, requestParameters.accountId, requestParameters.command, requestParameters.language, requestParameters.category, requestParameters.templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Will throw a 400 if there is no starting action ID
         * @summary Initiates a bot sequence. Fires the starting action ID
         * @param {BotsApiBotsFireRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsFire(requestParameters: BotsApiBotsFireRequest, options?: AxiosRequestConfig): AxiosPromise<ActionFireRecord> {
            return localVarFp.botsFire(requestParameters.id, requestParameters.botsFireRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of bots
         * @param {BotsApiBotsGetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsGets(requestParameters: BotsApiBotsGetsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<BotsGets200Response> {
            return localVarFp.botsGets(requestParameters.q, requestParameters.isForm, requestParameters.before, requestParameters.count, requestParameters.id, requestParameters.sortBy, requestParameters.order, requestParameters.folderId, requestParameters.language, requestParameters.industry, requestParameters.returnTotalCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an action
         * @param {BotsApiBotsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsPatch(requestParameters: BotsApiBotsPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.botsPatch(requestParameters.id, requestParameters.botPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update status of some templates
         * @param {BotsApiExternalTemplateStatusUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalTemplateStatusUpdate(requestParameters: BotsApiExternalTemplateStatusUpdateRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.externalTemplateStatusUpdate(requestParameters.templateStatusUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns list of action fire records
         * @param {BotsApiGetActionFireRecordsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActionFireRecords(requestParameters: BotsApiGetActionFireRecordsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetActionFireRecords200Response> {
            return localVarFp.getActionFireRecords(requestParameters.count, requestParameters.beforeId, requestParameters.botId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for botsBulkFire operation in BotsApi.
 * @export
 * @interface BotsApiBotsBulkFireRequest
 */
export interface BotsApiBotsBulkFireRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsBulkFire
     */
    readonly id: string

    /**
     * 
     * @type {BotsBulkFireRequest}
     * @memberof BotsApiBotsBulkFire
     */
    readonly botsBulkFireRequest?: BotsBulkFireRequest
}

/**
 * Request parameters for botsCreate operation in BotsApi.
 * @export
 * @interface BotsApiBotsCreateRequest
 */
export interface BotsApiBotsCreateRequest {
    /**
     * 
     * @type {BotsCreateRequest}
     * @memberof BotsApiBotsCreate
     */
    readonly botsCreateRequest?: BotsCreateRequest
}

/**
 * Request parameters for botsDataGet operation in BotsApi.
 * @export
 * @interface BotsApiBotsDataGetRequest
 */
export interface BotsApiBotsDataGetRequest {
    /**
     * The ID of the bot
     * @type {string}
     * @memberof BotsApiBotsDataGet
     */
    readonly botId: string
}

/**
 * Request parameters for botsDeletes operation in BotsApi.
 * @export
 * @interface BotsApiBotsDeletesRequest
 */
export interface BotsApiBotsDeletesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof BotsApiBotsDeletes
     */
    readonly bots: Array<string>
}

/**
 * Request parameters for botsExternalTemplateCommand operation in BotsApi.
 * @export
 * @interface BotsApiBotsExternalTemplateCommandRequest
 */
export interface BotsApiBotsExternalTemplateCommandRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly accountId: string

    /**
     * 
     * @type {TemplateCommand}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly command: TemplateCommand

    /**
     * ISO code of the language, required for WA business templates
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly language?: string

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly category?: string

    /**
     * The external ID of the template to link with, only valid for the \&quot;link\&quot; command
     * @type {string}
     * @memberof BotsApiBotsExternalTemplateCommand
     */
    readonly templateId?: string
}

/**
 * Request parameters for botsFire operation in BotsApi.
 * @export
 * @interface BotsApiBotsFireRequest
 */
export interface BotsApiBotsFireRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsFire
     */
    readonly id: string

    /**
     * 
     * @type {BotsFireRequest}
     * @memberof BotsApiBotsFire
     */
    readonly botsFireRequest?: BotsFireRequest
}

/**
 * Request parameters for botsGets operation in BotsApi.
 * @export
 * @interface BotsApiBotsGetsRequest
 */
export interface BotsApiBotsGetsRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly q?: string

    /**
     * If true, only bots that are a form will be returned. If false, only bots are not forms will be returned
     * @type {boolean}
     * @memberof BotsApiBotsGets
     */
    readonly isForm?: boolean

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly before?: string

    /**
     * 
     * @type {number}
     * @memberof BotsApiBotsGets
     */
    readonly count?: number

    /**
     * 
     * @type {Array<string>}
     * @memberof BotsApiBotsGets
     */
    readonly id?: Array<string>

    /**
     * 
     * @type {'name' | 'updatedAt'}
     * @memberof BotsApiBotsGets
     */
    readonly sortBy?: 'name' | 'updatedAt'

    /**
     * 
     * @type {'ASC' | 'DESC'}
     * @memberof BotsApiBotsGets
     */
    readonly order?: 'ASC' | 'DESC'

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly folderId?: string

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly language?: string

    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsGets
     */
    readonly industry?: string

    /**
     * 
     * @type {boolean}
     * @memberof BotsApiBotsGets
     */
    readonly returnTotalCount?: boolean
}

/**
 * Request parameters for botsPatch operation in BotsApi.
 * @export
 * @interface BotsApiBotsPatchRequest
 */
export interface BotsApiBotsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof BotsApiBotsPatch
     */
    readonly id: string

    /**
     * 
     * @type {BotPatch}
     * @memberof BotsApiBotsPatch
     */
    readonly botPatch?: BotPatch
}

/**
 * Request parameters for externalTemplateStatusUpdate operation in BotsApi.
 * @export
 * @interface BotsApiExternalTemplateStatusUpdateRequest
 */
export interface BotsApiExternalTemplateStatusUpdateRequest {
    /**
     * 
     * @type {TemplateStatusUpdateRequest}
     * @memberof BotsApiExternalTemplateStatusUpdate
     */
    readonly templateStatusUpdateRequest?: TemplateStatusUpdateRequest
}

/**
 * Request parameters for getActionFireRecords operation in BotsApi.
 * @export
 * @interface BotsApiGetActionFireRecordsRequest
 */
export interface BotsApiGetActionFireRecordsRequest {
    /**
     * 
     * @type {number}
     * @memberof BotsApiGetActionFireRecords
     */
    readonly count?: number

    /**
     * 
     * @type {number}
     * @memberof BotsApiGetActionFireRecords
     */
    readonly beforeId?: number

    /**
     * 
     * @type {string}
     * @memberof BotsApiGetActionFireRecords
     */
    readonly botId?: string
}

/**
 * BotsApi - object-oriented interface
 * @export
 * @class BotsApi
 * @extends {BaseAPI}
 */
export class BotsApi extends BaseAPI {
    /**
     * Fires the starting action ID
     * @summary Initiates a bot sequence onto 1 or more contacts.
     * @param {BotsApiBotsBulkFireRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsBulkFire(requestParameters: BotsApiBotsBulkFireRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsBulkFire(requestParameters.id, requestParameters.botsBulkFireRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates new bot
     * @param {BotsApiBotsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsCreate(requestParameters: BotsApiBotsCreateRequest = {}, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsCreate(requestParameters.botsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint fetches bot data based on provided botId parameters
     * @summary Retrieves bot data including triggers, notes and actions
     * @param {BotsApiBotsDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsDataGet(requestParameters: BotsApiBotsDataGetRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsDataGet(requestParameters.botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes list of bots
     * @param {BotsApiBotsDeletesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsDeletes(requestParameters: BotsApiBotsDeletesRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsDeletes(requestParameters.bots, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Either submit for review, unlink from the external template provider or link with an existing template ID
     * @summary Execute a command to update the status for the external template
     * @param {BotsApiBotsExternalTemplateCommandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsExternalTemplateCommand(requestParameters: BotsApiBotsExternalTemplateCommandRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsExternalTemplateCommand(requestParameters.id, requestParameters.accountId, requestParameters.command, requestParameters.language, requestParameters.category, requestParameters.templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Will throw a 400 if there is no starting action ID
     * @summary Initiates a bot sequence. Fires the starting action ID
     * @param {BotsApiBotsFireRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsFire(requestParameters: BotsApiBotsFireRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsFire(requestParameters.id, requestParameters.botsFireRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of bots
     * @param {BotsApiBotsGetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsGets(requestParameters: BotsApiBotsGetsRequest = {}, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsGets(requestParameters.q, requestParameters.isForm, requestParameters.before, requestParameters.count, requestParameters.id, requestParameters.sortBy, requestParameters.order, requestParameters.folderId, requestParameters.language, requestParameters.industry, requestParameters.returnTotalCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an action
     * @param {BotsApiBotsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public botsPatch(requestParameters: BotsApiBotsPatchRequest, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).botsPatch(requestParameters.id, requestParameters.botPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update status of some templates
     * @param {BotsApiExternalTemplateStatusUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public externalTemplateStatusUpdate(requestParameters: BotsApiExternalTemplateStatusUpdateRequest = {}, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).externalTemplateStatusUpdate(requestParameters.templateStatusUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns list of action fire records
     * @param {BotsApiGetActionFireRecordsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public getActionFireRecords(requestParameters: BotsApiGetActionFireRecordsRequest = {}, options?: AxiosRequestConfig) {
        return BotsApiFp(this.configuration).getActionFireRecords(requestParameters.count, requestParameters.beforeId, requestParameters.botId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FoldersApi - axios parameter creator
 * @export
 */
export const FoldersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create folder
         * @param {FolderCreateRequest} [folderCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderCreate: async (folderCreateRequest?: FolderCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folderCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes list of folders
         * @param {Array<string>} folders 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderDelete: async (folders: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folders' is not null or undefined
            assertParamExists('folderDelete', 'folders', folders)
            const localVarPath = `/folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_DELETE"], configuration)

            if (folders) {
                localVarQueryParameter['folders'] = folders;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all folders related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderGet: async (count?: number, before?: string, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update folder
         * @param {string} folderId 
         * @param {FolderUpdateRequest} [folderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderUpdate: async (folderId: string, folderUpdateRequest?: FolderUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('folderUpdate', 'folderId', folderId)
            const localVarPath = `/folder/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(folderUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoldersApi - functional programming interface
 * @export
 */
export const FoldersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoldersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create folder
         * @param {FolderCreateRequest} [folderCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async folderCreate(folderCreateRequest?: FolderCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Folder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.folderCreate(folderCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes list of folders
         * @param {Array<string>} folders 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async folderDelete(folders: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.folderDelete(folders, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets all folders related to account/team
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async folderGet(count?: number, before?: string, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.folderGet(count, before, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update folder
         * @param {string} folderId 
         * @param {FolderUpdateRequest} [folderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async folderUpdate(folderId: string, folderUpdateRequest?: FolderUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.folderUpdate(folderId, folderUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FoldersApi - factory interface
 * @export
 */
export const FoldersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoldersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create folder
         * @param {FoldersApiFolderCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderCreate(requestParameters: FoldersApiFolderCreateRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Folder> {
            return localVarFp.folderCreate(requestParameters.folderCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes list of folders
         * @param {FoldersApiFolderDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderDelete(requestParameters: FoldersApiFolderDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.folderDelete(requestParameters.folders, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all folders related to account/team
         * @param {FoldersApiFolderGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderGet(requestParameters: FoldersApiFolderGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<FolderGet200Response> {
            return localVarFp.folderGet(requestParameters.count, requestParameters.before, requestParameters.q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update folder
         * @param {FoldersApiFolderUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        folderUpdate(requestParameters: FoldersApiFolderUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.folderUpdate(requestParameters.folderId, requestParameters.folderUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for folderCreate operation in FoldersApi.
 * @export
 * @interface FoldersApiFolderCreateRequest
 */
export interface FoldersApiFolderCreateRequest {
    /**
     * 
     * @type {FolderCreateRequest}
     * @memberof FoldersApiFolderCreate
     */
    readonly folderCreateRequest?: FolderCreateRequest
}

/**
 * Request parameters for folderDelete operation in FoldersApi.
 * @export
 * @interface FoldersApiFolderDeleteRequest
 */
export interface FoldersApiFolderDeleteRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof FoldersApiFolderDelete
     */
    readonly folders: Array<string>
}

/**
 * Request parameters for folderGet operation in FoldersApi.
 * @export
 * @interface FoldersApiFolderGetRequest
 */
export interface FoldersApiFolderGetRequest {
    /**
     * 
     * @type {number}
     * @memberof FoldersApiFolderGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof FoldersApiFolderGet
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof FoldersApiFolderGet
     */
    readonly q?: string
}

/**
 * Request parameters for folderUpdate operation in FoldersApi.
 * @export
 * @interface FoldersApiFolderUpdateRequest
 */
export interface FoldersApiFolderUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof FoldersApiFolderUpdate
     */
    readonly folderId: string

    /**
     * 
     * @type {FolderUpdateRequest}
     * @memberof FoldersApiFolderUpdate
     */
    readonly folderUpdateRequest?: FolderUpdateRequest
}

/**
 * FoldersApi - object-oriented interface
 * @export
 * @class FoldersApi
 * @extends {BaseAPI}
 */
export class FoldersApi extends BaseAPI {
    /**
     * 
     * @summary Create folder
     * @param {FoldersApiFolderCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public folderCreate(requestParameters: FoldersApiFolderCreateRequest = {}, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).folderCreate(requestParameters.folderCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes list of folders
     * @param {FoldersApiFolderDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public folderDelete(requestParameters: FoldersApiFolderDeleteRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).folderDelete(requestParameters.folders, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all folders related to account/team
     * @param {FoldersApiFolderGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public folderGet(requestParameters: FoldersApiFolderGetRequest = {}, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).folderGet(requestParameters.count, requestParameters.before, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update folder
     * @param {FoldersApiFolderUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public folderUpdate(requestParameters: FoldersApiFolderUpdateRequest, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).folderUpdate(requestParameters.folderId, requestParameters.folderUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FormsApi - axios parameter creator
 * @export
 */
export const FormsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get form actions and submission data
         * @param {string} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formDataGet: async (submissionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionId' is not null or undefined
            assertParamExists('formDataGet', 'submissionId', submissionId)
            const localVarPath = `/form-data/{submissionId}`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create form submissions
         * @param {string} botId 
         * @param {FormSubmissionCreateRequest} [formSubmissionCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formSubmissionCreate: async (botId: string, formSubmissionCreateRequest?: FormSubmissionCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('formSubmissionCreate', 'botId', botId)
            const localVarPath = `/form-submissions/{botId}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(formSubmissionCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete form submissions
         * @param {string} botId 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formSubmissionDelete: async (botId: string, ids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('formSubmissionDelete', 'botId', botId)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('formSubmissionDelete', 'ids', ids)
            const localVarPath = `/form-submissions/{botId}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_DELETE"], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a form submission
         * @param {string} submissionId 
         * @param {FormSubmissionUpdate} [formSubmissionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formSubmissionUpdate: async (submissionId: string, formSubmissionUpdate?: FormSubmissionUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionId' is not null or undefined
            assertParamExists('formSubmissionUpdate', 'submissionId', submissionId)
            const localVarPath = `/form-submission/{submissionId}`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(formSubmissionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get form submissions
         * @param {string} botId 
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formSubmissionsGet: async (botId: string, count?: number, before?: string, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('formSubmissionsGet', 'botId', botId)
            const localVarPath = `/form-submissions/{botId}`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit a form
         * @param {string} submissionId 
         * @param {SubmitFormRequest} [submitFormRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm: async (submissionId: string, submitFormRequest?: SubmitFormRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionId' is not null or undefined
            assertParamExists('submitForm', 'submissionId', submissionId)
            const localVarPath = `/form-submission/{submissionId}/submit`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitFormRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FormsApi - functional programming interface
 * @export
 */
export const FormsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FormsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get form actions and submission data
         * @param {string} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formDataGet(submissionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormDataGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formDataGet(submissionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create form submissions
         * @param {string} botId 
         * @param {FormSubmissionCreateRequest} [formSubmissionCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formSubmissionCreate(botId: string, formSubmissionCreateRequest?: FormSubmissionCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormSubmissionCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formSubmissionCreate(botId, formSubmissionCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete form submissions
         * @param {string} botId 
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formSubmissionDelete(botId: string, ids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formSubmissionDelete(botId, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a form submission
         * @param {string} submissionId 
         * @param {FormSubmissionUpdate} [formSubmissionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formSubmissionUpdate(submissionId: string, formSubmissionUpdate?: FormSubmissionUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formSubmissionUpdate(submissionId, formSubmissionUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get form submissions
         * @param {string} botId 
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async formSubmissionsGet(botId: string, count?: number, before?: string, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormSubmissionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.formSubmissionsGet(botId, count, before, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit a form
         * @param {string} submissionId 
         * @param {SubmitFormRequest} [submitFormRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitForm(submissionId: string, submitFormRequest?: SubmitFormRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitForm(submissionId, submitFormRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FormsApi - factory interface
 * @export
 */
export const FormsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FormsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get form actions and submission data
         * @param {FormsApiFormDataGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formDataGet(requestParameters: FormsApiFormDataGetRequest, options?: AxiosRequestConfig): AxiosPromise<FormDataGet200Response> {
            return localVarFp.formDataGet(requestParameters.submissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create form submissions
         * @param {FormsApiFormSubmissionCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formSubmissionCreate(requestParameters: FormsApiFormSubmissionCreateRequest, options?: AxiosRequestConfig): AxiosPromise<FormSubmissionCreate200Response> {
            return localVarFp.formSubmissionCreate(requestParameters.botId, requestParameters.formSubmissionCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete form submissions
         * @param {FormsApiFormSubmissionDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formSubmissionDelete(requestParameters: FormsApiFormSubmissionDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.formSubmissionDelete(requestParameters.botId, requestParameters.ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a form submission
         * @param {FormsApiFormSubmissionUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formSubmissionUpdate(requestParameters: FormsApiFormSubmissionUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.formSubmissionUpdate(requestParameters.submissionId, requestParameters.formSubmissionUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get form submissions
         * @param {FormsApiFormSubmissionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        formSubmissionsGet(requestParameters: FormsApiFormSubmissionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<FormSubmissionsGet200Response> {
            return localVarFp.formSubmissionsGet(requestParameters.botId, requestParameters.count, requestParameters.before, requestParameters.q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit a form
         * @param {FormsApiSubmitFormRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm(requestParameters: FormsApiSubmitFormRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.submitForm(requestParameters.submissionId, requestParameters.submitFormRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for formDataGet operation in FormsApi.
 * @export
 * @interface FormsApiFormDataGetRequest
 */
export interface FormsApiFormDataGetRequest {
    /**
     * 
     * @type {string}
     * @memberof FormsApiFormDataGet
     */
    readonly submissionId: string
}

/**
 * Request parameters for formSubmissionCreate operation in FormsApi.
 * @export
 * @interface FormsApiFormSubmissionCreateRequest
 */
export interface FormsApiFormSubmissionCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof FormsApiFormSubmissionCreate
     */
    readonly botId: string

    /**
     * 
     * @type {FormSubmissionCreateRequest}
     * @memberof FormsApiFormSubmissionCreate
     */
    readonly formSubmissionCreateRequest?: FormSubmissionCreateRequest
}

/**
 * Request parameters for formSubmissionDelete operation in FormsApi.
 * @export
 * @interface FormsApiFormSubmissionDeleteRequest
 */
export interface FormsApiFormSubmissionDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof FormsApiFormSubmissionDelete
     */
    readonly botId: string

    /**
     * 
     * @type {Array<string>}
     * @memberof FormsApiFormSubmissionDelete
     */
    readonly ids: Array<string>
}

/**
 * Request parameters for formSubmissionUpdate operation in FormsApi.
 * @export
 * @interface FormsApiFormSubmissionUpdateRequest
 */
export interface FormsApiFormSubmissionUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof FormsApiFormSubmissionUpdate
     */
    readonly submissionId: string

    /**
     * 
     * @type {FormSubmissionUpdate}
     * @memberof FormsApiFormSubmissionUpdate
     */
    readonly formSubmissionUpdate?: FormSubmissionUpdate
}

/**
 * Request parameters for formSubmissionsGet operation in FormsApi.
 * @export
 * @interface FormsApiFormSubmissionsGetRequest
 */
export interface FormsApiFormSubmissionsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof FormsApiFormSubmissionsGet
     */
    readonly botId: string

    /**
     * 
     * @type {number}
     * @memberof FormsApiFormSubmissionsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof FormsApiFormSubmissionsGet
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof FormsApiFormSubmissionsGet
     */
    readonly q?: string
}

/**
 * Request parameters for submitForm operation in FormsApi.
 * @export
 * @interface FormsApiSubmitFormRequest
 */
export interface FormsApiSubmitFormRequest {
    /**
     * 
     * @type {string}
     * @memberof FormsApiSubmitForm
     */
    readonly submissionId: string

    /**
     * 
     * @type {SubmitFormRequest}
     * @memberof FormsApiSubmitForm
     */
    readonly submitFormRequest?: SubmitFormRequest
}

/**
 * FormsApi - object-oriented interface
 * @export
 * @class FormsApi
 * @extends {BaseAPI}
 */
export class FormsApi extends BaseAPI {
    /**
     * 
     * @summary Get form actions and submission data
     * @param {FormsApiFormDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formDataGet(requestParameters: FormsApiFormDataGetRequest, options?: AxiosRequestConfig) {
        return FormsApiFp(this.configuration).formDataGet(requestParameters.submissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create form submissions
     * @param {FormsApiFormSubmissionCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formSubmissionCreate(requestParameters: FormsApiFormSubmissionCreateRequest, options?: AxiosRequestConfig) {
        return FormsApiFp(this.configuration).formSubmissionCreate(requestParameters.botId, requestParameters.formSubmissionCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete form submissions
     * @param {FormsApiFormSubmissionDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formSubmissionDelete(requestParameters: FormsApiFormSubmissionDeleteRequest, options?: AxiosRequestConfig) {
        return FormsApiFp(this.configuration).formSubmissionDelete(requestParameters.botId, requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a form submission
     * @param {FormsApiFormSubmissionUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formSubmissionUpdate(requestParameters: FormsApiFormSubmissionUpdateRequest, options?: AxiosRequestConfig) {
        return FormsApiFp(this.configuration).formSubmissionUpdate(requestParameters.submissionId, requestParameters.formSubmissionUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get form submissions
     * @param {FormsApiFormSubmissionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public formSubmissionsGet(requestParameters: FormsApiFormSubmissionsGetRequest, options?: AxiosRequestConfig) {
        return FormsApiFp(this.configuration).formSubmissionsGet(requestParameters.botId, requestParameters.count, requestParameters.before, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit a form
     * @param {FormsApiSubmitFormRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormsApi
     */
    public submitForm(requestParameters: FormsApiSubmitFormRequest, options?: AxiosRequestConfig) {
        return FormsApiFp(this.configuration).submitForm(requestParameters.submissionId, requestParameters.submitFormRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShareBotApi - axios parameter creator
 * @export
 */
export const ShareBotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new slug, which is used the share the bot
         * @param {BotShareRequest} [botShareRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botShare: async (botShareRequest?: BotShareRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bot/share`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_READ"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botShareRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint fetches bot data based on provided slug parameters
         * @summary Retrieves bot data including triggers, notes and actions
         * @param {string} slug The shared sulg of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDataGetBySlug: async (slug: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('botsDataGetBySlug', 'slug', slug)
            const localVarPath = `/bot/share/{slug}/data`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the bot which is associated with token
         * @param {string} slug The slug of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShareBot: async (slug: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('getShareBot', 'slug', slug)
            const localVarPath = `/bot/share/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes list of slugs
         * @param {Array<string>} slugs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slugsDelete: async (slugs: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slugs' is not null or undefined
            assertParamExists('slugsDelete', 'slugs', slugs)
            const localVarPath = `/bot/share`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_DELETE"], configuration)

            if (slugs) {
                localVarQueryParameter['slugs'] = slugs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShareBotApi - functional programming interface
 * @export
 */
export const ShareBotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShareBotApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new slug, which is used the share the bot
         * @param {BotShareRequest} [botShareRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botShare(botShareRequest?: BotShareRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedSlug>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botShare(botShareRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint fetches bot data based on provided slug parameters
         * @summary Retrieves bot data including triggers, notes and actions
         * @param {string} slug The shared sulg of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsDataGetBySlug(slug: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsDataGetBySlug(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the bot which is associated with token
         * @param {string} slug The slug of the bot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShareBot(slug: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShareBot(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes list of slugs
         * @param {Array<string>} slugs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slugsDelete(slugs: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slugsDelete(slugs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShareBotApi - factory interface
 * @export
 */
export const ShareBotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShareBotApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new slug, which is used the share the bot
         * @param {ShareBotApiBotShareRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botShare(requestParameters: ShareBotApiBotShareRequest = {}, options?: AxiosRequestConfig): AxiosPromise<SharedSlug> {
            return localVarFp.botShare(requestParameters.botShareRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint fetches bot data based on provided slug parameters
         * @summary Retrieves bot data including triggers, notes and actions
         * @param {ShareBotApiBotsDataGetBySlugRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsDataGetBySlug(requestParameters: ShareBotApiBotsDataGetBySlugRequest, options?: AxiosRequestConfig): AxiosPromise<BotData> {
            return localVarFp.botsDataGetBySlug(requestParameters.slug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the bot which is associated with token
         * @param {ShareBotApiGetShareBotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShareBot(requestParameters: ShareBotApiGetShareBotRequest, options?: AxiosRequestConfig): AxiosPromise<Bot> {
            return localVarFp.getShareBot(requestParameters.slug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes list of slugs
         * @param {ShareBotApiSlugsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slugsDelete(requestParameters: ShareBotApiSlugsDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.slugsDelete(requestParameters.slugs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for botShare operation in ShareBotApi.
 * @export
 * @interface ShareBotApiBotShareRequest
 */
export interface ShareBotApiBotShareRequest {
    /**
     * 
     * @type {BotShareRequest}
     * @memberof ShareBotApiBotShare
     */
    readonly botShareRequest?: BotShareRequest
}

/**
 * Request parameters for botsDataGetBySlug operation in ShareBotApi.
 * @export
 * @interface ShareBotApiBotsDataGetBySlugRequest
 */
export interface ShareBotApiBotsDataGetBySlugRequest {
    /**
     * The shared sulg of the bot
     * @type {string}
     * @memberof ShareBotApiBotsDataGetBySlug
     */
    readonly slug: string
}

/**
 * Request parameters for getShareBot operation in ShareBotApi.
 * @export
 * @interface ShareBotApiGetShareBotRequest
 */
export interface ShareBotApiGetShareBotRequest {
    /**
     * The slug of the bot
     * @type {string}
     * @memberof ShareBotApiGetShareBot
     */
    readonly slug: string
}

/**
 * Request parameters for slugsDelete operation in ShareBotApi.
 * @export
 * @interface ShareBotApiSlugsDeleteRequest
 */
export interface ShareBotApiSlugsDeleteRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ShareBotApiSlugsDelete
     */
    readonly slugs: Array<string>
}

/**
 * ShareBotApi - object-oriented interface
 * @export
 * @class ShareBotApi
 * @extends {BaseAPI}
 */
export class ShareBotApi extends BaseAPI {
    /**
     * 
     * @summary Create new slug, which is used the share the bot
     * @param {ShareBotApiBotShareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareBotApi
     */
    public botShare(requestParameters: ShareBotApiBotShareRequest = {}, options?: AxiosRequestConfig) {
        return ShareBotApiFp(this.configuration).botShare(requestParameters.botShareRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint fetches bot data based on provided slug parameters
     * @summary Retrieves bot data including triggers, notes and actions
     * @param {ShareBotApiBotsDataGetBySlugRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareBotApi
     */
    public botsDataGetBySlug(requestParameters: ShareBotApiBotsDataGetBySlugRequest, options?: AxiosRequestConfig) {
        return ShareBotApiFp(this.configuration).botsDataGetBySlug(requestParameters.slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the bot which is associated with token
     * @param {ShareBotApiGetShareBotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareBotApi
     */
    public getShareBot(requestParameters: ShareBotApiGetShareBotRequest, options?: AxiosRequestConfig) {
        return ShareBotApiFp(this.configuration).getShareBot(requestParameters.slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes list of slugs
     * @param {ShareBotApiSlugsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareBotApi
     */
    public slugsDelete(requestParameters: ShareBotApiSlugsDeleteRequest, options?: AxiosRequestConfig) {
        return ShareBotApiFp(this.configuration).slugsDelete(requestParameters.slugs, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StoreApi - axios parameter creator
 * @export
 */
export const StoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create options in the store
         * @param {StoreCreateRequest} [storeCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCreate: async (storeCreateRequest?: StoreCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEMPLATES_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get options in the store
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [language] 
         * @param {Array<string>} [categoryKeyValue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeGet: async (count?: number, before?: string, q?: string, language?: string, categoryKeyValue?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (categoryKeyValue) {
                localVarQueryParameter['categoryKeyValue'] = categoryKeyValue;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreApi - functional programming interface
 * @export
 */
export const StoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoreApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create options in the store
         * @param {StoreCreateRequest} [storeCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeCreate(storeCreateRequest?: StoreCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplateItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeCreate(storeCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get options in the store
         * @param {number} [count] 
         * @param {string} [before] 
         * @param {string} [q] 
         * @param {string} [language] 
         * @param {Array<string>} [categoryKeyValue] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeGet(count?: number, before?: string, q?: string, language?: string, categoryKeyValue?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeGet(count, before, q, language, categoryKeyValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StoreApi - factory interface
 * @export
 */
export const StoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoreApiFp(configuration)
    return {
        /**
         * 
         * @summary Create options in the store
         * @param {StoreApiStoreCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeCreate(requestParameters: StoreApiStoreCreateRequest = {}, options?: AxiosRequestConfig): AxiosPromise<TemplateItem> {
            return localVarFp.storeCreate(requestParameters.storeCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get options in the store
         * @param {StoreApiStoreGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeGet(requestParameters: StoreApiStoreGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<StoreGet200Response> {
            return localVarFp.storeGet(requestParameters.count, requestParameters.before, requestParameters.q, requestParameters.language, requestParameters.categoryKeyValue, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for storeCreate operation in StoreApi.
 * @export
 * @interface StoreApiStoreCreateRequest
 */
export interface StoreApiStoreCreateRequest {
    /**
     * 
     * @type {StoreCreateRequest}
     * @memberof StoreApiStoreCreate
     */
    readonly storeCreateRequest?: StoreCreateRequest
}

/**
 * Request parameters for storeGet operation in StoreApi.
 * @export
 * @interface StoreApiStoreGetRequest
 */
export interface StoreApiStoreGetRequest {
    /**
     * 
     * @type {number}
     * @memberof StoreApiStoreGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof StoreApiStoreGet
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof StoreApiStoreGet
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof StoreApiStoreGet
     */
    readonly language?: string

    /**
     * 
     * @type {Array<string>}
     * @memberof StoreApiStoreGet
     */
    readonly categoryKeyValue?: Array<string>
}

/**
 * StoreApi - object-oriented interface
 * @export
 * @class StoreApi
 * @extends {BaseAPI}
 */
export class StoreApi extends BaseAPI {
    /**
     * 
     * @summary Create options in the store
     * @param {StoreApiStoreCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeCreate(requestParameters: StoreApiStoreCreateRequest = {}, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeCreate(requestParameters.storeCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get options in the store
     * @param {StoreApiStoreGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeGet(requestParameters: StoreApiStoreGetRequest = {}, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeGet(requestParameters.count, requestParameters.before, requestParameters.q, requestParameters.language, requestParameters.categoryKeyValue, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VisitURLApi - axios parameter creator
 * @export
 */
export const VisitURLApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Visit a URL
         * @param {string} actionFireRecordId 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        visitUrl: async (actionFireRecordId: string, url: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'actionFireRecordId' is not null or undefined
            assertParamExists('visitUrl', 'actionFireRecordId', actionFireRecordId)
            // verify required parameter 'url' is not null or undefined
            assertParamExists('visitUrl', 'url', url)
            const localVarPath = `/visit/{actionFireRecordId}`
                .replace(`{${"actionFireRecordId"}}`, encodeURIComponent(String(actionFireRecordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VisitURLApi - functional programming interface
 * @export
 */
export const VisitURLApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VisitURLApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Visit a URL
         * @param {string} actionFireRecordId 
         * @param {string} url 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async visitUrl(actionFireRecordId: string, url: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.visitUrl(actionFireRecordId, url, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VisitURLApi - factory interface
 * @export
 */
export const VisitURLApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VisitURLApiFp(configuration)
    return {
        /**
         * 
         * @summary Visit a URL
         * @param {VisitURLApiVisitUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        visitUrl(requestParameters: VisitURLApiVisitUrlRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.visitUrl(requestParameters.actionFireRecordId, requestParameters.url, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for visitUrl operation in VisitURLApi.
 * @export
 * @interface VisitURLApiVisitUrlRequest
 */
export interface VisitURLApiVisitUrlRequest {
    /**
     * 
     * @type {string}
     * @memberof VisitURLApiVisitUrl
     */
    readonly actionFireRecordId: string

    /**
     * 
     * @type {string}
     * @memberof VisitURLApiVisitUrl
     */
    readonly url: string
}

/**
 * VisitURLApi - object-oriented interface
 * @export
 * @class VisitURLApi
 * @extends {BaseAPI}
 */
export class VisitURLApi extends BaseAPI {
    /**
     * 
     * @summary Visit a URL
     * @param {VisitURLApiVisitUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisitURLApi
     */
    public visitUrl(requestParameters: VisitURLApiVisitUrlRequest, options?: AxiosRequestConfig) {
        return VisitURLApiFp(this.configuration).visitUrl(requestParameters.actionFireRecordId, requestParameters.url, options).then((request) => request(this.axios, this.basePath));
    }
}


