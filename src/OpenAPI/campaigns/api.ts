const BASE_PATH = "https://api.chatdaddy.tech/campaigns".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Campaigns Service
 * Make & run campaigns
 *
 * The version of the OpenAPI document: 0.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @interface ActivationTimeRange
 */
export interface ActivationTimeRange {
    /**
     * 
     * @type {string}
     * @memberof ActivationTimeRange
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof ActivationTimeRange
     */
    'endTime': string;
}
/**
 * 
 * @export
 * @interface AppError
 */
export interface AppError {
    /**
     * 
     * @type {number}
     * @memberof AppError
     */
    'statusCode': number;
    /**
     * What the error was
     * @type {string}
     * @memberof AppError
     */
    'message': string;
    /**
     * 
     * @type {AppErrorData}
     * @memberof AppError
     */
    'data'?: AppErrorData;
}
/**
 * Some extra information about the error
 * @export
 * @interface AppErrorData
 */
export interface AppErrorData {
    [key: string]: any;

    /**
     * 
     * @type {AppErrorDataHelpLink}
     * @memberof AppErrorData
     */
    'helpLink'?: AppErrorDataHelpLink;
}
/**
 * @type AppErrorDataHelpLink
 * @export
 */
export type AppErrorDataHelpLink = AppErrorDataHelpLinkOneOf | AppErrorDataHelpLinkOneOf1;

/**
 * 
 * @export
 * @interface AppErrorDataHelpLinkOneOf
 */
export interface AppErrorDataHelpLinkOneOf {
    /**
     * 
     * @type {string}
     * @memberof AppErrorDataHelpLinkOneOf
     */
    'docId': string;
}
/**
 * 
 * @export
 * @interface AppErrorDataHelpLinkOneOf1
 */
export interface AppErrorDataHelpLinkOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof AppErrorDataHelpLinkOneOf1
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface CampaignAsyncCreate200Response
 */
export interface CampaignAsyncCreate200Response {
    /**
     * ID of the campaign that is being created right now
     * @type {string}
     * @memberof CampaignAsyncCreate200Response
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface CampaignAsyncGet200Response
 */
export interface CampaignAsyncGet200Response {
    /**
     * ID of the campaign
     * @type {string}
     * @memberof CampaignAsyncGet200Response
     */
    'id': string;
    /**
     * Team ID of the campaign
     * @type {string}
     * @memberof CampaignAsyncGet200Response
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof CampaignAsyncGet200Response
     */
    'status': CampaignAsyncGet200ResponseStatusEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CampaignAsyncGet200Response
     */
    'error'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {CampaignMetadata}
     * @memberof CampaignAsyncGet200Response
     */
    'campaign'?: CampaignMetadata;
}

export const CampaignAsyncGet200ResponseStatusEnum = {
    Executing: 'executing',
    Success: 'success',
    Error: 'error'
} as const;

export type CampaignAsyncGet200ResponseStatusEnum = typeof CampaignAsyncGet200ResponseStatusEnum[keyof typeof CampaignAsyncGet200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface CampaignAsyncGet200ResponseAllOf
 */
export interface CampaignAsyncGet200ResponseAllOf {
    /**
     * 
     * @type {CampaignMetadata}
     * @memberof CampaignAsyncGet200ResponseAllOf
     */
    'campaign'?: CampaignMetadata;
}
/**
 * 
 * @export
 * @interface CampaignCreateAsync
 */
export interface CampaignCreateAsync {
    /**
     * Name of the campaign
     * @type {string}
     * @memberof CampaignCreateAsync
     */
    'name': string;
    /**
     * Time interval between each message sent in seconds
     * @type {number}
     * @memberof CampaignCreateAsync
     */
    'sendInterval': number;
    /**
     * The template to send out
     * @type {string}
     * @memberof CampaignCreateAsync
     */
    'messageTemplate': string;
    /**
     * 
     * @type {string}
     * @memberof CampaignCreateAsync
     */
    'scheduledAt'?: string | null;
    /**
     * Should the message be randomized before sending. Recommended to prevent bans
     * @type {boolean}
     * @memberof CampaignCreateAsync
     */
    'randomizeMessage'?: boolean;
    /**
     * Should typing indicator & read receipt be sent
     * @type {boolean}
     * @memberof CampaignCreateAsync
     */
    'sendTyping'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CampaignCreateAsync
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof CampaignCreateAsync
     * @deprecated
     */
    'accountId'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CampaignCreateAsync
     */
    'accountIds'?: Array<string> | null;
    /**
     * 
     * @type {NullableActivationTimeRange}
     * @memberof CampaignCreateAsync
     */
    'activationTimeRange'?: NullableActivationTimeRange;
    /**
     * Contact filter query
     * @type {{ [key: string]: any; }}
     * @memberof CampaignCreateAsync
     */
    'contactFilters'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof CampaignCreateAsync
     */
    'createdAt'?: string;
}
/**
 * Current state of campaign creation
 * @export
 * @interface CampaignCreateJob
 */
export interface CampaignCreateJob {
    /**
     * ID of the campaign
     * @type {string}
     * @memberof CampaignCreateJob
     */
    'id': string;
    /**
     * Team ID of the campaign
     * @type {string}
     * @memberof CampaignCreateJob
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof CampaignCreateJob
     */
    'status': CampaignCreateJobStatusEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CampaignCreateJob
     */
    'error'?: { [key: string]: any; } | null;
}

export const CampaignCreateJobStatusEnum = {
    Executing: 'executing',
    Success: 'success',
    Error: 'error'
} as const;

export type CampaignCreateJobStatusEnum = typeof CampaignCreateJobStatusEnum[keyof typeof CampaignCreateJobStatusEnum];

/**
 * 
 * @export
 * @interface CampaignDelete200Response
 */
export interface CampaignDelete200Response {
    /**
     * 
     * @type {boolean}
     * @memberof CampaignDelete200Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface CampaignEdit
 */
export interface CampaignEdit {
    /**
     * Name of the campaign
     * @type {string}
     * @memberof CampaignEdit
     */
    'name'?: string;
    /**
     * Time interval between each message sent in seconds
     * @type {number}
     * @memberof CampaignEdit
     */
    'sendInterval'?: number;
    /**
     * The template to send out
     * @type {string}
     * @memberof CampaignEdit
     */
    'messageTemplate'?: string;
    /**
     * 
     * @type {string}
     * @memberof CampaignEdit
     */
    'scheduledAt'?: string | null;
    /**
     * Should the message be randomized before sending
     * @type {boolean}
     * @memberof CampaignEdit
     */
    'randomizeMessage'?: boolean;
    /**
     * Should typing indicator & read receipt be sent
     * @type {boolean}
     * @memberof CampaignEdit
     */
    'sendTyping'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CampaignEdit
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof CampaignEdit
     * @deprecated
     */
    'accountId'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CampaignEdit
     */
    'accountIds'?: Array<string> | null;
    /**
     * 
     * @type {NullableActivationTimeRange}
     * @memberof CampaignEdit
     */
    'activationTimeRange'?: NullableActivationTimeRange;
    /**
     * Contact filter query
     * @type {{ [key: string]: any; }}
     * @memberof CampaignEdit
     */
    'contactFilters'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface CampaignMetadata
 */
export interface CampaignMetadata {
    /**
     * Name of the campaign
     * @type {string}
     * @memberof CampaignMetadata
     */
    'name': string;
    /**
     * Time interval between each message sent in seconds
     * @type {number}
     * @memberof CampaignMetadata
     */
    'sendInterval': number;
    /**
     * The template to send out
     * @type {string}
     * @memberof CampaignMetadata
     */
    'messageTemplate': string;
    /**
     * 
     * @type {string}
     * @memberof CampaignMetadata
     */
    'scheduledAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CampaignMetadata
     */
    'nextScheduledAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CampaignMetadata
     */
    'completedAt'?: string | null;
    /**
     * Should the message be randomized before sending
     * @type {boolean}
     * @memberof CampaignMetadata
     */
    'randomizeMessage'?: boolean;
    /**
     * Should typing indicator & read receipt be sent
     * @type {boolean}
     * @memberof CampaignMetadata
     */
    'sendTyping'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CampaignMetadata
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * ID of the campaign
     * @type {string}
     * @memberof CampaignMetadata
     */
    'id': string;
    /**
     * 
     * @type {CampaignState}
     * @memberof CampaignMetadata
     */
    'state': CampaignState;
    /**
     * 
     * @type {string}
     * @memberof CampaignMetadata
     */
    'createdAt': string;
    /**
     * User who created the campaign
     * @type {string}
     * @memberof CampaignMetadata
     */
    'createdBy': string;
    /**
     * Team ID of the campaign
     * @type {string}
     * @memberof CampaignMetadata
     */
    'teamId': string;
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof CampaignMetadata
     * @deprecated
     */
    'accountId'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CampaignMetadata
     */
    'accountIds'?: Array<string> | null;
    /**
     * Contact filter query
     * @type {{ [key: string]: any; }}
     * @memberof CampaignMetadata
     */
    'contactFilters'?: { [key: string]: any; };
    /**
     * 
     * @type {CampaignMetadataCounts}
     * @memberof CampaignMetadata
     */
    'counts': CampaignMetadataCounts;
    /**
     * 
     * @type {ActivationTimeRange}
     * @memberof CampaignMetadata
     */
    'activationTimeRange'?: ActivationTimeRange;
}


/**
 * 
 * @export
 * @interface CampaignMetadataCounts
 */
export interface CampaignMetadataCounts {
    /**
     * 
     * @type {number}
     * @memberof CampaignMetadataCounts
     */
    'failed'?: number;
    /**
     * 
     * @type {number}
     * @memberof CampaignMetadataCounts
     */
    'pending'?: number;
    /**
     * 
     * @type {number}
     * @memberof CampaignMetadataCounts
     */
    'pendingWAAck'?: number;
    /**
     * 
     * @type {number}
     * @memberof CampaignMetadataCounts
     */
    'sent'?: number;
    /**
     * 
     * @type {number}
     * @memberof CampaignMetadataCounts
     */
    'delivered'?: number;
}
/**
 * Current state of the recipient
 * @export
 * @enum {string}
 */

export const CampaignRecipientState = {
    Failed: 'failed',
    Pending: 'pending',
    PendingWaAck: 'pendingWAAck',
    Sent: 'sent',
    Delivered: 'delivered'
} as const;

export type CampaignRecipientState = typeof CampaignRecipientState[keyof typeof CampaignRecipientState];


/**
 * 
 * @export
 * @interface CampaignRecipients
 */
export interface CampaignRecipients {
    /**
     * 
     * @type {string}
     * @memberof CampaignRecipients
     */
    'jid': string;
    /**
     * 
     * @type {CampaignRecipientState}
     * @memberof CampaignRecipients
     */
    'state': CampaignRecipientState;
    /**
     * 
     * @type {string}
     * @memberof CampaignRecipients
     */
    'accountId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CampaignRecipients
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof CampaignRecipients
     */
    'messageId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CampaignRecipients
     */
    'sentAt'?: string | null;
    /**
     * 
     * @type {WaResponse}
     * @memberof CampaignRecipients
     */
    'waResponse'?: WaResponse;
}


/**
 * 
 * @export
 * @interface CampaignRecipientsResponse
 */
export interface CampaignRecipientsResponse {
    /**
     * 
     * @type {Array<CampaignRecipients>}
     * @memberof CampaignRecipientsResponse
     */
    'recipients': Array<CampaignRecipients>;
    /**
     * Cursor to fetch next page of campaign recipients
     * @type {string}
     * @memberof CampaignRecipientsResponse
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface CampaignRetreivalResponse
 */
export interface CampaignRetreivalResponse {
    /**
     * 
     * @type {Array<CampaignMetadata>}
     * @memberof CampaignRetreivalResponse
     */
    'campaigns': Array<CampaignMetadata>;
    /**
     * Cursor to fetch next page of campaigns
     * @type {string}
     * @memberof CampaignRetreivalResponse
     */
    'cursor'?: string;
    /**
     * total campaigns present with these filters. Only returned if returnTotalCount is true
     * @type {number}
     * @memberof CampaignRetreivalResponse
     */
    'totalCount'?: number;
}
/**
 * Current state of the campaign
 * @export
 * @enum {string}
 */

export const CampaignState = {
    Inactive: 'inactive',
    Scheduled: 'scheduled',
    Progress: 'progress',
    Completed: 'completed'
} as const;

export type CampaignState = typeof CampaignState[keyof typeof CampaignState];


/**
 * for adding nullability to a ref
 * @export
 * @enum {string}
 */

export const NullType = {
    Null: null as null
} as const;

export type NullType = typeof NullType[keyof typeof NullType];


/**
 * @type NullableActivationTimeRange
 * @export
 */
export type NullableActivationTimeRange = ActivationTimeRange | NullType;

/**
 * The response received from botsFire which it receives from WhatsApp. It contains either an error message or is of type \"Message\" of the IM service 
 * @export
 * @interface WaResponse
 */
export interface WaResponse {
    /**
     * 
     * @type {number}
     * @memberof WaResponse
     */
    'code'?: number;
    /**
     * 
     * @type {AppError}
     * @memberof WaResponse
     */
    'body'?: AppError;
}

/**
 * CampaignsApi - axios parameter creator
 * @export
 */
export const CampaignsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new campaign asynchronously
         * @param {CampaignCreateAsync} [campaignCreateAsync] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignAsyncCreate: async (campaignCreateAsync?: CampaignCreateAsync, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/async`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CAMPAIGNS_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignCreateAsync, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check the status of the asynchronously created campaign
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignAsyncGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('campaignAsyncGet', 'id', id)
            const localVarPath = `/async/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CAMPAIGNS_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the campaign
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('campaignDelete', 'id', id)
            const localVarPath = `/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CAMPAIGNS_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets campaign recipients
         * @param {string} id 
         * @param {number} [count] Number of campaign recipients to fetch
         * @param {string} [q] Campaign recipients search string
         * @param {string} [cursor] Campaign recipients cursor for pagination
         * @param {CampaignRecipientState} [state] only fetch recipients in this state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignGetRecipients: async (id: string, count?: number, q?: string, cursor?: string, state?: CampaignRecipientState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('campaignGetRecipients', 'id', id)
            const localVarPath = `/{id}/recipients`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CAMPAIGNS_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get campaigns in a paginated format
         * @param {number} [count] Number of campaigns to fetch
         * @param {string} [before] Campaigns to fetch before
         * @param {string} [searchString] Campaign search string
         * @param {boolean} [onlyActive] Show only active campaigns
         * @param {CampaignState} [status] Query campaigns with the specified status
         * @param {string} [id] Get metadata of this campaign
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignGets: async (count?: number, before?: string, searchString?: string, onlyActive?: boolean, status?: CampaignState, id?: string, returnTotalCount?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CAMPAIGNS_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['searchString'] = searchString;
            }

            if (onlyActive !== undefined) {
                localVarQueryParameter['onlyActive'] = onlyActive;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the updated campaign
         * @summary Update/Reschedule a Campaign
         * @param {string} id 
         * @param {CampaignEdit} [campaignEdit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignPatch: async (id: string, campaignEdit?: CampaignEdit, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('campaignPatch', 'id', id)
            const localVarPath = `/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CAMPAIGNS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignEdit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignStart: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('campaignStart', 'id', id)
            const localVarPath = `/{id}/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CAMPAIGNS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignStop: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('campaignStop', 'id', id)
            const localVarPath = `/{id}/stop`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CAMPAIGNS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CampaignsApi - functional programming interface
 * @export
 */
export const CampaignsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CampaignsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new campaign asynchronously
         * @param {CampaignCreateAsync} [campaignCreateAsync] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignAsyncCreate(campaignCreateAsync?: CampaignCreateAsync, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignAsyncCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignAsyncCreate(campaignCreateAsync, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check the status of the asynchronously created campaign
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignAsyncGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignAsyncGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignAsyncGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes the campaign
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets campaign recipients
         * @param {string} id 
         * @param {number} [count] Number of campaign recipients to fetch
         * @param {string} [q] Campaign recipients search string
         * @param {string} [cursor] Campaign recipients cursor for pagination
         * @param {CampaignRecipientState} [state] only fetch recipients in this state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignGetRecipients(id: string, count?: number, q?: string, cursor?: string, state?: CampaignRecipientState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignRecipientsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignGetRecipients(id, count, q, cursor, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get campaigns in a paginated format
         * @param {number} [count] Number of campaigns to fetch
         * @param {string} [before] Campaigns to fetch before
         * @param {string} [searchString] Campaign search string
         * @param {boolean} [onlyActive] Show only active campaigns
         * @param {CampaignState} [status] Query campaigns with the specified status
         * @param {string} [id] Get metadata of this campaign
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignGets(count?: number, before?: string, searchString?: string, onlyActive?: boolean, status?: CampaignState, id?: string, returnTotalCount?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignRetreivalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignGets(count, before, searchString, onlyActive, status, id, returnTotalCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the updated campaign
         * @summary Update/Reschedule a Campaign
         * @param {string} id 
         * @param {CampaignEdit} [campaignEdit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignPatch(id: string, campaignEdit?: CampaignEdit, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignPatch(id, campaignEdit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignStart(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignStart(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignStop(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignStop(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CampaignsApi - factory interface
 * @export
 */
export const CampaignsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CampaignsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new campaign asynchronously
         * @param {CampaignsApiCampaignAsyncCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignAsyncCreate(requestParameters: CampaignsApiCampaignAsyncCreateRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CampaignAsyncCreate200Response> {
            return localVarFp.campaignAsyncCreate(requestParameters.campaignCreateAsync, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check the status of the asynchronously created campaign
         * @param {CampaignsApiCampaignAsyncGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignAsyncGet(requestParameters: CampaignsApiCampaignAsyncGetRequest, options?: AxiosRequestConfig): AxiosPromise<CampaignAsyncGet200Response> {
            return localVarFp.campaignAsyncGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes the campaign
         * @param {CampaignsApiCampaignDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignDelete(requestParameters: CampaignsApiCampaignDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<CampaignDelete200Response> {
            return localVarFp.campaignDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets campaign recipients
         * @param {CampaignsApiCampaignGetRecipientsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignGetRecipients(requestParameters: CampaignsApiCampaignGetRecipientsRequest, options?: AxiosRequestConfig): AxiosPromise<CampaignRecipientsResponse> {
            return localVarFp.campaignGetRecipients(requestParameters.id, requestParameters.count, requestParameters.q, requestParameters.cursor, requestParameters.state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get campaigns in a paginated format
         * @param {CampaignsApiCampaignGetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignGets(requestParameters: CampaignsApiCampaignGetsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CampaignRetreivalResponse> {
            return localVarFp.campaignGets(requestParameters.count, requestParameters.before, requestParameters.searchString, requestParameters.onlyActive, requestParameters.status, requestParameters.id, requestParameters.returnTotalCount, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the updated campaign
         * @summary Update/Reschedule a Campaign
         * @param {CampaignsApiCampaignPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignPatch(requestParameters: CampaignsApiCampaignPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.campaignPatch(requestParameters.id, requestParameters.campaignEdit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CampaignsApiCampaignStartRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignStart(requestParameters: CampaignsApiCampaignStartRequest, options?: AxiosRequestConfig): AxiosPromise<CampaignDelete200Response> {
            return localVarFp.campaignStart(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CampaignsApiCampaignStopRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignStop(requestParameters: CampaignsApiCampaignStopRequest, options?: AxiosRequestConfig): AxiosPromise<CampaignDelete200Response> {
            return localVarFp.campaignStop(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for campaignAsyncCreate operation in CampaignsApi.
 * @export
 * @interface CampaignsApiCampaignAsyncCreateRequest
 */
export interface CampaignsApiCampaignAsyncCreateRequest {
    /**
     * 
     * @type {CampaignCreateAsync}
     * @memberof CampaignsApiCampaignAsyncCreate
     */
    readonly campaignCreateAsync?: CampaignCreateAsync
}

/**
 * Request parameters for campaignAsyncGet operation in CampaignsApi.
 * @export
 * @interface CampaignsApiCampaignAsyncGetRequest
 */
export interface CampaignsApiCampaignAsyncGetRequest {
    /**
     * 
     * @type {string}
     * @memberof CampaignsApiCampaignAsyncGet
     */
    readonly id: string
}

/**
 * Request parameters for campaignDelete operation in CampaignsApi.
 * @export
 * @interface CampaignsApiCampaignDeleteRequest
 */
export interface CampaignsApiCampaignDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof CampaignsApiCampaignDelete
     */
    readonly id: string
}

/**
 * Request parameters for campaignGetRecipients operation in CampaignsApi.
 * @export
 * @interface CampaignsApiCampaignGetRecipientsRequest
 */
export interface CampaignsApiCampaignGetRecipientsRequest {
    /**
     * 
     * @type {string}
     * @memberof CampaignsApiCampaignGetRecipients
     */
    readonly id: string

    /**
     * Number of campaign recipients to fetch
     * @type {number}
     * @memberof CampaignsApiCampaignGetRecipients
     */
    readonly count?: number

    /**
     * Campaign recipients search string
     * @type {string}
     * @memberof CampaignsApiCampaignGetRecipients
     */
    readonly q?: string

    /**
     * Campaign recipients cursor for pagination
     * @type {string}
     * @memberof CampaignsApiCampaignGetRecipients
     */
    readonly cursor?: string

    /**
     * only fetch recipients in this state
     * @type {CampaignRecipientState}
     * @memberof CampaignsApiCampaignGetRecipients
     */
    readonly state?: CampaignRecipientState
}

/**
 * Request parameters for campaignGets operation in CampaignsApi.
 * @export
 * @interface CampaignsApiCampaignGetsRequest
 */
export interface CampaignsApiCampaignGetsRequest {
    /**
     * Number of campaigns to fetch
     * @type {number}
     * @memberof CampaignsApiCampaignGets
     */
    readonly count?: number

    /**
     * Campaigns to fetch before
     * @type {string}
     * @memberof CampaignsApiCampaignGets
     */
    readonly before?: string

    /**
     * Campaign search string
     * @type {string}
     * @memberof CampaignsApiCampaignGets
     */
    readonly searchString?: string

    /**
     * Show only active campaigns
     * @type {boolean}
     * @memberof CampaignsApiCampaignGets
     */
    readonly onlyActive?: boolean

    /**
     * Query campaigns with the specified status
     * @type {CampaignState}
     * @memberof CampaignsApiCampaignGets
     */
    readonly status?: CampaignState

    /**
     * Get metadata of this campaign
     * @type {string}
     * @memberof CampaignsApiCampaignGets
     */
    readonly id?: string

    /**
     * 
     * @type {boolean}
     * @memberof CampaignsApiCampaignGets
     */
    readonly returnTotalCount?: boolean
}

/**
 * Request parameters for campaignPatch operation in CampaignsApi.
 * @export
 * @interface CampaignsApiCampaignPatchRequest
 */
export interface CampaignsApiCampaignPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof CampaignsApiCampaignPatch
     */
    readonly id: string

    /**
     * 
     * @type {CampaignEdit}
     * @memberof CampaignsApiCampaignPatch
     */
    readonly campaignEdit?: CampaignEdit
}

/**
 * Request parameters for campaignStart operation in CampaignsApi.
 * @export
 * @interface CampaignsApiCampaignStartRequest
 */
export interface CampaignsApiCampaignStartRequest {
    /**
     * 
     * @type {string}
     * @memberof CampaignsApiCampaignStart
     */
    readonly id: string
}

/**
 * Request parameters for campaignStop operation in CampaignsApi.
 * @export
 * @interface CampaignsApiCampaignStopRequest
 */
export interface CampaignsApiCampaignStopRequest {
    /**
     * 
     * @type {string}
     * @memberof CampaignsApiCampaignStop
     */
    readonly id: string
}

/**
 * CampaignsApi - object-oriented interface
 * @export
 * @class CampaignsApi
 * @extends {BaseAPI}
 */
export class CampaignsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new campaign asynchronously
     * @param {CampaignsApiCampaignAsyncCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignAsyncCreate(requestParameters: CampaignsApiCampaignAsyncCreateRequest = {}, options?: AxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignAsyncCreate(requestParameters.campaignCreateAsync, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check the status of the asynchronously created campaign
     * @param {CampaignsApiCampaignAsyncGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignAsyncGet(requestParameters: CampaignsApiCampaignAsyncGetRequest, options?: AxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignAsyncGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes the campaign
     * @param {CampaignsApiCampaignDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignDelete(requestParameters: CampaignsApiCampaignDeleteRequest, options?: AxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets campaign recipients
     * @param {CampaignsApiCampaignGetRecipientsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignGetRecipients(requestParameters: CampaignsApiCampaignGetRecipientsRequest, options?: AxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignGetRecipients(requestParameters.id, requestParameters.count, requestParameters.q, requestParameters.cursor, requestParameters.state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get campaigns in a paginated format
     * @param {CampaignsApiCampaignGetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignGets(requestParameters: CampaignsApiCampaignGetsRequest = {}, options?: AxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignGets(requestParameters.count, requestParameters.before, requestParameters.searchString, requestParameters.onlyActive, requestParameters.status, requestParameters.id, requestParameters.returnTotalCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the updated campaign
     * @summary Update/Reschedule a Campaign
     * @param {CampaignsApiCampaignPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignPatch(requestParameters: CampaignsApiCampaignPatchRequest, options?: AxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignPatch(requestParameters.id, requestParameters.campaignEdit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CampaignsApiCampaignStartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignStart(requestParameters: CampaignsApiCampaignStartRequest, options?: AxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignStart(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CampaignsApiCampaignStopRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignStop(requestParameters: CampaignsApiCampaignStopRequest, options?: AxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignStop(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


