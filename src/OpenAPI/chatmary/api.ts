const BASE_PATH = "https://api.chatdaddy.tech/chatmary".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * Chatdaddy ChatMary Service
 * Manage natural language to action automation
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @interface AutocompleteCalendarEventRequest
 */
export interface AutocompleteCalendarEventRequest {
    /**
     * message to extract calendar event data from
     * @type {string}
     * @memberof AutocompleteCalendarEventRequest
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface BotAddPost200Response
 */
export interface BotAddPost200Response {
    /**
     * 
     * @type {boolean}
     * @memberof BotAddPost200Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface BotAddPostRequest
 */
export interface BotAddPostRequest {
    /**
     * Name of the bot
     * @type {string}
     * @memberof BotAddPostRequest
     */
    'botId': string;
    /**
     * Description of the bot
     * @type {string}
     * @memberof BotAddPostRequest
     */
    'botToken': string;
    /**
     * Description of the bot
     * @type {string}
     * @memberof BotAddPostRequest
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface BotConversation
 */
export interface BotConversation {
    /**
     * Turn number
     * @type {number}
     * @memberof BotConversation
     */
    'turn'?: number;
    /**
     * Question asked by the user
     * @type {string}
     * @memberof BotConversation
     */
    'question'?: string;
    /**
     * Answer provided by the bot
     * @type {string}
     * @memberof BotConversation
     */
    'answer'?: string;
}
/**
 * 
 * @export
 * @interface BotDetails
 */
export interface BotDetails {
    /**
     * Id of the user
     * @type {string}
     * @memberof BotDetails
     */
    'userId': string;
    /**
     * 
     * @type {BotUseCase}
     * @memberof BotDetails
     */
    'botApp'?: BotUseCase;
    /**
     * 
     * @type {BotDetailsData}
     * @memberof BotDetails
     */
    'data'?: BotDetailsData;
    /**
     * Questions asked by the user
     * @type {Array<string>}
     * @memberof BotDetails
     */
    'questions'?: Array<string>;
    /**
     * Answers provided by the bot
     * @type {Array<string>}
     * @memberof BotDetails
     */
    'answers'?: Array<string>;
}


/**
 * @type BotDetailsData
 * Data specific to the bot use case
 * @export
 */
export type BotDetailsData = MedicalBotData;

/**
 * 
 * @export
 * @interface BotMessagePost200Response
 */
export interface BotMessagePost200Response {
    /**
     * 
     * @type {string}
     * @memberof BotMessagePost200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface BotMessagePostRequest
 */
export interface BotMessagePostRequest {
    /**
     * Message to send to the bot
     * @type {string}
     * @memberof BotMessagePostRequest
     */
    'message': string;
}
/**
 * Use case of the bot
 * @export
 * @enum {string}
 */

export const BotUseCase = {
    MedicalBot: 'medicalBot'
} as const;

export type BotUseCase = typeof BotUseCase[keyof typeof BotUseCase];


/**
 * 
 * @export
 * @interface BotUsersGet200Response
 */
export interface BotUsersGet200Response {
    /**
     * 
     * @type {Array<BotDetails>}
     * @memberof BotUsersGet200Response
     */
    'data'?: Array<BotDetails>;
}
/**
 * 
 * @export
 * @interface BotsGet200Response
 */
export interface BotsGet200Response {
    /**
     * 
     * @type {Array<CustomBot>}
     * @memberof BotsGet200Response
     */
    'bots'?: Array<CustomBot>;
}
/**
 * 
 * @export
 * @interface CalendarEvent
 */
export interface CalendarEvent {
    /**
     * Title of the event
     * @type {string}
     * @memberof CalendarEvent
     */
    'eventName': string;
    /**
     * Time of the event
     * @type {string}
     * @memberof CalendarEvent
     */
    'time': string;
    /**
     * Date of the event
     * @type {string}
     * @memberof CalendarEvent
     */
    'date': string;
    /**
     * duration of the event
     * @type {string}
     * @memberof CalendarEvent
     */
    'duration': string;
}
/**
 * 
 * @export
 * @interface ChatFlowHistory
 */
export interface ChatFlowHistory {
    /**
     * ID of this chat history
     * @type {string}
     * @memberof ChatFlowHistory
     */
    'id': string;
    /**
     * ID of the bot
     * @type {string}
     * @memberof ChatFlowHistory
     */
    'botId'?: string;
    /**
     * ID of the chat
     * @type {string}
     * @memberof ChatFlowHistory
     */
    'chatId': string;
    /**
     * ID of the worflow
     * @type {string}
     * @memberof ChatFlowHistory
     */
    'workflowId'?: string;
    /**
     * Name of the workflow being Used
     * @type {string}
     * @memberof ChatFlowHistory
     */
    'workflowName': string;
    /**
     * ID of the conversation
     * @type {string}
     * @memberof ChatFlowHistory
     */
    'conversationId': string;
    /**
     * JSON key value of variables associated with this conversation
     * @type {{ [key: string]: any; }}
     * @memberof ChatFlowHistory
     */
    'variableData'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ChatFlowHistory
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatFlowHistory
     */
    'lastRecordAddedAt'?: string;
    /**
     * 
     * @type {Array<ChatFlowRecordEntry>}
     * @memberof ChatFlowHistory
     */
    'records': Array<ChatFlowRecordEntry>;
}
/**
 * 
 * @export
 * @interface ChatFlowRecordEntry
 */
export interface ChatFlowRecordEntry {
    /**
     * ID of the chat record
     * @type {string}
     * @memberof ChatFlowRecordEntry
     */
    'id': string;
    /**
     * ID of the chat
     * @type {string}
     * @memberof ChatFlowRecordEntry
     */
    'chatId': string;
    /**
     * ID of the conversation
     * @type {string}
     * @memberof ChatFlowRecordEntry
     */
    'conversationId': string;
    /**
     * 
     * @type {string}
     * @memberof ChatFlowRecordEntry
     */
    'userMessage': string;
    /**
     * 
     * @type {string}
     * @memberof ChatFlowRecordEntry
     */
    'botOutput': string;
    /**
     * 
     * @type {string}
     * @memberof ChatFlowRecordEntry
     */
    'questionIntention'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatFlowRecordEntry
     */
    'questionForRAG'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatFlowRecordEntry
     */
    'createdAt'?: string;
    /**
     * 
     * @type {Array<RetrieverResourcesInner>}
     * @memberof ChatFlowRecordEntry
     */
    'limRAGResults'?: Array<RetrieverResourcesInner>;
    /**
     * 
     * @type {Array<RetrieverResourcesInner>}
     * @memberof ChatFlowRecordEntry
     */
    'exactRAGResults'?: Array<RetrieverResourcesInner>;
}
/**
 * 
 * @export
 * @interface ChatFlowRecordPostRequest
 */
export interface ChatFlowRecordPostRequest {
    /**
     * ID of the chat
     * @type {string}
     * @memberof ChatFlowRecordPostRequest
     */
    'chatId': string;
    /**
     * ID of the conversation
     * @type {string}
     * @memberof ChatFlowRecordPostRequest
     */
    'conversationId': string;
    /**
     * Name of the workflow being Used
     * @type {string}
     * @memberof ChatFlowRecordPostRequest
     */
    'workflowName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatFlowRecordPostRequest
     */
    'workflowId': string;
    /**
     * User message
     * @type {string}
     * @memberof ChatFlowRecordPostRequest
     */
    'userMessage': string;
    /**
     * Bot output
     * @type {string}
     * @memberof ChatFlowRecordPostRequest
     */
    'botOutput': string;
    /**
     * Intention of the question
     * @type {string}
     * @memberof ChatFlowRecordPostRequest
     */
    'questionIntention'?: string;
    /**
     * Question for RAG
     * @type {string}
     * @memberof ChatFlowRecordPostRequest
     */
    'questionForRAG'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatFlowRecordPostRequest
     */
    'limRAGResults'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatFlowRecordPostRequest
     */
    'exactRAGResults'?: string;
    /**
     * JSON key value of variables associated with this conversation
     * @type {string}
     * @memberof ChatFlowRecordPostRequest
     */
    'historyVariableData'?: string;
}
/**
 * 
 * @export
 * @interface ChatHistoryDataGet200Response
 */
export interface ChatHistoryDataGet200Response {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ChatHistoryDataGet200Response
     */
    'variableData'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<ChatFlowRecordEntry>}
     * @memberof ChatHistoryDataGet200Response
     */
    'records'?: Array<ChatFlowRecordEntry>;
}
/**
 * 
 * @export
 * @interface ContactToken
 */
export interface ContactToken {
    /**
     * ID of the contact
     * @type {string}
     * @memberof ContactToken
     */
    'contactId': string;
    /**
     * Access token for the contact
     * @type {string}
     * @memberof ContactToken
     */
    'accessToken': string;
}
/**
 * 
 * @export
 * @interface ContentComment
 */
export interface ContentComment {
    /**
     * 
     * @type {string}
     * @memberof ContentComment
     */
    'commentedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentComment
     */
    'commentedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentComment
     */
    'comment'?: string;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ContentComment
     */
    'reactions'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface ContentVersionHistory
 */
export interface ContentVersionHistory {
    /**
     * 
     * @type {string}
     * @memberof ContentVersionHistory
     */
    'editedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentVersionHistory
     */
    'editedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentVersionHistory
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentVersionHistory
     */
    'status'?: ContentVersionHistoryStatusEnum;
}

export const ContentVersionHistoryStatusEnum = {
    Live: 'live',
    Staging: 'staging',
    Archived: 'archived'
} as const;

export type ContentVersionHistoryStatusEnum = typeof ContentVersionHistoryStatusEnum[keyof typeof ContentVersionHistoryStatusEnum];

/**
 * 
 * @export
 * @interface ConversationIdGetRequest
 */
export interface ConversationIdGetRequest {
    /**
     * ID of the bot
     * @type {string}
     * @memberof ConversationIdGetRequest
     */
    'botId': string;
    /**
     * ID of the chat
     * @type {string}
     * @memberof ConversationIdGetRequest
     */
    'chatId': string;
    /**
     * data to extract input variables from
     * @type {string}
     * @memberof ConversationIdGetRequest
     */
    'variables'?: string;
}
/**
 * 
 * @export
 * @interface ConversationIdPostRequest
 */
export interface ConversationIdPostRequest {
    /**
     * ID of the bot
     * @type {string}
     * @memberof ConversationIdPostRequest
     */
    'botId': string;
    /**
     * ID of the chat
     * @type {string}
     * @memberof ConversationIdPostRequest
     */
    'chatId': string;
    /**
     * ID of the conversation
     * @type {string}
     * @memberof ConversationIdPostRequest
     */
    'conversationId': string;
    /**
     * Name of the app being Used
     * @type {string}
     * @memberof ConversationIdPostRequest
     */
    'appName'?: string;
    /**
     * 
     * @type {Array<ChatFlowHistory>}
     * @memberof ConversationIdPostRequest
     */
    'chatHistory'?: Array<ChatFlowHistory>;
}
/**
 * 
 * @export
 * @interface ConversationRecord
 */
export interface ConversationRecord {
    /**
     * ID of the bot
     * @type {string}
     * @memberof ConversationRecord
     */
    'botId': string;
    /**
     * ID of the chat
     * @type {string}
     * @memberof ConversationRecord
     */
    'chatId': string;
    /**
     * ID of the conversation
     * @type {string}
     * @memberof ConversationRecord
     */
    'conversationId'?: string;
    /**
     * Name of the app being Used
     * @type {string}
     * @memberof ConversationRecord
     */
    'appName'?: string;
    /**
     * 
     * @type {Array<ChatFlowHistory>}
     * @memberof ConversationRecord
     */
    'chatHistory'?: Array<ChatFlowHistory>;
    /**
     * input variables for context
     * @type {string}
     * @memberof ConversationRecord
     */
    'inputs'?: string;
}
/**
 * 
 * @export
 * @interface CustomBot
 */
export interface CustomBot {
    /**
     * Account ID
     * @type {string}
     * @memberof CustomBot
     */
    'accountId': string;
    /**
     * Bot id as generated by ai bot provider
     * @type {string}
     * @memberof CustomBot
     */
    'botId': string;
    /**
     * Access token for the bot
     * @type {string}
     * @memberof CustomBot
     */
    'botToken': string;
    /**
     * User Id as provided by the bot provider
     * @type {string}
     * @memberof CustomBot
     */
    'userId': string;
    /**
     * TeamId the bot belongs to
     * @type {string}
     * @memberof CustomBot
     */
    'teamId'?: string;
}
/**
 * 
 * @export
 * @interface GenerateFlowWithGenkitPostRequest
 */
export interface GenerateFlowWithGenkitPostRequest {
    /**
     * Text to generate flow from
     * @type {string}
     * @memberof GenerateFlowWithGenkitPostRequest
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface KnowledgeBaseGet200Response
 */
export interface KnowledgeBaseGet200Response {
    /**
     * 
     * @type {Array<KnowledgeGraph>}
     * @memberof KnowledgeBaseGet200Response
     */
    'knowledgeGraphs'?: Array<KnowledgeGraph>;
}
/**
 * 
 * @export
 * @interface KnowledgeBasePostRequest
 */
export interface KnowledgeBasePostRequest {
    /**
     * Content that goes into the graph database
     * @type {string}
     * @memberof KnowledgeBasePostRequest
     */
    'text'?: string;
    /**
     * 
     * @type {KnowledgeGraph}
     * @memberof KnowledgeBasePostRequest
     */
    'knowledgeGraph': KnowledgeGraph;
}
/**
 * 
 * @export
 * @interface KnowledgeGraph
 */
export interface KnowledgeGraph {
    /**
     * ID of the graph knowledge base
     * @type {string}
     * @memberof KnowledgeGraph
     */
    'id'?: string;
    /**
     * Name of the knowledge graph
     * @type {string}
     * @memberof KnowledgeGraph
     */
    'name'?: string;
    /**
     * Description of the knowledge graph
     * @type {string}
     * @memberof KnowledgeGraph
     */
    'description'?: string;
    /**
     * Team ID
     * @type {string}
     * @memberof KnowledgeGraph
     */
    'teamId'?: string;
    /**
     * Status of the knowledge graph
     * @type {string}
     * @memberof KnowledgeGraph
     */
    'status'?: KnowledgeGraphStatusEnum;
    /**
     * 
     * @type {KnowledgeGraphContent}
     * @memberof KnowledgeGraph
     */
    'content'?: KnowledgeGraphContent;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeGraph
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeGraph
     */
    'updatedAt'?: string;
    /**
     * User who created the knowledge graph
     * @type {string}
     * @memberof KnowledgeGraph
     */
    'createdBy'?: string;
    /**
     * User who updated the knowledge graph
     * @type {string}
     * @memberof KnowledgeGraph
     */
    'updatedBy'?: string;
    /**
     * Version of the knowledge graph
     * @type {string}
     * @memberof KnowledgeGraph
     */
    'version'?: string;
    /**
     * Total number of entities in the knowledge graph
     * @type {number}
     * @memberof KnowledgeGraph
     */
    'totalEntityCount'?: number;
    /**
     * 
     * @type {Array<ContentComment>}
     * @memberof KnowledgeGraph
     */
    'comments'?: Array<ContentComment>;
}

export const KnowledgeGraphStatusEnum = {
    Published: 'published',
    Draft: 'draft'
} as const;

export type KnowledgeGraphStatusEnum = typeof KnowledgeGraphStatusEnum[keyof typeof KnowledgeGraphStatusEnum];

/**
 * 
 * @export
 * @interface KnowledgeGraphContent
 */
export interface KnowledgeGraphContent {
    /**
     * Nodes in the knowledge graph
     * @type {Array<KnowledgeGraphContentNodesInner>}
     * @memberof KnowledgeGraphContent
     */
    'nodes'?: Array<KnowledgeGraphContentNodesInner>;
    /**
     * Relationships between nodes in the knowledge graph
     * @type {Array<KnowledgeGraphContentEdgesInner>}
     * @memberof KnowledgeGraphContent
     */
    'edges'?: Array<KnowledgeGraphContentEdgesInner>;
}
/**
 * 
 * @export
 * @interface KnowledgeGraphContentEdgesInner
 */
export interface KnowledgeGraphContentEdgesInner {
    /**
     * 
     * @type {string}
     * @memberof KnowledgeGraphContentEdgesInner
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeGraphContentEdgesInner
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeGraphContentEdgesInner
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface KnowledgeGraphContentNodesInner
 */
export interface KnowledgeGraphContentNodesInner {
    /**
     * 
     * @type {string}
     * @memberof KnowledgeGraphContentNodesInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeGraphContentNodesInner
     */
    'label'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof KnowledgeGraphContentNodesInner
     */
    'properties'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<ContentVersionHistory>}
     * @memberof KnowledgeGraphContentNodesInner
     */
    'versionHistory'?: Array<ContentVersionHistory>;
    /**
     * 
     * @type {Array<ContentComment>}
     * @memberof KnowledgeGraphContentNodesInner
     */
    'comments'?: Array<ContentComment>;
    /**
     * 
     * @type {number}
     * @memberof KnowledgeGraphContentNodesInner
     */
    'totalRetrievalTimes'?: number;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeGraphContentNodesInner
     */
    'lastRetrievedAt'?: string;
}
/**
 * 
 * @export
 * @interface KnowledgeGraphQueriedData
 */
export interface KnowledgeGraphQueriedData {
    /**
     * Textual response derived from the query
     * @type {string}
     * @memberof KnowledgeGraphQueriedData
     */
    'responseText'?: string;
    /**
     * Confidence score of the response
     * @type {number}
     * @memberof KnowledgeGraphQueriedData
     */
    'confidenceScore'?: number;
    /**
     * 
     * @type {KnowledgeGraphContent}
     * @memberof KnowledgeGraphQueriedData
     */
    'content'?: KnowledgeGraphContent;
}
/**
 * 
 * @export
 * @interface ManageUserDataPostRequest
 */
export interface ManageUserDataPostRequest {
    /**
     * Stringified json data about the user
     * @type {string}
     * @memberof ManageUserDataPostRequest
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface MedicalBotData
 */
export interface MedicalBotData {
    /**
     * Name of the user
     * @type {string}
     * @memberof MedicalBotData
     */
    'name'?: string;
    /**
     * Age of the user
     * @type {number}
     * @memberof MedicalBotData
     */
    'age'?: number;
    /**
     * Stage of the ailment
     * @type {string}
     * @memberof MedicalBotData
     */
    'stage'?: string;
    /**
     * Symptoms of the ailment
     * @type {Array<string>}
     * @memberof MedicalBotData
     */
    'symptoms'?: Array<string>;
    /**
     * 
     * @type {Array<BotConversation>}
     * @memberof MedicalBotData
     */
    'conversationHistory'?: Array<BotConversation>;
    /**
     * Additional details about the user
     * @type {object}
     * @memberof MedicalBotData
     */
    'additionalData'?: object;
}
/**
 * 
 * @export
 * @interface OauthCallback200Response
 */
export interface OauthCallback200Response {
    /**
     * 
     * @type {string}
     * @memberof OauthCallback200Response
     */
    'accessToken'?: string;
}
/**
 * 
 * @export
 * @interface Question
 */
export interface Question {
    /**
     * 
     * @type {string}
     * @memberof Question
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Question
     */
    'question'?: string;
    /**
     * 
     * @type {string}
     * @memberof Question
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof Question
     */
    'answerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Question
     */
    'answerBaseId'?: string;
    /**
     * 
     * @type {QuestionAsker}
     * @memberof Question
     */
    'asker'?: QuestionAsker;
    /**
     * 
     * @type {number}
     * @memberof Question
     */
    'confidenceScore'?: number;
    /**
     * 
     * @type {string}
     * @memberof Question
     */
    'topic'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Question
     */
    'exactRagResults'?: Array<string>;
}
/**
 * 
 * @export
 * @interface QuestionAsker
 */
export interface QuestionAsker {
    /**
     * 
     * @type {string}
     * @memberof QuestionAsker
     */
    'askedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionAsker
     */
    'askedAt'?: string;
}
/**
 * 
 * @export
 * @interface RetrieverResourcesInner
 */
export interface RetrieverResourcesInner {
    /**
     * 
     * @type {RetrieverResourcesInnerMetadata}
     * @memberof RetrieverResourcesInner
     */
    'metadata'?: RetrieverResourcesInnerMetadata;
    /**
     * 
     * @type {string}
     * @memberof RetrieverResourcesInner
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieverResourcesInner
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface RetrieverResourcesInnerMetadata
 */
export interface RetrieverResourcesInnerMetadata {
    /**
     * 
     * @type {string}
     * @memberof RetrieverResourcesInnerMetadata
     */
    '_source'?: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieverResourcesInnerMetadata
     */
    'dataset_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieverResourcesInnerMetadata
     */
    'dataset_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieverResourcesInnerMetadata
     */
    'document_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieverResourcesInnerMetadata
     */
    'document_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieverResourcesInnerMetadata
     */
    'document_data_source_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieverResourcesInnerMetadata
     */
    'segment_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RetrieverResourcesInnerMetadata
     */
    'retriever_from'?: string;
    /**
     * 
     * @type {number}
     * @memberof RetrieverResourcesInnerMetadata
     */
    'score'?: number;
    /**
     * 
     * @type {number}
     * @memberof RetrieverResourcesInnerMetadata
     */
    'segment_hit_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof RetrieverResourcesInnerMetadata
     */
    'segment_word_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof RetrieverResourcesInnerMetadata
     */
    'segment_position'?: number;
    /**
     * 
     * @type {string}
     * @memberof RetrieverResourcesInnerMetadata
     */
    'segment_index_node_hash'?: string;
    /**
     * 
     * @type {number}
     * @memberof RetrieverResourcesInnerMetadata
     */
    'position'?: number;
}
/**
 * 
 * @export
 * @interface TranslateTextPost200Response
 */
export interface TranslateTextPost200Response {
    /**
     * 
     * @type {string}
     * @memberof TranslateTextPost200Response
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof TranslateTextPost200Response
     */
    'language'?: string;
}
/**
 * 
 * @export
 * @interface TranslateTextPostRequest
 */
export interface TranslateTextPostRequest {
    /**
     * Content that needs translation
     * @type {string}
     * @memberof TranslateTextPostRequest
     */
    'text': string;
    /**
     * Language to translate to
     * @type {string}
     * @memberof TranslateTextPostRequest
     */
    'language': string;
}
/**
 * 
 * @export
 * @interface WebhookLarkGet200Response
 */
export interface WebhookLarkGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof WebhookLarkGet200Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface WebhookNotionPostRequest
 */
export interface WebhookNotionPostRequest {
    /**
     * 
     * @type {WebhookNotionPostRequestData}
     * @memberof WebhookNotionPostRequest
     */
    'data'?: WebhookNotionPostRequestData;
}
/**
 * 
 * @export
 * @interface WebhookNotionPostRequestData
 */
export interface WebhookNotionPostRequestData {
    /**
     * ID of the notion page
     * @type {string}
     * @memberof WebhookNotionPostRequestData
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookNotionPostRequestData
     */
    'properties'?: { [key: string]: any; };
}

/**
 * ChatmaryWebhookApi - axios parameter creator
 * @export
 */
export const ChatmaryWebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lark webhook
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLarkGet: async (code?: string, state?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhookLark`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Notion webhook
         * @param {string} token 
         * @param {WebhookNotionPostRequest} [webhookNotionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookNotionPost: async (token: string, webhookNotionPostRequest?: WebhookNotionPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('webhookNotionPost', 'token', token)
            const localVarPath = `/webhookNotion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookNotionPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatmaryWebhookApi - functional programming interface
 * @export
 */
export const ChatmaryWebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatmaryWebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lark webhook
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookLarkGet(code?: string, state?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookLarkGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookLarkGet(code, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Notion webhook
         * @param {string} token 
         * @param {WebhookNotionPostRequest} [webhookNotionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookNotionPost(token: string, webhookNotionPostRequest?: WebhookNotionPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookLarkGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookNotionPost(token, webhookNotionPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChatmaryWebhookApi - factory interface
 * @export
 */
export const ChatmaryWebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatmaryWebhookApiFp(configuration)
    return {
        /**
         * 
         * @summary Lark webhook
         * @param {ChatmaryWebhookApiWebhookLarkGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLarkGet(requestParameters: ChatmaryWebhookApiWebhookLarkGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<WebhookLarkGet200Response> {
            return localVarFp.webhookLarkGet(requestParameters.code, requestParameters.state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Notion webhook
         * @param {ChatmaryWebhookApiWebhookNotionPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookNotionPost(requestParameters: ChatmaryWebhookApiWebhookNotionPostRequest, options?: AxiosRequestConfig): AxiosPromise<WebhookLarkGet200Response> {
            return localVarFp.webhookNotionPost(requestParameters.token, requestParameters.webhookNotionPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for webhookLarkGet operation in ChatmaryWebhookApi.
 * @export
 * @interface ChatmaryWebhookApiWebhookLarkGetRequest
 */
export interface ChatmaryWebhookApiWebhookLarkGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatmaryWebhookApiWebhookLarkGet
     */
    readonly code?: string

    /**
     * 
     * @type {string}
     * @memberof ChatmaryWebhookApiWebhookLarkGet
     */
    readonly state?: string
}

/**
 * Request parameters for webhookNotionPost operation in ChatmaryWebhookApi.
 * @export
 * @interface ChatmaryWebhookApiWebhookNotionPostRequest
 */
export interface ChatmaryWebhookApiWebhookNotionPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatmaryWebhookApiWebhookNotionPost
     */
    readonly token: string

    /**
     * 
     * @type {WebhookNotionPostRequest}
     * @memberof ChatmaryWebhookApiWebhookNotionPost
     */
    readonly webhookNotionPostRequest?: WebhookNotionPostRequest
}

/**
 * ChatmaryWebhookApi - object-oriented interface
 * @export
 * @class ChatmaryWebhookApi
 * @extends {BaseAPI}
 */
export class ChatmaryWebhookApi extends BaseAPI {
    /**
     * 
     * @summary Lark webhook
     * @param {ChatmaryWebhookApiWebhookLarkGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatmaryWebhookApi
     */
    public webhookLarkGet(requestParameters: ChatmaryWebhookApiWebhookLarkGetRequest = {}, options?: AxiosRequestConfig) {
        return ChatmaryWebhookApiFp(this.configuration).webhookLarkGet(requestParameters.code, requestParameters.state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Notion webhook
     * @param {ChatmaryWebhookApiWebhookNotionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatmaryWebhookApi
     */
    public webhookNotionPost(requestParameters: ChatmaryWebhookApiWebhookNotionPostRequest, options?: AxiosRequestConfig) {
        return ChatmaryWebhookApiFp(this.configuration).webhookNotionPost(requestParameters.token, requestParameters.webhookNotionPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomBotApi - axios parameter creator
 * @export
 */
export const CustomBotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a custom AI bot
         * @param {string} accountId 
         * @param {BotAddPostRequest} [botAddPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botAddPost: async (accountId: string, botAddPostRequest?: BotAddPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('botAddPost', 'accountId', accountId)
            const localVarPath = `/bot/add/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botAddPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all custom bots
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botDelete: async (botId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botDelete', 'botId', botId)
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (botId !== undefined) {
                localVarQueryParameter['botId'] = botId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send a message to a custom bot
         * @param {string} botId 
         * @param {BotMessagePostRequest} [botMessagePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botMessagePost: async (botId: string, botMessagePostRequest?: BotMessagePostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('botMessagePost', 'botId', botId)
            const localVarPath = `/bots/{botId}/message`
                .replace(`{${"botId"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botMessagePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get bot users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botUsersGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/botUsers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete bot user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botUsersPost: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('botUsersPost', 'userId', userId)
            const localVarPath = `/botUsers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all custom bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set chat flow record
         * @param {ChatFlowRecordPostRequest} [chatFlowRecordPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatFlowRecordPost: async (chatFlowRecordPostRequest?: ChatFlowRecordPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chatflow-record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatFlowRecordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete chat flow records
         * @param {string} chatId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatFlowRecordsDelete: async (chatId: string, workflowId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('chatFlowRecordsDelete', 'chatId', chatId)
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('chatFlowRecordsDelete', 'workflowId', workflowId)
            const localVarPath = `/chatflow-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = chatId;
            }

            if (workflowId !== undefined) {
                localVarQueryParameter['workflowId'] = workflowId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get chat flow records
         * @param {string} chatId 
         * @param {string} [botId] 
         * @param {string} [conversationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatFlowRecordsGet: async (chatId: string, botId?: string, conversationId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('chatFlowRecordsGet', 'chatId', chatId)
            const localVarPath = `/chatflow-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (botId !== undefined) {
                localVarQueryParameter['botId'] = botId;
            }

            if (conversationId !== undefined) {
                localVarQueryParameter['conversationId'] = conversationId;
            }

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = chatId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get chat history data
         * @param {string} chatId 
         * @param {string} workflowId 
         * @param {number} [previousConverstationCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatHistoryDataGet: async (chatId: string, workflowId: string, previousConverstationCount?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('chatHistoryDataGet', 'chatId', chatId)
            // verify required parameter 'workflowId' is not null or undefined
            assertParamExists('chatHistoryDataGet', 'workflowId', workflowId)
            const localVarPath = `/chat-history-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (chatId !== undefined) {
                localVarQueryParameter['chatId'] = chatId;
            }

            if (workflowId !== undefined) {
                localVarQueryParameter['workflowId'] = workflowId;
            }

            if (previousConverstationCount !== undefined) {
                localVarQueryParameter['previousConverstationCount'] = previousConverstationCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get conversation ID
         * @param {ConversationIdGetRequest} [conversationIdGetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationIdGet: async (conversationIdGetRequest?: ConversationIdGetRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversationId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conversationIdGetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set conversation ID
         * @param {ConversationIdPostRequest} [conversationIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationIdPost: async (conversationIdPostRequest?: ConversationIdPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversationId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conversationIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user data
         * @param {BotUseCase} botApp 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageUserDataGet: async (botApp: BotUseCase, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botApp' is not null or undefined
            assertParamExists('manageUserDataGet', 'botApp', botApp)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('manageUserDataGet', 'userId', userId)
            const localVarPath = `/manageUserData/{botApp}`
                .replace(`{${"botApp"}}`, encodeURIComponent(String(botApp)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set user data
         * @param {BotUseCase} botApp 
         * @param {string} userId 
         * @param {ManageUserDataPostRequest} [manageUserDataPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageUserDataPost: async (botApp: BotUseCase, userId: string, manageUserDataPostRequest?: ManageUserDataPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botApp' is not null or undefined
            assertParamExists('manageUserDataPost', 'botApp', botApp)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('manageUserDataPost', 'userId', userId)
            const localVarPath = `/manageUserData/{botApp}`
                .replace(`{${"botApp"}}`, encodeURIComponent(String(botApp)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manageUserDataPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomBotApi - functional programming interface
 * @export
 */
export const CustomBotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomBotApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a custom AI bot
         * @param {string} accountId 
         * @param {BotAddPostRequest} [botAddPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botAddPost(accountId: string, botAddPostRequest?: BotAddPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotAddPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botAddPost(accountId, botAddPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete all custom bots
         * @param {string} botId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botDelete(botId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotAddPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botDelete(botId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send a message to a custom bot
         * @param {string} botId 
         * @param {BotMessagePostRequest} [botMessagePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botMessagePost(botId: string, botMessagePostRequest?: BotMessagePostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotMessagePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botMessagePost(botId, botMessagePostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get bot users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botUsersGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotUsersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botUsersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete bot user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botUsersPost(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botUsersPost(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all custom bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async botsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.botsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set chat flow record
         * @param {ChatFlowRecordPostRequest} [chatFlowRecordPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatFlowRecordPost(chatFlowRecordPostRequest?: ChatFlowRecordPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatFlowRecordPost(chatFlowRecordPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete chat flow records
         * @param {string} chatId 
         * @param {string} workflowId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatFlowRecordsDelete(chatId: string, workflowId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatFlowRecordsDelete(chatId, workflowId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get chat flow records
         * @param {string} chatId 
         * @param {string} [botId] 
         * @param {string} [conversationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatFlowRecordsGet(chatId: string, botId?: string, conversationId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChatFlowHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatFlowRecordsGet(chatId, botId, conversationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get chat history data
         * @param {string} chatId 
         * @param {string} workflowId 
         * @param {number} [previousConverstationCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatHistoryDataGet(chatId: string, workflowId: string, previousConverstationCount?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatHistoryDataGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatHistoryDataGet(chatId, workflowId, previousConverstationCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get conversation ID
         * @param {ConversationIdGetRequest} [conversationIdGetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversationIdGet(conversationIdGetRequest?: ConversationIdGetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conversationIdGet(conversationIdGetRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set conversation ID
         * @param {ConversationIdPostRequest} [conversationIdPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversationIdPost(conversationIdPostRequest?: ConversationIdPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conversationIdPost(conversationIdPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user data
         * @param {BotUseCase} botApp 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manageUserDataGet(botApp: BotUseCase, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.manageUserDataGet(botApp, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set user data
         * @param {BotUseCase} botApp 
         * @param {string} userId 
         * @param {ManageUserDataPostRequest} [manageUserDataPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manageUserDataPost(botApp: BotUseCase, userId: string, manageUserDataPostRequest?: ManageUserDataPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.manageUserDataPost(botApp, userId, manageUserDataPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomBotApi - factory interface
 * @export
 */
export const CustomBotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomBotApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a custom AI bot
         * @param {CustomBotApiBotAddPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botAddPost(requestParameters: CustomBotApiBotAddPostRequest, options?: AxiosRequestConfig): AxiosPromise<BotAddPost200Response> {
            return localVarFp.botAddPost(requestParameters.accountId, requestParameters.botAddPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all custom bots
         * @param {CustomBotApiBotDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botDelete(requestParameters: CustomBotApiBotDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<BotAddPost200Response> {
            return localVarFp.botDelete(requestParameters.botId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send a message to a custom bot
         * @param {CustomBotApiBotMessagePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botMessagePost(requestParameters: CustomBotApiBotMessagePostRequest, options?: AxiosRequestConfig): AxiosPromise<BotMessagePost200Response> {
            return localVarFp.botMessagePost(requestParameters.botId, requestParameters.botMessagePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get bot users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botUsersGet(options?: AxiosRequestConfig): AxiosPromise<BotUsersGet200Response> {
            return localVarFp.botUsersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete bot user
         * @param {CustomBotApiBotUsersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botUsersPost(requestParameters: CustomBotApiBotUsersPostRequest, options?: AxiosRequestConfig): AxiosPromise<BotDetails> {
            return localVarFp.botUsersPost(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all custom bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        botsGet(options?: AxiosRequestConfig): AxiosPromise<BotsGet200Response> {
            return localVarFp.botsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set chat flow record
         * @param {CustomBotApiChatFlowRecordPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatFlowRecordPost(requestParameters: CustomBotApiChatFlowRecordPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.chatFlowRecordPost(requestParameters.chatFlowRecordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete chat flow records
         * @param {CustomBotApiChatFlowRecordsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatFlowRecordsDelete(requestParameters: CustomBotApiChatFlowRecordsDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.chatFlowRecordsDelete(requestParameters.chatId, requestParameters.workflowId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get chat flow records
         * @param {CustomBotApiChatFlowRecordsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatFlowRecordsGet(requestParameters: CustomBotApiChatFlowRecordsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ChatFlowHistory>> {
            return localVarFp.chatFlowRecordsGet(requestParameters.chatId, requestParameters.botId, requestParameters.conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get chat history data
         * @param {CustomBotApiChatHistoryDataGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatHistoryDataGet(requestParameters: CustomBotApiChatHistoryDataGetRequest, options?: AxiosRequestConfig): AxiosPromise<ChatHistoryDataGet200Response> {
            return localVarFp.chatHistoryDataGet(requestParameters.chatId, requestParameters.workflowId, requestParameters.previousConverstationCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get conversation ID
         * @param {CustomBotApiConversationIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationIdGet(requestParameters: CustomBotApiConversationIdGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationRecord> {
            return localVarFp.conversationIdGet(requestParameters.conversationIdGetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set conversation ID
         * @param {CustomBotApiConversationIdPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationIdPost(requestParameters: CustomBotApiConversationIdPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ConversationRecord> {
            return localVarFp.conversationIdPost(requestParameters.conversationIdPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user data
         * @param {CustomBotApiManageUserDataGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageUserDataGet(requestParameters: CustomBotApiManageUserDataGetRequest, options?: AxiosRequestConfig): AxiosPromise<BotDetails> {
            return localVarFp.manageUserDataGet(requestParameters.botApp, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set user data
         * @param {CustomBotApiManageUserDataPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageUserDataPost(requestParameters: CustomBotApiManageUserDataPostRequest, options?: AxiosRequestConfig): AxiosPromise<BotDetails> {
            return localVarFp.manageUserDataPost(requestParameters.botApp, requestParameters.userId, requestParameters.manageUserDataPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for botAddPost operation in CustomBotApi.
 * @export
 * @interface CustomBotApiBotAddPostRequest
 */
export interface CustomBotApiBotAddPostRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomBotApiBotAddPost
     */
    readonly accountId: string

    /**
     * 
     * @type {BotAddPostRequest}
     * @memberof CustomBotApiBotAddPost
     */
    readonly botAddPostRequest?: BotAddPostRequest
}

/**
 * Request parameters for botDelete operation in CustomBotApi.
 * @export
 * @interface CustomBotApiBotDeleteRequest
 */
export interface CustomBotApiBotDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomBotApiBotDelete
     */
    readonly botId: string
}

/**
 * Request parameters for botMessagePost operation in CustomBotApi.
 * @export
 * @interface CustomBotApiBotMessagePostRequest
 */
export interface CustomBotApiBotMessagePostRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomBotApiBotMessagePost
     */
    readonly botId: string

    /**
     * 
     * @type {BotMessagePostRequest}
     * @memberof CustomBotApiBotMessagePost
     */
    readonly botMessagePostRequest?: BotMessagePostRequest
}

/**
 * Request parameters for botUsersPost operation in CustomBotApi.
 * @export
 * @interface CustomBotApiBotUsersPostRequest
 */
export interface CustomBotApiBotUsersPostRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomBotApiBotUsersPost
     */
    readonly userId: string
}

/**
 * Request parameters for chatFlowRecordPost operation in CustomBotApi.
 * @export
 * @interface CustomBotApiChatFlowRecordPostRequest
 */
export interface CustomBotApiChatFlowRecordPostRequest {
    /**
     * 
     * @type {ChatFlowRecordPostRequest}
     * @memberof CustomBotApiChatFlowRecordPost
     */
    readonly chatFlowRecordPostRequest?: ChatFlowRecordPostRequest
}

/**
 * Request parameters for chatFlowRecordsDelete operation in CustomBotApi.
 * @export
 * @interface CustomBotApiChatFlowRecordsDeleteRequest
 */
export interface CustomBotApiChatFlowRecordsDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomBotApiChatFlowRecordsDelete
     */
    readonly chatId: string

    /**
     * 
     * @type {string}
     * @memberof CustomBotApiChatFlowRecordsDelete
     */
    readonly workflowId: string
}

/**
 * Request parameters for chatFlowRecordsGet operation in CustomBotApi.
 * @export
 * @interface CustomBotApiChatFlowRecordsGetRequest
 */
export interface CustomBotApiChatFlowRecordsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomBotApiChatFlowRecordsGet
     */
    readonly chatId: string

    /**
     * 
     * @type {string}
     * @memberof CustomBotApiChatFlowRecordsGet
     */
    readonly botId?: string

    /**
     * 
     * @type {string}
     * @memberof CustomBotApiChatFlowRecordsGet
     */
    readonly conversationId?: string
}

/**
 * Request parameters for chatHistoryDataGet operation in CustomBotApi.
 * @export
 * @interface CustomBotApiChatHistoryDataGetRequest
 */
export interface CustomBotApiChatHistoryDataGetRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomBotApiChatHistoryDataGet
     */
    readonly chatId: string

    /**
     * 
     * @type {string}
     * @memberof CustomBotApiChatHistoryDataGet
     */
    readonly workflowId: string

    /**
     * 
     * @type {number}
     * @memberof CustomBotApiChatHistoryDataGet
     */
    readonly previousConverstationCount?: number
}

/**
 * Request parameters for conversationIdGet operation in CustomBotApi.
 * @export
 * @interface CustomBotApiConversationIdGetRequest
 */
export interface CustomBotApiConversationIdGetRequest {
    /**
     * 
     * @type {ConversationIdGetRequest}
     * @memberof CustomBotApiConversationIdGet
     */
    readonly conversationIdGetRequest?: ConversationIdGetRequest
}

/**
 * Request parameters for conversationIdPost operation in CustomBotApi.
 * @export
 * @interface CustomBotApiConversationIdPostRequest
 */
export interface CustomBotApiConversationIdPostRequest {
    /**
     * 
     * @type {ConversationIdPostRequest}
     * @memberof CustomBotApiConversationIdPost
     */
    readonly conversationIdPostRequest?: ConversationIdPostRequest
}

/**
 * Request parameters for manageUserDataGet operation in CustomBotApi.
 * @export
 * @interface CustomBotApiManageUserDataGetRequest
 */
export interface CustomBotApiManageUserDataGetRequest {
    /**
     * 
     * @type {BotUseCase}
     * @memberof CustomBotApiManageUserDataGet
     */
    readonly botApp: BotUseCase

    /**
     * 
     * @type {string}
     * @memberof CustomBotApiManageUserDataGet
     */
    readonly userId: string
}

/**
 * Request parameters for manageUserDataPost operation in CustomBotApi.
 * @export
 * @interface CustomBotApiManageUserDataPostRequest
 */
export interface CustomBotApiManageUserDataPostRequest {
    /**
     * 
     * @type {BotUseCase}
     * @memberof CustomBotApiManageUserDataPost
     */
    readonly botApp: BotUseCase

    /**
     * 
     * @type {string}
     * @memberof CustomBotApiManageUserDataPost
     */
    readonly userId: string

    /**
     * 
     * @type {ManageUserDataPostRequest}
     * @memberof CustomBotApiManageUserDataPost
     */
    readonly manageUserDataPostRequest?: ManageUserDataPostRequest
}

/**
 * CustomBotApi - object-oriented interface
 * @export
 * @class CustomBotApi
 * @extends {BaseAPI}
 */
export class CustomBotApi extends BaseAPI {
    /**
     * 
     * @summary Add a custom AI bot
     * @param {CustomBotApiBotAddPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomBotApi
     */
    public botAddPost(requestParameters: CustomBotApiBotAddPostRequest, options?: AxiosRequestConfig) {
        return CustomBotApiFp(this.configuration).botAddPost(requestParameters.accountId, requestParameters.botAddPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all custom bots
     * @param {CustomBotApiBotDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomBotApi
     */
    public botDelete(requestParameters: CustomBotApiBotDeleteRequest, options?: AxiosRequestConfig) {
        return CustomBotApiFp(this.configuration).botDelete(requestParameters.botId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send a message to a custom bot
     * @param {CustomBotApiBotMessagePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomBotApi
     */
    public botMessagePost(requestParameters: CustomBotApiBotMessagePostRequest, options?: AxiosRequestConfig) {
        return CustomBotApiFp(this.configuration).botMessagePost(requestParameters.botId, requestParameters.botMessagePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get bot users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomBotApi
     */
    public botUsersGet(options?: AxiosRequestConfig) {
        return CustomBotApiFp(this.configuration).botUsersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete bot user
     * @param {CustomBotApiBotUsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomBotApi
     */
    public botUsersPost(requestParameters: CustomBotApiBotUsersPostRequest, options?: AxiosRequestConfig) {
        return CustomBotApiFp(this.configuration).botUsersPost(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all custom bots
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomBotApi
     */
    public botsGet(options?: AxiosRequestConfig) {
        return CustomBotApiFp(this.configuration).botsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set chat flow record
     * @param {CustomBotApiChatFlowRecordPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomBotApi
     */
    public chatFlowRecordPost(requestParameters: CustomBotApiChatFlowRecordPostRequest = {}, options?: AxiosRequestConfig) {
        return CustomBotApiFp(this.configuration).chatFlowRecordPost(requestParameters.chatFlowRecordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete chat flow records
     * @param {CustomBotApiChatFlowRecordsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomBotApi
     */
    public chatFlowRecordsDelete(requestParameters: CustomBotApiChatFlowRecordsDeleteRequest, options?: AxiosRequestConfig) {
        return CustomBotApiFp(this.configuration).chatFlowRecordsDelete(requestParameters.chatId, requestParameters.workflowId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get chat flow records
     * @param {CustomBotApiChatFlowRecordsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomBotApi
     */
    public chatFlowRecordsGet(requestParameters: CustomBotApiChatFlowRecordsGetRequest, options?: AxiosRequestConfig) {
        return CustomBotApiFp(this.configuration).chatFlowRecordsGet(requestParameters.chatId, requestParameters.botId, requestParameters.conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get chat history data
     * @param {CustomBotApiChatHistoryDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomBotApi
     */
    public chatHistoryDataGet(requestParameters: CustomBotApiChatHistoryDataGetRequest, options?: AxiosRequestConfig) {
        return CustomBotApiFp(this.configuration).chatHistoryDataGet(requestParameters.chatId, requestParameters.workflowId, requestParameters.previousConverstationCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get conversation ID
     * @param {CustomBotApiConversationIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomBotApi
     */
    public conversationIdGet(requestParameters: CustomBotApiConversationIdGetRequest = {}, options?: AxiosRequestConfig) {
        return CustomBotApiFp(this.configuration).conversationIdGet(requestParameters.conversationIdGetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set conversation ID
     * @param {CustomBotApiConversationIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomBotApi
     */
    public conversationIdPost(requestParameters: CustomBotApiConversationIdPostRequest = {}, options?: AxiosRequestConfig) {
        return CustomBotApiFp(this.configuration).conversationIdPost(requestParameters.conversationIdPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user data
     * @param {CustomBotApiManageUserDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomBotApi
     */
    public manageUserDataGet(requestParameters: CustomBotApiManageUserDataGetRequest, options?: AxiosRequestConfig) {
        return CustomBotApiFp(this.configuration).manageUserDataGet(requestParameters.botApp, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set user data
     * @param {CustomBotApiManageUserDataPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomBotApi
     */
    public manageUserDataPost(requestParameters: CustomBotApiManageUserDataPostRequest, options?: AxiosRequestConfig) {
        return CustomBotApiFp(this.configuration).manageUserDataPost(requestParameters.botApp, requestParameters.userId, requestParameters.manageUserDataPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GenkitApi - axios parameter creator
 * @export
 */
export const GenkitApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generate flow with Genkit
         * @param {GenerateFlowWithGenkitPostRequest} [generateFlowWithGenkitPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateFlowWithGenkitPost: async (generateFlowWithGenkitPostRequest?: GenerateFlowWithGenkitPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/generateFlowWithGenkit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateFlowWithGenkitPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GenkitApi - functional programming interface
 * @export
 */
export const GenkitApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GenkitApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generate flow with Genkit
         * @param {GenerateFlowWithGenkitPostRequest} [generateFlowWithGenkitPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateFlowWithGenkitPost(generateFlowWithGenkitPostRequest?: GenerateFlowWithGenkitPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateFlowWithGenkitPost(generateFlowWithGenkitPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GenkitApi - factory interface
 * @export
 */
export const GenkitApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GenkitApiFp(configuration)
    return {
        /**
         * 
         * @summary Generate flow with Genkit
         * @param {GenkitApiGenerateFlowWithGenkitPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateFlowWithGenkitPost(requestParameters: GenkitApiGenerateFlowWithGenkitPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.generateFlowWithGenkitPost(requestParameters.generateFlowWithGenkitPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for generateFlowWithGenkitPost operation in GenkitApi.
 * @export
 * @interface GenkitApiGenerateFlowWithGenkitPostRequest
 */
export interface GenkitApiGenerateFlowWithGenkitPostRequest {
    /**
     * 
     * @type {GenerateFlowWithGenkitPostRequest}
     * @memberof GenkitApiGenerateFlowWithGenkitPost
     */
    readonly generateFlowWithGenkitPostRequest?: GenerateFlowWithGenkitPostRequest
}

/**
 * GenkitApi - object-oriented interface
 * @export
 * @class GenkitApi
 * @extends {BaseAPI}
 */
export class GenkitApi extends BaseAPI {
    /**
     * 
     * @summary Generate flow with Genkit
     * @param {GenkitApiGenerateFlowWithGenkitPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenkitApi
     */
    public generateFlowWithGenkitPost(requestParameters: GenkitApiGenerateFlowWithGenkitPostRequest = {}, options?: AxiosRequestConfig) {
        return GenkitApiFp(this.configuration).generateFlowWithGenkitPost(requestParameters.generateFlowWithGenkitPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * KnowledgeBaseApi - axios parameter creator
 * @export
 */
export const KnowledgeBaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete knowledge base
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('knowledgeBaseDelete', 'id', id)
            const localVarPath = `/knowledgeBase`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get knowledge base
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseGet: async (id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/knowledgeBase`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add knowledge base
         * @param {string} [id] 
         * @param {KnowledgeBasePostRequest} [knowledgeBasePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBasePost: async (id?: string, knowledgeBasePostRequest?: KnowledgeBasePostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/knowledgeBase`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(knowledgeBasePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KnowledgeBaseApi - functional programming interface
 * @export
 */
export const KnowledgeBaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KnowledgeBaseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete knowledge base
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgeBaseDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotAddPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgeBaseDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get knowledge base
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgeBaseGet(id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KnowledgeBaseGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgeBaseGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add knowledge base
         * @param {string} [id] 
         * @param {KnowledgeBasePostRequest} [knowledgeBasePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async knowledgeBasePost(id?: string, knowledgeBasePostRequest?: KnowledgeBasePostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotAddPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.knowledgeBasePost(id, knowledgeBasePostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * KnowledgeBaseApi - factory interface
 * @export
 */
export const KnowledgeBaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KnowledgeBaseApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete knowledge base
         * @param {KnowledgeBaseApiKnowledgeBaseDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseDelete(requestParameters: KnowledgeBaseApiKnowledgeBaseDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<BotAddPost200Response> {
            return localVarFp.knowledgeBaseDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get knowledge base
         * @param {KnowledgeBaseApiKnowledgeBaseGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBaseGet(requestParameters: KnowledgeBaseApiKnowledgeBaseGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<KnowledgeBaseGet200Response> {
            return localVarFp.knowledgeBaseGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add knowledge base
         * @param {KnowledgeBaseApiKnowledgeBasePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        knowledgeBasePost(requestParameters: KnowledgeBaseApiKnowledgeBasePostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<BotAddPost200Response> {
            return localVarFp.knowledgeBasePost(requestParameters.id, requestParameters.knowledgeBasePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for knowledgeBaseDelete operation in KnowledgeBaseApi.
 * @export
 * @interface KnowledgeBaseApiKnowledgeBaseDeleteRequest
 */
export interface KnowledgeBaseApiKnowledgeBaseDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseApiKnowledgeBaseDelete
     */
    readonly id: string
}

/**
 * Request parameters for knowledgeBaseGet operation in KnowledgeBaseApi.
 * @export
 * @interface KnowledgeBaseApiKnowledgeBaseGetRequest
 */
export interface KnowledgeBaseApiKnowledgeBaseGetRequest {
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseApiKnowledgeBaseGet
     */
    readonly id?: string
}

/**
 * Request parameters for knowledgeBasePost operation in KnowledgeBaseApi.
 * @export
 * @interface KnowledgeBaseApiKnowledgeBasePostRequest
 */
export interface KnowledgeBaseApiKnowledgeBasePostRequest {
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseApiKnowledgeBasePost
     */
    readonly id?: string

    /**
     * 
     * @type {KnowledgeBasePostRequest}
     * @memberof KnowledgeBaseApiKnowledgeBasePost
     */
    readonly knowledgeBasePostRequest?: KnowledgeBasePostRequest
}

/**
 * KnowledgeBaseApi - object-oriented interface
 * @export
 * @class KnowledgeBaseApi
 * @extends {BaseAPI}
 */
export class KnowledgeBaseApi extends BaseAPI {
    /**
     * 
     * @summary Delete knowledge base
     * @param {KnowledgeBaseApiKnowledgeBaseDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseApi
     */
    public knowledgeBaseDelete(requestParameters: KnowledgeBaseApiKnowledgeBaseDeleteRequest, options?: AxiosRequestConfig) {
        return KnowledgeBaseApiFp(this.configuration).knowledgeBaseDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get knowledge base
     * @param {KnowledgeBaseApiKnowledgeBaseGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseApi
     */
    public knowledgeBaseGet(requestParameters: KnowledgeBaseApiKnowledgeBaseGetRequest = {}, options?: AxiosRequestConfig) {
        return KnowledgeBaseApiFp(this.configuration).knowledgeBaseGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add knowledge base
     * @param {KnowledgeBaseApiKnowledgeBasePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseApi
     */
    public knowledgeBasePost(requestParameters: KnowledgeBaseApiKnowledgeBasePostRequest = {}, options?: AxiosRequestConfig) {
        return KnowledgeBaseApiFp(this.configuration).knowledgeBasePost(requestParameters.id, requestParameters.knowledgeBasePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LocaleBotApi - axios parameter creator
 * @export
 */
export const LocaleBotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get translation for text to language
         * @param {TranslateTextPostRequest} [translateTextPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateTextPost: async (translateTextPostRequest?: TranslateTextPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/translateText`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(translateTextPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocaleBotApi - functional programming interface
 * @export
 */
export const LocaleBotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocaleBotApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get translation for text to language
         * @param {TranslateTextPostRequest} [translateTextPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translateTextPost(translateTextPostRequest?: TranslateTextPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranslateTextPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translateTextPost(translateTextPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LocaleBotApi - factory interface
 * @export
 */
export const LocaleBotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocaleBotApiFp(configuration)
    return {
        /**
         * 
         * @summary Get translation for text to language
         * @param {LocaleBotApiTranslateTextPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateTextPost(requestParameters: LocaleBotApiTranslateTextPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<TranslateTextPost200Response> {
            return localVarFp.translateTextPost(requestParameters.translateTextPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for translateTextPost operation in LocaleBotApi.
 * @export
 * @interface LocaleBotApiTranslateTextPostRequest
 */
export interface LocaleBotApiTranslateTextPostRequest {
    /**
     * 
     * @type {TranslateTextPostRequest}
     * @memberof LocaleBotApiTranslateTextPost
     */
    readonly translateTextPostRequest?: TranslateTextPostRequest
}

/**
 * LocaleBotApi - object-oriented interface
 * @export
 * @class LocaleBotApi
 * @extends {BaseAPI}
 */
export class LocaleBotApi extends BaseAPI {
    /**
     * 
     * @summary Get translation for text to language
     * @param {LocaleBotApiTranslateTextPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocaleBotApi
     */
    public translateTextPost(requestParameters: LocaleBotApiTranslateTextPostRequest = {}, options?: AxiosRequestConfig) {
        return LocaleBotApiFp(this.configuration).translateTextPost(requestParameters.translateTextPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScheduleApi - axios parameter creator
 * @export
 */
export const ScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Extract calendar event information from message
         * @param {AutocompleteCalendarEventRequest} [autocompleteCalendarEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteCalendarEvent: async (autocompleteCalendarEventRequest?: AutocompleteCalendarEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/autocomplete/calendar-event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autocompleteCalendarEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary OAuth callback
         * @param {string} code 
         * @param {string} state 
         * @param {string} [scope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthCallback: async (code: string, state: string, scope?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('oauthCallback', 'code', code)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('oauthCallback', 'state', state)
            const localVarPath = `/oauth/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduleApi - functional programming interface
 * @export
 */
export const ScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Extract calendar event information from message
         * @param {AutocompleteCalendarEventRequest} [autocompleteCalendarEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompleteCalendarEvent(autocompleteCalendarEventRequest?: AutocompleteCalendarEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CalendarEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompleteCalendarEvent(autocompleteCalendarEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary OAuth callback
         * @param {string} code 
         * @param {string} state 
         * @param {string} [scope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthCallback(code: string, state: string, scope?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OauthCallback200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthCallback(code, state, scope, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScheduleApi - factory interface
 * @export
 */
export const ScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduleApiFp(configuration)
    return {
        /**
         * 
         * @summary Extract calendar event information from message
         * @param {ScheduleApiAutocompleteCalendarEventRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteCalendarEvent(requestParameters: ScheduleApiAutocompleteCalendarEventRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CalendarEvent> {
            return localVarFp.autocompleteCalendarEvent(requestParameters.autocompleteCalendarEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary OAuth callback
         * @param {ScheduleApiOauthCallbackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthCallback(requestParameters: ScheduleApiOauthCallbackRequest, options?: AxiosRequestConfig): AxiosPromise<OauthCallback200Response> {
            return localVarFp.oauthCallback(requestParameters.code, requestParameters.state, requestParameters.scope, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for autocompleteCalendarEvent operation in ScheduleApi.
 * @export
 * @interface ScheduleApiAutocompleteCalendarEventRequest
 */
export interface ScheduleApiAutocompleteCalendarEventRequest {
    /**
     * 
     * @type {AutocompleteCalendarEventRequest}
     * @memberof ScheduleApiAutocompleteCalendarEvent
     */
    readonly autocompleteCalendarEventRequest?: AutocompleteCalendarEventRequest
}

/**
 * Request parameters for oauthCallback operation in ScheduleApi.
 * @export
 * @interface ScheduleApiOauthCallbackRequest
 */
export interface ScheduleApiOauthCallbackRequest {
    /**
     * 
     * @type {string}
     * @memberof ScheduleApiOauthCallback
     */
    readonly code: string

    /**
     * 
     * @type {string}
     * @memberof ScheduleApiOauthCallback
     */
    readonly state: string

    /**
     * 
     * @type {string}
     * @memberof ScheduleApiOauthCallback
     */
    readonly scope?: string
}

/**
 * ScheduleApi - object-oriented interface
 * @export
 * @class ScheduleApi
 * @extends {BaseAPI}
 */
export class ScheduleApi extends BaseAPI {
    /**
     * 
     * @summary Extract calendar event information from message
     * @param {ScheduleApiAutocompleteCalendarEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public autocompleteCalendarEvent(requestParameters: ScheduleApiAutocompleteCalendarEventRequest = {}, options?: AxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).autocompleteCalendarEvent(requestParameters.autocompleteCalendarEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary OAuth callback
     * @param {ScheduleApiOauthCallbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public oauthCallback(requestParameters: ScheduleApiOauthCallbackRequest, options?: AxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).oauthCallback(requestParameters.code, requestParameters.state, requestParameters.scope, options).then((request) => request(this.axios, this.basePath));
    }
}


