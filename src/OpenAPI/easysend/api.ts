const BASE_PATH = "https://api.chatdaddy.tech/notifications".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Shop Service
 * Responsible for all shop related APIs. Formerly known as \"notifications\" or \"easysend\" service 
 *
 * The version of the OpenAPI document: 2.1.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @interface AddServiceModel
 */
export interface AddServiceModel {
    /**
     * Name of the service/scrapper
     * @type {string}
     * @memberof AddServiceModel
     */
    'name': string;
    /**
     * A service that implements only the schema route
     * @type {boolean}
     * @memberof AddServiceModel
     */
    'isEphemeral'?: boolean;
    /**
     * If true, then parameters wont be checked when editing a trigger
     * @type {boolean}
     * @memberof AddServiceModel
     */
    'skipParameterValidation'?: boolean;
    /**
     * any image/link representing the service/scrapper
     * @type {string}
     * @memberof AddServiceModel
     */
    'imgUrl': string;
    /**
     * Description of the service/scrapper
     * @type {string}
     * @memberof AddServiceModel
     */
    'description': string;
    /**
     * Whether the service supports the products API
     * @type {boolean}
     * @memberof AddServiceModel
     */
    'supportsProducts'?: boolean;
    /**
     * If true, then it will allow additional parameters for condition
     * @type {boolean}
     * @memberof AddServiceModel
     */
    'allowAdditionalParamsForCondition'?: boolean;
    /**
     * 
     * @type {{ [key: string]: AddServiceModelParametersValue; }}
     * @memberof AddServiceModel
     */
    'parameters': { [key: string]: AddServiceModelParametersValue; };
    /**
     * 
     * @type {{ [key: string]: AddServiceModelSetupValue; }}
     * @memberof AddServiceModel
     */
    'setup': { [key: string]: AddServiceModelSetupValue; };
    /**
     * 
     * @type {AddServiceModelOutput}
     * @memberof AddServiceModel
     */
    'output'?: AddServiceModelOutput;
}
/**
 * 
 * @export
 * @interface AddServiceModelOutput
 */
export interface AddServiceModelOutput {
    /**
     * URL to send webhooks to
     * @type {string}
     * @memberof AddServiceModelOutput
     */
    'webhookUrl'?: string;
}
/**
 * @type AddServiceModelParametersValue
 * @export
 */
export type AddServiceModelParametersValue = AddServiceModelParametersValueOneOf | AddServiceModelParametersValueOneOf1 | AddServiceModelParametersValueOneOf2 | AddServiceModelParametersValueOneOf3;

/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf
 */
export interface AddServiceModelParametersValueOneOf {
    /**
     * 
     * @type {AddServiceModelParametersValueOneOfCanBeConditionedOn}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'canBeConditionedOn'?: AddServiceModelParametersValueOneOfCanBeConditionedOn;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'type'?: AddServiceModelParametersValueOneOfTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'format'?: AddServiceModelParametersValueOneOfFormatEnum;
    /**
     * Inclusive array of possible values this property can take
     * @type {Array<string>}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'enum'?: Array<string>;
    /**
     * Non-inclusive array of possible values this property can take
     * @type {Array<string>}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'examples'?: Array<string>;
}

export const AddServiceModelParametersValueOneOfTypeEnum = {
    String: 'string'
} as const;

export type AddServiceModelParametersValueOneOfTypeEnum = typeof AddServiceModelParametersValueOneOfTypeEnum[keyof typeof AddServiceModelParametersValueOneOfTypeEnum];
export const AddServiceModelParametersValueOneOfFormatEnum = {
    DateTime: 'date-time',
    Date: 'date'
} as const;

export type AddServiceModelParametersValueOneOfFormatEnum = typeof AddServiceModelParametersValueOneOfFormatEnum[keyof typeof AddServiceModelParametersValueOneOfFormatEnum];

/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf1
 */
export interface AddServiceModelParametersValueOneOf1 {
    /**
     * 
     * @type {AddServiceModelParametersValueOneOfCanBeConditionedOn}
     * @memberof AddServiceModelParametersValueOneOf1
     */
    'canBeConditionedOn'?: AddServiceModelParametersValueOneOfCanBeConditionedOn;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf1
     */
    'type': AddServiceModelParametersValueOneOf1TypeEnum;
    /**
     * Inclusive array of possible values this property can take
     * @type {Array<number>}
     * @memberof AddServiceModelParametersValueOneOf1
     */
    'enum'?: Array<number>;
    /**
     * Non-inclusive array of possible values this property can take
     * @type {Array<number>}
     * @memberof AddServiceModelParametersValueOneOf1
     */
    'examples'?: Array<number>;
}

export const AddServiceModelParametersValueOneOf1TypeEnum = {
    Number: 'number'
} as const;

export type AddServiceModelParametersValueOneOf1TypeEnum = typeof AddServiceModelParametersValueOneOf1TypeEnum[keyof typeof AddServiceModelParametersValueOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf2
 */
export interface AddServiceModelParametersValueOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf2
     */
    'type': AddServiceModelParametersValueOneOf2TypeEnum;
    /**
     * 
     * @type {AddServiceModelParametersValueOneOf2Items}
     * @memberof AddServiceModelParametersValueOneOf2
     */
    'items'?: AddServiceModelParametersValueOneOf2Items;
    /**
     * Non-inclusive array of possible values this property can take
     * @type {Array<Array<any>>}
     * @memberof AddServiceModelParametersValueOneOf2
     */
    'examples'?: Array<Array<any>>;
}

export const AddServiceModelParametersValueOneOf2TypeEnum = {
    Array: 'array'
} as const;

export type AddServiceModelParametersValueOneOf2TypeEnum = typeof AddServiceModelParametersValueOneOf2TypeEnum[keyof typeof AddServiceModelParametersValueOneOf2TypeEnum];

/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf2Items
 */
export interface AddServiceModelParametersValueOneOf2Items {
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf2Items
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf3
 */
export interface AddServiceModelParametersValueOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf3
     */
    'type': AddServiceModelParametersValueOneOf3TypeEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AddServiceModelParametersValueOneOf3
     */
    'properties'?: { [key: string]: any; };
    /**
     * Non-inclusive array of possible values this property can take
     * @type {Array<{ [key: string]: any; }>}
     * @memberof AddServiceModelParametersValueOneOf3
     */
    'examples'?: Array<{ [key: string]: any; }>;
}

export const AddServiceModelParametersValueOneOf3TypeEnum = {
    Object: 'object'
} as const;

export type AddServiceModelParametersValueOneOf3TypeEnum = typeof AddServiceModelParametersValueOneOf3TypeEnum[keyof typeof AddServiceModelParametersValueOneOf3TypeEnum];

/**
 * @type AddServiceModelParametersValueOneOfCanBeConditionedOn
 * If this parameter can have conditions. If it is an object, it is forced to be false
 * @export
 */
export type AddServiceModelParametersValueOneOfCanBeConditionedOn = boolean | string;

/**
 * 
 * @export
 * @interface AddServiceModelSetupValue
 */
export interface AddServiceModelSetupValue {
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelSetupValue
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelSetupValue
     */
    'description'?: string;
    /**
     * 
     * @type {AddServiceModelSetupValueRequired}
     * @memberof AddServiceModelSetupValue
     */
    'required'?: AddServiceModelSetupValueRequired;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelSetupValue
     */
    'type': AddServiceModelSetupValueTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof AddServiceModelSetupValue
     */
    'enum'?: Array<string>;
    /**
     * the url used for oauth login
     * @type {string}
     * @memberof AddServiceModelSetupValue
     */
    'url'?: string;
}

export const AddServiceModelSetupValueTypeEnum = {
    String: 'string',
    Oauth: 'oauth',
    Password: 'password'
} as const;

export type AddServiceModelSetupValueTypeEnum = typeof AddServiceModelSetupValueTypeEnum[keyof typeof AddServiceModelSetupValueTypeEnum];

/**
 * @type AddServiceModelSetupValueRequired
 * @export
 */
export type AddServiceModelSetupValueRequired = boolean | string;

/**
 * 
 * @export
 * @interface AdminDataGet200ResponseInner
 */
export interface AdminDataGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof AdminDataGet200ResponseInner
     */
    'accountId': string;
    /**
     * 
     * @type {number}
     * @memberof AdminDataGet200ResponseInner
     */
    'notificationCount': number;
}
/**
 * 
 * @export
 * @interface AdminPaymentSystemPost200Response
 */
export interface AdminPaymentSystemPost200Response {
    /**
     * 
     * @type {PaymentSystem}
     * @memberof AdminPaymentSystemPost200Response
     */
    'integration': PaymentSystem;
}
/**
 * 
 * @export
 * @interface CreatePaymentIntegrationRequest
 */
export interface CreatePaymentIntegrationRequest {
    /**
     * payment integration system used
     * @type {string}
     * @memberof CreatePaymentIntegrationRequest
     */
    'paymentSystemId': string;
    /**
     * 
     * @type {PaymentIntegrationAuthRequest}
     * @memberof CreatePaymentIntegrationRequest
     */
    'auth'?: PaymentIntegrationAuthRequest;
    /**
     * 
     * @type {DataType}
     * @memberof CreatePaymentIntegrationRequest
     */
    'dataType'?: DataType;
}
/**
 * 
 * @export
 * @interface DataGet200Response
 */
export interface DataGet200Response {
    /**
     * 
     * @type {Array<EasysendDataModel>}
     * @memberof DataGet200Response
     */
    'data': Array<EasysendDataModel>;
    /**
     * 
     * @type {number}
     * @memberof DataGet200Response
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof DataGet200Response
     */
    'nextPageCursor'?: string | null;
}
/**
 * @type DataPatchRequest
 * @export
 */
export type DataPatchRequest = DataPatchRequestOneOf | UpdateOrderModel;

/**
 * 
 * @export
 * @interface DataPatchRequestOneOf
 */
export interface DataPatchRequestOneOf {
    /**
     * 
     * @type {Array<UpdateOrderModel>}
     * @memberof DataPatchRequestOneOf
     */
    'orders': Array<UpdateOrderModel>;
}
/**
 * 
 * @export
 * @interface DataResend200Response
 */
export interface DataResend200Response {
    /**
     * 
     * @type {EasysendDataModel}
     * @memberof DataResend200Response
     */
    'data': EasysendDataModel;
}
/**
 * 
 * @export
 * @interface DataType
 */
interface DataType {
    /**
     * 
     * @type {string}
     * @memberof DataType
     */
    'qrCodeUrl'?: string;
}
/**
 * The type of delay \"stale\" means that the message is sent out with the aforementioned delay (delayS) if the order is not updated. If the order is updated before the delay is over, then the message is cancelled \"simple\" means that the message is sent out regardless of the order update. 
 * @export
 * @enum {string}
 */

export const DelayTypeModel = {
    Simple: 'simple',
    Stale: 'stale'
} as const;

export type DelayTypeModel = typeof DelayTypeModel[keyof typeof DelayTypeModel];


/**
 * - A data point created via the \"dataPatch\" operation - this signifies a change in an order, or the creation of a new order 
 * @export
 * @interface EasysendDataModel
 */
export interface EasysendDataModel {
    /**
     * Unique identifier for the data point
     * @type {number}
     * @memberof EasysendDataModel
     */
    'id': number;
    /**
     * Unique identifier for the order, provided by the \"tracking\" its from
     * @type {string}
     * @memberof EasysendDataModel
     */
    'orderId': string;
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof EasysendDataModel
     */
    'accountId'?: string | null;
    /**
     * 
     * @type {NullablePhoneNumber}
     * @memberof EasysendDataModel
     */
    'phoneNumber': NullablePhoneNumber;
    /**
     * The recipientId to use when phone number is not applicable. Including this will override phone number
     * @type {string}
     * @memberof EasysendDataModel
     */
    'recipientId'?: string;
    /**
     * 
     * @type {EasysendDataModelWaResponse}
     * @memberof EasysendDataModel
     */
    'waResponse': EasysendDataModelWaResponse;
    /**
     * The trigger that captured this data point for message sending. If null, it means that no trigger captured this data point
     * @type {number}
     * @memberof EasysendDataModel
     */
    'triggerId': number | null;
    /**
     * The tracking that captured this data point for message sending
     * @type {number}
     * @memberof EasysendDataModel
     */
    'trackingId'?: number;
    /**
     * The status of the data point. - \"sent\" => data point has been sent to the bot service, either successfully or not - \"pending\" => data point is waiting to be sent to the bot service. If - \"cancelled\" => data point has been cancelled, and will not be sent to the bot service. this could be because no trigger was found, or the trigger was disabled
     * @type {string}
     * @memberof EasysendDataModel
     */
    'status': EasysendDataModelStatusEnum;
    /**
     * Whether this data point is a test data point or not. Test data points are created by the \"triggerTest\" operation
     * @type {boolean}
     * @memberof EasysendDataModel
     */
    'isTest': boolean;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof EasysendDataModel
     */
    'datetime': string;
    /**
     * The params that were sent by the integration when the data point was created
     * @type {{ [key: string]: any; }}
     * @memberof EasysendDataModel
     */
    'params': { [key: string]: any; };
}

export const EasysendDataModelStatusEnum = {
    Sent: 'sent',
    Pending: 'pending',
    Cancelled: 'cancelled'
} as const;

export type EasysendDataModelStatusEnum = typeof EasysendDataModelStatusEnum[keyof typeof EasysendDataModelStatusEnum];

/**
 * the response received from the bots service. \"waResponse\" is a bit of a misnomer now, but it\'s a legacy name as we used to only support data from WhatsApp 
 * @export
 * @interface EasysendDataModelWaResponse
 */
export interface EasysendDataModelWaResponse {
    /**
     * the response code
     * @type {number}
     * @memberof EasysendDataModelWaResponse
     */
    'code'?: number;
    /**
     * the body received
     * @type {object}
     * @memberof EasysendDataModelWaResponse
     */
    'body'?: object;
}
/**
 * 
 * @export
 * @interface ErrorState
 */
export interface ErrorState {
    /**
     * 
     * @type {number}
     * @memberof ErrorState
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof ErrorState
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface EventTrigger
 */
export interface EventTrigger {
    /**
     * 
     * @type {number}
     * @memberof EventTrigger
     */
    'id'?: number;
    /**
     * Passed in the body to mark for deletion
     * @type {boolean}
     * @memberof EventTrigger
     */
    'delete'?: boolean;
    /**
     * the message template to send when this trigger is activated
     * @type {string}
     * @memberof EventTrigger
     */
    'templateId'?: string;
    /**
     * Whether the condition is enabled. If false, the trigger will be ignored whenever a data point is ingested
     * @type {boolean}
     * @memberof EventTrigger
     */
    'enabled'?: boolean;
    /**
     * Maximum notifications to be sent per order on this trigger. Default null -- unlimited
     * @type {number}
     * @memberof EventTrigger
     */
    'limit'?: number | null;
    /**
     * 
     * @type {EventTriggerCreateDelay}
     * @memberof EventTrigger
     */
    'delay'?: EventTriggerCreateDelay;
    /**
     * 
     * @type {ScheduleOptions}
     * @memberof EventTrigger
     */
    'scheduleOptions'?: ScheduleOptions | null;
    /**
     * an array of usersIds to notify users when an event is created
     * @type {Array<string>}
     * @memberof EventTrigger
     */
    'notifyUsers'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: EventTriggerCondition; }}
     * @memberof EventTrigger
     */
    'conditions'?: { [key: string]: EventTriggerCondition; };
}
/**
 * 
 * @export
 * @interface EventTriggerAllOf
 */
export interface EventTriggerAllOf {
    /**
     * 
     * @type {number}
     * @memberof EventTriggerAllOf
     */
    'id'?: number;
    /**
     * Passed in the body to mark for deletion
     * @type {boolean}
     * @memberof EventTriggerAllOf
     */
    'delete'?: boolean;
}
/**
 * 
 * @export
 * @interface EventTriggerCondition
 */
export interface EventTriggerCondition {
    /**
     * 
     * @type {EventTriggerConditionValues}
     * @memberof EventTriggerCondition
     */
    'values': EventTriggerConditionValues;
    /**
     * the test for the condition. Default is `include`
     * @type {string}
     * @memberof EventTriggerCondition
     */
    'test'?: EventTriggerConditionTestEnum;
}

export const EventTriggerConditionTestEnum = {
    Include: 'include',
    Exclude: 'exclude',
    GreaterThan: 'greater-than',
    LessThan: 'less-than'
} as const;

export type EventTriggerConditionTestEnum = typeof EventTriggerConditionTestEnum[keyof typeof EventTriggerConditionTestEnum];

/**
 * @type EventTriggerConditionValues
 * @export
 */
export type EventTriggerConditionValues = Array<number> | Array<string>;

/**
 * 
 * @export
 * @interface EventTriggerCreate
 */
export interface EventTriggerCreate {
    /**
     * the message template to send when this trigger is activated
     * @type {string}
     * @memberof EventTriggerCreate
     */
    'templateId'?: string;
    /**
     * Whether the condition is enabled. If false, the trigger will be ignored whenever a data point is ingested
     * @type {boolean}
     * @memberof EventTriggerCreate
     */
    'enabled'?: boolean;
    /**
     * Maximum notifications to be sent per order on this trigger. Default null -- unlimited
     * @type {number}
     * @memberof EventTriggerCreate
     */
    'limit'?: number | null;
    /**
     * 
     * @type {EventTriggerCreateDelay}
     * @memberof EventTriggerCreate
     */
    'delay'?: EventTriggerCreateDelay;
    /**
     * 
     * @type {ScheduleOptions}
     * @memberof EventTriggerCreate
     */
    'scheduleOptions'?: ScheduleOptions | null;
    /**
     * an array of usersIds to notify users when an event is created
     * @type {Array<string>}
     * @memberof EventTriggerCreate
     */
    'notifyUsers'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: EventTriggerCondition; }}
     * @memberof EventTriggerCreate
     */
    'conditions'?: { [key: string]: EventTriggerCondition; };
}
/**
 * the optional delay to attach to this service
 * @export
 * @interface EventTriggerCreateDelay
 */
export interface EventTriggerCreateDelay {
    /**
     * the delay in sending the message
     * @type {number}
     * @memberof EventTriggerCreateDelay
     */
    'seconds'?: number;
    /**
     * 
     * @type {DelayTypeModel}
     * @memberof EventTriggerCreateDelay
     */
    'type'?: DelayTypeModel;
}


/**
 * 
 * @export
 * @interface GetPaymentIntegrations200Response
 */
export interface GetPaymentIntegrations200Response {
    /**
     * 
     * @type {Array<PaymentIntegration>}
     * @memberof GetPaymentIntegrations200Response
     */
    'integrations': Array<PaymentIntegration>;
}
/**
 * @type NullablePhoneNumber
 * Phone number to be sent to
 * @export
 */
export type NullablePhoneNumber = number | object | string;

/**
 * Authentication details for the payment system to create a payment integration
 * @export
 * @interface OAuth2AuthRequest
 */
export interface OAuth2AuthRequest {
    /**
     * 
     * @type {string}
     * @memberof OAuth2AuthRequest
     */
    'type': OAuth2AuthRequestTypeEnum;
    /**
     * OAuth2 authorization code
     * @type {string}
     * @memberof OAuth2AuthRequest
     */
    'authorizationCode': string;
}

export const OAuth2AuthRequestTypeEnum = {
    Oauth: 'oauth'
} as const;

export type OAuth2AuthRequestTypeEnum = typeof OAuth2AuthRequestTypeEnum[keyof typeof OAuth2AuthRequestTypeEnum];

/**
 * 
 * @export
 * @interface OrderDataGet200Response
 */
export interface OrderDataGet200Response {
    /**
     * 
     * @type {Array<OrderDataModel>}
     * @memberof OrderDataGet200Response
     */
    'data': Array<OrderDataModel>;
    /**
     * 
     * @type {number}
     * @memberof OrderDataGet200Response
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderDataGet200Response
     */
    'nextPageCursor'?: string | null;
}
/**
 * 
 * @export
 * @interface OrderDataModel
 */
export interface OrderDataModel {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof OrderDataModel
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof OrderDataModel
     */
    'updatedAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof OrderDataModel
     */
    'orderDate'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof OrderDataModel
     */
    'deliveryDate'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderDataModel
     */
    'orderId': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDataModel
     */
    'teamId': string;
    /**
     * 
     * @type {number}
     * @memberof OrderDataModel
     */
    'trackingId'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderDataModel
     */
    'customerName'?: string;
    /**
     * 
     * @type {NullablePhoneNumber}
     * @memberof OrderDataModel
     */
    'phoneNumber'?: NullablePhoneNumber;
    /**
     * 
     * @type {string}
     * @memberof OrderDataModel
     */
    'status': OrderDataModelStatusEnum;
    /**
     * 
     * @type {OrderDataModelNote}
     * @memberof OrderDataModel
     */
    'note'?: OrderDataModelNote | null;
    /**
     * 
     * @type {string}
     * @memberof OrderDataModel
     */
    'orderStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDataModel
     */
    'paymentStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDataModel
     */
    'deliveryStatus'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDataModel
     */
    'isTest': boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OrderDataModel
     */
    'data': { [key: string]: any; };
    /**
     * 
     * @type {Array<EasysendDataModel>}
     * @memberof OrderDataModel
     */
    'updates'?: Array<EasysendDataModel>;
}

export const OrderDataModelStatusEnum = {
    Sent: 'sent',
    Pending: 'pending',
    Cancelled: 'cancelled'
} as const;

export type OrderDataModelStatusEnum = typeof OrderDataModelStatusEnum[keyof typeof OrderDataModelStatusEnum];

/**
 * 
 * @export
 * @interface OrderDataModelNote
 */
export interface OrderDataModelNote {
    /**
     * 
     * @type {string}
     * @memberof OrderDataModelNote
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDataModelNote
     */
    'updatedBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof OrderDataModelNote
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface OrderDeleteRequest
 */
export interface OrderDeleteRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof OrderDeleteRequest
     */
    'orderIds': Array<string>;
}
/**
 * 
 * @export
 * @interface OrderPost200Response
 */
export interface OrderPost200Response {
    /**
     * 
     * @type {string}
     * @memberof OrderPost200Response
     */
    'waUrl'?: string;
}
/**
 * 
 * @export
 * @interface OrderPostRequest
 */
export interface OrderPostRequest {
    /**
     * 
     * @type {UpdateOrderModel}
     * @memberof OrderPostRequest
     */
    'order'?: UpdateOrderModel;
    /**
     * Team Id of the team the order belongs to
     * @type {string}
     * @memberof OrderPostRequest
     */
    'teamId'?: string;
    /**
     * The tracking order will be created
     * @type {string}
     * @memberof OrderPostRequest
     */
    'trackingId'?: string;
    /**
     * OTP sent to user order number
     * @type {string}
     * @memberof OrderPostRequest
     */
    'otp'?: string;
}
/**
 * @type OverridePhoneModel
 * @export
 */
export type OverridePhoneModel = OverridePhoneModelOneOf | OverridePhoneModelOneOf1;

/**
 * Override with exact phone number
 * @export
 * @interface OverridePhoneModelOneOf
 */
export interface OverridePhoneModelOneOf {
    /**
     * 
     * @type {number}
     * @memberof OverridePhoneModelOneOf
     */
    'exact': number;
}
/**
 * 
 * @export
 * @interface OverridePhoneModelOneOf1
 */
export interface OverridePhoneModelOneOf1 {
    /**
     * Override with a field from the data
     * @type {string}
     * @memberof OverridePhoneModelOneOf1
     */
    'field': string;
}
/**
 * 
 * @export
 * @interface PatchPaymentIntegrationRequest
 */
export interface PatchPaymentIntegrationRequest {
    /**
     * 
     * @type {DataType}
     * @memberof PatchPaymentIntegrationRequest
     */
    'dataType'?: DataType;
    /**
     * 
     * @type {boolean}
     * @memberof PatchPaymentIntegrationRequest
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentIntegration
 */
interface PaymentIntegration {
    /**
     * 
     * @type {string}
     * @memberof PaymentIntegration
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentIntegration
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentIntegration
     */
    'teamId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PaymentIntegration
     */
    'createdAt': string;
    /**
     * The user who created the payment integration. This is the user who authorized the payment integration
     * @type {string}
     * @memberof PaymentIntegration
     */
    'createdBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PaymentIntegration
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentIntegration
     */
    'paymentSystemId': string;
    /**
     * URL of the QR code image
     * @type {string}
     * @memberof PaymentIntegration
     */
    'qrCodeUrl'?: string;
    /**
     * Secret key for the payment system
     * @type {string}
     * @memberof PaymentIntegration
     */
    'secret'?: string;
}
/**
 * @type PaymentIntegrationAuthRequest
 * @export
 */
export type PaymentIntegrationAuthRequest = OAuth2AuthRequest | SecretAuthRequest;

/**
 * 
 * @export
 * @interface PaymentLink
 */
export interface PaymentLink {
    /**
     * The URL to the payment page
     * @type {string}
     * @memberof PaymentLink
     */
    'url': string;
    /**
     * The payment order reference is explicitly for pocket pay
     * @type {string}
     * @memberof PaymentLink
     */
    'paymentOrderRef'?: string;
    /**
     * The payment order id is explicitly for pocket pay
     * @type {string}
     * @memberof PaymentLink
     */
    'paymentOrderId'?: string;
}
/**
 * 
 * @export
 * @interface PaymentLinkPostRequest
 */
export interface PaymentLinkPostRequest {
    /**
     * 
     * @type {Array<PaymentLinkProduct>}
     * @memberof PaymentLinkPostRequest
     */
    'products': Array<PaymentLinkProduct>;
    /**
     * 
     * @type {PaymentLinkPostRequestToContact}
     * @memberof PaymentLinkPostRequest
     */
    'toContact': PaymentLinkPostRequestToContact;
    /**
     * 
     * @type {string}
     * @memberof PaymentLinkPostRequest
     */
    'orderId'?: string;
    /**
     * Additional parameters to be passed to the payment system
     * @type {{ [key: string]: string; }}
     * @memberof PaymentLinkPostRequest
     */
    'params'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface PaymentLinkPostRequestToContact
 */
export interface PaymentLinkPostRequestToContact {
    /**
     * 
     * @type {string}
     * @memberof PaymentLinkPostRequestToContact
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentLinkPostRequestToContact
     */
    'accountId': string;
}
/**
 * 
 * @export
 * @interface PaymentLinkProduct
 */
export interface PaymentLinkProduct {
    /**
     * ID of the product to add to the payment link
     * @type {string}
     * @memberof PaymentLinkProduct
     */
    'id': string;
    /**
     * Name of the product to add to the payment link
     * @type {string}
     * @memberof PaymentLinkProduct
     */
    'name': string;
    /**
     * The quantity of the product
     * @type {number}
     * @memberof PaymentLinkProduct
     */
    'quantity': number;
    /**
     * The price of the product
     * @type {number}
     * @memberof PaymentLinkProduct
     */
    'price': number;
    /**
     * ISO currency code
     * @type {string}
     * @memberof PaymentLinkProduct
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface PaymentRecord
 */
export interface PaymentRecord {
    /**
     * 
     * @type {number}
     * @memberof PaymentRecord
     */
    'id': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PaymentRecord
     */
    'createdAt': string;
    /**
     * 
     * @type {number}
     * @memberof PaymentRecord
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'orderId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'paymentIntegrationId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'contactId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'currency': string;
    /**
     * 
     * @type {PaymentRecordNote}
     * @memberof PaymentRecord
     */
    'note'?: PaymentRecordNote;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'status': PaymentRecordStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'messageId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'attachmentUrl'?: string;
}

export const PaymentRecordStatusEnum = {
    Pending: 'pending',
    Cancelled: 'cancelled',
    Completed: 'completed'
} as const;

export type PaymentRecordStatusEnum = typeof PaymentRecordStatusEnum[keyof typeof PaymentRecordStatusEnum];

/**
 * 
 * @export
 * @interface PaymentRecordNote
 */
export interface PaymentRecordNote {
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordNote
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordNote
     */
    'updatedBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PaymentRecordNote
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface PaymentRecordPostRequest
 */
export interface PaymentRecordPostRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'paymentIntegrationId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'status': PaymentRecordPostRequestStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof PaymentRecordPostRequest
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'contactId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'messageId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'orderId'?: string;
    /**
     * 
     * @type {PaymentRecordNote}
     * @memberof PaymentRecordPostRequest
     */
    'note'?: PaymentRecordNote;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'attachmentUrl'?: string;
    /**
     * The payment order reference is explicitly for pocket pay
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'paymentOrderRef'?: string;
    /**
     * The payment order id is explicitly for pocket pay
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'paymentOrderId'?: string;
}

export const PaymentRecordPostRequestStatusEnum = {
    Completed: 'completed',
    Pending: 'pending',
    Cancelled: 'cancelled'
} as const;

export type PaymentRecordPostRequestStatusEnum = typeof PaymentRecordPostRequestStatusEnum[keyof typeof PaymentRecordPostRequestStatusEnum];

/**
 * 
 * @export
 * @interface PaymentRecordsGet200Response
 */
export interface PaymentRecordsGet200Response {
    /**
     * 
     * @type {number}
     * @memberof PaymentRecordsGet200Response
     */
    'nextPageCursor'?: number;
    /**
     * 
     * @type {Array<PaymentRecord>}
     * @memberof PaymentRecordsGet200Response
     */
    'records': Array<PaymentRecord>;
}
/**
 * 
 * @export
 * @interface PaymentSystem
 */
interface PaymentSystem {
    /**
     * 
     * @type {string}
     * @memberof PaymentSystem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentSystem
     */
    'name': string;
    /**
     * - qr - QR code payment system - url - payment link generation system
     * @type {string}
     * @memberof PaymentSystem
     */
    'type': PaymentSystemTypeEnum;
    /**
     * 
     * @type {DataType}
     * @memberof PaymentSystem
     */
    'dataType': DataType;
    /**
     * 
     * @type {PaymentSystemAuth}
     * @memberof PaymentSystem
     */
    'auth'?: PaymentSystemAuth;
    /**
     * User\'s integrations of this payment system
     * @type {Array<PaymentIntegration>}
     * @memberof PaymentSystem
     */
    'currentIntegrations'?: Array<PaymentIntegration> | null;
    /**
     * ISO 3166-1 alpha-2 country code.
     * @type {string}
     * @memberof PaymentSystem
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentSystem
     */
    'logoImageUrl'?: string;
}

const PaymentSystemTypeEnum = {
    Qr: 'qr',
    Url: 'url'
} as const;

type PaymentSystemTypeEnum = typeof PaymentSystemTypeEnum[keyof typeof PaymentSystemTypeEnum];

/**
 * 
 * @export
 * @interface PaymentSystemAuth
 */
interface PaymentSystemAuth {
    /**
     * URL to redirect user to in order to authorize the payment system integration
     * @type {string}
     * @memberof PaymentSystemAuth
     */
    'oauthUrl'?: string;
}
/**
 * 
 * @export
 * @interface PaymentSystemsGet200Response
 */
export interface PaymentSystemsGet200Response {
    /**
     * 
     * @type {Array<PaymentSystem>}
     * @memberof PaymentSystemsGet200Response
     */
    'paymentSystems': Array<PaymentSystem>;
}
/**
 * 
 * @export
 * @interface PostServiceModel
 */
export interface PostServiceModel {
    /**
     * 
     * @type {string}
     * @memberof PostServiceModel
     */
    'id': string;
    /**
     * Base route on top of which all easysend paths are appended
     * @type {string}
     * @memberof PostServiceModel
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface PostTracking
 */
export interface PostTracking {
    /**
     * service ID
     * @type {string}
     * @memberof PostTracking
     */
    'serviceId': string;
    /**
     * Nickname to identify this tracking
     * @type {string}
     * @memberof PostTracking
     */
    'name': string;
    /**
     * default country code of phone number if that doesn\'t exists on target phone.
     * @type {number}
     * @memberof PostTracking
     */
    'defaultCountryCode'?: number;
    /**
     * The triggers
     * @type {Array<EventTriggerCreate>}
     * @memberof PostTracking
     */
    'events': Array<EventTriggerCreate>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PostTracking
     */
    'credentials': { [key: string]: any; };
    /**
     * 
     * @type {OverridePhoneModel}
     * @memberof PostTracking
     */
    'overridePhoneNumber'?: OverridePhoneModel;
    /**
     * 
     * @type {RecipientIdOptions}
     * @memberof PostTracking
     */
    'recipientIdOptions'?: RecipientIdOptions;
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof PostTracking
     */
    'accountId'?: string | null;
    /**
     * 
     * @type {TrackingAutoPaymentConfig}
     * @memberof PostTracking
     */
    'autoPayment'?: TrackingAutoPaymentConfig | null;
}
/**
 * 
 * @export
 * @interface ProductAccountSync
 */
export interface ProductAccountSync {
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof ProductAccountSync
     */
    'accountId': string | null;
    /**
     * 
     * @type {ProductSyncStatus}
     * @memberof ProductAccountSync
     */
    'ProductSyncStatus'?: ProductSyncStatus;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ProductAccountSync
     */
    'lastSyncDate': string | null;
    /**
     * Id of the team member that syncs the product from chatdaddy->WhatsApp
     * @type {string}
     * @memberof ProductAccountSync
     */
    'syncedBy': string;
}


/**
 * 
 * @export
 * @interface ProductImageUrl
 */
export interface ProductImageUrl {
    /**
     * 
     * @type {string}
     * @memberof ProductImageUrl
     */
    'url': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ProductSyncStatus = {
    Synced: 'synced',
    Failed: 'failed',
    Syncing: 'syncing'
} as const;

export type ProductSyncStatus = typeof ProductSyncStatus[keyof typeof ProductSyncStatus];


/**
 * 
 * @export
 * @interface RecipientIdOptions
 */
export interface RecipientIdOptions {
    /**
     * The format of the recipient ID. Defaults to `phone_number` if not specified. Set to `opaque` if you want to send the recipient ID as is with no additional formating.
     * @type {string}
     * @memberof RecipientIdOptions
     */
    'format': RecipientIdOptionsFormatEnum;
}

export const RecipientIdOptionsFormatEnum = {
    PhoneNumber: 'phone_number',
    Opaque: 'opaque'
} as const;

export type RecipientIdOptionsFormatEnum = typeof RecipientIdOptionsFormatEnum[keyof typeof RecipientIdOptionsFormatEnum];

/**
 * 
 * @export
 * @interface ScheduleOptions
 */
export interface ScheduleOptions {
    /**
     * the order parameter to use for the schedule
     * @type {string}
     * @memberof ScheduleOptions
     */
    'parameter'?: string;
    /**
     * the time to schedule message before or after the parameter in seconds. Negative value means before the parameter date
     * @type {number}
     * @memberof ScheduleOptions
     */
    'delaySeconds'?: number;
}
/**
 * Authentication details for the payment system to create a payment integration
 * @export
 * @interface SecretAuthRequest
 */
export interface SecretAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof SecretAuthRequest
     */
    'type': SecretAuthRequestTypeEnum;
    /**
     * Authorization secret
     * @type {string}
     * @memberof SecretAuthRequest
     */
    'secret'?: string;
    /**
     * Username
     * @type {string}
     * @memberof SecretAuthRequest
     */
    'username'?: string;
    /**
     * Email so we can use this to map the integration on our end to the payment partner\'s end
     * @type {string}
     * @memberof SecretAuthRequest
     */
    'email': string;
}

export const SecretAuthRequestTypeEnum = {
    Secret: 'secret'
} as const;

export type SecretAuthRequestTypeEnum = typeof SecretAuthRequestTypeEnum[keyof typeof SecretAuthRequestTypeEnum];

/**
 * 
 * @export
 * @interface ServiceModel
 */
export interface ServiceModel {
    /**
     * Used to store and uniquely identify a service/scraper
     * @type {string}
     * @memberof ServiceModel
     */
    'id': string;
    /**
     * URL of the service
     * @type {string}
     * @memberof ServiceModel
     */
    'url'?: string;
    /**
     * Name of the service/scrapper
     * @type {string}
     * @memberof ServiceModel
     */
    'name': string;
    /**
     * A service that implements only the schema route
     * @type {boolean}
     * @memberof ServiceModel
     */
    'isEphemeral'?: boolean;
    /**
     * If true, then parameters wont be checked when editing a trigger
     * @type {boolean}
     * @memberof ServiceModel
     */
    'skipParameterValidation'?: boolean;
    /**
     * any image/link representing the service/scrapper
     * @type {string}
     * @memberof ServiceModel
     */
    'imgUrl': string;
    /**
     * Description of the service/scrapper
     * @type {string}
     * @memberof ServiceModel
     */
    'description': string;
    /**
     * Whether the service supports the products API
     * @type {boolean}
     * @memberof ServiceModel
     */
    'supportsProducts'?: boolean;
    /**
     * If true, then it will allow additional parameters for condition
     * @type {boolean}
     * @memberof ServiceModel
     */
    'allowAdditionalParamsForCondition'?: boolean;
    /**
     * 
     * @type {{ [key: string]: AddServiceModelParametersValue; }}
     * @memberof ServiceModel
     */
    'parameters': { [key: string]: AddServiceModelParametersValue; };
    /**
     * 
     * @type {{ [key: string]: AddServiceModelSetupValue; }}
     * @memberof ServiceModel
     */
    'setup': { [key: string]: AddServiceModelSetupValue; };
    /**
     * 
     * @type {AddServiceModelOutput}
     * @memberof ServiceModel
     */
    'output'?: AddServiceModelOutput;
}
/**
 * 
 * @export
 * @interface ServiceModelAllOf
 */
export interface ServiceModelAllOf {
    /**
     * Used to store and uniquely identify a service/scraper
     * @type {string}
     * @memberof ServiceModelAllOf
     */
    'id': string;
    /**
     * URL of the service
     * @type {string}
     * @memberof ServiceModelAllOf
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ServiceProductsData
 */
export interface ServiceProductsData {
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof ServiceProductsData
     */
    'products': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface Services
 */
export interface Services {
    /**
     * 
     * @type {Array<ServiceModel>}
     * @memberof Services
     */
    'services': Array<ServiceModel>;
}
/**
 * 
 * @export
 * @interface ShopMetadataGet200Response
 */
export interface ShopMetadataGet200Response {
    /**
     * 
     * @type {ShopMetadataModel}
     * @memberof ShopMetadataGet200Response
     */
    'shopMetadata'?: ShopMetadataModel;
}
/**
 * 
 * @export
 * @interface ShopMetadataModel
 */
export interface ShopMetadataModel {
    /**
     * Unique identifier for the shop. if CD shop then it is the teamId else phonenumber
     * @type {string}
     * @memberof ShopMetadataModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModel
     */
    'shopName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModel
     */
    'shopPhoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModel
     */
    'shopNotice'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModel
     */
    'shopCurrency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModel
     */
    'shopImageUrl'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShopMetadataModel
     */
    'shippingEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShopMetadataModel
     */
    'pickUpEnabled'?: boolean;
    /**
     * 
     * @type {Array<ShopMetadataModelPickUpAddressesInner>}
     * @memberof ShopMetadataModel
     */
    'pickUpAddresses'?: Array<ShopMetadataModelPickUpAddressesInner>;
    /**
     * 
     * @type {Array<ShopMetadataModelAdditionalFeesInner>}
     * @memberof ShopMetadataModel
     */
    'additionalFees'?: Array<ShopMetadataModelAdditionalFeesInner>;
    /**
     * 
     * @type {Array<ShopMetadataModelAdditionalFeesInner>}
     * @memberof ShopMetadataModel
     */
    'shippingFee'?: Array<ShopMetadataModelAdditionalFeesInner>;
    /**
     * 
     * @type {number}
     * @memberof ShopMetadataModel
     */
    'freeShippingThreshold'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ShopMetadataModel
     */
    'completedShopSetupProcess'?: boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ShopMetadataModel
     */
    'onBoardingData'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModel
     */
    'shopService'?: ShopMetadataModelShopServiceEnum;
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModel
     */
    'externalShopUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModel
     */
    'type'?: ShopMetadataModelTypeEnum;
}

export const ShopMetadataModelShopServiceEnum = {
    Shopify: 'shopify',
    Shopline: 'shopline',
    Woocommerce: 'woocommerce',
    Boutir: 'boutir'
} as const;

export type ShopMetadataModelShopServiceEnum = typeof ShopMetadataModelShopServiceEnum[keyof typeof ShopMetadataModelShopServiceEnum];
export const ShopMetadataModelTypeEnum = {
    CdTeam: 'cd-team',
    ExternalShop: 'external-shop'
} as const;

export type ShopMetadataModelTypeEnum = typeof ShopMetadataModelTypeEnum[keyof typeof ShopMetadataModelTypeEnum];

/**
 * 
 * @export
 * @interface ShopMetadataModelAdditionalFeesInner
 */
export interface ShopMetadataModelAdditionalFeesInner {
    /**
     * 
     * @type {number}
     * @memberof ShopMetadataModelAdditionalFeesInner
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModelAdditionalFeesInner
     */
    'currency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShopMetadataModelAdditionalFeesInner
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModelAdditionalFeesInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ShopMetadataModelPickUpAddressesInner
 */
export interface ShopMetadataModelPickUpAddressesInner {
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModelPickUpAddressesInner
     */
    'address'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShopMetadataModelPickUpAddressesInner
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface ShopMetadataPostRequest
 */
export interface ShopMetadataPostRequest {
    /**
     * 
     * @type {Array<ShopMetadataModel>}
     * @memberof ShopMetadataPostRequest
     */
    'shopMetadata'?: Array<ShopMetadataModel>;
}
/**
 * Product model for Waha Shop
 * @export
 * @interface ShopProduct
 */
export interface ShopProduct {
    /**
     * 
     * @type {string}
     * @memberof ShopProduct
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ShopProduct
     */
    'retailerId'?: string | null;
    /**
     * 
     * @type {Array<ProductAccountSync>}
     * @memberof ShopProduct
     */
    'accountSyncStatuses'?: Array<ProductAccountSync>;
    /**
     * Specify category id
     * @type {string}
     * @memberof ShopProduct
     */
    'categoryId'?: string;
    /**
     * 
     * @type {ShopProductCategoryBase}
     * @memberof ShopProduct
     */
    'category'?: ShopProductCategoryBase;
    /**
     * 
     * @type {string}
     * @memberof ShopProduct
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof ShopProduct
     */
    'price': number | null;
    /**
     * 
     * @type {string}
     * @memberof ShopProduct
     */
    'currency'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ShopProduct
     */
    'isHidden': boolean;
    /**
     * 
     * @type {string}
     * @memberof ShopProduct
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ShopProduct
     */
    'teamId': string;
    /**
     * 
     * @type {Array<ProductImageUrl>}
     * @memberof ShopProduct
     */
    'imageUrls': Array<ProductImageUrl>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ShopProduct
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof ShopProduct
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ShopProduct
     */
    'createdBy': string;
}
/**
 * 
 * @export
 * @interface ShopProductCategoriesGet200Response
 */
export interface ShopProductCategoriesGet200Response {
    /**
     * 
     * @type {Array<ShopProductCategory>}
     * @memberof ShopProductCategoriesGet200Response
     */
    'categories': Array<ShopProductCategory>;
}
/**
 * 
 * @export
 * @interface ShopProductCategoriesPostRequest
 */
export interface ShopProductCategoriesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ShopProductCategoriesPostRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ShopProductCategory
 */
export interface ShopProductCategory {
    /**
     * 
     * @type {string}
     * @memberof ShopProductCategory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ShopProductCategory
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ShopProductCategory
     */
    'productCount': number;
    /**
     * 
     * @type {string}
     * @memberof ShopProductCategory
     */
    'teamId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopProductCategory
     */
    'productId'?: Array<string> | null;
    /**
     * 
     * @type {Array<ShopProduct>}
     * @memberof ShopProductCategory
     */
    'products'?: Array<ShopProduct> | null;
}
/**
 * 
 * @export
 * @interface ShopProductCategoryAllOf
 */
export interface ShopProductCategoryAllOf {
    /**
     * 
     * @type {Array<ShopProduct>}
     * @memberof ShopProductCategoryAllOf
     */
    'products'?: Array<ShopProduct> | null;
}
/**
 * 
 * @export
 * @interface ShopProductCategoryBase
 */
export interface ShopProductCategoryBase {
    /**
     * 
     * @type {string}
     * @memberof ShopProductCategoryBase
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ShopProductCategoryBase
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ShopProductCategoryBase
     */
    'productCount': number;
    /**
     * 
     * @type {string}
     * @memberof ShopProductCategoryBase
     */
    'teamId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopProductCategoryBase
     */
    'productId'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface ShopProductCreate
 */
export interface ShopProductCreate {
    /**
     * 
     * @type {Array<ShopProductCreateItem>}
     * @memberof ShopProductCreate
     */
    'products': Array<ShopProductCreateItem>;
}
/**
 * 
 * @export
 * @interface ShopProductCreateItem
 */
export interface ShopProductCreateItem {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ShopProductCreateItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ShopProductCreateItem
     */
    'retailerId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopProductCreateItem
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopProductCreateItem
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof ShopProductCreateItem
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof ShopProductCreateItem
     */
    'currency': string;
    /**
     * 
     * @type {boolean}
     * @memberof ShopProductCreateItem
     */
    'isHidden': boolean;
    /**
     * 
     * @type {ShopProductCategory}
     * @memberof ShopProductCreateItem
     */
    'category'?: ShopProductCategory;
    /**
     * 
     * @type {Array<ProductImageUrl>}
     * @memberof ShopProductCreateItem
     */
    'imageUrls': Array<ProductImageUrl>;
}
/**
 * 
 * @export
 * @interface ShopProductUpdate
 */
export interface ShopProductUpdate {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ShopProductUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopProductUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof ShopProductUpdate
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopProductUpdate
     */
    'currency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShopProductUpdate
     */
    'isHidden'?: boolean;
    /**
     * 
     * @type {ShopProductCategory}
     * @memberof ShopProductUpdate
     */
    'category'?: ShopProductCategory;
    /**
     * 
     * @type {Array<ProductImageUrl>}
     * @memberof ShopProductUpdate
     */
    'imageUrls'?: Array<ProductImageUrl>;
}
/**
 * 
 * @export
 * @interface ShopProductsGet200Response
 */
export interface ShopProductsGet200Response {
    /**
     * 
     * @type {Array<ShopProduct>}
     * @memberof ShopProductsGet200Response
     */
    'items': Array<ShopProduct>;
    /**
     * Cursor to use to fetch next page of results
     * @type {string}
     * @memberof ShopProductsGet200Response
     */
    'nextPageCursor'?: string;
    /**
     * total products present with these filters. Only returned if returnTotalCount is true
     * @type {number}
     * @memberof ShopProductsGet200Response
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface ShopProductsPost200Response
 */
export interface ShopProductsPost200Response {
    /**
     * 
     * @type {Array<ShopProduct>}
     * @memberof ShopProductsPost200Response
     */
    'items': Array<ShopProduct>;
}
/**
 * 
 * @export
 * @interface SuccessResponse
 */
export interface SuccessResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SuccessResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface TrackServiceModel
 */
export interface TrackServiceModel {
    /**
     * 
     * @type {number}
     * @memberof TrackServiceModel
     */
    'id': number;
    /**
     * secret ID used to communicate with shop integrations. Shop integrations never see the actual ID of a tracking, they only see the secret ID. They identify a tracking by the secret ID itself
     * @type {string}
     * @memberof TrackServiceModel
     */
    'secretId': string;
    /**
     * 
     * @type {string}
     * @memberof TrackServiceModel
     */
    'name': string;
    /**
     * Used to store and uniquely identify a service/scraper.
     * @type {string}
     * @memberof TrackServiceModel
     */
    'serviceId'?: string;
    /**
     * The team ID this tracking belongs to
     * @type {string}
     * @memberof TrackServiceModel
     */
    'teamId': string;
    /**
     * default country code of phone number if that doesn\'t exists on target phone.
     * @type {number}
     * @memberof TrackServiceModel
     */
    'defaultCountryCode'?: number;
    /**
     * The triggers setup for this service
     * @type {Array<EventTrigger>}
     * @memberof TrackServiceModel
     */
    'events'?: Array<EventTrigger>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TrackServiceModel
     */
    'lastActivity': string | null;
    /**
     * number of times tracking has received an event
     * @type {number}
     * @memberof TrackServiceModel
     */
    'triggered': number;
    /**
     * Whether the tracking is active or not. If the service isn\'t active -- no events are sent out
     * @type {boolean}
     * @memberof TrackServiceModel
     */
    'isActive': boolean;
    /**
     * 
     * @type {OverridePhoneModel}
     * @memberof TrackServiceModel
     */
    'overridePhoneNumber'?: OverridePhoneModel;
    /**
     * 
     * @type {RecipientIdOptions}
     * @memberof TrackServiceModel
     */
    'recipientIdOptions'?: RecipientIdOptions;
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof TrackServiceModel
     */
    'accountId': string | null;
    /**
     * 
     * @type {ErrorState}
     * @memberof TrackServiceModel
     */
    'error': ErrorState | null;
    /**
     * 
     * @type {TrackingAutoPaymentConfig}
     * @memberof TrackServiceModel
     */
    'autoPayment'?: TrackingAutoPaymentConfig | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TrackServiceModel
     */
    'createdAt': string;
    /**
     * The user who created the tracking
     * @type {string}
     * @memberof TrackServiceModel
     */
    'createdBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TrackServiceModel
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface TrackServices
 */
export interface TrackServices {
    /**
     * 
     * @type {Array<TrackServiceModel>}
     * @memberof TrackServices
     */
    'trackings': Array<TrackServiceModel>;
}
/**
 * 
 * @export
 * @interface TrackingAutoPaymentConfig
 */
export interface TrackingAutoPaymentConfig {
    /**
     * 
     * @type {string}
     * @memberof TrackingAutoPaymentConfig
     */
    'paymentIntegrationId': string;
}
/**
 * 
 * @export
 * @interface TrackingPatch200Response
 */
export interface TrackingPatch200Response {
    /**
     * 
     * @type {TrackServiceModel}
     * @memberof TrackingPatch200Response
     */
    'tracking': TrackServiceModel;
}
/**
 * 
 * @export
 * @interface TrackingPost200Response
 */
export interface TrackingPost200Response {
    /**
     * 
     * @type {TrackServiceModel}
     * @memberof TrackingPost200Response
     */
    'tracking': TrackServiceModel;
}
/**
 * 
 * @export
 * @interface TriggerTest200Response
 */
export interface TriggerTest200Response {
    /**
     * the parameter that was sent
     * @type {object}
     * @memberof TriggerTest200Response
     */
    'params': object;
    /**
     * mock order ID
     * @type {string}
     * @memberof TriggerTest200Response
     */
    'orderId': string;
}
/**
 * 
 * @export
 * @interface UpdateOrderDataModel
 */
export interface UpdateOrderDataModel {
    /**
     * 
     * @type {UpdateOrderDataModelNote}
     * @memberof UpdateOrderDataModel
     */
    'note'?: UpdateOrderDataModelNote | null;
    /**
     * 
     * @type {NullablePhoneNumber}
     * @memberof UpdateOrderDataModel
     */
    'phoneNumber'?: NullablePhoneNumber;
}
/**
 * 
 * @export
 * @interface UpdateOrderDataModelNote
 */
export interface UpdateOrderDataModelNote {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrderDataModelNote
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrderDataModelNote
     */
    'updatedBy'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof UpdateOrderDataModelNote
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface UpdateOrderModel
 */
export interface UpdateOrderModel {
    /**
     * 
     * @type {NullablePhoneNumber}
     * @memberof UpdateOrderModel
     */
    'phoneNumber'?: NullablePhoneNumber;
    /**
     * Unique identifier for the order. Is used to track the status internally
     * @type {string}
     * @memberof UpdateOrderModel
     */
    'orderId': string;
    /**
     * Is it a test order
     * @type {boolean}
     * @memberof UpdateOrderModel
     */
    'isTest'?: boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UpdateOrderModel
     */
    'params': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface UpdateTracking
 */
export interface UpdateTracking {
    /**
     * Nickname to identify this tracking
     * @type {string}
     * @memberof UpdateTracking
     */
    'name'?: string;
    /**
     * 
     * @type {OverridePhoneModel}
     * @memberof UpdateTracking
     */
    'overridePhoneNumber'?: OverridePhoneModel;
    /**
     * 
     * @type {RecipientIdOptions}
     * @memberof UpdateTracking
     */
    'recipientIdOptions'?: RecipientIdOptions;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UpdateTracking
     */
    'credentials'?: { [key: string]: any; };
    /**
     * default country code of phone number if that doesn\'t exists on target phone.
     * @type {number}
     * @memberof UpdateTracking
     */
    'defaultCountryCode'?: number;
    /**
     * 
     * @type {Array<EventTrigger>}
     * @memberof UpdateTracking
     */
    'events'?: Array<EventTrigger>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTracking
     */
    'isActive'?: boolean;
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof UpdateTracking
     */
    'accountId'?: string | null;
    /**
     * 
     * @type {TrackingAutoPaymentConfig}
     * @memberof UpdateTracking
     */
    'autoPayment'?: TrackingAutoPaymentConfig | null;
}
/**
 * 
 * @export
 * @interface UpdateTrackingErrorState
 */
export interface UpdateTrackingErrorState {
    /**
     * 
     * @type {ErrorState}
     * @memberof UpdateTrackingErrorState
     */
    'error': ErrorState | null;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get admin data
         * @param {Array<string>} [teamId] Fetch orders of the specified teamIds
         * @param {'ASC' | 'DESC'} [direction] Fetch orders sent to the specified phone number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDataGet: async (teamId?: Array<string>, direction?: 'ASC' | 'DESC', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)

            if (teamId) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add/Update Payment system supported by chatdaddy
         * @param {PaymentSystem} [paymentSystem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPaymentSystemPost: async (paymentSystem?: PaymentSystem, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/payment-system`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentSystem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get admin data
         * @param {Array<string>} [teamId] Fetch orders of the specified teamIds
         * @param {'ASC' | 'DESC'} [direction] Fetch orders sent to the specified phone number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDataGet(teamId?: Array<string>, direction?: 'ASC' | 'DESC', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AdminDataGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDataGet(teamId, direction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add/Update Payment system supported by chatdaddy
         * @param {PaymentSystem} [paymentSystem] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminPaymentSystemPost(paymentSystem?: PaymentSystem, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminPaymentSystemPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminPaymentSystemPost(paymentSystem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @summary Get admin data
         * @param {AdminApiAdminDataGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDataGet(requestParameters: AdminApiAdminDataGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<AdminDataGet200ResponseInner>> {
            return localVarFp.adminDataGet(requestParameters.teamId, requestParameters.direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add/Update Payment system supported by chatdaddy
         * @param {AdminApiAdminPaymentSystemPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminPaymentSystemPost(requestParameters: AdminApiAdminPaymentSystemPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<AdminPaymentSystemPost200Response> {
            return localVarFp.adminPaymentSystemPost(requestParameters.paymentSystem, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for adminDataGet operation in AdminApi.
 * @export
 * @interface AdminApiAdminDataGetRequest
 */
export interface AdminApiAdminDataGetRequest {
    /**
     * Fetch orders of the specified teamIds
     * @type {Array<string>}
     * @memberof AdminApiAdminDataGet
     */
    readonly teamId?: Array<string>

    /**
     * Fetch orders sent to the specified phone number
     * @type {'ASC' | 'DESC'}
     * @memberof AdminApiAdminDataGet
     */
    readonly direction?: 'ASC' | 'DESC'
}

/**
 * Request parameters for adminPaymentSystemPost operation in AdminApi.
 * @export
 * @interface AdminApiAdminPaymentSystemPostRequest
 */
export interface AdminApiAdminPaymentSystemPostRequest {
    /**
     * 
     * @type {PaymentSystem}
     * @memberof AdminApiAdminPaymentSystemPost
     */
    readonly paymentSystem?: PaymentSystem
}

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @summary Get admin data
     * @param {AdminApiAdminDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminDataGet(requestParameters: AdminApiAdminDataGetRequest = {}, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDataGet(requestParameters.teamId, requestParameters.direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add/Update Payment system supported by chatdaddy
     * @param {AdminApiAdminPaymentSystemPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminPaymentSystemPost(requestParameters: AdminApiAdminPaymentSystemPostRequest = {}, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminPaymentSystemPost(requestParameters.paymentSystem, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To be called by a scraping service whenever something happens. Examples include -- an email is received, an order is placed or updated, an order is cancelled, etc.
         * @summary Update data/order details of a tracking
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {string} [accountId] The account ID to use when sending the flow
         * @param {DataPatchRequest} [dataPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataPatch: async (secretId: string, accountId?: string, dataPatchRequest?: DataPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('dataPatch', 'secretId', secretId)
            const localVarPath = `/event/{secretId}`
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resend the WA message associated with this data point
         * @param {string} dataId The secret sent to the parsing service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataResend: async (dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('dataResend', 'dataId', dataId)
            const localVarPath = `/data/{dataId}/resend-wa`
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post the order data on easysend.
         * @param {OrderPostRequest} [orderPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPost: async (orderPostRequest?: OrderPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/checkout-product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * To be called by a scraping service whenever something happens. Examples include -- an email is received, an order is placed or updated, an order is cancelled, etc.
         * @summary Update data/order details of a tracking
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {string} [accountId] The account ID to use when sending the flow
         * @param {DataPatchRequest} [dataPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataPatch(secretId: string, accountId?: string, dataPatchRequest?: DataPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataPatch(secretId, accountId, dataPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resend the WA message associated with this data point
         * @param {string} dataId The secret sent to the parsing service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataResend(dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResend200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataResend(dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post the order data on easysend.
         * @param {OrderPostRequest} [orderPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderPost(orderPostRequest?: OrderPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderPost(orderPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * To be called by a scraping service whenever something happens. Examples include -- an email is received, an order is placed or updated, an order is cancelled, etc.
         * @summary Update data/order details of a tracking
         * @param {EventsApiDataPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataPatch(requestParameters: EventsApiDataPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.dataPatch(requestParameters.secretId, requestParameters.accountId, requestParameters.dataPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resend the WA message associated with this data point
         * @param {EventsApiDataResendRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataResend(requestParameters: EventsApiDataResendRequest, options?: AxiosRequestConfig): AxiosPromise<DataResend200Response> {
            return localVarFp.dataResend(requestParameters.dataId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post the order data on easysend.
         * @param {EventsApiOrderPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPost(requestParameters: EventsApiOrderPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<OrderPost200Response> {
            return localVarFp.orderPost(requestParameters.orderPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for dataPatch operation in EventsApi.
 * @export
 * @interface EventsApiDataPatchRequest
 */
export interface EventsApiDataPatchRequest {
    /**
     * The secret ID of the tracking made available to the service
     * @type {string}
     * @memberof EventsApiDataPatch
     */
    readonly secretId: string

    /**
     * The account ID to use when sending the flow
     * @type {string}
     * @memberof EventsApiDataPatch
     */
    readonly accountId?: string

    /**
     * 
     * @type {DataPatchRequest}
     * @memberof EventsApiDataPatch
     */
    readonly dataPatchRequest?: DataPatchRequest
}

/**
 * Request parameters for dataResend operation in EventsApi.
 * @export
 * @interface EventsApiDataResendRequest
 */
export interface EventsApiDataResendRequest {
    /**
     * The secret sent to the parsing service
     * @type {string}
     * @memberof EventsApiDataResend
     */
    readonly dataId: string
}

/**
 * Request parameters for orderPost operation in EventsApi.
 * @export
 * @interface EventsApiOrderPostRequest
 */
export interface EventsApiOrderPostRequest {
    /**
     * 
     * @type {OrderPostRequest}
     * @memberof EventsApiOrderPost
     */
    readonly orderPostRequest?: OrderPostRequest
}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * To be called by a scraping service whenever something happens. Examples include -- an email is received, an order is placed or updated, an order is cancelled, etc.
     * @summary Update data/order details of a tracking
     * @param {EventsApiDataPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public dataPatch(requestParameters: EventsApiDataPatchRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).dataPatch(requestParameters.secretId, requestParameters.accountId, requestParameters.dataPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resend the WA message associated with this data point
     * @param {EventsApiDataResendRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public dataResend(requestParameters: EventsApiDataResendRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).dataResend(requestParameters.dataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post the order data on easysend.
     * @param {EventsApiOrderPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public orderPost(requestParameters: EventsApiOrderPostRequest = {}, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).orderPost(requestParameters.orderPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentIntegrationsApi - axios parameter creator
 * @export
 */
export const PaymentIntegrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a payment integration
         * @param {CreatePaymentIntegrationRequest} [createPaymentIntegrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentIntegration: async (createPaymentIntegrationRequest?: CreatePaymentIntegrationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_INTEGRATION_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPaymentIntegrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete the user\'s payment integration
         * @param {Array<string>} id the ids of the payment integration to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentIntegration: async (id: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePaymentIntegration', 'id', id)
            const localVarPath = `/payment-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_INTEGRATION_WRITE"], configuration)

            if (id) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all payment integrations available to a user
         * @param {string} teamId 
         * @param {string} [id] Fetch the payment integrations with the id specified
         * @param {boolean} [isEnabled] Fetch only enabled integrations if true
         * @param {boolean} [fetchAll] Fetch all integrations if you have admin Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentIntegrations: async (teamId: string, id?: string, isEnabled?: boolean, fetchAll?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getPaymentIntegrations', 'teamId', teamId)
            const localVarPath = `/payment-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (isEnabled !== undefined) {
                localVarQueryParameter['isEnabled'] = isEnabled;
            }

            if (fetchAll !== undefined) {
                localVarQueryParameter['fetchAll'] = fetchAll;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update the user\'s payment integration
         * @param {string} id the id of the payment integration to patch
         * @param {PatchPaymentIntegrationRequest} [patchPaymentIntegrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchPaymentIntegration: async (id: string, patchPaymentIntegrationRequest?: PatchPaymentIntegrationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchPaymentIntegration', 'id', id)
            const localVarPath = `/payment-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_INTEGRATION_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchPaymentIntegrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used by payment integrations to notify the server of payment events
         * @summary Webhook for payment integrations
         * @param {string} name Name of the payment integration
         * @param {string} secret Secret of the payment integration
         * @param {string} [secret2] Secret for payex integration
         * @param {string} [mid] Merchant id for payex integration
         * @param {string} [email] Email for payex integration
         * @param {string} [name2] Name for payex integration
         * @param {string} [integrationId] Integration Id of selected payment integration
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentIntegrationWebhook: async (name: string, secret: string, secret2?: string, mid?: string, email?: string, name2?: string, integrationId?: string, requestBody?: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('paymentIntegrationWebhook', 'name', name)
            // verify required parameter 'secret' is not null or undefined
            assertParamExists('paymentIntegrationWebhook', 'secret', secret)
            const localVarPath = `/payment-integrations/{name}/webhook/{secret}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"secret"}}`, encodeURIComponent(String(secret)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (secret2 !== undefined) {
                localVarQueryParameter['secret'] = secret2;
            }

            if (mid !== undefined) {
                localVarQueryParameter['mid'] = mid;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (name2 !== undefined) {
                localVarQueryParameter['name'] = name2;
            }

            if (integrationId !== undefined) {
                localVarQueryParameter['integrationId'] = integrationId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a payment link
         * @param {string} id the id of the payment integration to generate a payment link for
         * @param {PaymentLinkPostRequest} [paymentLinkPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentLinkPost: async (id: string, paymentLinkPostRequest?: PaymentLinkPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentLinkPost', 'id', id)
            const localVarPath = `/payment-integrations/{id}/payment-link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_INTEGRATION_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentLinkPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentIntegrationsApi - functional programming interface
 * @export
 */
export const PaymentIntegrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentIntegrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a payment integration
         * @param {CreatePaymentIntegrationRequest} [createPaymentIntegrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentIntegration(createPaymentIntegrationRequest?: CreatePaymentIntegrationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentIntegration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentIntegration(createPaymentIntegrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary delete the user\'s payment integration
         * @param {Array<string>} id the ids of the payment integration to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentIntegration(id: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePaymentIntegration(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all payment integrations available to a user
         * @param {string} teamId 
         * @param {string} [id] Fetch the payment integrations with the id specified
         * @param {boolean} [isEnabled] Fetch only enabled integrations if true
         * @param {boolean} [fetchAll] Fetch all integrations if you have admin Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentIntegrations(teamId: string, id?: string, isEnabled?: boolean, fetchAll?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentIntegrations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentIntegrations(teamId, id, isEnabled, fetchAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update the user\'s payment integration
         * @param {string} id the id of the payment integration to patch
         * @param {PatchPaymentIntegrationRequest} [patchPaymentIntegrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchPaymentIntegration(id: string, patchPaymentIntegrationRequest?: PatchPaymentIntegrationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchPaymentIntegration(id, patchPaymentIntegrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is used by payment integrations to notify the server of payment events
         * @summary Webhook for payment integrations
         * @param {string} name Name of the payment integration
         * @param {string} secret Secret of the payment integration
         * @param {string} [secret2] Secret for payex integration
         * @param {string} [mid] Merchant id for payex integration
         * @param {string} [email] Email for payex integration
         * @param {string} [name2] Name for payex integration
         * @param {string} [integrationId] Integration Id of selected payment integration
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentIntegrationWebhook(name: string, secret: string, secret2?: string, mid?: string, email?: string, name2?: string, integrationId?: string, requestBody?: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentIntegrationWebhook(name, secret, secret2, mid, email, name2, integrationId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate a payment link
         * @param {string} id the id of the payment integration to generate a payment link for
         * @param {PaymentLinkPostRequest} [paymentLinkPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentLinkPost(id: string, paymentLinkPostRequest?: PaymentLinkPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentLinkPost(id, paymentLinkPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentIntegrationsApi - factory interface
 * @export
 */
export const PaymentIntegrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentIntegrationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a payment integration
         * @param {PaymentIntegrationsApiCreatePaymentIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentIntegration(requestParameters: PaymentIntegrationsApiCreatePaymentIntegrationRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PaymentIntegration> {
            return localVarFp.createPaymentIntegration(requestParameters.createPaymentIntegrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete the user\'s payment integration
         * @param {PaymentIntegrationsApiDeletePaymentIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentIntegration(requestParameters: PaymentIntegrationsApiDeletePaymentIntegrationRequest, options?: AxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.deletePaymentIntegration(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all payment integrations available to a user
         * @param {PaymentIntegrationsApiGetPaymentIntegrationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentIntegrations(requestParameters: PaymentIntegrationsApiGetPaymentIntegrationsRequest, options?: AxiosRequestConfig): AxiosPromise<GetPaymentIntegrations200Response> {
            return localVarFp.getPaymentIntegrations(requestParameters.teamId, requestParameters.id, requestParameters.isEnabled, requestParameters.fetchAll, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update the user\'s payment integration
         * @param {PaymentIntegrationsApiPatchPaymentIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchPaymentIntegration(requestParameters: PaymentIntegrationsApiPatchPaymentIntegrationRequest, options?: AxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.patchPaymentIntegration(requestParameters.id, requestParameters.patchPaymentIntegrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used by payment integrations to notify the server of payment events
         * @summary Webhook for payment integrations
         * @param {PaymentIntegrationsApiPaymentIntegrationWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentIntegrationWebhook(requestParameters: PaymentIntegrationsApiPaymentIntegrationWebhookRequest, options?: AxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.paymentIntegrationWebhook(requestParameters.name, requestParameters.secret, requestParameters.secret2, requestParameters.mid, requestParameters.email, requestParameters.name2, requestParameters.integrationId, requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a payment link
         * @param {PaymentIntegrationsApiPaymentLinkPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentLinkPost(requestParameters: PaymentIntegrationsApiPaymentLinkPostRequest, options?: AxiosRequestConfig): AxiosPromise<PaymentLink> {
            return localVarFp.paymentLinkPost(requestParameters.id, requestParameters.paymentLinkPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPaymentIntegration operation in PaymentIntegrationsApi.
 * @export
 * @interface PaymentIntegrationsApiCreatePaymentIntegrationRequest
 */
export interface PaymentIntegrationsApiCreatePaymentIntegrationRequest {
    /**
     * 
     * @type {CreatePaymentIntegrationRequest}
     * @memberof PaymentIntegrationsApiCreatePaymentIntegration
     */
    readonly createPaymentIntegrationRequest?: CreatePaymentIntegrationRequest
}

/**
 * Request parameters for deletePaymentIntegration operation in PaymentIntegrationsApi.
 * @export
 * @interface PaymentIntegrationsApiDeletePaymentIntegrationRequest
 */
export interface PaymentIntegrationsApiDeletePaymentIntegrationRequest {
    /**
     * the ids of the payment integration to delete
     * @type {Array<string>}
     * @memberof PaymentIntegrationsApiDeletePaymentIntegration
     */
    readonly id: Array<string>
}

/**
 * Request parameters for getPaymentIntegrations operation in PaymentIntegrationsApi.
 * @export
 * @interface PaymentIntegrationsApiGetPaymentIntegrationsRequest
 */
export interface PaymentIntegrationsApiGetPaymentIntegrationsRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentIntegrationsApiGetPaymentIntegrations
     */
    readonly teamId: string

    /**
     * Fetch the payment integrations with the id specified
     * @type {string}
     * @memberof PaymentIntegrationsApiGetPaymentIntegrations
     */
    readonly id?: string

    /**
     * Fetch only enabled integrations if true
     * @type {boolean}
     * @memberof PaymentIntegrationsApiGetPaymentIntegrations
     */
    readonly isEnabled?: boolean

    /**
     * Fetch all integrations if you have admin Access
     * @type {boolean}
     * @memberof PaymentIntegrationsApiGetPaymentIntegrations
     */
    readonly fetchAll?: boolean
}

/**
 * Request parameters for patchPaymentIntegration operation in PaymentIntegrationsApi.
 * @export
 * @interface PaymentIntegrationsApiPatchPaymentIntegrationRequest
 */
export interface PaymentIntegrationsApiPatchPaymentIntegrationRequest {
    /**
     * the id of the payment integration to patch
     * @type {string}
     * @memberof PaymentIntegrationsApiPatchPaymentIntegration
     */
    readonly id: string

    /**
     * 
     * @type {PatchPaymentIntegrationRequest}
     * @memberof PaymentIntegrationsApiPatchPaymentIntegration
     */
    readonly patchPaymentIntegrationRequest?: PatchPaymentIntegrationRequest
}

/**
 * Request parameters for paymentIntegrationWebhook operation in PaymentIntegrationsApi.
 * @export
 * @interface PaymentIntegrationsApiPaymentIntegrationWebhookRequest
 */
export interface PaymentIntegrationsApiPaymentIntegrationWebhookRequest {
    /**
     * Name of the payment integration
     * @type {string}
     * @memberof PaymentIntegrationsApiPaymentIntegrationWebhook
     */
    readonly name: string

    /**
     * Secret of the payment integration
     * @type {string}
     * @memberof PaymentIntegrationsApiPaymentIntegrationWebhook
     */
    readonly secret: string

    /**
     * Secret for payex integration
     * @type {string}
     * @memberof PaymentIntegrationsApiPaymentIntegrationWebhook
     */
    readonly secret2?: string

    /**
     * Merchant id for payex integration
     * @type {string}
     * @memberof PaymentIntegrationsApiPaymentIntegrationWebhook
     */
    readonly mid?: string

    /**
     * Email for payex integration
     * @type {string}
     * @memberof PaymentIntegrationsApiPaymentIntegrationWebhook
     */
    readonly email?: string

    /**
     * Name for payex integration
     * @type {string}
     * @memberof PaymentIntegrationsApiPaymentIntegrationWebhook
     */
    readonly name2?: string

    /**
     * Integration Id of selected payment integration
     * @type {string}
     * @memberof PaymentIntegrationsApiPaymentIntegrationWebhook
     */
    readonly integrationId?: string

    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PaymentIntegrationsApiPaymentIntegrationWebhook
     */
    readonly requestBody?: { [key: string]: any; }
}

/**
 * Request parameters for paymentLinkPost operation in PaymentIntegrationsApi.
 * @export
 * @interface PaymentIntegrationsApiPaymentLinkPostRequest
 */
export interface PaymentIntegrationsApiPaymentLinkPostRequest {
    /**
     * the id of the payment integration to generate a payment link for
     * @type {string}
     * @memberof PaymentIntegrationsApiPaymentLinkPost
     */
    readonly id: string

    /**
     * 
     * @type {PaymentLinkPostRequest}
     * @memberof PaymentIntegrationsApiPaymentLinkPost
     */
    readonly paymentLinkPostRequest?: PaymentLinkPostRequest
}

/**
 * PaymentIntegrationsApi - object-oriented interface
 * @export
 * @class PaymentIntegrationsApi
 * @extends {BaseAPI}
 */
export class PaymentIntegrationsApi extends BaseAPI {
    /**
     * 
     * @summary Create a payment integration
     * @param {PaymentIntegrationsApiCreatePaymentIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntegrationsApi
     */
    public createPaymentIntegration(requestParameters: PaymentIntegrationsApiCreatePaymentIntegrationRequest = {}, options?: AxiosRequestConfig) {
        return PaymentIntegrationsApiFp(this.configuration).createPaymentIntegration(requestParameters.createPaymentIntegrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete the user\'s payment integration
     * @param {PaymentIntegrationsApiDeletePaymentIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntegrationsApi
     */
    public deletePaymentIntegration(requestParameters: PaymentIntegrationsApiDeletePaymentIntegrationRequest, options?: AxiosRequestConfig) {
        return PaymentIntegrationsApiFp(this.configuration).deletePaymentIntegration(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all payment integrations available to a user
     * @param {PaymentIntegrationsApiGetPaymentIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntegrationsApi
     */
    public getPaymentIntegrations(requestParameters: PaymentIntegrationsApiGetPaymentIntegrationsRequest, options?: AxiosRequestConfig) {
        return PaymentIntegrationsApiFp(this.configuration).getPaymentIntegrations(requestParameters.teamId, requestParameters.id, requestParameters.isEnabled, requestParameters.fetchAll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update the user\'s payment integration
     * @param {PaymentIntegrationsApiPatchPaymentIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntegrationsApi
     */
    public patchPaymentIntegration(requestParameters: PaymentIntegrationsApiPatchPaymentIntegrationRequest, options?: AxiosRequestConfig) {
        return PaymentIntegrationsApiFp(this.configuration).patchPaymentIntegration(requestParameters.id, requestParameters.patchPaymentIntegrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used by payment integrations to notify the server of payment events
     * @summary Webhook for payment integrations
     * @param {PaymentIntegrationsApiPaymentIntegrationWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntegrationsApi
     */
    public paymentIntegrationWebhook(requestParameters: PaymentIntegrationsApiPaymentIntegrationWebhookRequest, options?: AxiosRequestConfig) {
        return PaymentIntegrationsApiFp(this.configuration).paymentIntegrationWebhook(requestParameters.name, requestParameters.secret, requestParameters.secret2, requestParameters.mid, requestParameters.email, requestParameters.name2, requestParameters.integrationId, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a payment link
     * @param {PaymentIntegrationsApiPaymentLinkPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntegrationsApi
     */
    public paymentLinkPost(requestParameters: PaymentIntegrationsApiPaymentLinkPostRequest, options?: AxiosRequestConfig) {
        return PaymentIntegrationsApiFp(this.configuration).paymentLinkPost(requestParameters.id, requestParameters.paymentLinkPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentRecordsApi - axios parameter creator
 * @export
 */
export const PaymentRecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PaymentRecordPostRequest} [paymentRecordPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRecordPost: async (paymentRecordPostRequest?: PaymentRecordPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_RECORDS_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentRecordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] Number of items to retreive
         * @param {string} [cursor] Cursor to retreive items. It is the ID before which you want to retrieve the orders
         * @param {Array<number>} [ids] Fetch payment records of specified transaction ids
         * @param {Array<string>} [paymentIntegrationId] Fetch payment records of specified integration ids
         * @param {string} [orderId] Fetch payment records by orderId
         * @param {'completed' | 'pending' | 'cancelled'} [status] Fetch payment records with status
         * @param {boolean} [fetchAll] Fetch all records if you have admin Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRecordsGet: async (pageSize?: number, cursor?: string, ids?: Array<number>, paymentIntegrationId?: Array<string>, orderId?: string, status?: 'completed' | 'pending' | 'cancelled', fetchAll?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_RECORDS_READ"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (paymentIntegrationId) {
                localVarQueryParameter['paymentIntegrationId'] = paymentIntegrationId;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (fetchAll !== undefined) {
                localVarQueryParameter['fetchAll'] = fetchAll;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentRecordsApi - functional programming interface
 * @export
 */
export const PaymentRecordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentRecordsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PaymentRecordPostRequest} [paymentRecordPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentRecordPost(paymentRecordPostRequest?: PaymentRecordPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentRecordPost(paymentRecordPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [pageSize] Number of items to retreive
         * @param {string} [cursor] Cursor to retreive items. It is the ID before which you want to retrieve the orders
         * @param {Array<number>} [ids] Fetch payment records of specified transaction ids
         * @param {Array<string>} [paymentIntegrationId] Fetch payment records of specified integration ids
         * @param {string} [orderId] Fetch payment records by orderId
         * @param {'completed' | 'pending' | 'cancelled'} [status] Fetch payment records with status
         * @param {boolean} [fetchAll] Fetch all records if you have admin Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentRecordsGet(pageSize?: number, cursor?: string, ids?: Array<number>, paymentIntegrationId?: Array<string>, orderId?: string, status?: 'completed' | 'pending' | 'cancelled', fetchAll?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRecordsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentRecordsGet(pageSize, cursor, ids, paymentIntegrationId, orderId, status, fetchAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentRecordsApi - factory interface
 * @export
 */
export const PaymentRecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentRecordsApiFp(configuration)
    return {
        /**
         * 
         * @param {PaymentRecordsApiPaymentRecordPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRecordPost(requestParameters: PaymentRecordsApiPaymentRecordPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PaymentRecord> {
            return localVarFp.paymentRecordPost(requestParameters.paymentRecordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PaymentRecordsApiPaymentRecordsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRecordsGet(requestParameters: PaymentRecordsApiPaymentRecordsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PaymentRecordsGet200Response> {
            return localVarFp.paymentRecordsGet(requestParameters.pageSize, requestParameters.cursor, requestParameters.ids, requestParameters.paymentIntegrationId, requestParameters.orderId, requestParameters.status, requestParameters.fetchAll, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for paymentRecordPost operation in PaymentRecordsApi.
 * @export
 * @interface PaymentRecordsApiPaymentRecordPostRequest
 */
export interface PaymentRecordsApiPaymentRecordPostRequest {
    /**
     * 
     * @type {PaymentRecordPostRequest}
     * @memberof PaymentRecordsApiPaymentRecordPost
     */
    readonly paymentRecordPostRequest?: PaymentRecordPostRequest
}

/**
 * Request parameters for paymentRecordsGet operation in PaymentRecordsApi.
 * @export
 * @interface PaymentRecordsApiPaymentRecordsGetRequest
 */
export interface PaymentRecordsApiPaymentRecordsGetRequest {
    /**
     * Number of items to retreive
     * @type {number}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly pageSize?: number

    /**
     * Cursor to retreive items. It is the ID before which you want to retrieve the orders
     * @type {string}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly cursor?: string

    /**
     * Fetch payment records of specified transaction ids
     * @type {Array<number>}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly ids?: Array<number>

    /**
     * Fetch payment records of specified integration ids
     * @type {Array<string>}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly paymentIntegrationId?: Array<string>

    /**
     * Fetch payment records by orderId
     * @type {string}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly orderId?: string

    /**
     * Fetch payment records with status
     * @type {'completed' | 'pending' | 'cancelled'}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly status?: 'completed' | 'pending' | 'cancelled'

    /**
     * Fetch all records if you have admin Access
     * @type {boolean}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly fetchAll?: boolean
}

/**
 * PaymentRecordsApi - object-oriented interface
 * @export
 * @class PaymentRecordsApi
 * @extends {BaseAPI}
 */
export class PaymentRecordsApi extends BaseAPI {
    /**
     * 
     * @param {PaymentRecordsApiPaymentRecordPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentRecordsApi
     */
    public paymentRecordPost(requestParameters: PaymentRecordsApiPaymentRecordPostRequest = {}, options?: AxiosRequestConfig) {
        return PaymentRecordsApiFp(this.configuration).paymentRecordPost(requestParameters.paymentRecordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PaymentRecordsApiPaymentRecordsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentRecordsApi
     */
    public paymentRecordsGet(requestParameters: PaymentRecordsApiPaymentRecordsGetRequest = {}, options?: AxiosRequestConfig) {
        return PaymentRecordsApiFp(this.configuration).paymentRecordsGet(requestParameters.pageSize, requestParameters.cursor, requestParameters.ids, requestParameters.paymentIntegrationId, requestParameters.orderId, requestParameters.status, requestParameters.fetchAll, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentSystemsApi - axios parameter creator
 * @export
 */
export const PaymentSystemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get available payment systems
         * @param {string} teamId 
         * @param {string} [country] Fetch Payment Systems from a particular country
         * @param {string} [q] Fetch Payment Systems by query
         * @param {boolean} [fetchAll] Fetch all systems if you have admin Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsGet: async (teamId: string, country?: string, q?: string, fetchAll?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('paymentSystemsGet', 'teamId', teamId)
            const localVarPath = `/payment-systems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (fetchAll !== undefined) {
                localVarQueryParameter['fetchAll'] = fetchAll;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentSystemsApi - functional programming interface
 * @export
 */
export const PaymentSystemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentSystemsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get available payment systems
         * @param {string} teamId 
         * @param {string} [country] Fetch Payment Systems from a particular country
         * @param {string} [q] Fetch Payment Systems by query
         * @param {boolean} [fetchAll] Fetch all systems if you have admin Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentSystemsGet(teamId: string, country?: string, q?: string, fetchAll?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSystemsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentSystemsGet(teamId, country, q, fetchAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentSystemsApi - factory interface
 * @export
 */
export const PaymentSystemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentSystemsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get available payment systems
         * @param {PaymentSystemsApiPaymentSystemsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsGet(requestParameters: PaymentSystemsApiPaymentSystemsGetRequest, options?: AxiosRequestConfig): AxiosPromise<PaymentSystemsGet200Response> {
            return localVarFp.paymentSystemsGet(requestParameters.teamId, requestParameters.country, requestParameters.q, requestParameters.fetchAll, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for paymentSystemsGet operation in PaymentSystemsApi.
 * @export
 * @interface PaymentSystemsApiPaymentSystemsGetRequest
 */
export interface PaymentSystemsApiPaymentSystemsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentSystemsApiPaymentSystemsGet
     */
    readonly teamId: string

    /**
     * Fetch Payment Systems from a particular country
     * @type {string}
     * @memberof PaymentSystemsApiPaymentSystemsGet
     */
    readonly country?: string

    /**
     * Fetch Payment Systems by query
     * @type {string}
     * @memberof PaymentSystemsApiPaymentSystemsGet
     */
    readonly q?: string

    /**
     * Fetch all systems if you have admin Access
     * @type {boolean}
     * @memberof PaymentSystemsApiPaymentSystemsGet
     */
    readonly fetchAll?: boolean
}

/**
 * PaymentSystemsApi - object-oriented interface
 * @export
 * @class PaymentSystemsApi
 * @extends {BaseAPI}
 */
export class PaymentSystemsApi extends BaseAPI {
    /**
     * 
     * @summary Get available payment systems
     * @param {PaymentSystemsApiPaymentSystemsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSystemsApi
     */
    public paymentSystemsGet(requestParameters: PaymentSystemsApiPaymentSystemsGetRequest, options?: AxiosRequestConfig) {
        return PaymentSystemsApiFp(this.configuration).paymentSystemsGet(requestParameters.teamId, requestParameters.country, requestParameters.q, requestParameters.fetchAll, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServicesApi - axios parameter creator
 * @export
 */
export const ServicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This deletes the service and any trackings associated with it
         * @summary Removes the specified service
         * @param {string} id ID of service to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('servicesDelete', 'id', id)
            const localVarPath = `/services/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["INTEGRATIONS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This contains all the metadata required to display & create a \"tracking\" for said service. 
         * @summary Get the list of all supported integrations or services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a new service to the list
         * @param {PostServiceModel} [postServiceModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesPost: async (postServiceModel?: PostServiceModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["INTEGRATIONS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postServiceModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Call this endpoint to reload all service schemas by fetching them from the their respective hosted URLs 
         * @summary Reload all service schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesReload: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services/reload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["INTEGRATIONS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServicesApi - functional programming interface
 * @export
 */
export const ServicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServicesApiAxiosParamCreator(configuration)
    return {
        /**
         * This deletes the service and any trackings associated with it
         * @summary Removes the specified service
         * @param {string} id ID of service to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This contains all the metadata required to display & create a \"tracking\" for said service. 
         * @summary Get the list of all supported integrations or services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Services>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a new service to the list
         * @param {PostServiceModel} [postServiceModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesPost(postServiceModel?: PostServiceModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesPost(postServiceModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Call this endpoint to reload all service schemas by fetching them from the their respective hosted URLs 
         * @summary Reload all service schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesReload(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesReload(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServicesApi - factory interface
 * @export
 */
export const ServicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServicesApiFp(configuration)
    return {
        /**
         * This deletes the service and any trackings associated with it
         * @summary Removes the specified service
         * @param {ServicesApiServicesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesDelete(requestParameters: ServicesApiServicesDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.servicesDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This contains all the metadata required to display & create a \"tracking\" for said service. 
         * @summary Get the list of all supported integrations or services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesGet(options?: AxiosRequestConfig): AxiosPromise<Services> {
            return localVarFp.servicesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a new service to the list
         * @param {ServicesApiServicesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesPost(requestParameters: ServicesApiServicesPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.servicesPost(requestParameters.postServiceModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Call this endpoint to reload all service schemas by fetching them from the their respective hosted URLs 
         * @summary Reload all service schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesReload(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.servicesReload(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for servicesDelete operation in ServicesApi.
 * @export
 * @interface ServicesApiServicesDeleteRequest
 */
export interface ServicesApiServicesDeleteRequest {
    /**
     * ID of service to remove
     * @type {string}
     * @memberof ServicesApiServicesDelete
     */
    readonly id: string
}

/**
 * Request parameters for servicesPost operation in ServicesApi.
 * @export
 * @interface ServicesApiServicesPostRequest
 */
export interface ServicesApiServicesPostRequest {
    /**
     * 
     * @type {PostServiceModel}
     * @memberof ServicesApiServicesPost
     */
    readonly postServiceModel?: PostServiceModel
}

/**
 * ServicesApi - object-oriented interface
 * @export
 * @class ServicesApi
 * @extends {BaseAPI}
 */
export class ServicesApi extends BaseAPI {
    /**
     * This deletes the service and any trackings associated with it
     * @summary Removes the specified service
     * @param {ServicesApiServicesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesDelete(requestParameters: ServicesApiServicesDeleteRequest, options?: AxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This contains all the metadata required to display & create a \"tracking\" for said service. 
     * @summary Get the list of all supported integrations or services
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesGet(options?: AxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a new service to the list
     * @param {ServicesApiServicesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesPost(requestParameters: ServicesApiServicesPostRequest = {}, options?: AxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesPost(requestParameters.postServiceModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Call this endpoint to reload all service schemas by fetching them from the their respective hosted URLs 
     * @summary Reload all service schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesReload(options?: AxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesReload(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShopMetadataApi - axios parameter creator
 * @export
 */
export const ShopMetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the shop metadata
         * @param {string} [id] Fetch a particular team\&#39;s metadata
         * @param {string} [shopName] Fetch a particular shops\&#39;s metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopMetadataGet: async (id?: string, shopName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shop-metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (shopName !== undefined) {
                localVarQueryParameter['shopName'] = shopName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the shop metadata
         * @param {string} id Patch a particular team\&#39;s metadata
         * @param {ShopMetadataGet200Response} [shopMetadataGet200Response] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopMetadataPatch: async (id: string, shopMetadataGet200Response?: ShopMetadataGet200Response, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopMetadataPatch', 'id', id)
            const localVarPath = `/shop-metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["INTEGRATIONS_UPDATE"], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopMetadataGet200Response, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create shop metadata in bulk
         * @param {ShopMetadataPostRequest} [shopMetadataPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopMetadataPost: async (shopMetadataPostRequest?: ShopMetadataPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shop-metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopMetadataPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShopMetadataApi - functional programming interface
 * @export
 */
export const ShopMetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShopMetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the shop metadata
         * @param {string} [id] Fetch a particular team\&#39;s metadata
         * @param {string} [shopName] Fetch a particular shops\&#39;s metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopMetadataGet(id?: string, shopName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopMetadataGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopMetadataGet(id, shopName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the shop metadata
         * @param {string} id Patch a particular team\&#39;s metadata
         * @param {ShopMetadataGet200Response} [shopMetadataGet200Response] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopMetadataPatch(id: string, shopMetadataGet200Response?: ShopMetadataGet200Response, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopMetadataGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopMetadataPatch(id, shopMetadataGet200Response, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create shop metadata in bulk
         * @param {ShopMetadataPostRequest} [shopMetadataPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopMetadataPost(shopMetadataPostRequest?: ShopMetadataPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopMetadataPostRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopMetadataPost(shopMetadataPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShopMetadataApi - factory interface
 * @export
 */
export const ShopMetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShopMetadataApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the shop metadata
         * @param {ShopMetadataApiShopMetadataGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopMetadataGet(requestParameters: ShopMetadataApiShopMetadataGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ShopMetadataGet200Response> {
            return localVarFp.shopMetadataGet(requestParameters.id, requestParameters.shopName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the shop metadata
         * @param {ShopMetadataApiShopMetadataPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopMetadataPatch(requestParameters: ShopMetadataApiShopMetadataPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ShopMetadataGet200Response> {
            return localVarFp.shopMetadataPatch(requestParameters.id, requestParameters.shopMetadataGet200Response, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create shop metadata in bulk
         * @param {ShopMetadataApiShopMetadataPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopMetadataPost(requestParameters: ShopMetadataApiShopMetadataPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ShopMetadataPostRequest> {
            return localVarFp.shopMetadataPost(requestParameters.shopMetadataPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for shopMetadataGet operation in ShopMetadataApi.
 * @export
 * @interface ShopMetadataApiShopMetadataGetRequest
 */
export interface ShopMetadataApiShopMetadataGetRequest {
    /**
     * Fetch a particular team\&#39;s metadata
     * @type {string}
     * @memberof ShopMetadataApiShopMetadataGet
     */
    readonly id?: string

    /**
     * Fetch a particular shops\&#39;s metadata
     * @type {string}
     * @memberof ShopMetadataApiShopMetadataGet
     */
    readonly shopName?: string
}

/**
 * Request parameters for shopMetadataPatch operation in ShopMetadataApi.
 * @export
 * @interface ShopMetadataApiShopMetadataPatchRequest
 */
export interface ShopMetadataApiShopMetadataPatchRequest {
    /**
     * Patch a particular team\&#39;s metadata
     * @type {string}
     * @memberof ShopMetadataApiShopMetadataPatch
     */
    readonly id: string

    /**
     * 
     * @type {ShopMetadataGet200Response}
     * @memberof ShopMetadataApiShopMetadataPatch
     */
    readonly shopMetadataGet200Response?: ShopMetadataGet200Response
}

/**
 * Request parameters for shopMetadataPost operation in ShopMetadataApi.
 * @export
 * @interface ShopMetadataApiShopMetadataPostRequest
 */
export interface ShopMetadataApiShopMetadataPostRequest {
    /**
     * 
     * @type {ShopMetadataPostRequest}
     * @memberof ShopMetadataApiShopMetadataPost
     */
    readonly shopMetadataPostRequest?: ShopMetadataPostRequest
}

/**
 * ShopMetadataApi - object-oriented interface
 * @export
 * @class ShopMetadataApi
 * @extends {BaseAPI}
 */
export class ShopMetadataApi extends BaseAPI {
    /**
     * 
     * @summary Get the shop metadata
     * @param {ShopMetadataApiShopMetadataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopMetadataApi
     */
    public shopMetadataGet(requestParameters: ShopMetadataApiShopMetadataGetRequest = {}, options?: AxiosRequestConfig) {
        return ShopMetadataApiFp(this.configuration).shopMetadataGet(requestParameters.id, requestParameters.shopName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the shop metadata
     * @param {ShopMetadataApiShopMetadataPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopMetadataApi
     */
    public shopMetadataPatch(requestParameters: ShopMetadataApiShopMetadataPatchRequest, options?: AxiosRequestConfig) {
        return ShopMetadataApiFp(this.configuration).shopMetadataPatch(requestParameters.id, requestParameters.shopMetadataGet200Response, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create shop metadata in bulk
     * @param {ShopMetadataApiShopMetadataPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopMetadataApi
     */
    public shopMetadataPost(requestParameters: ShopMetadataApiShopMetadataPostRequest = {}, options?: AxiosRequestConfig) {
        return ShopMetadataApiFp(this.configuration).shopMetadataPost(requestParameters.shopMetadataPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShopProductCategoriesApi - axios parameter creator
 * @export
 */
export const ShopProductCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id Id of the category to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductCategoriesDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopProductCategoriesDelete', 'id', id)
            const localVarPath = `/product-categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all the product categories
         * @param {Array<string>} [id] Ids of the category to fetch
         * @param {boolean} [allProduct] If true then api return details of all products associated with the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductCategoriesGet: async (id?: Array<string>, allProduct?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_GET"], configuration)

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (allProduct !== undefined) {
                localVarQueryParameter['allProduct'] = allProduct;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a category for products
         * @param {ShopProductCategoriesPostRequest} [shopProductCategoriesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductCategoriesPost: async (shopProductCategoriesPostRequest?: ShopProductCategoriesPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopProductCategoriesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Id of the category to delete
         * @param {ShopProductCategoriesPostRequest} [shopProductCategoriesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductCategoriesUpdate: async (id: string, shopProductCategoriesPostRequest?: ShopProductCategoriesPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopProductCategoriesUpdate', 'id', id)
            const localVarPath = `/product-categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopProductCategoriesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShopProductCategoriesApi - functional programming interface
 * @export
 */
export const ShopProductCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShopProductCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id Id of the category to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductCategoriesDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductCategoriesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all the product categories
         * @param {Array<string>} [id] Ids of the category to fetch
         * @param {boolean} [allProduct] If true then api return details of all products associated with the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductCategoriesGet(id?: Array<string>, allProduct?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopProductCategoriesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductCategoriesGet(id, allProduct, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a category for products
         * @param {ShopProductCategoriesPostRequest} [shopProductCategoriesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductCategoriesPost(shopProductCategoriesPostRequest?: ShopProductCategoriesPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopProductCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductCategoriesPost(shopProductCategoriesPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Id of the category to delete
         * @param {ShopProductCategoriesPostRequest} [shopProductCategoriesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductCategoriesUpdate(id: string, shopProductCategoriesPostRequest?: ShopProductCategoriesPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductCategoriesUpdate(id, shopProductCategoriesPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShopProductCategoriesApi - factory interface
 * @export
 */
export const ShopProductCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShopProductCategoriesApiFp(configuration)
    return {
        /**
         * 
         * @param {ShopProductCategoriesApiShopProductCategoriesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductCategoriesDelete(requestParameters: ShopProductCategoriesApiShopProductCategoriesDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.shopProductCategoriesDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all the product categories
         * @param {ShopProductCategoriesApiShopProductCategoriesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductCategoriesGet(requestParameters: ShopProductCategoriesApiShopProductCategoriesGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ShopProductCategoriesGet200Response> {
            return localVarFp.shopProductCategoriesGet(requestParameters.id, requestParameters.allProduct, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a category for products
         * @param {ShopProductCategoriesApiShopProductCategoriesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductCategoriesPost(requestParameters: ShopProductCategoriesApiShopProductCategoriesPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ShopProductCategory> {
            return localVarFp.shopProductCategoriesPost(requestParameters.shopProductCategoriesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ShopProductCategoriesApiShopProductCategoriesUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductCategoriesUpdate(requestParameters: ShopProductCategoriesApiShopProductCategoriesUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.shopProductCategoriesUpdate(requestParameters.id, requestParameters.shopProductCategoriesPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for shopProductCategoriesDelete operation in ShopProductCategoriesApi.
 * @export
 * @interface ShopProductCategoriesApiShopProductCategoriesDeleteRequest
 */
export interface ShopProductCategoriesApiShopProductCategoriesDeleteRequest {
    /**
     * Id of the category to delete
     * @type {string}
     * @memberof ShopProductCategoriesApiShopProductCategoriesDelete
     */
    readonly id: string
}

/**
 * Request parameters for shopProductCategoriesGet operation in ShopProductCategoriesApi.
 * @export
 * @interface ShopProductCategoriesApiShopProductCategoriesGetRequest
 */
export interface ShopProductCategoriesApiShopProductCategoriesGetRequest {
    /**
     * Ids of the category to fetch
     * @type {Array<string>}
     * @memberof ShopProductCategoriesApiShopProductCategoriesGet
     */
    readonly id?: Array<string>

    /**
     * If true then api return details of all products associated with the category
     * @type {boolean}
     * @memberof ShopProductCategoriesApiShopProductCategoriesGet
     */
    readonly allProduct?: boolean
}

/**
 * Request parameters for shopProductCategoriesPost operation in ShopProductCategoriesApi.
 * @export
 * @interface ShopProductCategoriesApiShopProductCategoriesPostRequest
 */
export interface ShopProductCategoriesApiShopProductCategoriesPostRequest {
    /**
     * 
     * @type {ShopProductCategoriesPostRequest}
     * @memberof ShopProductCategoriesApiShopProductCategoriesPost
     */
    readonly shopProductCategoriesPostRequest?: ShopProductCategoriesPostRequest
}

/**
 * Request parameters for shopProductCategoriesUpdate operation in ShopProductCategoriesApi.
 * @export
 * @interface ShopProductCategoriesApiShopProductCategoriesUpdateRequest
 */
export interface ShopProductCategoriesApiShopProductCategoriesUpdateRequest {
    /**
     * Id of the category to delete
     * @type {string}
     * @memberof ShopProductCategoriesApiShopProductCategoriesUpdate
     */
    readonly id: string

    /**
     * 
     * @type {ShopProductCategoriesPostRequest}
     * @memberof ShopProductCategoriesApiShopProductCategoriesUpdate
     */
    readonly shopProductCategoriesPostRequest?: ShopProductCategoriesPostRequest
}

/**
 * ShopProductCategoriesApi - object-oriented interface
 * @export
 * @class ShopProductCategoriesApi
 * @extends {BaseAPI}
 */
export class ShopProductCategoriesApi extends BaseAPI {
    /**
     * 
     * @param {ShopProductCategoriesApiShopProductCategoriesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopProductCategoriesApi
     */
    public shopProductCategoriesDelete(requestParameters: ShopProductCategoriesApiShopProductCategoriesDeleteRequest, options?: AxiosRequestConfig) {
        return ShopProductCategoriesApiFp(this.configuration).shopProductCategoriesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all the product categories
     * @param {ShopProductCategoriesApiShopProductCategoriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopProductCategoriesApi
     */
    public shopProductCategoriesGet(requestParameters: ShopProductCategoriesApiShopProductCategoriesGetRequest = {}, options?: AxiosRequestConfig) {
        return ShopProductCategoriesApiFp(this.configuration).shopProductCategoriesGet(requestParameters.id, requestParameters.allProduct, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a category for products
     * @param {ShopProductCategoriesApiShopProductCategoriesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopProductCategoriesApi
     */
    public shopProductCategoriesPost(requestParameters: ShopProductCategoriesApiShopProductCategoriesPostRequest = {}, options?: AxiosRequestConfig) {
        return ShopProductCategoriesApiFp(this.configuration).shopProductCategoriesPost(requestParameters.shopProductCategoriesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShopProductCategoriesApiShopProductCategoriesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopProductCategoriesApi
     */
    public shopProductCategoriesUpdate(requestParameters: ShopProductCategoriesApiShopProductCategoriesUpdateRequest, options?: AxiosRequestConfig) {
        return ShopProductCategoriesApiFp(this.configuration).shopProductCategoriesUpdate(requestParameters.id, requestParameters.shopProductCategoriesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShopProductsApi - axios parameter creator
 * @export
 */
export const ShopProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Products
         * @param {Array<string>} id Ids of the products that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductDelete: async (id: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopProductDelete', 'id', id)
            const localVarPath = `/shop-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_DELETE"], configuration)

            if (id) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update shop product
         * @param {string} id Id of the product to update
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductUpdate: async (id: string, requestBody?: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopProductUpdate', 'id', id)
            const localVarPath = `/shop-products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all products for a team
         * @param {Array<string>} [category] Filter based on categories
         * @param {Array<string>} [id] 
         * @param {string} [cursor] 
         * @param {string} [q] Search items by this string
         * @param {number} [count] Number of items to return
         * @param {boolean} [returnTotalCount] 
         * @param {'name' | 'updatedAt'} [sortBy] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsGet: async (category?: Array<string>, id?: Array<string>, cursor?: string, q?: string, count?: number, returnTotalCount?: boolean, sortBy?: 'name' | 'updatedAt', order?: 'ASC' | 'DESC', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shop-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_GET"], configuration)

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Product
         * @param {ShopProductCreate} [shopProductCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsPost: async (shopProductCreate?: ShopProductCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shop-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopProductCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger sync of the specified products on ChatDaddy with WhatsApp
         * @param {string} accountId Account ID to sync products from/to
         * @param {string} id Product id to sync with WhatsApp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsSync: async (accountId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('shopProductsSync', 'accountId', accountId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopProductsSync', 'id', id)
            const localVarPath = `/shop-products/sync/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_UPDATE"], configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShopProductsApi - functional programming interface
 * @export
 */
export const ShopProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShopProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Products
         * @param {Array<string>} id Ids of the products that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductDelete(id: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update shop product
         * @param {string} id Id of the product to update
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductUpdate(id: string, requestBody?: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductUpdate(id, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all products for a team
         * @param {Array<string>} [category] Filter based on categories
         * @param {Array<string>} [id] 
         * @param {string} [cursor] 
         * @param {string} [q] Search items by this string
         * @param {number} [count] Number of items to return
         * @param {boolean} [returnTotalCount] 
         * @param {'name' | 'updatedAt'} [sortBy] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductsGet(category?: Array<string>, id?: Array<string>, cursor?: string, q?: string, count?: number, returnTotalCount?: boolean, sortBy?: 'name' | 'updatedAt', order?: 'ASC' | 'DESC', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopProductsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductsGet(category, id, cursor, q, count, returnTotalCount, sortBy, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a Product
         * @param {ShopProductCreate} [shopProductCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductsPost(shopProductCreate?: ShopProductCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopProductsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductsPost(shopProductCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger sync of the specified products on ChatDaddy with WhatsApp
         * @param {string} accountId Account ID to sync products from/to
         * @param {string} id Product id to sync with WhatsApp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductsSync(accountId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductsSync(accountId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShopProductsApi - factory interface
 * @export
 */
export const ShopProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShopProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Products
         * @param {ShopProductsApiShopProductDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductDelete(requestParameters: ShopProductsApiShopProductDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.shopProductDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update shop product
         * @param {ShopProductsApiShopProductUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductUpdate(requestParameters: ShopProductsApiShopProductUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<ShopProduct> {
            return localVarFp.shopProductUpdate(requestParameters.id, requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all products for a team
         * @param {ShopProductsApiShopProductsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsGet(requestParameters: ShopProductsApiShopProductsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ShopProductsGet200Response> {
            return localVarFp.shopProductsGet(requestParameters.category, requestParameters.id, requestParameters.cursor, requestParameters.q, requestParameters.count, requestParameters.returnTotalCount, requestParameters.sortBy, requestParameters.order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Product
         * @param {ShopProductsApiShopProductsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsPost(requestParameters: ShopProductsApiShopProductsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ShopProductsPost200Response> {
            return localVarFp.shopProductsPost(requestParameters.shopProductCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger sync of the specified products on ChatDaddy with WhatsApp
         * @param {ShopProductsApiShopProductsSyncRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsSync(requestParameters: ShopProductsApiShopProductsSyncRequest, options?: AxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.shopProductsSync(requestParameters.accountId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for shopProductDelete operation in ShopProductsApi.
 * @export
 * @interface ShopProductsApiShopProductDeleteRequest
 */
export interface ShopProductsApiShopProductDeleteRequest {
    /**
     * Ids of the products that needs to be deleted
     * @type {Array<string>}
     * @memberof ShopProductsApiShopProductDelete
     */
    readonly id: Array<string>
}

/**
 * Request parameters for shopProductUpdate operation in ShopProductsApi.
 * @export
 * @interface ShopProductsApiShopProductUpdateRequest
 */
export interface ShopProductsApiShopProductUpdateRequest {
    /**
     * Id of the product to update
     * @type {string}
     * @memberof ShopProductsApiShopProductUpdate
     */
    readonly id: string

    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ShopProductsApiShopProductUpdate
     */
    readonly requestBody?: { [key: string]: any; }
}

/**
 * Request parameters for shopProductsGet operation in ShopProductsApi.
 * @export
 * @interface ShopProductsApiShopProductsGetRequest
 */
export interface ShopProductsApiShopProductsGetRequest {
    /**
     * Filter based on categories
     * @type {Array<string>}
     * @memberof ShopProductsApiShopProductsGet
     */
    readonly category?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof ShopProductsApiShopProductsGet
     */
    readonly id?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof ShopProductsApiShopProductsGet
     */
    readonly cursor?: string

    /**
     * Search items by this string
     * @type {string}
     * @memberof ShopProductsApiShopProductsGet
     */
    readonly q?: string

    /**
     * Number of items to return
     * @type {number}
     * @memberof ShopProductsApiShopProductsGet
     */
    readonly count?: number

    /**
     * 
     * @type {boolean}
     * @memberof ShopProductsApiShopProductsGet
     */
    readonly returnTotalCount?: boolean

    /**
     * 
     * @type {'name' | 'updatedAt'}
     * @memberof ShopProductsApiShopProductsGet
     */
    readonly sortBy?: 'name' | 'updatedAt'

    /**
     * 
     * @type {'ASC' | 'DESC'}
     * @memberof ShopProductsApiShopProductsGet
     */
    readonly order?: 'ASC' | 'DESC'
}

/**
 * Request parameters for shopProductsPost operation in ShopProductsApi.
 * @export
 * @interface ShopProductsApiShopProductsPostRequest
 */
export interface ShopProductsApiShopProductsPostRequest {
    /**
     * 
     * @type {ShopProductCreate}
     * @memberof ShopProductsApiShopProductsPost
     */
    readonly shopProductCreate?: ShopProductCreate
}

/**
 * Request parameters for shopProductsSync operation in ShopProductsApi.
 * @export
 * @interface ShopProductsApiShopProductsSyncRequest
 */
export interface ShopProductsApiShopProductsSyncRequest {
    /**
     * Account ID to sync products from/to
     * @type {string}
     * @memberof ShopProductsApiShopProductsSync
     */
    readonly accountId: string

    /**
     * Product id to sync with WhatsApp.
     * @type {string}
     * @memberof ShopProductsApiShopProductsSync
     */
    readonly id: string
}

/**
 * ShopProductsApi - object-oriented interface
 * @export
 * @class ShopProductsApi
 * @extends {BaseAPI}
 */
export class ShopProductsApi extends BaseAPI {
    /**
     * 
     * @summary Delete Products
     * @param {ShopProductsApiShopProductDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopProductsApi
     */
    public shopProductDelete(requestParameters: ShopProductsApiShopProductDeleteRequest, options?: AxiosRequestConfig) {
        return ShopProductsApiFp(this.configuration).shopProductDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update shop product
     * @param {ShopProductsApiShopProductUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopProductsApi
     */
    public shopProductUpdate(requestParameters: ShopProductsApiShopProductUpdateRequest, options?: AxiosRequestConfig) {
        return ShopProductsApiFp(this.configuration).shopProductUpdate(requestParameters.id, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all products for a team
     * @param {ShopProductsApiShopProductsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopProductsApi
     */
    public shopProductsGet(requestParameters: ShopProductsApiShopProductsGetRequest = {}, options?: AxiosRequestConfig) {
        return ShopProductsApiFp(this.configuration).shopProductsGet(requestParameters.category, requestParameters.id, requestParameters.cursor, requestParameters.q, requestParameters.count, requestParameters.returnTotalCount, requestParameters.sortBy, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Product
     * @param {ShopProductsApiShopProductsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopProductsApi
     */
    public shopProductsPost(requestParameters: ShopProductsApiShopProductsPostRequest = {}, options?: AxiosRequestConfig) {
        return ShopProductsApiFp(this.configuration).shopProductsPost(requestParameters.shopProductCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger sync of the specified products on ChatDaddy with WhatsApp
     * @param {ShopProductsApiShopProductsSyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopProductsApi
     */
    public shopProductsSync(requestParameters: ShopProductsApiShopProductsSyncRequest, options?: AxiosRequestConfig) {
        return ShopProductsApiFp(this.configuration).shopProductsSync(requestParameters.accountId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrackingProductsApi - axios parameter creator
 * @export
 */
export const TrackingProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get products of the tracking
         * @param {number} trackingId Fetch products of the specified trackingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet: async (trackingId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('productsGet', 'trackingId', trackingId)
            const localVarPath = `/products/{trackingId}`
                .replace(`{${"trackingId"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackingProductsApi - functional programming interface
 * @export
 */
export const TrackingProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackingProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get products of the tracking
         * @param {number} trackingId Fetch products of the specified trackingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGet(trackingId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProductsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGet(trackingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrackingProductsApi - factory interface
 * @export
 */
export const TrackingProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackingProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get products of the tracking
         * @param {TrackingProductsApiProductsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet(requestParameters: TrackingProductsApiProductsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ServiceProductsData> {
            return localVarFp.productsGet(requestParameters.trackingId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for productsGet operation in TrackingProductsApi.
 * @export
 * @interface TrackingProductsApiProductsGetRequest
 */
export interface TrackingProductsApiProductsGetRequest {
    /**
     * Fetch products of the specified trackingId
     * @type {number}
     * @memberof TrackingProductsApiProductsGet
     */
    readonly trackingId: number
}

/**
 * TrackingProductsApi - object-oriented interface
 * @export
 * @class TrackingProductsApi
 * @extends {BaseAPI}
 */
export class TrackingProductsApi extends BaseAPI {
    /**
     * 
     * @summary Get products of the tracking
     * @param {TrackingProductsApiProductsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingProductsApi
     */
    public productsGet(requestParameters: TrackingProductsApiProductsGetRequest, options?: AxiosRequestConfig) {
        return TrackingProductsApiFp(this.configuration).productsGet(requestParameters.trackingId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrackingsApi - axios parameter creator
 * @export
 */
export const TrackingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the event histor
         * @param {number} [trackingId] Fetch orders of the specified trackingId
         * @param {number} [phoneNumber] Fetch orders sent to the specified phone number
         * @param {number} [triggerId] Fetch orders of the specified triggerId
         * @param {number} [pageSize] Number of items to retreive
         * @param {string} [cursor] Cursor to retreive items. It can be anyone of orderBy by which you want to retrieve the orders
         * @param {'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate'} [orderBy] Order by which value
         * @param {'ASC' | 'DESC'} [direction] Sorting order of the response
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {Array<string>} [orderStatus] 
         * @param {Array<string>} [paymentStatus] 
         * @param {Array<string>} [messageStatus] 
         * @param {string} [q] Query to retrieve select orders
         * @param {boolean} [excludeTests] Should tests be excluded
         * @param {boolean} [includeNullTriggers] Should events which did not trigger an EventTrigger be included?
         * @param {boolean} [returnTotal] Should a total of the number of orders returned by the given query be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGet: async (trackingId?: number, phoneNumber?: number, triggerId?: number, pageSize?: number, cursor?: string, orderBy?: 'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate', direction?: 'ASC' | 'DESC', startTime?: string, endTime?: string, orderStatus?: Array<string>, paymentStatus?: Array<string>, messageStatus?: Array<string>, q?: string, excludeTests?: boolean, includeNullTriggers?: boolean, returnTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tracking/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_READ"], configuration)

            if (trackingId !== undefined) {
                localVarQueryParameter['trackingId'] = trackingId;
            }

            if (phoneNumber !== undefined) {
                localVarQueryParameter['phoneNumber'] = phoneNumber;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (orderStatus) {
                localVarQueryParameter['orderStatus'] = orderStatus;
            }

            if (paymentStatus) {
                localVarQueryParameter['paymentStatus'] = paymentStatus;
            }

            if (messageStatus) {
                localVarQueryParameter['messageStatus'] = messageStatus;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (excludeTests !== undefined) {
                localVarQueryParameter['excludeTests'] = excludeTests;
            }

            if (includeNullTriggers !== undefined) {
                localVarQueryParameter['includeNullTriggers'] = includeNullTriggers;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the updated order data
         * @param {number} [trackingId] Fetch orders of the specified trackingId
         * @param {number} [phoneNumber] Fetch orders sent to the specified phone number
         * @param {number} [pageSize] Number of items to retreive
         * @param {string} [cursor] Cursor to retreive items. It can be anyone of orderBy by which you want to retrieve the orders
         * @param {'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate' | 'createdAt' | 'updatedAt'} [orderBy] Order by which value
         * @param {'ASC' | 'DESC'} [direction] Sorting order of the response
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {Array<string>} [orderStatus] 
         * @param {Array<string>} [paymentStatus] 
         * @param {Array<string>} [messageStatus] 
         * @param {string} [q] Query to retrieve select orders
         * @param {boolean} [excludeTests] Should tests be excluded
         * @param {boolean} [returnTotal] Should a total of the number of orders returned by the given query be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDataGet: async (trackingId?: number, phoneNumber?: number, pageSize?: number, cursor?: string, orderBy?: 'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate' | 'createdAt' | 'updatedAt', direction?: 'ASC' | 'DESC', startTime?: string, endTime?: string, orderStatus?: Array<string>, paymentStatus?: Array<string>, messageStatus?: Array<string>, q?: string, excludeTests?: boolean, returnTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_READ"], configuration)

            if (trackingId !== undefined) {
                localVarQueryParameter['trackingId'] = trackingId;
            }

            if (phoneNumber !== undefined) {
                localVarQueryParameter['phoneNumber'] = phoneNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (orderStatus) {
                localVarQueryParameter['orderStatus'] = orderStatus;
            }

            if (paymentStatus) {
                localVarQueryParameter['paymentStatus'] = paymentStatus;
            }

            if (messageStatus) {
                localVarQueryParameter['messageStatus'] = messageStatus;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (excludeTests !== undefined) {
                localVarQueryParameter['excludeTests'] = excludeTests;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This deletes the orders from the Database permanently.
         * @summary Delete orders
         * @param {OrderDeleteRequest} [orderDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDelete: async (orderDeleteRequest?: OrderDeleteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_DELETE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update order details
         * @param {string} orderId The orderId of the tracking made available to the service
         * @param {UpdateOrderDataModel} [updateOrderDataModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPatch: async (orderId: string, updateOrderDataModel?: UpdateOrderDataModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderPatch', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrderDataModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This deletes the tracking and its associated flowIds from the Database permanently.
         * @summary Stop tracking
         * @param {number} trackingId The Tracking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingDelete: async (trackingId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('trackingDelete', 'trackingId', trackingId)
            const localVarPath = `/tracking/{trackingId}`
                .replace(`{${"trackingId"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of all trackings for your team 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tracking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit existing events\' flowIds or create new events. Credentials array is forwarded to scrapper for updation.
         * @summary Update events, credentials, notifyUsers or isActive of a tracking
         * @param {number} trackingId The Tracking
         * @param {UpdateTracking} [updateTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingPatch: async (trackingId: number, updateTracking?: UpdateTracking, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('trackingPatch', 'trackingId', trackingId)
            const localVarPath = `/tracking/{trackingId}`
                .replace(`{${"trackingId"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTracking, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start tracking of a new service for a team
         * @param {PostTracking} [postTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingPost: async (postTracking?: PostTracking, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tracking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTracking, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used by the external tracking integration to update the error state of a tracking. The scrapper will call this endpoint when it encounters an irrecoverable error while scraping. 
         * @summary Update the error state of a tracking
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {UpdateTrackingErrorState} [updateTrackingErrorState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingUpdateErrorState: async (secretId: string, updateTrackingErrorState?: UpdateTrackingErrorState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('trackingUpdateErrorState', 'secretId', secretId)
            const localVarPath = `/tracking/{secretId}/update-error-state`
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTrackingErrorState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test a trigger
         * @param {number} trackingId The trackingId to test
         * @param {number} triggerId The triggerId to test
         * @param {string} [recipientPhoneNumber] Phone number to send the test to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTest: async (trackingId: number, triggerId: number, recipientPhoneNumber?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('triggerTest', 'trackingId', trackingId)
            // verify required parameter 'triggerId' is not null or undefined
            assertParamExists('triggerTest', 'triggerId', triggerId)
            const localVarPath = `/tracking/{trackingId}/{triggerId}/test`
                .replace(`{${"trackingId"}}`, encodeURIComponent(String(trackingId)))
                .replace(`{${"triggerId"}}`, encodeURIComponent(String(triggerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_UPDATE"], configuration)

            if (recipientPhoneNumber !== undefined) {
                localVarQueryParameter['recipientPhoneNumber'] = recipientPhoneNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackingsApi - functional programming interface
 * @export
 */
export const TrackingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the event histor
         * @param {number} [trackingId] Fetch orders of the specified trackingId
         * @param {number} [phoneNumber] Fetch orders sent to the specified phone number
         * @param {number} [triggerId] Fetch orders of the specified triggerId
         * @param {number} [pageSize] Number of items to retreive
         * @param {string} [cursor] Cursor to retreive items. It can be anyone of orderBy by which you want to retrieve the orders
         * @param {'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate'} [orderBy] Order by which value
         * @param {'ASC' | 'DESC'} [direction] Sorting order of the response
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {Array<string>} [orderStatus] 
         * @param {Array<string>} [paymentStatus] 
         * @param {Array<string>} [messageStatus] 
         * @param {string} [q] Query to retrieve select orders
         * @param {boolean} [excludeTests] Should tests be excluded
         * @param {boolean} [includeNullTriggers] Should events which did not trigger an EventTrigger be included?
         * @param {boolean} [returnTotal] Should a total of the number of orders returned by the given query be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataGet(trackingId?: number, phoneNumber?: number, triggerId?: number, pageSize?: number, cursor?: string, orderBy?: 'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate', direction?: 'ASC' | 'DESC', startTime?: string, endTime?: string, orderStatus?: Array<string>, paymentStatus?: Array<string>, messageStatus?: Array<string>, q?: string, excludeTests?: boolean, includeNullTriggers?: boolean, returnTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataGet(trackingId, phoneNumber, triggerId, pageSize, cursor, orderBy, direction, startTime, endTime, orderStatus, paymentStatus, messageStatus, q, excludeTests, includeNullTriggers, returnTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the updated order data
         * @param {number} [trackingId] Fetch orders of the specified trackingId
         * @param {number} [phoneNumber] Fetch orders sent to the specified phone number
         * @param {number} [pageSize] Number of items to retreive
         * @param {string} [cursor] Cursor to retreive items. It can be anyone of orderBy by which you want to retrieve the orders
         * @param {'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate' | 'createdAt' | 'updatedAt'} [orderBy] Order by which value
         * @param {'ASC' | 'DESC'} [direction] Sorting order of the response
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {Array<string>} [orderStatus] 
         * @param {Array<string>} [paymentStatus] 
         * @param {Array<string>} [messageStatus] 
         * @param {string} [q] Query to retrieve select orders
         * @param {boolean} [excludeTests] Should tests be excluded
         * @param {boolean} [returnTotal] Should a total of the number of orders returned by the given query be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderDataGet(trackingId?: number, phoneNumber?: number, pageSize?: number, cursor?: string, orderBy?: 'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate' | 'createdAt' | 'updatedAt', direction?: 'ASC' | 'DESC', startTime?: string, endTime?: string, orderStatus?: Array<string>, paymentStatus?: Array<string>, messageStatus?: Array<string>, q?: string, excludeTests?: boolean, returnTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDataGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderDataGet(trackingId, phoneNumber, pageSize, cursor, orderBy, direction, startTime, endTime, orderStatus, paymentStatus, messageStatus, q, excludeTests, returnTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes the orders from the Database permanently.
         * @summary Delete orders
         * @param {OrderDeleteRequest} [orderDeleteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderDelete(orderDeleteRequest?: OrderDeleteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderDelete(orderDeleteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update order details
         * @param {string} orderId The orderId of the tracking made available to the service
         * @param {UpdateOrderDataModel} [updateOrderDataModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderPatch(orderId: string, updateOrderDataModel?: UpdateOrderDataModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderPatch(orderId, updateOrderDataModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes the tracking and its associated flowIds from the Database permanently.
         * @summary Stop tracking
         * @param {number} trackingId The Tracking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingDelete(trackingId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingDelete(trackingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of all trackings for your team 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackServices>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit existing events\' flowIds or create new events. Credentials array is forwarded to scrapper for updation.
         * @summary Update events, credentials, notifyUsers or isActive of a tracking
         * @param {number} trackingId The Tracking
         * @param {UpdateTracking} [updateTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingPatch(trackingId: number, updateTracking?: UpdateTracking, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingPatch(trackingId, updateTracking, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start tracking of a new service for a team
         * @param {PostTracking} [postTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingPost(postTracking?: PostTracking, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingPost(postTracking, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is used by the external tracking integration to update the error state of a tracking. The scrapper will call this endpoint when it encounters an irrecoverable error while scraping. 
         * @summary Update the error state of a tracking
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {UpdateTrackingErrorState} [updateTrackingErrorState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingUpdateErrorState(secretId: string, updateTrackingErrorState?: UpdateTrackingErrorState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingUpdateErrorState(secretId, updateTrackingErrorState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Test a trigger
         * @param {number} trackingId The trackingId to test
         * @param {number} triggerId The triggerId to test
         * @param {string} [recipientPhoneNumber] Phone number to send the test to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerTest(trackingId: number, triggerId: number, recipientPhoneNumber?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TriggerTest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerTest(trackingId, triggerId, recipientPhoneNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrackingsApi - factory interface
 * @export
 */
export const TrackingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the event histor
         * @param {TrackingsApiDataGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGet(requestParameters: TrackingsApiDataGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<DataGet200Response> {
            return localVarFp.dataGet(requestParameters.trackingId, requestParameters.phoneNumber, requestParameters.triggerId, requestParameters.pageSize, requestParameters.cursor, requestParameters.orderBy, requestParameters.direction, requestParameters.startTime, requestParameters.endTime, requestParameters.orderStatus, requestParameters.paymentStatus, requestParameters.messageStatus, requestParameters.q, requestParameters.excludeTests, requestParameters.includeNullTriggers, requestParameters.returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the updated order data
         * @param {TrackingsApiOrderDataGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDataGet(requestParameters: TrackingsApiOrderDataGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<OrderDataGet200Response> {
            return localVarFp.orderDataGet(requestParameters.trackingId, requestParameters.phoneNumber, requestParameters.pageSize, requestParameters.cursor, requestParameters.orderBy, requestParameters.direction, requestParameters.startTime, requestParameters.endTime, requestParameters.orderStatus, requestParameters.paymentStatus, requestParameters.messageStatus, requestParameters.q, requestParameters.excludeTests, requestParameters.returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * This deletes the orders from the Database permanently.
         * @summary Delete orders
         * @param {TrackingsApiOrderDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDelete(requestParameters: TrackingsApiOrderDeleteRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderDelete(requestParameters.orderDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update order details
         * @param {TrackingsApiOrderPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPatch(requestParameters: TrackingsApiOrderPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderPatch(requestParameters.orderId, requestParameters.updateOrderDataModel, options).then((request) => request(axios, basePath));
        },
        /**
         * This deletes the tracking and its associated flowIds from the Database permanently.
         * @summary Stop tracking
         * @param {TrackingsApiTrackingDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingDelete(requestParameters: TrackingsApiTrackingDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.trackingDelete(requestParameters.trackingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of all trackings for your team 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingGet(options?: AxiosRequestConfig): AxiosPromise<TrackServices> {
            return localVarFp.trackingGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Edit existing events\' flowIds or create new events. Credentials array is forwarded to scrapper for updation.
         * @summary Update events, credentials, notifyUsers or isActive of a tracking
         * @param {TrackingsApiTrackingPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingPatch(requestParameters: TrackingsApiTrackingPatchRequest, options?: AxiosRequestConfig): AxiosPromise<TrackingPatch200Response> {
            return localVarFp.trackingPatch(requestParameters.trackingId, requestParameters.updateTracking, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start tracking of a new service for a team
         * @param {TrackingsApiTrackingPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingPost(requestParameters: TrackingsApiTrackingPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<TrackingPost200Response> {
            return localVarFp.trackingPost(requestParameters.postTracking, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used by the external tracking integration to update the error state of a tracking. The scrapper will call this endpoint when it encounters an irrecoverable error while scraping. 
         * @summary Update the error state of a tracking
         * @param {TrackingsApiTrackingUpdateErrorStateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingUpdateErrorState(requestParameters: TrackingsApiTrackingUpdateErrorStateRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.trackingUpdateErrorState(requestParameters.secretId, requestParameters.updateTrackingErrorState, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test a trigger
         * @param {TrackingsApiTriggerTestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTest(requestParameters: TrackingsApiTriggerTestRequest, options?: AxiosRequestConfig): AxiosPromise<TriggerTest200Response> {
            return localVarFp.triggerTest(requestParameters.trackingId, requestParameters.triggerId, requestParameters.recipientPhoneNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for dataGet operation in TrackingsApi.
 * @export
 * @interface TrackingsApiDataGetRequest
 */
export interface TrackingsApiDataGetRequest {
    /**
     * Fetch orders of the specified trackingId
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly trackingId?: number

    /**
     * Fetch orders sent to the specified phone number
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly phoneNumber?: number

    /**
     * Fetch orders of the specified triggerId
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly triggerId?: number

    /**
     * Number of items to retreive
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly pageSize?: number

    /**
     * Cursor to retreive items. It can be anyone of orderBy by which you want to retrieve the orders
     * @type {string}
     * @memberof TrackingsApiDataGet
     */
    readonly cursor?: string

    /**
     * Order by which value
     * @type {'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate'}
     * @memberof TrackingsApiDataGet
     */
    readonly orderBy?: 'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate'

    /**
     * Sorting order of the response
     * @type {'ASC' | 'DESC'}
     * @memberof TrackingsApiDataGet
     */
    readonly direction?: 'ASC' | 'DESC'

    /**
     * 
     * @type {string}
     * @memberof TrackingsApiDataGet
     */
    readonly startTime?: string

    /**
     * 
     * @type {string}
     * @memberof TrackingsApiDataGet
     */
    readonly endTime?: string

    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingsApiDataGet
     */
    readonly orderStatus?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingsApiDataGet
     */
    readonly paymentStatus?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingsApiDataGet
     */
    readonly messageStatus?: Array<string>

    /**
     * Query to retrieve select orders
     * @type {string}
     * @memberof TrackingsApiDataGet
     */
    readonly q?: string

    /**
     * Should tests be excluded
     * @type {boolean}
     * @memberof TrackingsApiDataGet
     */
    readonly excludeTests?: boolean

    /**
     * Should events which did not trigger an EventTrigger be included?
     * @type {boolean}
     * @memberof TrackingsApiDataGet
     */
    readonly includeNullTriggers?: boolean

    /**
     * Should a total of the number of orders returned by the given query be included
     * @type {boolean}
     * @memberof TrackingsApiDataGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for orderDataGet operation in TrackingsApi.
 * @export
 * @interface TrackingsApiOrderDataGetRequest
 */
export interface TrackingsApiOrderDataGetRequest {
    /**
     * Fetch orders of the specified trackingId
     * @type {number}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly trackingId?: number

    /**
     * Fetch orders sent to the specified phone number
     * @type {number}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly phoneNumber?: number

    /**
     * Number of items to retreive
     * @type {number}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly pageSize?: number

    /**
     * Cursor to retreive items. It can be anyone of orderBy by which you want to retrieve the orders
     * @type {string}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly cursor?: string

    /**
     * Order by which value
     * @type {'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate' | 'createdAt' | 'updatedAt'}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly orderBy?: 'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate' | 'createdAt' | 'updatedAt'

    /**
     * Sorting order of the response
     * @type {'ASC' | 'DESC'}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly direction?: 'ASC' | 'DESC'

    /**
     * 
     * @type {string}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly startTime?: string

    /**
     * 
     * @type {string}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly endTime?: string

    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly orderStatus?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly paymentStatus?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly messageStatus?: Array<string>

    /**
     * Query to retrieve select orders
     * @type {string}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly q?: string

    /**
     * Should tests be excluded
     * @type {boolean}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly excludeTests?: boolean

    /**
     * Should a total of the number of orders returned by the given query be included
     * @type {boolean}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for orderDelete operation in TrackingsApi.
 * @export
 * @interface TrackingsApiOrderDeleteRequest
 */
export interface TrackingsApiOrderDeleteRequest {
    /**
     * 
     * @type {OrderDeleteRequest}
     * @memberof TrackingsApiOrderDelete
     */
    readonly orderDeleteRequest?: OrderDeleteRequest
}

/**
 * Request parameters for orderPatch operation in TrackingsApi.
 * @export
 * @interface TrackingsApiOrderPatchRequest
 */
export interface TrackingsApiOrderPatchRequest {
    /**
     * The orderId of the tracking made available to the service
     * @type {string}
     * @memberof TrackingsApiOrderPatch
     */
    readonly orderId: string

    /**
     * 
     * @type {UpdateOrderDataModel}
     * @memberof TrackingsApiOrderPatch
     */
    readonly updateOrderDataModel?: UpdateOrderDataModel
}

/**
 * Request parameters for trackingDelete operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTrackingDeleteRequest
 */
export interface TrackingsApiTrackingDeleteRequest {
    /**
     * The Tracking
     * @type {number}
     * @memberof TrackingsApiTrackingDelete
     */
    readonly trackingId: number
}

/**
 * Request parameters for trackingPatch operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTrackingPatchRequest
 */
export interface TrackingsApiTrackingPatchRequest {
    /**
     * The Tracking
     * @type {number}
     * @memberof TrackingsApiTrackingPatch
     */
    readonly trackingId: number

    /**
     * 
     * @type {UpdateTracking}
     * @memberof TrackingsApiTrackingPatch
     */
    readonly updateTracking?: UpdateTracking
}

/**
 * Request parameters for trackingPost operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTrackingPostRequest
 */
export interface TrackingsApiTrackingPostRequest {
    /**
     * 
     * @type {PostTracking}
     * @memberof TrackingsApiTrackingPost
     */
    readonly postTracking?: PostTracking
}

/**
 * Request parameters for trackingUpdateErrorState operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTrackingUpdateErrorStateRequest
 */
export interface TrackingsApiTrackingUpdateErrorStateRequest {
    /**
     * The secret ID of the tracking made available to the service
     * @type {string}
     * @memberof TrackingsApiTrackingUpdateErrorState
     */
    readonly secretId: string

    /**
     * 
     * @type {UpdateTrackingErrorState}
     * @memberof TrackingsApiTrackingUpdateErrorState
     */
    readonly updateTrackingErrorState?: UpdateTrackingErrorState
}

/**
 * Request parameters for triggerTest operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTriggerTestRequest
 */
export interface TrackingsApiTriggerTestRequest {
    /**
     * The trackingId to test
     * @type {number}
     * @memberof TrackingsApiTriggerTest
     */
    readonly trackingId: number

    /**
     * The triggerId to test
     * @type {number}
     * @memberof TrackingsApiTriggerTest
     */
    readonly triggerId: number

    /**
     * Phone number to send the test to
     * @type {string}
     * @memberof TrackingsApiTriggerTest
     */
    readonly recipientPhoneNumber?: string
}

/**
 * TrackingsApi - object-oriented interface
 * @export
 * @class TrackingsApi
 * @extends {BaseAPI}
 */
export class TrackingsApi extends BaseAPI {
    /**
     * 
     * @summary Get the event histor
     * @param {TrackingsApiDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public dataGet(requestParameters: TrackingsApiDataGetRequest = {}, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).dataGet(requestParameters.trackingId, requestParameters.phoneNumber, requestParameters.triggerId, requestParameters.pageSize, requestParameters.cursor, requestParameters.orderBy, requestParameters.direction, requestParameters.startTime, requestParameters.endTime, requestParameters.orderStatus, requestParameters.paymentStatus, requestParameters.messageStatus, requestParameters.q, requestParameters.excludeTests, requestParameters.includeNullTriggers, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the updated order data
     * @param {TrackingsApiOrderDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public orderDataGet(requestParameters: TrackingsApiOrderDataGetRequest = {}, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).orderDataGet(requestParameters.trackingId, requestParameters.phoneNumber, requestParameters.pageSize, requestParameters.cursor, requestParameters.orderBy, requestParameters.direction, requestParameters.startTime, requestParameters.endTime, requestParameters.orderStatus, requestParameters.paymentStatus, requestParameters.messageStatus, requestParameters.q, requestParameters.excludeTests, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes the orders from the Database permanently.
     * @summary Delete orders
     * @param {TrackingsApiOrderDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public orderDelete(requestParameters: TrackingsApiOrderDeleteRequest = {}, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).orderDelete(requestParameters.orderDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update order details
     * @param {TrackingsApiOrderPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public orderPatch(requestParameters: TrackingsApiOrderPatchRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).orderPatch(requestParameters.orderId, requestParameters.updateOrderDataModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes the tracking and its associated flowIds from the Database permanently.
     * @summary Stop tracking
     * @param {TrackingsApiTrackingDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingDelete(requestParameters: TrackingsApiTrackingDeleteRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingDelete(requestParameters.trackingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of all trackings for your team 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingGet(options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit existing events\' flowIds or create new events. Credentials array is forwarded to scrapper for updation.
     * @summary Update events, credentials, notifyUsers or isActive of a tracking
     * @param {TrackingsApiTrackingPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingPatch(requestParameters: TrackingsApiTrackingPatchRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingPatch(requestParameters.trackingId, requestParameters.updateTracking, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start tracking of a new service for a team
     * @param {TrackingsApiTrackingPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingPost(requestParameters: TrackingsApiTrackingPostRequest = {}, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingPost(requestParameters.postTracking, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used by the external tracking integration to update the error state of a tracking. The scrapper will call this endpoint when it encounters an irrecoverable error while scraping. 
     * @summary Update the error state of a tracking
     * @param {TrackingsApiTrackingUpdateErrorStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingUpdateErrorState(requestParameters: TrackingsApiTrackingUpdateErrorStateRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingUpdateErrorState(requestParameters.secretId, requestParameters.updateTrackingErrorState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test a trigger
     * @param {TrackingsApiTriggerTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public triggerTest(requestParameters: TrackingsApiTriggerTestRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).triggerTest(requestParameters.trackingId, requestParameters.triggerId, requestParameters.recipientPhoneNumber, options).then((request) => request(this.axios, this.basePath));
    }
}


