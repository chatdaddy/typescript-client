const BASE_PATH = "https://api-notifications.chatdaddy.tech".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Shop Service
 * Responsible for all shop related APIs. Formerly known as \"notifications\" or \"easysend\" service 
 *
 * The version of the OpenAPI document: 2.1.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @interface AddServiceModel
 */
export interface AddServiceModel {
    /**
     * Name of the service/scrapper
     * @type {string}
     * @memberof AddServiceModel
     */
    'name': string;
    /**
     * A service that implements only the schema route
     * @type {boolean}
     * @memberof AddServiceModel
     */
    'isEphemeral'?: boolean;
    /**
     * If true, then parameters wont be checked when editing a trigger
     * @type {boolean}
     * @memberof AddServiceModel
     */
    'skipParameterValidation'?: boolean;
    /**
     * any image/link representing the service/scrapper
     * @type {string}
     * @memberof AddServiceModel
     */
    'imgUrl': string;
    /**
     * Description of the service/scrapper
     * @type {string}
     * @memberof AddServiceModel
     */
    'description': string;
    /**
     * Whether the service supports the products API
     * @type {boolean}
     * @memberof AddServiceModel
     */
    'supportsProducts'?: boolean;
    /**
     * 
     * @type {{ [key: string]: AddServiceModelParametersValue; }}
     * @memberof AddServiceModel
     */
    'parameters': { [key: string]: AddServiceModelParametersValue; };
    /**
     * 
     * @type {{ [key: string]: AddServiceModelSetupValue; }}
     * @memberof AddServiceModel
     */
    'setup': { [key: string]: AddServiceModelSetupValue; };
    /**
     * 
     * @type {AddServiceModelOutput}
     * @memberof AddServiceModel
     */
    'output'?: AddServiceModelOutput;
}
/**
 * 
 * @export
 * @interface AddServiceModelOutput
 */
export interface AddServiceModelOutput {
    /**
     * URL to send webhooks to
     * @type {string}
     * @memberof AddServiceModelOutput
     */
    'webhookUrl'?: string;
}
/**
 * @type AddServiceModelParametersValue
 * @export
 */
export type AddServiceModelParametersValue = AddServiceModelParametersValueOneOf | AddServiceModelParametersValueOneOf1 | AddServiceModelParametersValueOneOf2 | AddServiceModelParametersValueOneOf3;

/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf
 */
export interface AddServiceModelParametersValueOneOf {
    /**
     * 
     * @type {AddServiceModelParametersValueOneOfCanBeConditionedOn}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'canBeConditionedOn'?: AddServiceModelParametersValueOneOfCanBeConditionedOn;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'type'?: AddServiceModelParametersValueOneOfTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'format'?: AddServiceModelParametersValueOneOfFormatEnum;
    /**
     * Inclusive array of possible values this property can take
     * @type {Array<string>}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'enum'?: Array<string>;
    /**
     * Non-inclusive array of possible values this property can take
     * @type {Array<string>}
     * @memberof AddServiceModelParametersValueOneOf
     */
    'examples'?: Array<string>;
}

export const AddServiceModelParametersValueOneOfTypeEnum = {
    String: 'string'
} as const;

export type AddServiceModelParametersValueOneOfTypeEnum = typeof AddServiceModelParametersValueOneOfTypeEnum[keyof typeof AddServiceModelParametersValueOneOfTypeEnum];
export const AddServiceModelParametersValueOneOfFormatEnum = {
    DateTime: 'date-time',
    Date: 'date'
} as const;

export type AddServiceModelParametersValueOneOfFormatEnum = typeof AddServiceModelParametersValueOneOfFormatEnum[keyof typeof AddServiceModelParametersValueOneOfFormatEnum];

/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf1
 */
export interface AddServiceModelParametersValueOneOf1 {
    /**
     * 
     * @type {AddServiceModelParametersValueOneOfCanBeConditionedOn}
     * @memberof AddServiceModelParametersValueOneOf1
     */
    'canBeConditionedOn'?: AddServiceModelParametersValueOneOfCanBeConditionedOn;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf1
     */
    'type': AddServiceModelParametersValueOneOf1TypeEnum;
    /**
     * Inclusive array of possible values this property can take
     * @type {Array<number>}
     * @memberof AddServiceModelParametersValueOneOf1
     */
    'enum'?: Array<number>;
    /**
     * Non-inclusive array of possible values this property can take
     * @type {Array<number>}
     * @memberof AddServiceModelParametersValueOneOf1
     */
    'examples'?: Array<number>;
}

export const AddServiceModelParametersValueOneOf1TypeEnum = {
    Number: 'number'
} as const;

export type AddServiceModelParametersValueOneOf1TypeEnum = typeof AddServiceModelParametersValueOneOf1TypeEnum[keyof typeof AddServiceModelParametersValueOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf2
 */
export interface AddServiceModelParametersValueOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf2
     */
    'type': AddServiceModelParametersValueOneOf2TypeEnum;
    /**
     * 
     * @type {AddServiceModelParametersValueOneOf2Items}
     * @memberof AddServiceModelParametersValueOneOf2
     */
    'items'?: AddServiceModelParametersValueOneOf2Items;
    /**
     * Non-inclusive array of possible values this property can take
     * @type {Array<Array<any>>}
     * @memberof AddServiceModelParametersValueOneOf2
     */
    'examples'?: Array<Array<any>>;
}

export const AddServiceModelParametersValueOneOf2TypeEnum = {
    Array: 'array'
} as const;

export type AddServiceModelParametersValueOneOf2TypeEnum = typeof AddServiceModelParametersValueOneOf2TypeEnum[keyof typeof AddServiceModelParametersValueOneOf2TypeEnum];

/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf2Items
 */
export interface AddServiceModelParametersValueOneOf2Items {
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf2Items
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface AddServiceModelParametersValueOneOf3
 */
export interface AddServiceModelParametersValueOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelParametersValueOneOf3
     */
    'type': AddServiceModelParametersValueOneOf3TypeEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AddServiceModelParametersValueOneOf3
     */
    'properties'?: { [key: string]: any; };
    /**
     * Non-inclusive array of possible values this property can take
     * @type {Array<{ [key: string]: any; }>}
     * @memberof AddServiceModelParametersValueOneOf3
     */
    'examples'?: Array<{ [key: string]: any; }>;
}

export const AddServiceModelParametersValueOneOf3TypeEnum = {
    Object: 'object'
} as const;

export type AddServiceModelParametersValueOneOf3TypeEnum = typeof AddServiceModelParametersValueOneOf3TypeEnum[keyof typeof AddServiceModelParametersValueOneOf3TypeEnum];

/**
 * @type AddServiceModelParametersValueOneOfCanBeConditionedOn
 * If this parameter can have conditions. If it is an object, it is forced to be false
 * @export
 */
export type AddServiceModelParametersValueOneOfCanBeConditionedOn = boolean | string;

/**
 * 
 * @export
 * @interface AddServiceModelSetupValue
 */
export interface AddServiceModelSetupValue {
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelSetupValue
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelSetupValue
     */
    'description'?: string;
    /**
     * 
     * @type {AddServiceModelSetupValueRequired}
     * @memberof AddServiceModelSetupValue
     */
    'required'?: AddServiceModelSetupValueRequired;
    /**
     * 
     * @type {string}
     * @memberof AddServiceModelSetupValue
     */
    'type': AddServiceModelSetupValueTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof AddServiceModelSetupValue
     */
    'enum'?: Array<string>;
    /**
     * the url used for oauth login
     * @type {string}
     * @memberof AddServiceModelSetupValue
     */
    'url'?: string;
}

export const AddServiceModelSetupValueTypeEnum = {
    String: 'string',
    Oauth: 'oauth',
    Password: 'password'
} as const;

export type AddServiceModelSetupValueTypeEnum = typeof AddServiceModelSetupValueTypeEnum[keyof typeof AddServiceModelSetupValueTypeEnum];

/**
 * @type AddServiceModelSetupValueRequired
 * @export
 */
export type AddServiceModelSetupValueRequired = boolean | string;

/**
 * 
 * @export
 * @interface AdminDataGet200ResponseInner
 */
export interface AdminDataGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof AdminDataGet200ResponseInner
     */
    'accountId': string;
    /**
     * 
     * @type {number}
     * @memberof AdminDataGet200ResponseInner
     */
    'notificationCount': number;
}
/**
 * 
 * @export
 * @interface CreatePaymentIntegrationRequest
 */
export interface CreatePaymentIntegrationRequest {
    /**
     * payment integration system used
     * @type {string}
     * @memberof CreatePaymentIntegrationRequest
     */
    'paymentSystemId': string;
    /**
     * 
     * @type {PaymentIntegrationAuthRequest}
     * @memberof CreatePaymentIntegrationRequest
     */
    'auth'?: PaymentIntegrationAuthRequest;
    /**
     * 
     * @type {DataType}
     * @memberof CreatePaymentIntegrationRequest
     */
    'dataType'?: DataType;
}
/**
 * 
 * @export
 * @interface DataGet200Response
 */
export interface DataGet200Response {
    /**
     * 
     * @type {Array<EasysendDataModel>}
     * @memberof DataGet200Response
     */
    'data': Array<EasysendDataModel>;
    /**
     * 
     * @type {number}
     * @memberof DataGet200Response
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof DataGet200Response
     */
    'nextPageCursor'?: string | null;
}
/**
 * @type DataPatchRequest
 * @export
 */
export type DataPatchRequest = DataPatchRequestOneOf | UpdateOrderModel;

/**
 * 
 * @export
 * @interface DataPatchRequestOneOf
 */
export interface DataPatchRequestOneOf {
    /**
     * 
     * @type {Array<UpdateOrderModel>}
     * @memberof DataPatchRequestOneOf
     */
    'orders': Array<UpdateOrderModel>;
}
/**
 * 
 * @export
 * @interface DataResend200Response
 */
export interface DataResend200Response {
    /**
     * 
     * @type {EasysendDataModel}
     * @memberof DataResend200Response
     */
    'data': EasysendDataModel;
}
/**
 * 
 * @export
 * @interface DataType
 */
export interface DataType {
    /**
     * 
     * @type {string}
     * @memberof DataType
     */
    'qrCodeUrl'?: string;
}
/**
 * The type of delay \"stale\" means that the message is sent out with the aforementioned delay (delayS) if the order is not updated. If the order is updated before the delay is over, then the message is cancelled \"simple\" means that the message is sent out regardless of the order update. 
 * @export
 * @enum {string}
 */

export const DelayTypeModel = {
    Simple: 'simple',
    Stale: 'stale'
} as const;

export type DelayTypeModel = typeof DelayTypeModel[keyof typeof DelayTypeModel];


/**
 * - A data point created via the \"dataPatch\" operation - this signifies a change in an order, or the creation of a new order 
 * @export
 * @interface EasysendDataModel
 */
export interface EasysendDataModel {
    /**
     * Unique identifier for the data point
     * @type {number}
     * @memberof EasysendDataModel
     */
    'id': number;
    /**
     * Unique identifier for the order, provided by the \"tracking\" its from
     * @type {string}
     * @memberof EasysendDataModel
     */
    'orderId': string;
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof EasysendDataModel
     */
    'accountId'?: string | null;
    /**
     * 
     * @type {NullablePhoneNumber}
     * @memberof EasysendDataModel
     */
    'phoneNumber': NullablePhoneNumber;
    /**
     * 
     * @type {EasysendDataModelWaResponse}
     * @memberof EasysendDataModel
     */
    'waResponse': EasysendDataModelWaResponse;
    /**
     * The trigger that captured this data point for message sending. If null, it means that no trigger captured this data point
     * @type {number}
     * @memberof EasysendDataModel
     */
    'triggerId': number | null;
    /**
     * The tracking that captured this data point for message sending
     * @type {number}
     * @memberof EasysendDataModel
     */
    'trackingId'?: number;
    /**
     * The status of the data point. - \"sent\" => data point has been sent to the bot service, either successfully or not - \"pending\" => data point is waiting to be sent to the bot service. If - \"cancelled\" => data point has been cancelled, and will not be sent to the bot service. this could be because no trigger was found, or the trigger was disabled
     * @type {string}
     * @memberof EasysendDataModel
     */
    'status': EasysendDataModelStatusEnum;
    /**
     * Whether this data point is a test data point or not. Test data points are created by the \"triggerTest\" operation
     * @type {boolean}
     * @memberof EasysendDataModel
     */
    'isTest': boolean;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof EasysendDataModel
     */
    'datetime': string;
    /**
     * The params that were sent by the integration when the data point was created
     * @type {{ [key: string]: any; }}
     * @memberof EasysendDataModel
     */
    'params': { [key: string]: any; };
}

export const EasysendDataModelStatusEnum = {
    Sent: 'sent',
    Pending: 'pending',
    Cancelled: 'cancelled'
} as const;

export type EasysendDataModelStatusEnum = typeof EasysendDataModelStatusEnum[keyof typeof EasysendDataModelStatusEnum];

/**
 * the response received from the bots service. \"waResponse\" is a bit of a misnomer now, but it\'s a legacy name as we used to only support data from WhatsApp 
 * @export
 * @interface EasysendDataModelWaResponse
 */
export interface EasysendDataModelWaResponse {
    /**
     * the response code
     * @type {number}
     * @memberof EasysendDataModelWaResponse
     */
    'code'?: number;
    /**
     * the body received
     * @type {object}
     * @memberof EasysendDataModelWaResponse
     */
    'body'?: object;
}
/**
 * 
 * @export
 * @interface ErrorState
 */
export interface ErrorState {
    /**
     * 
     * @type {number}
     * @memberof ErrorState
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof ErrorState
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface EventTrigger
 */
export interface EventTrigger {
    /**
     * 
     * @type {number}
     * @memberof EventTrigger
     */
    'id'?: number;
    /**
     * Passed in the body to mark for deletion
     * @type {boolean}
     * @memberof EventTrigger
     */
    'delete'?: boolean;
    /**
     * the message template to send when this trigger is activated
     * @type {string}
     * @memberof EventTrigger
     */
    'templateId'?: string;
    /**
     * Whether the condition is enabled. If false, the trigger will be ignored whenever a data point is ingested
     * @type {boolean}
     * @memberof EventTrigger
     */
    'enabled'?: boolean;
    /**
     * Maximum notifications to be sent per order on this trigger. Default null -- unlimited
     * @type {number}
     * @memberof EventTrigger
     */
    'limit'?: number | null;
    /**
     * 
     * @type {EventTriggerCreateDelay}
     * @memberof EventTrigger
     */
    'delay'?: EventTriggerCreateDelay;
    /**
     * an array of usersIds to notify users when an event is created
     * @type {Array<string>}
     * @memberof EventTrigger
     */
    'notifyUsers'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: EventTriggerCondition; }}
     * @memberof EventTrigger
     */
    'conditions'?: { [key: string]: EventTriggerCondition; };
}
/**
 * 
 * @export
 * @interface EventTriggerAllOf
 */
export interface EventTriggerAllOf {
    /**
     * 
     * @type {number}
     * @memberof EventTriggerAllOf
     */
    'id'?: number;
    /**
     * Passed in the body to mark for deletion
     * @type {boolean}
     * @memberof EventTriggerAllOf
     */
    'delete'?: boolean;
}
/**
 * 
 * @export
 * @interface EventTriggerCondition
 */
export interface EventTriggerCondition {
    /**
     * 
     * @type {EventTriggerConditionValues}
     * @memberof EventTriggerCondition
     */
    'values': EventTriggerConditionValues;
    /**
     * the test for the condition. Default is `include`
     * @type {string}
     * @memberof EventTriggerCondition
     */
    'test'?: EventTriggerConditionTestEnum;
}

export const EventTriggerConditionTestEnum = {
    Include: 'include',
    Exclude: 'exclude',
    GreaterThan: 'greater-than',
    LessThan: 'less-than'
} as const;

export type EventTriggerConditionTestEnum = typeof EventTriggerConditionTestEnum[keyof typeof EventTriggerConditionTestEnum];

/**
 * @type EventTriggerConditionValues
 * @export
 */
export type EventTriggerConditionValues = Array<number> | Array<string>;

/**
 * 
 * @export
 * @interface EventTriggerCreate
 */
export interface EventTriggerCreate {
    /**
     * the message template to send when this trigger is activated
     * @type {string}
     * @memberof EventTriggerCreate
     */
    'templateId'?: string;
    /**
     * Whether the condition is enabled. If false, the trigger will be ignored whenever a data point is ingested
     * @type {boolean}
     * @memberof EventTriggerCreate
     */
    'enabled'?: boolean;
    /**
     * Maximum notifications to be sent per order on this trigger. Default null -- unlimited
     * @type {number}
     * @memberof EventTriggerCreate
     */
    'limit'?: number | null;
    /**
     * 
     * @type {EventTriggerCreateDelay}
     * @memberof EventTriggerCreate
     */
    'delay'?: EventTriggerCreateDelay;
    /**
     * an array of usersIds to notify users when an event is created
     * @type {Array<string>}
     * @memberof EventTriggerCreate
     */
    'notifyUsers'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: EventTriggerCondition; }}
     * @memberof EventTriggerCreate
     */
    'conditions'?: { [key: string]: EventTriggerCondition; };
}
/**
 * the optional delay to attach to this service
 * @export
 * @interface EventTriggerCreateDelay
 */
export interface EventTriggerCreateDelay {
    /**
     * the delay in sending the message
     * @type {number}
     * @memberof EventTriggerCreateDelay
     */
    'seconds'?: number;
    /**
     * 
     * @type {DelayTypeModel}
     * @memberof EventTriggerCreateDelay
     */
    'type'?: DelayTypeModel;
}


/**
 * 
 * @export
 * @interface GetPaymentIntegrations200Response
 */
export interface GetPaymentIntegrations200Response {
    /**
     * 
     * @type {Array<PaymentIntegration>}
     * @memberof GetPaymentIntegrations200Response
     */
    'integrations': Array<PaymentIntegration>;
}
/**
 * @type NullablePhoneNumber
 * Phone number to be sent to
 * @export
 */
export type NullablePhoneNumber = number | object | string;

/**
 * Authentication details for the payment system to create a payment integration
 * @export
 * @interface OAuth2AuthRequest
 */
export interface OAuth2AuthRequest {
    /**
     * 
     * @type {string}
     * @memberof OAuth2AuthRequest
     */
    'type': OAuth2AuthRequestTypeEnum;
    /**
     * OAuth2 authorization code
     * @type {string}
     * @memberof OAuth2AuthRequest
     */
    'authorizationCode': string;
}

export const OAuth2AuthRequestTypeEnum = {
    Oauth: 'oauth'
} as const;

export type OAuth2AuthRequestTypeEnum = typeof OAuth2AuthRequestTypeEnum[keyof typeof OAuth2AuthRequestTypeEnum];

/**
 * 
 * @export
 * @interface OrderDataGet200Response
 */
export interface OrderDataGet200Response {
    /**
     * 
     * @type {Array<OrderDataModel>}
     * @memberof OrderDataGet200Response
     */
    'data': Array<OrderDataModel>;
    /**
     * 
     * @type {number}
     * @memberof OrderDataGet200Response
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderDataGet200Response
     */
    'nextPageCursor'?: string | null;
}
/**
 * 
 * @export
 * @interface OrderDataModel
 */
export interface OrderDataModel {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof OrderDataModel
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof OrderDataModel
     */
    'updatedAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof OrderDataModel
     */
    'orderDate'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof OrderDataModel
     */
    'deliveryDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDataModel
     */
    'orderId': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDataModel
     */
    'teamId': string;
    /**
     * 
     * @type {number}
     * @memberof OrderDataModel
     */
    'trackingId'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderDataModel
     */
    'customerName'?: string;
    /**
     * 
     * @type {NullablePhoneNumber}
     * @memberof OrderDataModel
     */
    'phoneNumber'?: NullablePhoneNumber;
    /**
     * 
     * @type {string}
     * @memberof OrderDataModel
     */
    'status': OrderDataModelStatusEnum;
    /**
     * 
     * @type {OrderDataModelNote}
     * @memberof OrderDataModel
     */
    'note': OrderDataModelNote;
    /**
     * 
     * @type {string}
     * @memberof OrderDataModel
     */
    'orderStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDataModel
     */
    'paymentStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDataModel
     */
    'deliveryStatus'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDataModel
     */
    'isTest': boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OrderDataModel
     */
    'data': { [key: string]: any; };
    /**
     * 
     * @type {Array<EasysendDataModel>}
     * @memberof OrderDataModel
     */
    'updates'?: Array<EasysendDataModel>;
}

export const OrderDataModelStatusEnum = {
    Sent: 'sent',
    Pending: 'pending',
    Cancelled: 'cancelled'
} as const;

export type OrderDataModelStatusEnum = typeof OrderDataModelStatusEnum[keyof typeof OrderDataModelStatusEnum];

/**
 * 
 * @export
 * @interface OrderDataModelNote
 */
export interface OrderDataModelNote {
    /**
     * 
     * @type {string}
     * @memberof OrderDataModelNote
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof OrderDataModelNote
     */
    'updatedBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof OrderDataModelNote
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface OrderPost200Response
 */
export interface OrderPost200Response {
    /**
     * 
     * @type {string}
     * @memberof OrderPost200Response
     */
    'waUrl'?: string;
}
/**
 * 
 * @export
 * @interface OrderPostRequest
 */
export interface OrderPostRequest {
    /**
     * 
     * @type {UpdateOrderModel}
     * @memberof OrderPostRequest
     */
    'order'?: UpdateOrderModel;
    /**
     * Team Id of the team the order belongs to
     * @type {string}
     * @memberof OrderPostRequest
     */
    'teamId'?: string;
    /**
     * The tracking order will be created
     * @type {string}
     * @memberof OrderPostRequest
     */
    'trackingId'?: string;
    /**
     * OTP sent to user order number
     * @type {string}
     * @memberof OrderPostRequest
     */
    'otp'?: string;
}
/**
 * @type OverridePhoneModel
 * @export
 */
export type OverridePhoneModel = OverridePhoneModelOneOf | OverridePhoneModelOneOf1;

/**
 * Override with exact phone number
 * @export
 * @interface OverridePhoneModelOneOf
 */
export interface OverridePhoneModelOneOf {
    /**
     * 
     * @type {number}
     * @memberof OverridePhoneModelOneOf
     */
    'exact': number;
}
/**
 * Override with a field from the data
 * @export
 * @interface OverridePhoneModelOneOf1
 */
export interface OverridePhoneModelOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof OverridePhoneModelOneOf1
     */
    'field': string;
}
/**
 * 
 * @export
 * @interface PatchPaymentIntegrationRequest
 */
export interface PatchPaymentIntegrationRequest {
    /**
     * 
     * @type {DataType}
     * @memberof PatchPaymentIntegrationRequest
     */
    'dataType'?: DataType;
    /**
     * 
     * @type {boolean}
     * @memberof PatchPaymentIntegrationRequest
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentIntegration
 */
export interface PaymentIntegration {
    /**
     * 
     * @type {string}
     * @memberof PaymentIntegration
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentIntegration
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentIntegration
     */
    'teamId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PaymentIntegration
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PaymentIntegration
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentIntegration
     */
    'paymentSystemId': string;
    /**
     * URL of the QR code image
     * @type {string}
     * @memberof PaymentIntegration
     */
    'qrCodeUrl'?: string;
    /**
     * Secret key for the payment system
     * @type {string}
     * @memberof PaymentIntegration
     */
    'secret'?: string;
}
/**
 * @type PaymentIntegrationAuthRequest
 * @export
 */
export type PaymentIntegrationAuthRequest = OAuth2AuthRequest | SecretAuthRequest;

/**
 * 
 * @export
 * @interface PaymentLink
 */
export interface PaymentLink {
    /**
     * The URL to the payment page
     * @type {string}
     * @memberof PaymentLink
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface PaymentLinkPostRequest
 */
export interface PaymentLinkPostRequest {
    /**
     * 
     * @type {Array<PaymentLinkProduct>}
     * @memberof PaymentLinkPostRequest
     */
    'products': Array<PaymentLinkProduct>;
    /**
     * 
     * @type {PaymentLinkPostRequestToContact}
     * @memberof PaymentLinkPostRequest
     */
    'toContact': PaymentLinkPostRequestToContact;
    /**
     * 
     * @type {string}
     * @memberof PaymentLinkPostRequest
     */
    'orderId'?: string;
    /**
     * Additional parameters to be passed to the payment system
     * @type {{ [key: string]: string; }}
     * @memberof PaymentLinkPostRequest
     */
    'params'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface PaymentLinkPostRequestToContact
 */
export interface PaymentLinkPostRequestToContact {
    /**
     * 
     * @type {string}
     * @memberof PaymentLinkPostRequestToContact
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentLinkPostRequestToContact
     */
    'accountId': string;
}
/**
 * 
 * @export
 * @interface PaymentLinkProduct
 */
export interface PaymentLinkProduct {
    /**
     * ID of the product to add to the payment link
     * @type {string}
     * @memberof PaymentLinkProduct
     */
    'id': string;
    /**
     * Name of the product to add to the payment link
     * @type {string}
     * @memberof PaymentLinkProduct
     */
    'name': string;
    /**
     * The quantity of the product
     * @type {number}
     * @memberof PaymentLinkProduct
     */
    'quantity': number;
    /**
     * The price of the product
     * @type {number}
     * @memberof PaymentLinkProduct
     */
    'price': number;
    /**
     * ISO currency code
     * @type {string}
     * @memberof PaymentLinkProduct
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface PaymentRecord
 */
export interface PaymentRecord {
    /**
     * 
     * @type {number}
     * @memberof PaymentRecord
     */
    'id': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PaymentRecord
     */
    'createdAt': string;
    /**
     * 
     * @type {number}
     * @memberof PaymentRecord
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'orderId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'paymentIntegrationId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'contactId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'status': PaymentRecordStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'messageId': string;
}

export const PaymentRecordStatusEnum = {
    Pending: 'pending',
    Cancelled: 'cancelled',
    Completed: 'completed'
} as const;

export type PaymentRecordStatusEnum = typeof PaymentRecordStatusEnum[keyof typeof PaymentRecordStatusEnum];

/**
 * 
 * @export
 * @interface PaymentRecordPostRequest
 */
export interface PaymentRecordPostRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'paymentIntegrationId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'status': PaymentRecordPostRequestStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof PaymentRecordPostRequest
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'contactId': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'messageId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecordPostRequest
     */
    'orderId'?: string;
}

export const PaymentRecordPostRequestStatusEnum = {
    Completed: 'completed',
    Pending: 'pending',
    Cancelled: 'cancelled'
} as const;

export type PaymentRecordPostRequestStatusEnum = typeof PaymentRecordPostRequestStatusEnum[keyof typeof PaymentRecordPostRequestStatusEnum];

/**
 * 
 * @export
 * @interface PaymentRecordsGet200Response
 */
export interface PaymentRecordsGet200Response {
    /**
     * 
     * @type {number}
     * @memberof PaymentRecordsGet200Response
     */
    'nextPageCursor'?: number;
    /**
     * 
     * @type {Array<PaymentRecord>}
     * @memberof PaymentRecordsGet200Response
     */
    'records': Array<PaymentRecord>;
}
/**
 * 
 * @export
 * @interface PaymentSystem
 */
export interface PaymentSystem {
    /**
     * 
     * @type {string}
     * @memberof PaymentSystem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentSystem
     */
    'name': string;
    /**
     * - qr - QR code payment system - url - payment link generation system
     * @type {string}
     * @memberof PaymentSystem
     */
    'type': PaymentSystemTypeEnum;
    /**
     * 
     * @type {DataType}
     * @memberof PaymentSystem
     */
    'dataType': DataType;
    /**
     * 
     * @type {PaymentSystemAuth}
     * @memberof PaymentSystem
     */
    'auth'?: PaymentSystemAuth;
    /**
     * User\'s integrations of this payment system
     * @type {Array<PaymentIntegration>}
     * @memberof PaymentSystem
     */
    'currentIntegrations'?: Array<PaymentIntegration> | null;
    /**
     * ISO 3166-1 alpha-2 country code.
     * @type {string}
     * @memberof PaymentSystem
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentSystem
     */
    'logoImageUrl'?: string;
}

export const PaymentSystemTypeEnum = {
    Qr: 'qr',
    Url: 'url'
} as const;

export type PaymentSystemTypeEnum = typeof PaymentSystemTypeEnum[keyof typeof PaymentSystemTypeEnum];

/**
 * 
 * @export
 * @interface PaymentSystemAuth
 */
export interface PaymentSystemAuth {
    /**
     * URL to redirect user to in order to authorize the payment system integration
     * @type {string}
     * @memberof PaymentSystemAuth
     */
    'oauthUrl'?: string;
}
/**
 * 
 * @export
 * @interface PaymentSystemsGet200Response
 */
export interface PaymentSystemsGet200Response {
    /**
     * 
     * @type {Array<PaymentSystem>}
     * @memberof PaymentSystemsGet200Response
     */
    'paymentSystems': Array<PaymentSystem>;
}
/**
 * 
 * @export
 * @interface PostServiceModel
 */
export interface PostServiceModel {
    /**
     * 
     * @type {string}
     * @memberof PostServiceModel
     */
    'id': string;
    /**
     * Base route on top of which all easysend paths are appended
     * @type {string}
     * @memberof PostServiceModel
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface PostTracking
 */
export interface PostTracking {
    /**
     * service ID
     * @type {string}
     * @memberof PostTracking
     */
    'serviceId': string;
    /**
     * Nickname to identify this tracking
     * @type {string}
     * @memberof PostTracking
     */
    'name': string;
    /**
     * default country code of phone number if that doesn\'t exists on target phone.
     * @type {number}
     * @memberof PostTracking
     */
    'defaultCountryCode'?: number;
    /**
     * The triggers
     * @type {Array<EventTriggerCreate>}
     * @memberof PostTracking
     */
    'events': Array<EventTriggerCreate>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PostTracking
     */
    'credentials': { [key: string]: any; };
    /**
     * 
     * @type {OverridePhoneModel}
     * @memberof PostTracking
     */
    'overridePhoneNumber'?: OverridePhoneModel;
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof PostTracking
     */
    'accountId'?: string | null;
    /**
     * 
     * @type {TrackingAutoPaymentConfig}
     * @memberof PostTracking
     */
    'autoPayment'?: TrackingAutoPaymentConfig | null;
}
/**
 * @type SecretAuthRequest
 * @export
 */
export type SecretAuthRequest = SecretAuthRequestWithEmail | SecretAuthRequestWithOptionalEmail;

/**
 * Authentication details for the payment system to create a payment integration
 * @export
 * @interface SecretAuthRequestWithEmail
 */
export interface SecretAuthRequestWithEmail {
    /**
     * 
     * @type {string}
     * @memberof SecretAuthRequestWithEmail
     */
    'type': SecretAuthRequestWithEmailTypeEnum;
    /**
     * Authorization secret
     * @type {string}
     * @memberof SecretAuthRequestWithEmail
     */
    'secret'?: string;
    /**
     * Username
     * @type {string}
     * @memberof SecretAuthRequestWithEmail
     */
    'username'?: string;
    /**
     * Email so we can use this to map the integration on our end to the payment partner\'s end
     * @type {string}
     * @memberof SecretAuthRequestWithEmail
     */
    'email': string;
}

export const SecretAuthRequestWithEmailTypeEnum = {
    Secret: 'secret'
} as const;

export type SecretAuthRequestWithEmailTypeEnum = typeof SecretAuthRequestWithEmailTypeEnum[keyof typeof SecretAuthRequestWithEmailTypeEnum];

/**
 * Authentication details for the payment system to create a payment integration
 * @export
 * @interface SecretAuthRequestWithOptionalEmail
 */
export interface SecretAuthRequestWithOptionalEmail {
    /**
     * 
     * @type {string}
     * @memberof SecretAuthRequestWithOptionalEmail
     */
    'type': SecretAuthRequestWithOptionalEmailTypeEnum;
    /**
     * Authorization secret
     * @type {string}
     * @memberof SecretAuthRequestWithOptionalEmail
     */
    'secret': string;
    /**
     * Username
     * @type {string}
     * @memberof SecretAuthRequestWithOptionalEmail
     */
    'username': string;
    /**
     * Email so we can use this to map the integration on our end to the payment partner\'s end
     * @type {string}
     * @memberof SecretAuthRequestWithOptionalEmail
     */
    'email'?: string;
}

export const SecretAuthRequestWithOptionalEmailTypeEnum = {
    Secret: 'secret'
} as const;

export type SecretAuthRequestWithOptionalEmailTypeEnum = typeof SecretAuthRequestWithOptionalEmailTypeEnum[keyof typeof SecretAuthRequestWithOptionalEmailTypeEnum];

/**
 * 
 * @export
 * @interface ServiceModel
 */
export interface ServiceModel {
    /**
     * Used to store and uniquely identify a service/scraper
     * @type {string}
     * @memberof ServiceModel
     */
    'id': string;
    /**
     * URL of the service
     * @type {string}
     * @memberof ServiceModel
     */
    'url'?: string;
    /**
     * Name of the service/scrapper
     * @type {string}
     * @memberof ServiceModel
     */
    'name': string;
    /**
     * A service that implements only the schema route
     * @type {boolean}
     * @memberof ServiceModel
     */
    'isEphemeral'?: boolean;
    /**
     * If true, then parameters wont be checked when editing a trigger
     * @type {boolean}
     * @memberof ServiceModel
     */
    'skipParameterValidation'?: boolean;
    /**
     * any image/link representing the service/scrapper
     * @type {string}
     * @memberof ServiceModel
     */
    'imgUrl': string;
    /**
     * Description of the service/scrapper
     * @type {string}
     * @memberof ServiceModel
     */
    'description': string;
    /**
     * Whether the service supports the products API
     * @type {boolean}
     * @memberof ServiceModel
     */
    'supportsProducts'?: boolean;
    /**
     * 
     * @type {{ [key: string]: AddServiceModelParametersValue; }}
     * @memberof ServiceModel
     */
    'parameters': { [key: string]: AddServiceModelParametersValue; };
    /**
     * 
     * @type {{ [key: string]: AddServiceModelSetupValue; }}
     * @memberof ServiceModel
     */
    'setup': { [key: string]: AddServiceModelSetupValue; };
    /**
     * 
     * @type {AddServiceModelOutput}
     * @memberof ServiceModel
     */
    'output'?: AddServiceModelOutput;
}
/**
 * 
 * @export
 * @interface ServiceModelAllOf
 */
export interface ServiceModelAllOf {
    /**
     * Used to store and uniquely identify a service/scraper
     * @type {string}
     * @memberof ServiceModelAllOf
     */
    'id': string;
    /**
     * URL of the service
     * @type {string}
     * @memberof ServiceModelAllOf
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ServiceProductsData
 */
export interface ServiceProductsData {
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof ServiceProductsData
     */
    'products': Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface Services
 */
export interface Services {
    /**
     * 
     * @type {Array<ServiceModel>}
     * @memberof Services
     */
    'services': Array<ServiceModel>;
}
/**
 * 
 * @export
 * @interface ShopMetadataGet200Response
 */
export interface ShopMetadataGet200Response {
    /**
     * 
     * @type {ShopMetadataModel}
     * @memberof ShopMetadataGet200Response
     */
    'shopMetadata'?: ShopMetadataModel;
}
/**
 * 
 * @export
 * @interface ShopMetadataModel
 */
export interface ShopMetadataModel {
    /**
     * Unique identifier for the shop. if CD shop then it is the teamId else phonenumber
     * @type {string}
     * @memberof ShopMetadataModel
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModel
     */
    'shopName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModel
     */
    'shopPhoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModel
     */
    'shopCurrency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModel
     */
    'shopImageUrl'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShopMetadataModel
     */
    'shippingEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShopMetadataModel
     */
    'pickUpEnabled'?: boolean;
    /**
     * 
     * @type {Array<ShopMetadataModelPickUpAddressesInner>}
     * @memberof ShopMetadataModel
     */
    'pickUpAddresses'?: Array<ShopMetadataModelPickUpAddressesInner>;
    /**
     * 
     * @type {Array<ShopMetadataModelShippingFeeInner>}
     * @memberof ShopMetadataModel
     */
    'shippingFee'?: Array<ShopMetadataModelShippingFeeInner>;
    /**
     * 
     * @type {number}
     * @memberof ShopMetadataModel
     */
    'freeShippingThreshold'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ShopMetadataModel
     */
    'completedShopSetupProcess'?: boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ShopMetadataModel
     */
    'onBoardingData'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModel
     */
    'shopService'?: ShopMetadataModelShopServiceEnum;
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModel
     */
    'externalShopUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModel
     */
    'type'?: ShopMetadataModelTypeEnum;
}

export const ShopMetadataModelShopServiceEnum = {
    Shopify: 'shopify',
    Shopline: 'shopline',
    Woocommerce: 'woocommerce',
    Boutir: 'boutir'
} as const;

export type ShopMetadataModelShopServiceEnum = typeof ShopMetadataModelShopServiceEnum[keyof typeof ShopMetadataModelShopServiceEnum];
export const ShopMetadataModelTypeEnum = {
    CdTeam: 'cd-team',
    ExternalShop: 'external-shop'
} as const;

export type ShopMetadataModelTypeEnum = typeof ShopMetadataModelTypeEnum[keyof typeof ShopMetadataModelTypeEnum];

/**
 * 
 * @export
 * @interface ShopMetadataModelPickUpAddressesInner
 */
export interface ShopMetadataModelPickUpAddressesInner {
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModelPickUpAddressesInner
     */
    'address'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShopMetadataModelPickUpAddressesInner
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface ShopMetadataModelShippingFeeInner
 */
export interface ShopMetadataModelShippingFeeInner {
    /**
     * 
     * @type {number}
     * @memberof ShopMetadataModelShippingFeeInner
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModelShippingFeeInner
     */
    'currency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShopMetadataModelShippingFeeInner
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShopMetadataModelShippingFeeInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ShopMetadataPostRequest
 */
export interface ShopMetadataPostRequest {
    /**
     * 
     * @type {Array<ShopMetadataModel>}
     * @memberof ShopMetadataPostRequest
     */
    'shopMetadata'?: Array<ShopMetadataModel>;
}
/**
 * 
 * @export
 * @interface SuccessResponse
 */
export interface SuccessResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SuccessResponse
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface TrackServiceModel
 */
export interface TrackServiceModel {
    /**
     * 
     * @type {number}
     * @memberof TrackServiceModel
     */
    'id': number;
    /**
     * secret ID used to communicate with shop integrations. Shop integrations never see the actual ID of a tracking, they only see the secret ID. They identify a tracking by the secret ID itself
     * @type {string}
     * @memberof TrackServiceModel
     */
    'secretId': string;
    /**
     * 
     * @type {string}
     * @memberof TrackServiceModel
     */
    'name': string;
    /**
     * Used to store and uniquely identify a service/scraper.
     * @type {string}
     * @memberof TrackServiceModel
     */
    'serviceId'?: string;
    /**
     * The team ID this tracking belongs to
     * @type {string}
     * @memberof TrackServiceModel
     */
    'teamId': string;
    /**
     * default country code of phone number if that doesn\'t exists on target phone.
     * @type {number}
     * @memberof TrackServiceModel
     */
    'defaultCountryCode'?: number;
    /**
     * The triggers setup for this service
     * @type {Array<EventTrigger>}
     * @memberof TrackServiceModel
     */
    'events': Array<EventTrigger>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TrackServiceModel
     */
    'lastActivity': string;
    /**
     * number of times tracking has received an event
     * @type {number}
     * @memberof TrackServiceModel
     */
    'triggered': number;
    /**
     * Whether the tracking is active or not. If the service isn\'t active -- no events are sent out
     * @type {boolean}
     * @memberof TrackServiceModel
     */
    'isActive': boolean;
    /**
     * 
     * @type {OverridePhoneModel}
     * @memberof TrackServiceModel
     */
    'overridePhoneNumber'?: OverridePhoneModel;
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof TrackServiceModel
     */
    'accountId': string | null;
    /**
     * 
     * @type {ErrorState}
     * @memberof TrackServiceModel
     */
    'error': ErrorState | null;
    /**
     * 
     * @type {TrackingAutoPaymentConfig}
     * @memberof TrackServiceModel
     */
    'autoPayment'?: TrackingAutoPaymentConfig | null;
}
/**
 * 
 * @export
 * @interface TrackServices
 */
export interface TrackServices {
    /**
     * 
     * @type {Array<TrackServiceModel>}
     * @memberof TrackServices
     */
    'trackings': Array<TrackServiceModel>;
}
/**
 * 
 * @export
 * @interface TrackingAutoPaymentConfig
 */
export interface TrackingAutoPaymentConfig {
    /**
     * 
     * @type {string}
     * @memberof TrackingAutoPaymentConfig
     */
    'paymentIntegrationId': string;
}
/**
 * 
 * @export
 * @interface TrackingPatch200Response
 */
export interface TrackingPatch200Response {
    /**
     * 
     * @type {TrackServiceModel}
     * @memberof TrackingPatch200Response
     */
    'tracking': TrackServiceModel;
}
/**
 * 
 * @export
 * @interface TrackingPost200Response
 */
export interface TrackingPost200Response {
    /**
     * 
     * @type {TrackServiceModel}
     * @memberof TrackingPost200Response
     */
    'tracking': TrackServiceModel;
}
/**
 * 
 * @export
 * @interface TriggerTest200Response
 */
export interface TriggerTest200Response {
    /**
     * the parameter that was sent
     * @type {object}
     * @memberof TriggerTest200Response
     */
    'params': object;
    /**
     * mock order ID
     * @type {string}
     * @memberof TriggerTest200Response
     */
    'orderId': string;
}
/**
 * 
 * @export
 * @interface UpdateOrderDataModel
 */
export interface UpdateOrderDataModel {
    /**
     * 
     * @type {UpdateOrderDataModelNote}
     * @memberof UpdateOrderDataModel
     */
    'note'?: UpdateOrderDataModelNote;
}
/**
 * 
 * @export
 * @interface UpdateOrderDataModelNote
 */
export interface UpdateOrderDataModelNote {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrderDataModelNote
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrderDataModelNote
     */
    'updatedBy'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof UpdateOrderDataModelNote
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface UpdateOrderModel
 */
export interface UpdateOrderModel {
    /**
     * 
     * @type {NullablePhoneNumber}
     * @memberof UpdateOrderModel
     */
    'phoneNumber'?: NullablePhoneNumber;
    /**
     * Unique identifier for the order. Is used to track the status internally
     * @type {string}
     * @memberof UpdateOrderModel
     */
    'orderId': string;
    /**
     * Is it a test order
     * @type {boolean}
     * @memberof UpdateOrderModel
     */
    'isTest'?: boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UpdateOrderModel
     */
    'params': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface UpdateTracking
 */
export interface UpdateTracking {
    /**
     * Nickname to identify this tracking
     * @type {string}
     * @memberof UpdateTracking
     */
    'name'?: string;
    /**
     * 
     * @type {OverridePhoneModel}
     * @memberof UpdateTracking
     */
    'overridePhoneNumber'?: OverridePhoneModel;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UpdateTracking
     */
    'credentials'?: { [key: string]: any; };
    /**
     * default country code of phone number if that doesn\'t exists on target phone.
     * @type {number}
     * @memberof UpdateTracking
     */
    'defaultCountryCode'?: number;
    /**
     * 
     * @type {Array<EventTrigger>}
     * @memberof UpdateTracking
     */
    'events'?: Array<EventTrigger>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTracking
     */
    'isActive'?: boolean;
    /**
     * Specify IM account to use
     * @type {string}
     * @memberof UpdateTracking
     */
    'accountId'?: string | null;
    /**
     * 
     * @type {TrackingAutoPaymentConfig}
     * @memberof UpdateTracking
     */
    'autoPayment'?: TrackingAutoPaymentConfig | null;
}
/**
 * 
 * @export
 * @interface UpdateTrackingErrorState
 */
export interface UpdateTrackingErrorState {
    /**
     * 
     * @type {ErrorState}
     * @memberof UpdateTrackingErrorState
     */
    'error': ErrorState | null;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get admin data
         * @param {Array<string>} [teamId] Fetch orders of the specified teamIds
         * @param {'ASC' | 'DESC'} [direction] Fetch orders sent to the specified phone number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDataGet: async (teamId?: Array<string>, direction?: 'ASC' | 'DESC', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)

            if (teamId) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get admin data
         * @param {Array<string>} [teamId] Fetch orders of the specified teamIds
         * @param {'ASC' | 'DESC'} [direction] Fetch orders sent to the specified phone number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDataGet(teamId?: Array<string>, direction?: 'ASC' | 'DESC', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AdminDataGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDataGet(teamId, direction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @summary Get admin data
         * @param {AdminApiAdminDataGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDataGet(requestParameters: AdminApiAdminDataGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<AdminDataGet200ResponseInner>> {
            return localVarFp.adminDataGet(requestParameters.teamId, requestParameters.direction, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for adminDataGet operation in AdminApi.
 * @export
 * @interface AdminApiAdminDataGetRequest
 */
export interface AdminApiAdminDataGetRequest {
    /**
     * Fetch orders of the specified teamIds
     * @type {Array<string>}
     * @memberof AdminApiAdminDataGet
     */
    readonly teamId?: Array<string>

    /**
     * Fetch orders sent to the specified phone number
     * @type {'ASC' | 'DESC'}
     * @memberof AdminApiAdminDataGet
     */
    readonly direction?: 'ASC' | 'DESC'
}

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @summary Get admin data
     * @param {AdminApiAdminDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminDataGet(requestParameters: AdminApiAdminDataGetRequest = {}, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminDataGet(requestParameters.teamId, requestParameters.direction, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To be called by a scraping service whenever something happens. Examples include -- an email is received, an order is placed or updated, an order is cancelled, etc.
         * @summary Update data/order details of a tracking
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {string} [accountId] The account ID to use when sending the flow
         * @param {DataPatchRequest} [dataPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataPatch: async (secretId: string, accountId?: string, dataPatchRequest?: DataPatchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('dataPatch', 'secretId', secretId)
            const localVarPath = `/event/{secretId}`
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resend the WA message associated with this data point
         * @param {string} dataId The secret sent to the parsing service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataResend: async (dataId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataId' is not null or undefined
            assertParamExists('dataResend', 'dataId', dataId)
            const localVarPath = `/data/{dataId}/resend-wa`
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post the order data on easysend.
         * @param {OrderPostRequest} [orderPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPost: async (orderPostRequest?: OrderPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/checkout-product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * To be called by a scraping service whenever something happens. Examples include -- an email is received, an order is placed or updated, an order is cancelled, etc.
         * @summary Update data/order details of a tracking
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {string} [accountId] The account ID to use when sending the flow
         * @param {DataPatchRequest} [dataPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataPatch(secretId: string, accountId?: string, dataPatchRequest?: DataPatchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataPatch(secretId, accountId, dataPatchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resend the WA message associated with this data point
         * @param {string} dataId The secret sent to the parsing service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataResend(dataId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataResend200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataResend(dataId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Post the order data on easysend.
         * @param {OrderPostRequest} [orderPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderPost(orderPostRequest?: OrderPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderPost(orderPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * To be called by a scraping service whenever something happens. Examples include -- an email is received, an order is placed or updated, an order is cancelled, etc.
         * @summary Update data/order details of a tracking
         * @param {EventsApiDataPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataPatch(requestParameters: EventsApiDataPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.dataPatch(requestParameters.secretId, requestParameters.accountId, requestParameters.dataPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resend the WA message associated with this data point
         * @param {EventsApiDataResendRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataResend(requestParameters: EventsApiDataResendRequest, options?: AxiosRequestConfig): AxiosPromise<DataResend200Response> {
            return localVarFp.dataResend(requestParameters.dataId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post the order data on easysend.
         * @param {EventsApiOrderPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPost(requestParameters: EventsApiOrderPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<OrderPost200Response> {
            return localVarFp.orderPost(requestParameters.orderPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for dataPatch operation in EventsApi.
 * @export
 * @interface EventsApiDataPatchRequest
 */
export interface EventsApiDataPatchRequest {
    /**
     * The secret ID of the tracking made available to the service
     * @type {string}
     * @memberof EventsApiDataPatch
     */
    readonly secretId: string

    /**
     * The account ID to use when sending the flow
     * @type {string}
     * @memberof EventsApiDataPatch
     */
    readonly accountId?: string

    /**
     * 
     * @type {DataPatchRequest}
     * @memberof EventsApiDataPatch
     */
    readonly dataPatchRequest?: DataPatchRequest
}

/**
 * Request parameters for dataResend operation in EventsApi.
 * @export
 * @interface EventsApiDataResendRequest
 */
export interface EventsApiDataResendRequest {
    /**
     * The secret sent to the parsing service
     * @type {string}
     * @memberof EventsApiDataResend
     */
    readonly dataId: string
}

/**
 * Request parameters for orderPost operation in EventsApi.
 * @export
 * @interface EventsApiOrderPostRequest
 */
export interface EventsApiOrderPostRequest {
    /**
     * 
     * @type {OrderPostRequest}
     * @memberof EventsApiOrderPost
     */
    readonly orderPostRequest?: OrderPostRequest
}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * To be called by a scraping service whenever something happens. Examples include -- an email is received, an order is placed or updated, an order is cancelled, etc.
     * @summary Update data/order details of a tracking
     * @param {EventsApiDataPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public dataPatch(requestParameters: EventsApiDataPatchRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).dataPatch(requestParameters.secretId, requestParameters.accountId, requestParameters.dataPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resend the WA message associated with this data point
     * @param {EventsApiDataResendRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public dataResend(requestParameters: EventsApiDataResendRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).dataResend(requestParameters.dataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post the order data on easysend.
     * @param {EventsApiOrderPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public orderPost(requestParameters: EventsApiOrderPostRequest = {}, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).orderPost(requestParameters.orderPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentIntegrationsApi - axios parameter creator
 * @export
 */
export const PaymentIntegrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a payment integration
         * @param {CreatePaymentIntegrationRequest} [createPaymentIntegrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentIntegration: async (createPaymentIntegrationRequest?: CreatePaymentIntegrationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_INTEGRATION_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPaymentIntegrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete the user\'s payment integration
         * @param {Array<string>} id the ids of the payment integration to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentIntegration: async (id: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePaymentIntegration', 'id', id)
            const localVarPath = `/payment-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_INTEGRATION_WRITE"], configuration)

            if (id) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all payment integrations available to a user
         * @param {string} teamId 
         * @param {string} [id] Fetch the payment integrations with the id specified
         * @param {boolean} [isEnabled] Fetch only enabled integrations if true
         * @param {boolean} [fetchAll] Fetch all integrations if you have admin Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentIntegrations: async (teamId: string, id?: string, isEnabled?: boolean, fetchAll?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getPaymentIntegrations', 'teamId', teamId)
            const localVarPath = `/payment-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (isEnabled !== undefined) {
                localVarQueryParameter['isEnabled'] = isEnabled;
            }

            if (fetchAll !== undefined) {
                localVarQueryParameter['fetchAll'] = fetchAll;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update the user\'s payment integration
         * @param {string} id the id of the payment integration to patch
         * @param {PatchPaymentIntegrationRequest} [patchPaymentIntegrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchPaymentIntegration: async (id: string, patchPaymentIntegrationRequest?: PatchPaymentIntegrationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchPaymentIntegration', 'id', id)
            const localVarPath = `/payment-integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_INTEGRATION_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchPaymentIntegrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used by payment integrations to notify the server of payment events
         * @summary Webhook for payment integrations
         * @param {string} name Name of the payment integration
         * @param {string} secret Secret of the payment integration
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentIntegrationWebhook: async (name: string, secret: string, requestBody?: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('paymentIntegrationWebhook', 'name', name)
            // verify required parameter 'secret' is not null or undefined
            assertParamExists('paymentIntegrationWebhook', 'secret', secret)
            const localVarPath = `/payment-integrations/{name}/webhook/{secret}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"secret"}}`, encodeURIComponent(String(secret)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a payment link
         * @param {string} id the id of the payment integration to generate a payment link for
         * @param {PaymentLinkPostRequest} [paymentLinkPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentLinkPost: async (id: string, paymentLinkPostRequest?: PaymentLinkPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentLinkPost', 'id', id)
            const localVarPath = `/payment-integrations/{id}/payment-link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_INTEGRATION_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentLinkPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentIntegrationsApi - functional programming interface
 * @export
 */
export const PaymentIntegrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentIntegrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a payment integration
         * @param {CreatePaymentIntegrationRequest} [createPaymentIntegrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentIntegration(createPaymentIntegrationRequest?: CreatePaymentIntegrationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentIntegration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentIntegration(createPaymentIntegrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary delete the user\'s payment integration
         * @param {Array<string>} id the ids of the payment integration to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentIntegration(id: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePaymentIntegration(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all payment integrations available to a user
         * @param {string} teamId 
         * @param {string} [id] Fetch the payment integrations with the id specified
         * @param {boolean} [isEnabled] Fetch only enabled integrations if true
         * @param {boolean} [fetchAll] Fetch all integrations if you have admin Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentIntegrations(teamId: string, id?: string, isEnabled?: boolean, fetchAll?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentIntegrations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentIntegrations(teamId, id, isEnabled, fetchAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update the user\'s payment integration
         * @param {string} id the id of the payment integration to patch
         * @param {PatchPaymentIntegrationRequest} [patchPaymentIntegrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchPaymentIntegration(id: string, patchPaymentIntegrationRequest?: PatchPaymentIntegrationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchPaymentIntegration(id, patchPaymentIntegrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is used by payment integrations to notify the server of payment events
         * @summary Webhook for payment integrations
         * @param {string} name Name of the payment integration
         * @param {string} secret Secret of the payment integration
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentIntegrationWebhook(name: string, secret: string, requestBody?: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentIntegrationWebhook(name, secret, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate a payment link
         * @param {string} id the id of the payment integration to generate a payment link for
         * @param {PaymentLinkPostRequest} [paymentLinkPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentLinkPost(id: string, paymentLinkPostRequest?: PaymentLinkPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentLinkPost(id, paymentLinkPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentIntegrationsApi - factory interface
 * @export
 */
export const PaymentIntegrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentIntegrationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a payment integration
         * @param {PaymentIntegrationsApiCreatePaymentIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentIntegration(requestParameters: PaymentIntegrationsApiCreatePaymentIntegrationRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PaymentIntegration> {
            return localVarFp.createPaymentIntegration(requestParameters.createPaymentIntegrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete the user\'s payment integration
         * @param {PaymentIntegrationsApiDeletePaymentIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentIntegration(requestParameters: PaymentIntegrationsApiDeletePaymentIntegrationRequest, options?: AxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.deletePaymentIntegration(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all payment integrations available to a user
         * @param {PaymentIntegrationsApiGetPaymentIntegrationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentIntegrations(requestParameters: PaymentIntegrationsApiGetPaymentIntegrationsRequest, options?: AxiosRequestConfig): AxiosPromise<GetPaymentIntegrations200Response> {
            return localVarFp.getPaymentIntegrations(requestParameters.teamId, requestParameters.id, requestParameters.isEnabled, requestParameters.fetchAll, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update the user\'s payment integration
         * @param {PaymentIntegrationsApiPatchPaymentIntegrationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchPaymentIntegration(requestParameters: PaymentIntegrationsApiPatchPaymentIntegrationRequest, options?: AxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.patchPaymentIntegration(requestParameters.id, requestParameters.patchPaymentIntegrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used by payment integrations to notify the server of payment events
         * @summary Webhook for payment integrations
         * @param {PaymentIntegrationsApiPaymentIntegrationWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentIntegrationWebhook(requestParameters: PaymentIntegrationsApiPaymentIntegrationWebhookRequest, options?: AxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.paymentIntegrationWebhook(requestParameters.name, requestParameters.secret, requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a payment link
         * @param {PaymentIntegrationsApiPaymentLinkPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentLinkPost(requestParameters: PaymentIntegrationsApiPaymentLinkPostRequest, options?: AxiosRequestConfig): AxiosPromise<PaymentLink> {
            return localVarFp.paymentLinkPost(requestParameters.id, requestParameters.paymentLinkPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPaymentIntegration operation in PaymentIntegrationsApi.
 * @export
 * @interface PaymentIntegrationsApiCreatePaymentIntegrationRequest
 */
export interface PaymentIntegrationsApiCreatePaymentIntegrationRequest {
    /**
     * 
     * @type {CreatePaymentIntegrationRequest}
     * @memberof PaymentIntegrationsApiCreatePaymentIntegration
     */
    readonly createPaymentIntegrationRequest?: CreatePaymentIntegrationRequest
}

/**
 * Request parameters for deletePaymentIntegration operation in PaymentIntegrationsApi.
 * @export
 * @interface PaymentIntegrationsApiDeletePaymentIntegrationRequest
 */
export interface PaymentIntegrationsApiDeletePaymentIntegrationRequest {
    /**
     * the ids of the payment integration to delete
     * @type {Array<string>}
     * @memberof PaymentIntegrationsApiDeletePaymentIntegration
     */
    readonly id: Array<string>
}

/**
 * Request parameters for getPaymentIntegrations operation in PaymentIntegrationsApi.
 * @export
 * @interface PaymentIntegrationsApiGetPaymentIntegrationsRequest
 */
export interface PaymentIntegrationsApiGetPaymentIntegrationsRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentIntegrationsApiGetPaymentIntegrations
     */
    readonly teamId: string

    /**
     * Fetch the payment integrations with the id specified
     * @type {string}
     * @memberof PaymentIntegrationsApiGetPaymentIntegrations
     */
    readonly id?: string

    /**
     * Fetch only enabled integrations if true
     * @type {boolean}
     * @memberof PaymentIntegrationsApiGetPaymentIntegrations
     */
    readonly isEnabled?: boolean

    /**
     * Fetch all integrations if you have admin Access
     * @type {boolean}
     * @memberof PaymentIntegrationsApiGetPaymentIntegrations
     */
    readonly fetchAll?: boolean
}

/**
 * Request parameters for patchPaymentIntegration operation in PaymentIntegrationsApi.
 * @export
 * @interface PaymentIntegrationsApiPatchPaymentIntegrationRequest
 */
export interface PaymentIntegrationsApiPatchPaymentIntegrationRequest {
    /**
     * the id of the payment integration to patch
     * @type {string}
     * @memberof PaymentIntegrationsApiPatchPaymentIntegration
     */
    readonly id: string

    /**
     * 
     * @type {PatchPaymentIntegrationRequest}
     * @memberof PaymentIntegrationsApiPatchPaymentIntegration
     */
    readonly patchPaymentIntegrationRequest?: PatchPaymentIntegrationRequest
}

/**
 * Request parameters for paymentIntegrationWebhook operation in PaymentIntegrationsApi.
 * @export
 * @interface PaymentIntegrationsApiPaymentIntegrationWebhookRequest
 */
export interface PaymentIntegrationsApiPaymentIntegrationWebhookRequest {
    /**
     * Name of the payment integration
     * @type {string}
     * @memberof PaymentIntegrationsApiPaymentIntegrationWebhook
     */
    readonly name: string

    /**
     * Secret of the payment integration
     * @type {string}
     * @memberof PaymentIntegrationsApiPaymentIntegrationWebhook
     */
    readonly secret: string

    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PaymentIntegrationsApiPaymentIntegrationWebhook
     */
    readonly requestBody?: { [key: string]: any; }
}

/**
 * Request parameters for paymentLinkPost operation in PaymentIntegrationsApi.
 * @export
 * @interface PaymentIntegrationsApiPaymentLinkPostRequest
 */
export interface PaymentIntegrationsApiPaymentLinkPostRequest {
    /**
     * the id of the payment integration to generate a payment link for
     * @type {string}
     * @memberof PaymentIntegrationsApiPaymentLinkPost
     */
    readonly id: string

    /**
     * 
     * @type {PaymentLinkPostRequest}
     * @memberof PaymentIntegrationsApiPaymentLinkPost
     */
    readonly paymentLinkPostRequest?: PaymentLinkPostRequest
}

/**
 * PaymentIntegrationsApi - object-oriented interface
 * @export
 * @class PaymentIntegrationsApi
 * @extends {BaseAPI}
 */
export class PaymentIntegrationsApi extends BaseAPI {
    /**
     * 
     * @summary Create a payment integration
     * @param {PaymentIntegrationsApiCreatePaymentIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntegrationsApi
     */
    public createPaymentIntegration(requestParameters: PaymentIntegrationsApiCreatePaymentIntegrationRequest = {}, options?: AxiosRequestConfig) {
        return PaymentIntegrationsApiFp(this.configuration).createPaymentIntegration(requestParameters.createPaymentIntegrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete the user\'s payment integration
     * @param {PaymentIntegrationsApiDeletePaymentIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntegrationsApi
     */
    public deletePaymentIntegration(requestParameters: PaymentIntegrationsApiDeletePaymentIntegrationRequest, options?: AxiosRequestConfig) {
        return PaymentIntegrationsApiFp(this.configuration).deletePaymentIntegration(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all payment integrations available to a user
     * @param {PaymentIntegrationsApiGetPaymentIntegrationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntegrationsApi
     */
    public getPaymentIntegrations(requestParameters: PaymentIntegrationsApiGetPaymentIntegrationsRequest, options?: AxiosRequestConfig) {
        return PaymentIntegrationsApiFp(this.configuration).getPaymentIntegrations(requestParameters.teamId, requestParameters.id, requestParameters.isEnabled, requestParameters.fetchAll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update the user\'s payment integration
     * @param {PaymentIntegrationsApiPatchPaymentIntegrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntegrationsApi
     */
    public patchPaymentIntegration(requestParameters: PaymentIntegrationsApiPatchPaymentIntegrationRequest, options?: AxiosRequestConfig) {
        return PaymentIntegrationsApiFp(this.configuration).patchPaymentIntegration(requestParameters.id, requestParameters.patchPaymentIntegrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used by payment integrations to notify the server of payment events
     * @summary Webhook for payment integrations
     * @param {PaymentIntegrationsApiPaymentIntegrationWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntegrationsApi
     */
    public paymentIntegrationWebhook(requestParameters: PaymentIntegrationsApiPaymentIntegrationWebhookRequest, options?: AxiosRequestConfig) {
        return PaymentIntegrationsApiFp(this.configuration).paymentIntegrationWebhook(requestParameters.name, requestParameters.secret, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a payment link
     * @param {PaymentIntegrationsApiPaymentLinkPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntegrationsApi
     */
    public paymentLinkPost(requestParameters: PaymentIntegrationsApiPaymentLinkPostRequest, options?: AxiosRequestConfig) {
        return PaymentIntegrationsApiFp(this.configuration).paymentLinkPost(requestParameters.id, requestParameters.paymentLinkPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentRecordsApi - axios parameter creator
 * @export
 */
export const PaymentRecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PaymentRecordPostRequest} [paymentRecordPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRecordPost: async (paymentRecordPostRequest?: PaymentRecordPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_RECORDS_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentRecordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] Number of items to retreive
         * @param {string} [cursor] Cursor to retreive items. It is the ID before which you want to retrieve the orders
         * @param {Array<number>} [ids] Fetch payment records of specified transaction ids
         * @param {Array<string>} [paymentIntegrationId] Fetch payment records of specified integration ids
         * @param {string} [orderId] Fetch payment records by orderId
         * @param {'completed' | 'pending' | 'cancelled'} [status] Fetch payment records with status
         * @param {boolean} [fetchAll] Fetch all records if you have admin Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRecordsGet: async (pageSize?: number, cursor?: string, ids?: Array<number>, paymentIntegrationId?: Array<string>, orderId?: string, status?: 'completed' | 'pending' | 'cancelled', fetchAll?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payment-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENT_RECORDS_READ"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (paymentIntegrationId) {
                localVarQueryParameter['paymentIntegrationId'] = paymentIntegrationId;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (fetchAll !== undefined) {
                localVarQueryParameter['fetchAll'] = fetchAll;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentRecordsApi - functional programming interface
 * @export
 */
export const PaymentRecordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentRecordsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PaymentRecordPostRequest} [paymentRecordPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentRecordPost(paymentRecordPostRequest?: PaymentRecordPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentRecordPost(paymentRecordPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [pageSize] Number of items to retreive
         * @param {string} [cursor] Cursor to retreive items. It is the ID before which you want to retrieve the orders
         * @param {Array<number>} [ids] Fetch payment records of specified transaction ids
         * @param {Array<string>} [paymentIntegrationId] Fetch payment records of specified integration ids
         * @param {string} [orderId] Fetch payment records by orderId
         * @param {'completed' | 'pending' | 'cancelled'} [status] Fetch payment records with status
         * @param {boolean} [fetchAll] Fetch all records if you have admin Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentRecordsGet(pageSize?: number, cursor?: string, ids?: Array<number>, paymentIntegrationId?: Array<string>, orderId?: string, status?: 'completed' | 'pending' | 'cancelled', fetchAll?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRecordsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentRecordsGet(pageSize, cursor, ids, paymentIntegrationId, orderId, status, fetchAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentRecordsApi - factory interface
 * @export
 */
export const PaymentRecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentRecordsApiFp(configuration)
    return {
        /**
         * 
         * @param {PaymentRecordsApiPaymentRecordPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRecordPost(requestParameters: PaymentRecordsApiPaymentRecordPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PaymentRecord> {
            return localVarFp.paymentRecordPost(requestParameters.paymentRecordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PaymentRecordsApiPaymentRecordsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRecordsGet(requestParameters: PaymentRecordsApiPaymentRecordsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PaymentRecordsGet200Response> {
            return localVarFp.paymentRecordsGet(requestParameters.pageSize, requestParameters.cursor, requestParameters.ids, requestParameters.paymentIntegrationId, requestParameters.orderId, requestParameters.status, requestParameters.fetchAll, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for paymentRecordPost operation in PaymentRecordsApi.
 * @export
 * @interface PaymentRecordsApiPaymentRecordPostRequest
 */
export interface PaymentRecordsApiPaymentRecordPostRequest {
    /**
     * 
     * @type {PaymentRecordPostRequest}
     * @memberof PaymentRecordsApiPaymentRecordPost
     */
    readonly paymentRecordPostRequest?: PaymentRecordPostRequest
}

/**
 * Request parameters for paymentRecordsGet operation in PaymentRecordsApi.
 * @export
 * @interface PaymentRecordsApiPaymentRecordsGetRequest
 */
export interface PaymentRecordsApiPaymentRecordsGetRequest {
    /**
     * Number of items to retreive
     * @type {number}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly pageSize?: number

    /**
     * Cursor to retreive items. It is the ID before which you want to retrieve the orders
     * @type {string}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly cursor?: string

    /**
     * Fetch payment records of specified transaction ids
     * @type {Array<number>}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly ids?: Array<number>

    /**
     * Fetch payment records of specified integration ids
     * @type {Array<string>}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly paymentIntegrationId?: Array<string>

    /**
     * Fetch payment records by orderId
     * @type {string}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly orderId?: string

    /**
     * Fetch payment records with status
     * @type {'completed' | 'pending' | 'cancelled'}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly status?: 'completed' | 'pending' | 'cancelled'

    /**
     * Fetch all records if you have admin Access
     * @type {boolean}
     * @memberof PaymentRecordsApiPaymentRecordsGet
     */
    readonly fetchAll?: boolean
}

/**
 * PaymentRecordsApi - object-oriented interface
 * @export
 * @class PaymentRecordsApi
 * @extends {BaseAPI}
 */
export class PaymentRecordsApi extends BaseAPI {
    /**
     * 
     * @param {PaymentRecordsApiPaymentRecordPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentRecordsApi
     */
    public paymentRecordPost(requestParameters: PaymentRecordsApiPaymentRecordPostRequest = {}, options?: AxiosRequestConfig) {
        return PaymentRecordsApiFp(this.configuration).paymentRecordPost(requestParameters.paymentRecordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PaymentRecordsApiPaymentRecordsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentRecordsApi
     */
    public paymentRecordsGet(requestParameters: PaymentRecordsApiPaymentRecordsGetRequest = {}, options?: AxiosRequestConfig) {
        return PaymentRecordsApiFp(this.configuration).paymentRecordsGet(requestParameters.pageSize, requestParameters.cursor, requestParameters.ids, requestParameters.paymentIntegrationId, requestParameters.orderId, requestParameters.status, requestParameters.fetchAll, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentSystemsApi - axios parameter creator
 * @export
 */
export const PaymentSystemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get available payment systems
         * @param {string} teamId 
         * @param {string} [country] Fetch Payment Systems from a particular country
         * @param {string} [q] Fetch Payment Systems by query
         * @param {boolean} [fetchAll] Fetch all systems if you have admin Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsGet: async (teamId: string, country?: string, q?: string, fetchAll?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('paymentSystemsGet', 'teamId', teamId)
            const localVarPath = `/payment-systems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (fetchAll !== undefined) {
                localVarQueryParameter['fetchAll'] = fetchAll;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentSystemsApi - functional programming interface
 * @export
 */
export const PaymentSystemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentSystemsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get available payment systems
         * @param {string} teamId 
         * @param {string} [country] Fetch Payment Systems from a particular country
         * @param {string} [q] Fetch Payment Systems by query
         * @param {boolean} [fetchAll] Fetch all systems if you have admin Access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentSystemsGet(teamId: string, country?: string, q?: string, fetchAll?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSystemsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentSystemsGet(teamId, country, q, fetchAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentSystemsApi - factory interface
 * @export
 */
export const PaymentSystemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentSystemsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get available payment systems
         * @param {PaymentSystemsApiPaymentSystemsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentSystemsGet(requestParameters: PaymentSystemsApiPaymentSystemsGetRequest, options?: AxiosRequestConfig): AxiosPromise<PaymentSystemsGet200Response> {
            return localVarFp.paymentSystemsGet(requestParameters.teamId, requestParameters.country, requestParameters.q, requestParameters.fetchAll, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for paymentSystemsGet operation in PaymentSystemsApi.
 * @export
 * @interface PaymentSystemsApiPaymentSystemsGetRequest
 */
export interface PaymentSystemsApiPaymentSystemsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentSystemsApiPaymentSystemsGet
     */
    readonly teamId: string

    /**
     * Fetch Payment Systems from a particular country
     * @type {string}
     * @memberof PaymentSystemsApiPaymentSystemsGet
     */
    readonly country?: string

    /**
     * Fetch Payment Systems by query
     * @type {string}
     * @memberof PaymentSystemsApiPaymentSystemsGet
     */
    readonly q?: string

    /**
     * Fetch all systems if you have admin Access
     * @type {boolean}
     * @memberof PaymentSystemsApiPaymentSystemsGet
     */
    readonly fetchAll?: boolean
}

/**
 * PaymentSystemsApi - object-oriented interface
 * @export
 * @class PaymentSystemsApi
 * @extends {BaseAPI}
 */
export class PaymentSystemsApi extends BaseAPI {
    /**
     * 
     * @summary Get available payment systems
     * @param {PaymentSystemsApiPaymentSystemsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSystemsApi
     */
    public paymentSystemsGet(requestParameters: PaymentSystemsApiPaymentSystemsGetRequest, options?: AxiosRequestConfig) {
        return PaymentSystemsApiFp(this.configuration).paymentSystemsGet(requestParameters.teamId, requestParameters.country, requestParameters.q, requestParameters.fetchAll, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServicesApi - axios parameter creator
 * @export
 */
export const ServicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This deletes the service and any trackings associated with it
         * @summary Removes the specified service
         * @param {string} id ID of service to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('servicesDelete', 'id', id)
            const localVarPath = `/services/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["INTEGRATIONS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This contains all the metadata required to display & create a \"tracking\" for said service. 
         * @summary Get the list of all supported integrations or services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a new service to the list
         * @param {PostServiceModel} [postServiceModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesPost: async (postServiceModel?: PostServiceModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["INTEGRATIONS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postServiceModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Call this endpoint to reload all service schemas by fetching them from the their respective hosted URLs 
         * @summary Reload all service schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesReload: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services/reload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["INTEGRATIONS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServicesApi - functional programming interface
 * @export
 */
export const ServicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServicesApiAxiosParamCreator(configuration)
    return {
        /**
         * This deletes the service and any trackings associated with it
         * @summary Removes the specified service
         * @param {string} id ID of service to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This contains all the metadata required to display & create a \"tracking\" for said service. 
         * @summary Get the list of all supported integrations or services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Services>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a new service to the list
         * @param {PostServiceModel} [postServiceModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesPost(postServiceModel?: PostServiceModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesPost(postServiceModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Call this endpoint to reload all service schemas by fetching them from the their respective hosted URLs 
         * @summary Reload all service schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesReload(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesReload(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServicesApi - factory interface
 * @export
 */
export const ServicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServicesApiFp(configuration)
    return {
        /**
         * This deletes the service and any trackings associated with it
         * @summary Removes the specified service
         * @param {ServicesApiServicesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesDelete(requestParameters: ServicesApiServicesDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.servicesDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This contains all the metadata required to display & create a \"tracking\" for said service. 
         * @summary Get the list of all supported integrations or services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesGet(options?: AxiosRequestConfig): AxiosPromise<Services> {
            return localVarFp.servicesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a new service to the list
         * @param {ServicesApiServicesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesPost(requestParameters: ServicesApiServicesPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.servicesPost(requestParameters.postServiceModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Call this endpoint to reload all service schemas by fetching them from the their respective hosted URLs 
         * @summary Reload all service schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesReload(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.servicesReload(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for servicesDelete operation in ServicesApi.
 * @export
 * @interface ServicesApiServicesDeleteRequest
 */
export interface ServicesApiServicesDeleteRequest {
    /**
     * ID of service to remove
     * @type {string}
     * @memberof ServicesApiServicesDelete
     */
    readonly id: string
}

/**
 * Request parameters for servicesPost operation in ServicesApi.
 * @export
 * @interface ServicesApiServicesPostRequest
 */
export interface ServicesApiServicesPostRequest {
    /**
     * 
     * @type {PostServiceModel}
     * @memberof ServicesApiServicesPost
     */
    readonly postServiceModel?: PostServiceModel
}

/**
 * ServicesApi - object-oriented interface
 * @export
 * @class ServicesApi
 * @extends {BaseAPI}
 */
export class ServicesApi extends BaseAPI {
    /**
     * This deletes the service and any trackings associated with it
     * @summary Removes the specified service
     * @param {ServicesApiServicesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesDelete(requestParameters: ServicesApiServicesDeleteRequest, options?: AxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This contains all the metadata required to display & create a \"tracking\" for said service. 
     * @summary Get the list of all supported integrations or services
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesGet(options?: AxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a new service to the list
     * @param {ServicesApiServicesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesPost(requestParameters: ServicesApiServicesPostRequest = {}, options?: AxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesPost(requestParameters.postServiceModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Call this endpoint to reload all service schemas by fetching them from the their respective hosted URLs 
     * @summary Reload all service schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesReload(options?: AxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesReload(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShopMetadataApi - axios parameter creator
 * @export
 */
export const ShopMetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the shop metadata
         * @param {string} [id] Fetch a particular team\&#39;s metadata
         * @param {string} [shopName] Fetch a particular shops\&#39;s metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopMetadataGet: async (id?: string, shopName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shop-metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (shopName !== undefined) {
                localVarQueryParameter['shopName'] = shopName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the shop metadata
         * @param {string} id Patch a particular team\&#39;s metadata
         * @param {ShopMetadataGet200Response} [shopMetadataGet200Response] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopMetadataPatch: async (id: string, shopMetadataGet200Response?: ShopMetadataGet200Response, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopMetadataPatch', 'id', id)
            const localVarPath = `/shop-metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["INTEGRATIONS_UPDATE"], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopMetadataGet200Response, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create shop metadata in bulk
         * @param {ShopMetadataPostRequest} [shopMetadataPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopMetadataPost: async (shopMetadataPostRequest?: ShopMetadataPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shop-metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopMetadataPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShopMetadataApi - functional programming interface
 * @export
 */
export const ShopMetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShopMetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the shop metadata
         * @param {string} [id] Fetch a particular team\&#39;s metadata
         * @param {string} [shopName] Fetch a particular shops\&#39;s metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopMetadataGet(id?: string, shopName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopMetadataGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopMetadataGet(id, shopName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the shop metadata
         * @param {string} id Patch a particular team\&#39;s metadata
         * @param {ShopMetadataGet200Response} [shopMetadataGet200Response] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopMetadataPatch(id: string, shopMetadataGet200Response?: ShopMetadataGet200Response, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopMetadataGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopMetadataPatch(id, shopMetadataGet200Response, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create shop metadata in bulk
         * @param {ShopMetadataPostRequest} [shopMetadataPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopMetadataPost(shopMetadataPostRequest?: ShopMetadataPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopMetadataPostRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopMetadataPost(shopMetadataPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShopMetadataApi - factory interface
 * @export
 */
export const ShopMetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShopMetadataApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the shop metadata
         * @param {ShopMetadataApiShopMetadataGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopMetadataGet(requestParameters: ShopMetadataApiShopMetadataGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ShopMetadataGet200Response> {
            return localVarFp.shopMetadataGet(requestParameters.id, requestParameters.shopName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the shop metadata
         * @param {ShopMetadataApiShopMetadataPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopMetadataPatch(requestParameters: ShopMetadataApiShopMetadataPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ShopMetadataGet200Response> {
            return localVarFp.shopMetadataPatch(requestParameters.id, requestParameters.shopMetadataGet200Response, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create shop metadata in bulk
         * @param {ShopMetadataApiShopMetadataPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopMetadataPost(requestParameters: ShopMetadataApiShopMetadataPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ShopMetadataPostRequest> {
            return localVarFp.shopMetadataPost(requestParameters.shopMetadataPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for shopMetadataGet operation in ShopMetadataApi.
 * @export
 * @interface ShopMetadataApiShopMetadataGetRequest
 */
export interface ShopMetadataApiShopMetadataGetRequest {
    /**
     * Fetch a particular team\&#39;s metadata
     * @type {string}
     * @memberof ShopMetadataApiShopMetadataGet
     */
    readonly id?: string

    /**
     * Fetch a particular shops\&#39;s metadata
     * @type {string}
     * @memberof ShopMetadataApiShopMetadataGet
     */
    readonly shopName?: string
}

/**
 * Request parameters for shopMetadataPatch operation in ShopMetadataApi.
 * @export
 * @interface ShopMetadataApiShopMetadataPatchRequest
 */
export interface ShopMetadataApiShopMetadataPatchRequest {
    /**
     * Patch a particular team\&#39;s metadata
     * @type {string}
     * @memberof ShopMetadataApiShopMetadataPatch
     */
    readonly id: string

    /**
     * 
     * @type {ShopMetadataGet200Response}
     * @memberof ShopMetadataApiShopMetadataPatch
     */
    readonly shopMetadataGet200Response?: ShopMetadataGet200Response
}

/**
 * Request parameters for shopMetadataPost operation in ShopMetadataApi.
 * @export
 * @interface ShopMetadataApiShopMetadataPostRequest
 */
export interface ShopMetadataApiShopMetadataPostRequest {
    /**
     * 
     * @type {ShopMetadataPostRequest}
     * @memberof ShopMetadataApiShopMetadataPost
     */
    readonly shopMetadataPostRequest?: ShopMetadataPostRequest
}

/**
 * ShopMetadataApi - object-oriented interface
 * @export
 * @class ShopMetadataApi
 * @extends {BaseAPI}
 */
export class ShopMetadataApi extends BaseAPI {
    /**
     * 
     * @summary Get the shop metadata
     * @param {ShopMetadataApiShopMetadataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopMetadataApi
     */
    public shopMetadataGet(requestParameters: ShopMetadataApiShopMetadataGetRequest = {}, options?: AxiosRequestConfig) {
        return ShopMetadataApiFp(this.configuration).shopMetadataGet(requestParameters.id, requestParameters.shopName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the shop metadata
     * @param {ShopMetadataApiShopMetadataPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopMetadataApi
     */
    public shopMetadataPatch(requestParameters: ShopMetadataApiShopMetadataPatchRequest, options?: AxiosRequestConfig) {
        return ShopMetadataApiFp(this.configuration).shopMetadataPatch(requestParameters.id, requestParameters.shopMetadataGet200Response, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create shop metadata in bulk
     * @param {ShopMetadataApiShopMetadataPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopMetadataApi
     */
    public shopMetadataPost(requestParameters: ShopMetadataApiShopMetadataPostRequest = {}, options?: AxiosRequestConfig) {
        return ShopMetadataApiFp(this.configuration).shopMetadataPost(requestParameters.shopMetadataPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrackingProductsApi - axios parameter creator
 * @export
 */
export const TrackingProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get products of the tracking
         * @param {number} trackingId Fetch products of the specified trackingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet: async (trackingId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('productsGet', 'trackingId', trackingId)
            const localVarPath = `/products/{trackingId}`
                .replace(`{${"trackingId"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PRODUCTS_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackingProductsApi - functional programming interface
 * @export
 */
export const TrackingProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackingProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get products of the tracking
         * @param {number} trackingId Fetch products of the specified trackingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGet(trackingId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProductsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGet(trackingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrackingProductsApi - factory interface
 * @export
 */
export const TrackingProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackingProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get products of the tracking
         * @param {TrackingProductsApiProductsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet(requestParameters: TrackingProductsApiProductsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ServiceProductsData> {
            return localVarFp.productsGet(requestParameters.trackingId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for productsGet operation in TrackingProductsApi.
 * @export
 * @interface TrackingProductsApiProductsGetRequest
 */
export interface TrackingProductsApiProductsGetRequest {
    /**
     * Fetch products of the specified trackingId
     * @type {number}
     * @memberof TrackingProductsApiProductsGet
     */
    readonly trackingId: number
}

/**
 * TrackingProductsApi - object-oriented interface
 * @export
 * @class TrackingProductsApi
 * @extends {BaseAPI}
 */
export class TrackingProductsApi extends BaseAPI {
    /**
     * 
     * @summary Get products of the tracking
     * @param {TrackingProductsApiProductsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingProductsApi
     */
    public productsGet(requestParameters: TrackingProductsApiProductsGetRequest, options?: AxiosRequestConfig) {
        return TrackingProductsApiFp(this.configuration).productsGet(requestParameters.trackingId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrackingsApi - axios parameter creator
 * @export
 */
export const TrackingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the event histor
         * @param {number} [trackingId] Fetch orders of the specified trackingId
         * @param {number} [phoneNumber] Fetch orders sent to the specified phone number
         * @param {number} [triggerId] Fetch orders of the specified triggerId
         * @param {number} [pageSize] Number of items to retreive
         * @param {string} [cursor] Cursor to retreive items. It can be anyone of orderBy by which you want to retrieve the orders
         * @param {'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate'} [orderBy] Order by which value
         * @param {'ASC' | 'DESC'} [direction] Sorting order of the response
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {Array<string>} [orderStatus] 
         * @param {Array<string>} [paymentStatus] 
         * @param {Array<string>} [messageStatus] 
         * @param {string} [q] Query to retrieve select orders
         * @param {boolean} [excludeTests] Should tests be excluded
         * @param {boolean} [includeNullTriggers] Should events which did not trigger an EventTrigger be included?
         * @param {boolean} [returnTotal] Should a total of the number of orders returned by the given query be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGet: async (trackingId?: number, phoneNumber?: number, triggerId?: number, pageSize?: number, cursor?: string, orderBy?: 'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate', direction?: 'ASC' | 'DESC', startTime?: string, endTime?: string, orderStatus?: Array<string>, paymentStatus?: Array<string>, messageStatus?: Array<string>, q?: string, excludeTests?: boolean, includeNullTriggers?: boolean, returnTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tracking/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_READ"], configuration)

            if (trackingId !== undefined) {
                localVarQueryParameter['trackingId'] = trackingId;
            }

            if (phoneNumber !== undefined) {
                localVarQueryParameter['phoneNumber'] = phoneNumber;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (orderStatus) {
                localVarQueryParameter['orderStatus'] = orderStatus;
            }

            if (paymentStatus) {
                localVarQueryParameter['paymentStatus'] = paymentStatus;
            }

            if (messageStatus) {
                localVarQueryParameter['messageStatus'] = messageStatus;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (excludeTests !== undefined) {
                localVarQueryParameter['excludeTests'] = excludeTests;
            }

            if (includeNullTriggers !== undefined) {
                localVarQueryParameter['includeNullTriggers'] = includeNullTriggers;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the updated order data
         * @param {number} [trackingId] Fetch orders of the specified trackingId
         * @param {number} [phoneNumber] Fetch orders sent to the specified phone number
         * @param {number} [pageSize] Number of items to retreive
         * @param {string} [cursor] Cursor to retreive items. It can be anyone of orderBy by which you want to retrieve the orders
         * @param {'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate' | 'createdAt' | 'updatedAt'} [orderBy] Order by which value
         * @param {'ASC' | 'DESC'} [direction] Sorting order of the response
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {Array<string>} [orderStatus] 
         * @param {Array<string>} [paymentStatus] 
         * @param {Array<string>} [messageStatus] 
         * @param {string} [q] Query to retrieve select orders
         * @param {boolean} [excludeTests] Should tests be excluded
         * @param {boolean} [returnTotal] Should a total of the number of orders returned by the given query be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDataGet: async (trackingId?: number, phoneNumber?: number, pageSize?: number, cursor?: string, orderBy?: 'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate' | 'createdAt' | 'updatedAt', direction?: 'ASC' | 'DESC', startTime?: string, endTime?: string, orderStatus?: Array<string>, paymentStatus?: Array<string>, messageStatus?: Array<string>, q?: string, excludeTests?: boolean, returnTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_READ"], configuration)

            if (trackingId !== undefined) {
                localVarQueryParameter['trackingId'] = trackingId;
            }

            if (phoneNumber !== undefined) {
                localVarQueryParameter['phoneNumber'] = phoneNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (orderStatus) {
                localVarQueryParameter['orderStatus'] = orderStatus;
            }

            if (paymentStatus) {
                localVarQueryParameter['paymentStatus'] = paymentStatus;
            }

            if (messageStatus) {
                localVarQueryParameter['messageStatus'] = messageStatus;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (excludeTests !== undefined) {
                localVarQueryParameter['excludeTests'] = excludeTests;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update order details
         * @param {string} orderId The orderId of the tracking made available to the service
         * @param {UpdateOrderDataModel} [updateOrderDataModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPatch: async (orderId: string, updateOrderDataModel?: UpdateOrderDataModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderPatch', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrderDataModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This deletes the tracking and its associated flowIds from the Database permanently.
         * @summary Stop tracking
         * @param {number} trackingId The Tracking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingDelete: async (trackingId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('trackingDelete', 'trackingId', trackingId)
            const localVarPath = `/tracking/{trackingId}`
                .replace(`{${"trackingId"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of all trackings for your team 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tracking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit existing events\' flowIds or create new events. Credentials array is forwarded to scrapper for updation.
         * @summary Update events, credentials, notifyUsers or isActive of a tracking
         * @param {number} trackingId The Tracking
         * @param {UpdateTracking} [updateTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingPatch: async (trackingId: number, updateTracking?: UpdateTracking, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('trackingPatch', 'trackingId', trackingId)
            const localVarPath = `/tracking/{trackingId}`
                .replace(`{${"trackingId"}}`, encodeURIComponent(String(trackingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTracking, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start tracking of a new service for a team
         * @param {PostTracking} [postTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingPost: async (postTracking?: PostTracking, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tracking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTracking, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used by the external tracking integration to update the error state of a tracking. The scrapper will call this endpoint when it encounters an irrecoverable error while scraping. 
         * @summary Update the error state of a tracking
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {UpdateTrackingErrorState} [updateTrackingErrorState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingUpdateErrorState: async (secretId: string, updateTrackingErrorState?: UpdateTrackingErrorState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('trackingUpdateErrorState', 'secretId', secretId)
            const localVarPath = `/tracking/{secretId}/update-error-state`
                .replace(`{${"secretId"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTrackingErrorState, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test a trigger
         * @param {number} trackingId The trackingId to test
         * @param {number} triggerId The triggerId to test
         * @param {string} [recipientPhoneNumber] Phone number to send the test to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTest: async (trackingId: number, triggerId: number, recipientPhoneNumber?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackingId' is not null or undefined
            assertParamExists('triggerTest', 'trackingId', trackingId)
            // verify required parameter 'triggerId' is not null or undefined
            assertParamExists('triggerTest', 'triggerId', triggerId)
            const localVarPath = `/tracking/{trackingId}/{triggerId}/test`
                .replace(`{${"trackingId"}}`, encodeURIComponent(String(trackingId)))
                .replace(`{${"triggerId"}}`, encodeURIComponent(String(triggerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["NOTIFICATION_UPDATE"], configuration)

            if (recipientPhoneNumber !== undefined) {
                localVarQueryParameter['recipientPhoneNumber'] = recipientPhoneNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackingsApi - functional programming interface
 * @export
 */
export const TrackingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the event histor
         * @param {number} [trackingId] Fetch orders of the specified trackingId
         * @param {number} [phoneNumber] Fetch orders sent to the specified phone number
         * @param {number} [triggerId] Fetch orders of the specified triggerId
         * @param {number} [pageSize] Number of items to retreive
         * @param {string} [cursor] Cursor to retreive items. It can be anyone of orderBy by which you want to retrieve the orders
         * @param {'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate'} [orderBy] Order by which value
         * @param {'ASC' | 'DESC'} [direction] Sorting order of the response
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {Array<string>} [orderStatus] 
         * @param {Array<string>} [paymentStatus] 
         * @param {Array<string>} [messageStatus] 
         * @param {string} [q] Query to retrieve select orders
         * @param {boolean} [excludeTests] Should tests be excluded
         * @param {boolean} [includeNullTriggers] Should events which did not trigger an EventTrigger be included?
         * @param {boolean} [returnTotal] Should a total of the number of orders returned by the given query be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataGet(trackingId?: number, phoneNumber?: number, triggerId?: number, pageSize?: number, cursor?: string, orderBy?: 'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate', direction?: 'ASC' | 'DESC', startTime?: string, endTime?: string, orderStatus?: Array<string>, paymentStatus?: Array<string>, messageStatus?: Array<string>, q?: string, excludeTests?: boolean, includeNullTriggers?: boolean, returnTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataGet(trackingId, phoneNumber, triggerId, pageSize, cursor, orderBy, direction, startTime, endTime, orderStatus, paymentStatus, messageStatus, q, excludeTests, includeNullTriggers, returnTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the updated order data
         * @param {number} [trackingId] Fetch orders of the specified trackingId
         * @param {number} [phoneNumber] Fetch orders sent to the specified phone number
         * @param {number} [pageSize] Number of items to retreive
         * @param {string} [cursor] Cursor to retreive items. It can be anyone of orderBy by which you want to retrieve the orders
         * @param {'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate' | 'createdAt' | 'updatedAt'} [orderBy] Order by which value
         * @param {'ASC' | 'DESC'} [direction] Sorting order of the response
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {Array<string>} [orderStatus] 
         * @param {Array<string>} [paymentStatus] 
         * @param {Array<string>} [messageStatus] 
         * @param {string} [q] Query to retrieve select orders
         * @param {boolean} [excludeTests] Should tests be excluded
         * @param {boolean} [returnTotal] Should a total of the number of orders returned by the given query be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderDataGet(trackingId?: number, phoneNumber?: number, pageSize?: number, cursor?: string, orderBy?: 'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate' | 'createdAt' | 'updatedAt', direction?: 'ASC' | 'DESC', startTime?: string, endTime?: string, orderStatus?: Array<string>, paymentStatus?: Array<string>, messageStatus?: Array<string>, q?: string, excludeTests?: boolean, returnTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDataGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderDataGet(trackingId, phoneNumber, pageSize, cursor, orderBy, direction, startTime, endTime, orderStatus, paymentStatus, messageStatus, q, excludeTests, returnTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update order details
         * @param {string} orderId The orderId of the tracking made available to the service
         * @param {UpdateOrderDataModel} [updateOrderDataModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderPatch(orderId: string, updateOrderDataModel?: UpdateOrderDataModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderPatch(orderId, updateOrderDataModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This deletes the tracking and its associated flowIds from the Database permanently.
         * @summary Stop tracking
         * @param {number} trackingId The Tracking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingDelete(trackingId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingDelete(trackingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the list of all trackings for your team 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackServices>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit existing events\' flowIds or create new events. Credentials array is forwarded to scrapper for updation.
         * @summary Update events, credentials, notifyUsers or isActive of a tracking
         * @param {number} trackingId The Tracking
         * @param {UpdateTracking} [updateTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingPatch(trackingId: number, updateTracking?: UpdateTracking, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingPatch(trackingId, updateTracking, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start tracking of a new service for a team
         * @param {PostTracking} [postTracking] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingPost(postTracking?: PostTracking, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingPost(postTracking, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is used by the external tracking integration to update the error state of a tracking. The scrapper will call this endpoint when it encounters an irrecoverable error while scraping. 
         * @summary Update the error state of a tracking
         * @param {string} secretId The secret ID of the tracking made available to the service
         * @param {UpdateTrackingErrorState} [updateTrackingErrorState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackingUpdateErrorState(secretId: string, updateTrackingErrorState?: UpdateTrackingErrorState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackingUpdateErrorState(secretId, updateTrackingErrorState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Test a trigger
         * @param {number} trackingId The trackingId to test
         * @param {number} triggerId The triggerId to test
         * @param {string} [recipientPhoneNumber] Phone number to send the test to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerTest(trackingId: number, triggerId: number, recipientPhoneNumber?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TriggerTest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerTest(trackingId, triggerId, recipientPhoneNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrackingsApi - factory interface
 * @export
 */
export const TrackingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the event histor
         * @param {TrackingsApiDataGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataGet(requestParameters: TrackingsApiDataGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<DataGet200Response> {
            return localVarFp.dataGet(requestParameters.trackingId, requestParameters.phoneNumber, requestParameters.triggerId, requestParameters.pageSize, requestParameters.cursor, requestParameters.orderBy, requestParameters.direction, requestParameters.startTime, requestParameters.endTime, requestParameters.orderStatus, requestParameters.paymentStatus, requestParameters.messageStatus, requestParameters.q, requestParameters.excludeTests, requestParameters.includeNullTriggers, requestParameters.returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the updated order data
         * @param {TrackingsApiOrderDataGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDataGet(requestParameters: TrackingsApiOrderDataGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<OrderDataGet200Response> {
            return localVarFp.orderDataGet(requestParameters.trackingId, requestParameters.phoneNumber, requestParameters.pageSize, requestParameters.cursor, requestParameters.orderBy, requestParameters.direction, requestParameters.startTime, requestParameters.endTime, requestParameters.orderStatus, requestParameters.paymentStatus, requestParameters.messageStatus, requestParameters.q, requestParameters.excludeTests, requestParameters.returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update order details
         * @param {TrackingsApiOrderPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPatch(requestParameters: TrackingsApiOrderPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderPatch(requestParameters.orderId, requestParameters.updateOrderDataModel, options).then((request) => request(axios, basePath));
        },
        /**
         * This deletes the tracking and its associated flowIds from the Database permanently.
         * @summary Stop tracking
         * @param {TrackingsApiTrackingDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingDelete(requestParameters: TrackingsApiTrackingDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.trackingDelete(requestParameters.trackingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the list of all trackings for your team 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingGet(options?: AxiosRequestConfig): AxiosPromise<TrackServices> {
            return localVarFp.trackingGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Edit existing events\' flowIds or create new events. Credentials array is forwarded to scrapper for updation.
         * @summary Update events, credentials, notifyUsers or isActive of a tracking
         * @param {TrackingsApiTrackingPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingPatch(requestParameters: TrackingsApiTrackingPatchRequest, options?: AxiosRequestConfig): AxiosPromise<TrackingPatch200Response> {
            return localVarFp.trackingPatch(requestParameters.trackingId, requestParameters.updateTracking, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start tracking of a new service for a team
         * @param {TrackingsApiTrackingPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingPost(requestParameters: TrackingsApiTrackingPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<TrackingPost200Response> {
            return localVarFp.trackingPost(requestParameters.postTracking, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used by the external tracking integration to update the error state of a tracking. The scrapper will call this endpoint when it encounters an irrecoverable error while scraping. 
         * @summary Update the error state of a tracking
         * @param {TrackingsApiTrackingUpdateErrorStateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackingUpdateErrorState(requestParameters: TrackingsApiTrackingUpdateErrorStateRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.trackingUpdateErrorState(requestParameters.secretId, requestParameters.updateTrackingErrorState, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test a trigger
         * @param {TrackingsApiTriggerTestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTest(requestParameters: TrackingsApiTriggerTestRequest, options?: AxiosRequestConfig): AxiosPromise<TriggerTest200Response> {
            return localVarFp.triggerTest(requestParameters.trackingId, requestParameters.triggerId, requestParameters.recipientPhoneNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for dataGet operation in TrackingsApi.
 * @export
 * @interface TrackingsApiDataGetRequest
 */
export interface TrackingsApiDataGetRequest {
    /**
     * Fetch orders of the specified trackingId
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly trackingId?: number

    /**
     * Fetch orders sent to the specified phone number
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly phoneNumber?: number

    /**
     * Fetch orders of the specified triggerId
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly triggerId?: number

    /**
     * Number of items to retreive
     * @type {number}
     * @memberof TrackingsApiDataGet
     */
    readonly pageSize?: number

    /**
     * Cursor to retreive items. It can be anyone of orderBy by which you want to retrieve the orders
     * @type {string}
     * @memberof TrackingsApiDataGet
     */
    readonly cursor?: string

    /**
     * Order by which value
     * @type {'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate'}
     * @memberof TrackingsApiDataGet
     */
    readonly orderBy?: 'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate'

    /**
     * Sorting order of the response
     * @type {'ASC' | 'DESC'}
     * @memberof TrackingsApiDataGet
     */
    readonly direction?: 'ASC' | 'DESC'

    /**
     * 
     * @type {string}
     * @memberof TrackingsApiDataGet
     */
    readonly startTime?: string

    /**
     * 
     * @type {string}
     * @memberof TrackingsApiDataGet
     */
    readonly endTime?: string

    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingsApiDataGet
     */
    readonly orderStatus?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingsApiDataGet
     */
    readonly paymentStatus?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingsApiDataGet
     */
    readonly messageStatus?: Array<string>

    /**
     * Query to retrieve select orders
     * @type {string}
     * @memberof TrackingsApiDataGet
     */
    readonly q?: string

    /**
     * Should tests be excluded
     * @type {boolean}
     * @memberof TrackingsApiDataGet
     */
    readonly excludeTests?: boolean

    /**
     * Should events which did not trigger an EventTrigger be included?
     * @type {boolean}
     * @memberof TrackingsApiDataGet
     */
    readonly includeNullTriggers?: boolean

    /**
     * Should a total of the number of orders returned by the given query be included
     * @type {boolean}
     * @memberof TrackingsApiDataGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for orderDataGet operation in TrackingsApi.
 * @export
 * @interface TrackingsApiOrderDataGetRequest
 */
export interface TrackingsApiOrderDataGetRequest {
    /**
     * Fetch orders of the specified trackingId
     * @type {number}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly trackingId?: number

    /**
     * Fetch orders sent to the specified phone number
     * @type {number}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly phoneNumber?: number

    /**
     * Number of items to retreive
     * @type {number}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly pageSize?: number

    /**
     * Cursor to retreive items. It can be anyone of orderBy by which you want to retrieve the orders
     * @type {string}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly cursor?: string

    /**
     * Order by which value
     * @type {'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate' | 'createdAt' | 'updatedAt'}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly orderBy?: 'orderCustomer' | 'orderId' | 'orderDate' | 'deliveryDate' | 'createdAt' | 'updatedAt'

    /**
     * Sorting order of the response
     * @type {'ASC' | 'DESC'}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly direction?: 'ASC' | 'DESC'

    /**
     * 
     * @type {string}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly startTime?: string

    /**
     * 
     * @type {string}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly endTime?: string

    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly orderStatus?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly paymentStatus?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly messageStatus?: Array<string>

    /**
     * Query to retrieve select orders
     * @type {string}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly q?: string

    /**
     * Should tests be excluded
     * @type {boolean}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly excludeTests?: boolean

    /**
     * Should a total of the number of orders returned by the given query be included
     * @type {boolean}
     * @memberof TrackingsApiOrderDataGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for orderPatch operation in TrackingsApi.
 * @export
 * @interface TrackingsApiOrderPatchRequest
 */
export interface TrackingsApiOrderPatchRequest {
    /**
     * The orderId of the tracking made available to the service
     * @type {string}
     * @memberof TrackingsApiOrderPatch
     */
    readonly orderId: string

    /**
     * 
     * @type {UpdateOrderDataModel}
     * @memberof TrackingsApiOrderPatch
     */
    readonly updateOrderDataModel?: UpdateOrderDataModel
}

/**
 * Request parameters for trackingDelete operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTrackingDeleteRequest
 */
export interface TrackingsApiTrackingDeleteRequest {
    /**
     * The Tracking
     * @type {number}
     * @memberof TrackingsApiTrackingDelete
     */
    readonly trackingId: number
}

/**
 * Request parameters for trackingPatch operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTrackingPatchRequest
 */
export interface TrackingsApiTrackingPatchRequest {
    /**
     * The Tracking
     * @type {number}
     * @memberof TrackingsApiTrackingPatch
     */
    readonly trackingId: number

    /**
     * 
     * @type {UpdateTracking}
     * @memberof TrackingsApiTrackingPatch
     */
    readonly updateTracking?: UpdateTracking
}

/**
 * Request parameters for trackingPost operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTrackingPostRequest
 */
export interface TrackingsApiTrackingPostRequest {
    /**
     * 
     * @type {PostTracking}
     * @memberof TrackingsApiTrackingPost
     */
    readonly postTracking?: PostTracking
}

/**
 * Request parameters for trackingUpdateErrorState operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTrackingUpdateErrorStateRequest
 */
export interface TrackingsApiTrackingUpdateErrorStateRequest {
    /**
     * The secret ID of the tracking made available to the service
     * @type {string}
     * @memberof TrackingsApiTrackingUpdateErrorState
     */
    readonly secretId: string

    /**
     * 
     * @type {UpdateTrackingErrorState}
     * @memberof TrackingsApiTrackingUpdateErrorState
     */
    readonly updateTrackingErrorState?: UpdateTrackingErrorState
}

/**
 * Request parameters for triggerTest operation in TrackingsApi.
 * @export
 * @interface TrackingsApiTriggerTestRequest
 */
export interface TrackingsApiTriggerTestRequest {
    /**
     * The trackingId to test
     * @type {number}
     * @memberof TrackingsApiTriggerTest
     */
    readonly trackingId: number

    /**
     * The triggerId to test
     * @type {number}
     * @memberof TrackingsApiTriggerTest
     */
    readonly triggerId: number

    /**
     * Phone number to send the test to
     * @type {string}
     * @memberof TrackingsApiTriggerTest
     */
    readonly recipientPhoneNumber?: string
}

/**
 * TrackingsApi - object-oriented interface
 * @export
 * @class TrackingsApi
 * @extends {BaseAPI}
 */
export class TrackingsApi extends BaseAPI {
    /**
     * 
     * @summary Get the event histor
     * @param {TrackingsApiDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public dataGet(requestParameters: TrackingsApiDataGetRequest = {}, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).dataGet(requestParameters.trackingId, requestParameters.phoneNumber, requestParameters.triggerId, requestParameters.pageSize, requestParameters.cursor, requestParameters.orderBy, requestParameters.direction, requestParameters.startTime, requestParameters.endTime, requestParameters.orderStatus, requestParameters.paymentStatus, requestParameters.messageStatus, requestParameters.q, requestParameters.excludeTests, requestParameters.includeNullTriggers, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the updated order data
     * @param {TrackingsApiOrderDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public orderDataGet(requestParameters: TrackingsApiOrderDataGetRequest = {}, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).orderDataGet(requestParameters.trackingId, requestParameters.phoneNumber, requestParameters.pageSize, requestParameters.cursor, requestParameters.orderBy, requestParameters.direction, requestParameters.startTime, requestParameters.endTime, requestParameters.orderStatus, requestParameters.paymentStatus, requestParameters.messageStatus, requestParameters.q, requestParameters.excludeTests, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update order details
     * @param {TrackingsApiOrderPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public orderPatch(requestParameters: TrackingsApiOrderPatchRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).orderPatch(requestParameters.orderId, requestParameters.updateOrderDataModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This deletes the tracking and its associated flowIds from the Database permanently.
     * @summary Stop tracking
     * @param {TrackingsApiTrackingDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingDelete(requestParameters: TrackingsApiTrackingDeleteRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingDelete(requestParameters.trackingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the list of all trackings for your team 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingGet(options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit existing events\' flowIds or create new events. Credentials array is forwarded to scrapper for updation.
     * @summary Update events, credentials, notifyUsers or isActive of a tracking
     * @param {TrackingsApiTrackingPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingPatch(requestParameters: TrackingsApiTrackingPatchRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingPatch(requestParameters.trackingId, requestParameters.updateTracking, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start tracking of a new service for a team
     * @param {TrackingsApiTrackingPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingPost(requestParameters: TrackingsApiTrackingPostRequest = {}, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingPost(requestParameters.postTracking, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used by the external tracking integration to update the error state of a tracking. The scrapper will call this endpoint when it encounters an irrecoverable error while scraping. 
     * @summary Update the error state of a tracking
     * @param {TrackingsApiTrackingUpdateErrorStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public trackingUpdateErrorState(requestParameters: TrackingsApiTrackingUpdateErrorStateRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).trackingUpdateErrorState(requestParameters.secretId, requestParameters.updateTrackingErrorState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test a trigger
     * @param {TrackingsApiTriggerTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackingsApi
     */
    public triggerTest(requestParameters: TrackingsApiTriggerTestRequest, options?: AxiosRequestConfig) {
        return TrackingsApiFp(this.configuration).triggerTest(requestParameters.trackingId, requestParameters.triggerId, requestParameters.recipientPhoneNumber, options).then((request) => request(this.axios, this.basePath));
    }
}


