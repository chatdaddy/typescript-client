const BASE_PATH = "https://api.chatdaddy.tech/payments".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Payments Service
 * Manage all payment/subscription related operations
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: info@chatdaddy.tech
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from '../base';

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * 
     * @type {Array<Feature>}
     * @memberof Access
     */
    'features': Array<Feature>;
    /**
     * 
     * @type {LimitationMap}
     * @memberof Access
     */
    'limits': LimitationMap;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Access
     */
    'lastExpiryOrRenewalDate'?: string;
}
/**
 * 
 * @export
 * @interface AccountAccess
 */
export interface AccountAccess {
    /**
     * 
     * @type {Array<AccountFeature>}
     * @memberof AccountAccess
     */
    'features': Array<AccountFeature>;
    /**
     * 
     * @type {AccountLimitationMap}
     * @memberof AccountAccess
     */
    'limits': AccountLimitationMap;
}
/**
 * 
 * @export
 * @interface AccountAccessDetail
 */
export interface AccountAccessDetail {
    /**
     * 
     * @type {AccountAccess}
     * @memberof AccountAccessDetail
     */
    'access': AccountAccess;
    /**
     * 
     * @type {LimitationMap}
     * @memberof AccountAccessDetail
     */
    'usage': LimitationMap;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AccountFeature = {
    TeamInbox: 'team-inbox',
    CustomMarketingMessage: 'custom-marketing-message',
    ChatHistorySync: 'chat-history-sync'
} as const;

export type AccountFeature = typeof AccountFeature[keyof typeof AccountFeature];


/**
 * 
 * @export
 * @interface AccountLimitationMap
 */
export interface AccountLimitationMap {
    /**
     * The number of messages that can be sent per month.
     * @type {number}
     * @memberof AccountLimitationMap
     */
    'messages'?: number;
}
/**
 * 
 * @export
 * @interface AmountWithCurrency
 */
export interface AmountWithCurrency {
    /**
     * The amount in cents. So 100 is $1.00
     * @type {number}
     * @memberof AmountWithCurrency
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof AmountWithCurrency
     */
    'currency': string;
}
/**
 * @type AnyCreditConsumptionType
 * @export
 */
export type AnyCreditConsumptionType = CreditConsumptionType | RecurringCreditConsumptionType;

/**
 * 
 * @export
 * @interface AutoChargeProduct
 */
export interface AutoChargeProduct {
    /**
     * 
     * @type {LimitedItem}
     * @memberof AutoChargeProduct
     */
    'item': LimitedItem;
    /**
     * 
     * @type {string}
     * @memberof AutoChargeProduct
     */
    'stripePriceId': string;
}


/**
 * 
 * @export
 * @interface AutoChargeProductSet
 */
export interface AutoChargeProductSet {
    /**
     * 
     * @type {LimitedItem}
     * @memberof AutoChargeProductSet
     */
    'item': LimitedItem;
    /**
     * If null, auto charge for this item is disabled. Otherwise, this is the stripe price ID to charge for this item.
     * @type {string}
     * @memberof AutoChargeProductSet
     */
    'stripePriceId': string | null;
}


/**
 * 
 * @export
 * @interface AutoChargeProductsGet200Response
 */
export interface AutoChargeProductsGet200Response {
    /**
     * 
     * @type {Array<AutoChargeProduct>}
     * @memberof AutoChargeProductsGet200Response
     */
    'items': Array<AutoChargeProduct>;
}
/**
 * 
 * @export
 * @interface AutoChargeProductsPrepare200Response
 */
export interface AutoChargeProductsPrepare200Response {
    /**
     * 
     * @type {Access}
     * @memberof AutoChargeProductsPrepare200Response
     */
    'access': Access;
    /**
     * 
     * @type {LimitationMap}
     * @memberof AutoChargeProductsPrepare200Response
     */
    'usage': LimitationMap;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AutoRenewalPeriod = {
    Quarter: 'quarter',
    Year: 'year'
} as const;

export type AutoRenewalPeriod = typeof AutoRenewalPeriod[keyof typeof AutoRenewalPeriod];


/**
 * 
 * @export
 * @enum {string}
 */

export const BillingPeriod = {
    Month: 'month',
    Quarter: 'quarter',
    Year: 'year'
} as const;

export type BillingPeriod = typeof BillingPeriod[keyof typeof BillingPeriod];


/**
 * 
 * @export
 * @interface BillingSessionPost200Response
 */
export interface BillingSessionPost200Response {
    /**
     * 
     * @type {string}
     * @memberof BillingSessionPost200Response
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof BillingSessionPost200Response
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface CheckoutCreateOptions
 */
export interface CheckoutCreateOptions {
    /**
     * 
     * @type {CheckoutCreateOptionsCallbackUrls}
     * @memberof CheckoutCreateOptions
     */
    'callbackUrls': CheckoutCreateOptionsCallbackUrls;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateOptions
     */
    'coupon'?: string;
    /**
     * 
     * @type {Array<ProductsSelectionInner>}
     * @memberof CheckoutCreateOptions
     */
    'products': Array<ProductsSelectionInner>;
    /**
     * Add extra days to a subscription. Can only set using admin access
     * @type {number}
     * @memberof CheckoutCreateOptions
     */
    'extraDays'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CheckoutCreateOptions
     */
    'disableAutoRenew'?: boolean;
}
/**
 * 
 * @export
 * @interface CheckoutCreateOptionsCallbackUrls
 */
export interface CheckoutCreateOptionsCallbackUrls {
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateOptionsCallbackUrls
     */
    'success': string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateOptionsCallbackUrls
     */
    'failure': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CountryTier = {
    Tier1: 'tier1',
    Tier2: 'tier2',
    Tier3: 'tier3',
    Tier4: 'tier4'
} as const;

export type CountryTier = typeof CountryTier[keyof typeof CountryTier];


/**
 * 
 * @export
 * @interface Coupon
 */
export interface Coupon {
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof Coupon
     */
    'id': string;
    /**
     * The percentage off the coupon provides
     * @type {number}
     * @memberof Coupon
     */
    'percentageOff': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Coupon
     */
    'createdAt': string;
    /**
     * The ID of a user
     * @type {string}
     * @memberof Coupon
     */
    'createdBy': string;
    /**
     * If true, the coupon can be used for all subsequent billing cycles, else, only the first
     * @type {boolean}
     * @memberof Coupon
     */
    'isRecurring'?: boolean;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Coupon
     */
    'expiresAt'?: string | null;
    /**
     * limit coupon code to certain product types. If not provided, coupon code is applicable to all recurring product types
     * @type {Array<AnyCreditConsumptionType>}
     * @memberof Coupon
     */
    'creditConsumptionTypes': Array<AnyCreditConsumptionType>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Coupon
     */
    'archivedAt'?: string | null;
    /**
     * The partnership to use for this coupon. Only partnership teams can redeem this coupon.
     * @type {string}
     * @memberof Coupon
     */
    'partnership'?: string;
    /**
     * 
     * @type {CouponValidation}
     * @memberof Coupon
     */
    'couponValidation'?: CouponValidation;
}
/**
 * 
 * @export
 * @interface CouponCodeCreateOptions
 */
export interface CouponCodeCreateOptions {
    /**
     * 
     * @type {string}
     * @memberof CouponCodeCreateOptions
     */
    'category': string;
    /**
     * limit coupon code to products
     * @type {Array<string>}
     * @memberof CouponCodeCreateOptions
     */
    'products'?: Array<string>;
    /**
     * set free trial. Can only set using admin access
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'freeTrialDays'?: number;
    /**
     * Add extra days to a subscription. Can only set using admin access
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'extraDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'discountPercentageOff': number;
}
/**
 * 
 * @export
 * @interface CouponValidation
 */
export interface CouponValidation {
    /**
     * 
     * @type {Array<AutoRenewalPeriod>}
     * @memberof CouponValidation
     */
    'period'?: Array<AutoRenewalPeriod>;
}
/**
 * 
 * @export
 * @interface CouponsPost200Response
 */
export interface CouponsPost200Response {
    /**
     * 
     * @type {string}
     * @memberof CouponsPost200Response
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface CreditAmountObj
 */
export interface CreditAmountObj {
    /**
     * 
     * @type {number}
     * @memberof CreditAmountObj
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface CreditAutoRenewalUpdate
 */
export interface CreditAutoRenewalUpdate {
    /**
     * 
     * @type {AutoRenewalPeriod}
     * @memberof CreditAutoRenewalUpdate
     */
    'period': AutoRenewalPeriod;
    /**
     * 
     * @type {CreditUnitsPurchaseOpts}
     * @memberof CreditAutoRenewalUpdate
     */
    'units': CreditUnitsPurchaseOpts;
    /**
     * 
     * @type {MiscBillingOptions}
     * @memberof CreditAutoRenewalUpdate
     */
    'options'?: MiscBillingOptions;
    /**
     * These actions are executed after the payment is successful
     * @type {Array<PostPaymentAction>}
     * @memberof CreditAutoRenewalUpdate
     */
    'postPaymentActions'?: Array<PostPaymentAction>;
}


/**
 * @type CreditBalanceEffectType
 * All the ways a team\'s credit balance can be affected.
 * @export
 */
export type CreditBalanceEffectType = CreditConsumptionType | CreditGainType | RecurringCreditConsumptionType;

/**
 * 
 * @export
 * @interface CreditCanConsumeResponse
 */
export interface CreditCanConsumeResponse {
    /**
     * 
     * @type {Array<CreditUnlockType>}
     * @memberof CreditCanConsumeResponse
     */
    'unlocks': Array<CreditUnlockType>;
}
/**
 * 
 * @export
 * @interface CreditConsumptionCreate
 */
export interface CreditConsumptionCreate {
    /**
     * 
     * @type {CreditConsumptionType}
     * @memberof CreditConsumptionCreate
     */
    'type': CreditConsumptionType;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CreditConsumptionCreate
     */
    'createdAt'?: string;
    /**
     * The ID of the object that was consumed. (createdAt, objectId) will be enforced to be unique.
     * @type {string}
     * @memberof CreditConsumptionCreate
     */
    'objectId': string;
    /**
     * The ID of a team
     * @type {string}
     * @memberof CreditConsumptionCreate
     */
    'teamId': string;
    /**
     * Multiplier for the number of units to consume of this consumption type. For eg. if multiplier is 2, and each consumption of this type consumes 5 units, then 10 units will be consumed.
     * @type {number}
     * @memberof CreditConsumptionCreate
     */
    'multiplier'?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CreditConsumptionCreate
     */
    'metadata'?: { [key: string]: any; };
}


/**
 * 
 * @export
 * @interface CreditConsumptionPostRequest
 */
export interface CreditConsumptionPostRequest {
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof CreditConsumptionPostRequest
     */
    'customerId': string;
    /**
     * 
     * @type {Array<CreditConsumptionCreate>}
     * @memberof CreditConsumptionPostRequest
     */
    'items': Array<CreditConsumptionCreate>;
}
/**
 * 
 * @export
 * @interface CreditConsumptionRecordData
 */
export interface CreditConsumptionRecordData {
    /**
     * 
     * @type {CreditConsumptionRecordDataType}
     * @memberof CreditConsumptionRecordData
     */
    'type': CreditConsumptionRecordDataType;
    /**
     * 
     * @type {string}
     * @memberof CreditConsumptionRecordData
     */
    'teamId'?: string;
    /**
     * ID of a recurring credit consumption
     * @type {string}
     * @memberof CreditConsumptionRecordData
     */
    'recurringConsumptionId'?: string;
}
/**
 * @type CreditConsumptionRecordDataType
 * @export
 */
export type CreditConsumptionRecordDataType = CreditConsumptionType | RecurringCreditConsumptionType;

/**
 * 
 * @export
 * @interface CreditConsumptionTier
 */
export interface CreditConsumptionTier {
    /**
     * Cost per unit of consumption
     * @type {number}
     * @memberof CreditConsumptionTier
     */
    'perUnitCost': number;
    /**
     * Maximum number of items that can be consumed before the next tier is used. This limit is inclusive as well. Undefined means no cap.
     * @type {number}
     * @memberof CreditConsumptionTier
     */
    'maxItems'?: number;
}
/**
 * Enum of all the types of single-use credit consumption. This is used to track the usage of credits. Category of consumptions are separated by a slash.
 * @export
 * @enum {string}
 */

export const CreditConsumptionType = {
    MessageSentWa: 'message_sent/wa',
    MessageSentMail: 'message_sent/mail',
    MessageSentSms: 'message_sent/sms',
    ConversationWaBusinessApi: 'conversation/wa-business-api',
    VoiceCall: 'voice_call',
    IntegrationNotification: 'integration/notification',
    IntegrationPayment: 'integration/payment',
    AiChatbot: 'ai_chatbot',
    Consultation1h: 'consultation/1h',
    AdminDiscretionary: 'admin/discretionary',
    AdminRefund: 'admin/refund',
    AdminExpiredCreditGain: 'admin/expired_credit_gain',
    ConsultationTraining: 'consultation/training',
    ActiveChat: 'active_chat',
    AiCreditUse: 'ai_credit_use',
    AiTranscription: 'ai_transcription'
} as const;

export type CreditConsumptionType = typeof CreditConsumptionType[keyof typeof CreditConsumptionType];


/**
 * 
 * @export
 * @interface CreditCouponCodeCreateOptions
 */
export interface CreditCouponCodeCreateOptions {
    /**
     * limit coupon code to certain product types. If not provided, coupon code is applicable to all recurring product types
     * @type {Array<AnyCreditConsumptionType>}
     * @memberof CreditCouponCodeCreateOptions
     */
    'creditConsumptionTypes'?: Array<AnyCreditConsumptionType>;
    /**
     * 
     * @type {number}
     * @memberof CreditCouponCodeCreateOptions
     */
    'discountPercentageOff': number;
    /**
     * 
     * @type {boolean}
     * @memberof CreditCouponCodeCreateOptions
     */
    'isRecurring'?: boolean;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CreditCouponCodeCreateOptions
     */
    'expiresAt'?: string | null;
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof CreditCouponCodeCreateOptions
     */
    'id'?: string;
    /**
     * 
     * @type {CouponValidation}
     * @memberof CreditCouponCodeCreateOptions
     */
    'couponValidation'?: CouponValidation;
}
/**
 * 
 * @export
 * @interface CreditCustomer
 */
export interface CreditCustomer {
    /**
     * The partnership to use for this customer. This is only used if the customer is new.
     * @type {string}
     * @memberof CreditCustomer
     */
    'partnership'?: string;
    /**
     * Region from which the customer is from.
     * @type {string}
     * @memberof CreditCustomer
     */
    'region': string;
    /**
     * ID of the Stripe account that was created for this customer.
     * @type {string}
     * @memberof CreditCustomer
     */
    'stripeAccountId'?: string;
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof CreditCustomer
     */
    'id': string;
    /**
     * Total number of units available for consumption
     * @type {number}
     * @memberof CreditCustomer
     */
    'unitsAvailable': number;
    /**
     * Number of units consumed per period.
     * @type {number}
     * @memberof CreditCustomer
     */
    'recurringConsumptionUnits': number;
    /**
     * List of features that have been unlocked.
     * @type {Array<CreditUnlockType>}
     * @memberof CreditCustomer
     */
    'unlockedFeatures': Array<CreditUnlockType>;
    /**
     * 
     * @type {CustomerAutoRenewalWRedeemedCoupon}
     * @memberof CreditCustomer
     */
    'autoRenewal'?: CustomerAutoRenewalWRedeemedCoupon;
    /**
     * 
     * @type {CountryTier}
     * @memberof CreditCustomer
     */
    'tier'?: CountryTier;
    /**
     * 
     * @type {CreditLevelStatus}
     * @memberof CreditCustomer
     */
    'creditLevelStatus'?: CreditLevelStatus | null;
    /**
     * 
     * @type {RecurringCreditConsumption}
     * @memberof CreditCustomer
     */
    'supportPlan'?: RecurringCreditConsumption;
    /**
     * 
     * @type {CreditCustomerRecurringPlans}
     * @memberof CreditCustomer
     */
    'recurringPlans'?: CreditCustomerRecurringPlans;
}


/**
 * 
 * @export
 * @interface CreditCustomerMetadata
 */
export interface CreditCustomerMetadata {
    /**
     * The partnership to use for this customer. This is only used if the customer is new.
     * @type {string}
     * @memberof CreditCustomerMetadata
     */
    'partnership'?: string;
    /**
     * Region from which the customer is from.
     * @type {string}
     * @memberof CreditCustomerMetadata
     */
    'region': string;
    /**
     * ID of the Stripe account that was created for this customer.
     * @type {string}
     * @memberof CreditCustomerMetadata
     */
    'stripeAccountId'?: string;
}
/**
 * Used to migrate a customer to the credits system. Any recurring consumptions will be migrated to the new system. If the customerId is not provided, we\'ll retreive the customerId from Stripe using the teamId
 * @export
 * @interface CreditCustomerMigrate
 */
export interface CreditCustomerMigrate {
    /**
     * The ID of a team
     * @type {string}
     * @memberof CreditCustomerMigrate
     */
    'teamId': string;
    /**
     * Region from which the customer is from.
     * @type {string}
     * @memberof CreditCustomerMigrate
     */
    'region'?: string;
    /**
     * 
     * @type {StripeCustomerCreate}
     * @memberof CreditCustomerMigrate
     */
    'customer'?: StripeCustomerCreate;
    /**
     * 
     * @type {CreditAutoRenewalUpdate}
     * @memberof CreditCustomerMigrate
     */
    'autoRenewal'?: CreditAutoRenewalUpdate;
}
/**
 * 
 * @export
 * @interface CreditCustomerPost
 */
export interface CreditCustomerPost {
    /**
     * 
     * @type {StripeCustomerCreate}
     * @memberof CreditCustomerPost
     */
    'stripeCustomer': StripeCustomerCreate;
    /**
     * 
     * @type {CreditCustomerMetadata}
     * @memberof CreditCustomerPost
     */
    'metadata': CreditCustomerMetadata;
    /**
     * If true, the customer will receive the signup bonus.
     * @type {boolean}
     * @memberof CreditCustomerPost
     */
    'addSignupBonus'?: boolean;
    /**
     * The referral code to use for this customer. This is only used if the customer is new.
     * @type {string}
     * @memberof CreditCustomerPost
     */
    'referralCode'?: string;
}
/**
 * 
 * @export
 * @interface CreditCustomerRecurringPlans
 */
export interface CreditCustomerRecurringPlans {
    /**
     * 
     * @type {RecurringCreditConsumption}
     * @memberof CreditCustomerRecurringPlans
     */
    'supportPlan'?: RecurringCreditConsumption;
    /**
     * 
     * @type {RecurringCreditConsumption}
     * @memberof CreditCustomerRecurringPlans
     */
    'analyticsPlan'?: RecurringCreditConsumption;
}
/**
 * 
 * @export
 * @interface CreditGain
 */
export interface CreditGain {
    /**
     * ID of a credit gain
     * @type {string}
     * @memberof CreditGain
     */
    'id': string;
    /**
     * 
     * @type {CreditGainType}
     * @memberof CreditGain
     */
    'type': CreditGainType;
    /**
     * Number of units gained
     * @type {number}
     * @memberof CreditGain
     */
    'units': number;
    /**
     * Number of units left in this gain. Credits are consumed bottom up, i.e. credits from the oldest gain are consumed first.
     * @type {number}
     * @memberof CreditGain
     */
    'unitsLeft': number;
    /**
     * 
     * @type {CreditGainStatus}
     * @memberof CreditGain
     */
    'status': CreditGainStatus;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CreditGain
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreditGain
     */
    'expiresAt'?: string;
    /**
     * The ID of a user
     * @type {string}
     * @memberof CreditGain
     */
    'doneBy': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CreditGain
     */
    'metadata'?: { [key: string]: any; };
    /**
     * 
     * @type {StripeMetadata}
     * @memberof CreditGain
     */
    'stripe'?: StripeMetadata;
    /**
     * 
     * @type {FloatAmountWithCurrency}
     * @memberof CreditGain
     */
    'amountPaid': FloatAmountWithCurrency;
}


/**
 * 
 * @export
 * @interface CreditGainCreate
 */
export interface CreditGainCreate {
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof CreditGainCreate
     */
    'customerId': string;
    /**
     * Number of units gained
     * @type {number}
     * @memberof CreditGainCreate
     */
    'units': number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CreditGainCreate
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface CreditGainRecordData
 */
export interface CreditGainRecordData {
    /**
     * 
     * @type {CreditGainType}
     * @memberof CreditGainRecordData
     */
    'type': CreditGainType;
    /**
     * 
     * @type {CreditGainRecordDataGain}
     * @memberof CreditGainRecordData
     */
    'gain'?: CreditGainRecordDataGain;
}


/**
 * 
 * @export
 * @interface CreditGainRecordDataGain
 */
export interface CreditGainRecordDataGain {
    /**
     * 
     * @type {StripeMetadata}
     * @memberof CreditGainRecordDataGain
     */
    'stripe'?: StripeMetadata;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CreditGainStatus = {
    Paid: 'paid',
    PendingPayment: 'pending_payment',
    Expired: 'expired'
} as const;

export type CreditGainStatus = typeof CreditGainStatus[keyof typeof CreditGainStatus];


/**
 * Different ways to categorise credits being added to the team\'s account.
 * @export
 * @enum {string}
 */

export const CreditGainType = {
    AutoRenewal: 'auto_renewal',
    TopUp: 'top_up',
    Bonus: 'bonus'
} as const;

export type CreditGainType = typeof CreditGainType[keyof typeof CreditGainType];


/**
 * 
 * @export
 * @interface CreditGainsGet200Response
 */
export interface CreditGainsGet200Response {
    /**
     * 
     * @type {Array<CreditGain>}
     * @memberof CreditGainsGet200Response
     */
    'items': Array<CreditGain>;
    /**
     * 
     * @type {string}
     * @memberof CreditGainsGet200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditGainsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CreditLevelStatus = {
    Danger: 'danger',
    Warning: 'warning'
} as const;

export type CreditLevelStatus = typeof CreditLevelStatus[keyof typeof CreditLevelStatus];


/**
 * A tier of credits that can be purchased. Credits can only be purchased in multiples of the step size. The tier is to be used exactly as is for top-up purchases, and must be  multiplied by the number of months for recurring purchases.
 * @export
 * @interface CreditPurchaseTier
 */
export interface CreditPurchaseTier {
    /**
     * Step size for the tier. This is the minimum number of credits that can be purchased at once in this tier. This will increase with tier
     * @type {number}
     * @memberof CreditPurchaseTier
     */
    'step': number;
    /**
     * Maximum number of units to purchase. This limit is inclusive. Undefined means no cap. If cap is 100 & if the user purchases 101 credits, they\'ll move to the next tier.
     * @type {number}
     * @memberof CreditPurchaseTier
     */
    'maxUnits'?: number;
}
/**
 * 
 * @export
 * @interface CreditStripePrice
 */
export interface CreditStripePrice {
    /**
     * Cost per credit in terms of fiat currency.
     * @type {number}
     * @memberof CreditStripePrice
     */
    'costPerCredit': number;
    /**
     * ISO country code for currency
     * @type {string}
     * @memberof CreditStripePrice
     */
    'currency': string;
    /**
     * 
     * @type {CreditStripePricePriceIds}
     * @memberof CreditStripePrice
     */
    'priceIds': CreditStripePricePriceIds;
}
/**
 * 
 * @export
 * @interface CreditStripePricePriceIds
 */
export interface CreditStripePricePriceIds {
    /**
     * The ID of the price in Stripe. This is used to identify the price in Stripe. For credit billing, ensure that the price ID has the following prefixs for the respective billing types: - recurring: auto_renew_credit - top_up: top_up_credit - bonus: bonus_credit
     * @type {string}
     * @memberof CreditStripePricePriceIds
     */
    'quarter': string;
    /**
     * The ID of the price in Stripe. This is used to identify the price in Stripe. For credit billing, ensure that the price ID has the following prefixs for the respective billing types: - recurring: auto_renew_credit - top_up: top_up_credit - bonus: bonus_credit
     * @type {string}
     * @memberof CreditStripePricePriceIds
     */
    'year': string;
    /**
     * The ID of the price in Stripe. This is used to identify the price in Stripe. For credit billing, ensure that the price ID has the following prefixs for the respective billing types: - recurring: auto_renew_credit - top_up: top_up_credit - bonus: bonus_credit
     * @type {string}
     * @memberof CreditStripePricePriceIds
     */
    'oneTime': string;
}
/**
 * 
 * @export
 * @interface CreditTopUpOptions
 */
export interface CreditTopUpOptions {
    /**
     * 
     * @type {CreditUnitsPurchaseOpts}
     * @memberof CreditTopUpOptions
     */
    'units': CreditUnitsPurchaseOpts;
    /**
     * 
     * @type {MiscBillingOptions}
     * @memberof CreditTopUpOptions
     */
    'options'?: MiscBillingOptions;
}
/**
 * 
 * @export
 * @interface CreditTransactionBase
 */
export interface CreditTransactionBase {
    /**
     * ID of a credit consumption. IDs are chronological.
     * @type {string}
     * @memberof CreditTransactionBase
     */
    'id': string;
    /**
     * Number of units consumed/credited. Positive for credit, negative for consumption.
     * @type {number}
     * @memberof CreditTransactionBase
     */
    'units': number;
    /**
     * The ID of a user
     * @type {string}
     * @memberof CreditTransactionBase
     */
    'doneBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CreditTransactionBase
     */
    'createdAt': string;
    /**
     * The ID of the object that was consumed, or the ID of the gain that created this tx record. (createdAt, objectId) will be enforced to be unique.
     * @type {string}
     * @memberof CreditTransactionBase
     */
    'objectId': string;
    /**
     * 
     * @type {TxMetadata}
     * @memberof CreditTransactionBase
     */
    'metadata'?: TxMetadata | null;
}
/**
 * A record of a credit transaction. This could be a gain or a consumption record & is immutable.
 * @export
 * @interface CreditTransactionRecord
 */
export interface CreditTransactionRecord {
    /**
     * ID of a credit consumption. IDs are chronological.
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'id': string;
    /**
     * Number of units consumed/credited. Positive for credit, negative for consumption.
     * @type {number}
     * @memberof CreditTransactionRecord
     */
    'units': number;
    /**
     * The ID of a user
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'doneBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'createdAt': string;
    /**
     * The ID of the object that was consumed, or the ID of the gain that created this tx record. (createdAt, objectId) will be enforced to be unique.
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'objectId': string;
    /**
     * 
     * @type {TxMetadata}
     * @memberof CreditTransactionRecord
     */
    'metadata'?: TxMetadata | null;
    /**
     * 
     * @type {CreditConsumptionRecordDataType}
     * @memberof CreditTransactionRecord
     */
    'type': CreditConsumptionRecordDataType;
    /**
     * 
     * @type {CreditGainRecordDataGain}
     * @memberof CreditTransactionRecord
     */
    'gain'?: CreditGainRecordDataGain;
    /**
     * 
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'teamId'?: string;
    /**
     * ID of a recurring credit consumption
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'recurringConsumptionId'?: string;
}
/**
 * 
 * @export
 * @interface CreditTxsGet200Response
 */
export interface CreditTxsGet200Response {
    /**
     * 
     * @type {Array<CreditTransactionRecord>}
     * @memberof CreditTxsGet200Response
     */
    'items': Array<CreditTransactionRecord>;
    /**
     * 
     * @type {string}
     * @memberof CreditTxsGet200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditTxsGet200Response
     */
    'total'?: number;
}
/**
 * @type CreditUnitsPurchaseOpts
 * @export
 */
export type CreditUnitsPurchaseOpts = CreditUnitsPurchaseOpts1 | CreditUnitsPurchaseOpts2;

/**
 * Options for purchasing credits. The total units are computed as the maxUnits of the previous tier from the specified tier, plus the step size of the specified tier multiplied by the number of steps specified. Essentially:   totalUnits = prev(maxUnits) + current(step) * steps
 * @export
 * @interface CreditUnitsPurchaseOpts1
 */
export interface CreditUnitsPurchaseOpts1 {
    /**
     * 
     * @type {string}
     * @memberof CreditUnitsPurchaseOpts1
     */
    'tier': string;
    /**
     * 
     * @type {number}
     * @memberof CreditUnitsPurchaseOpts1
     */
    'steps': number;
}
/**
 * Number of units to purchase. This is the total number of units to purchase.
 * @export
 * @interface CreditUnitsPurchaseOpts2
 */
export interface CreditUnitsPurchaseOpts2 {
    /**
     * Number of units to purchase
     * @type {number}
     * @memberof CreditUnitsPurchaseOpts2
     */
    'units': number;
}
/**
 * 
 * @export
 * @interface CreditUnlockMetadata
 */
export interface CreditUnlockMetadata {
    /**
     * Minimum number of auto renewing credits required to unlock this feature. Period of consumption is not considered.
     * @type {number}
     * @memberof CreditUnlockMetadata
     */
    'minRecurringCredits': number;
}
/**
 * Enum of all the types of credit unlocks. These are unlocked at a certain auto-renewal credit threshhold.
 * @export
 * @enum {string}
 */

export const CreditUnlockType = {
    ExportMsgFlow: 'export/msg_flow',
    ExportContacts: 'export/contacts',
    ExportTags: 'export/tags',
    ExportCustomFields: 'export/custom_fields',
    ExportProducts: 'export/products',
    RemoveMarketingMessage: 'remove_marketing_message'
} as const;

export type CreditUnlockType = typeof CreditUnlockType[keyof typeof CreditUnlockType];


/**
 * 
 * @export
 * @interface CreditsCouponsArchiveRequest
 */
export interface CreditsCouponsArchiveRequest {
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof CreditsCouponsArchiveRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface CreditsCouponsGet200Response
 */
export interface CreditsCouponsGet200Response {
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof CreditsCouponsGet200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {Array<Coupon>}
     * @memberof CreditsCouponsGet200Response
     */
    'items': Array<Coupon>;
    /**
     * 
     * @type {number}
     * @memberof CreditsCouponsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface CreditsCouponsRedemptionsGet200Response
 */
export interface CreditsCouponsRedemptionsGet200Response {
    /**
     * The redeemed coupon ID
     * @type {string}
     * @memberof CreditsCouponsRedemptionsGet200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {Array<RedeemedCoupon>}
     * @memberof CreditsCouponsRedemptionsGet200Response
     */
    'items': Array<RedeemedCoupon>;
    /**
     * 
     * @type {number}
     * @memberof CreditsCouponsRedemptionsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface CreditsCustomerPost200Response
 */
export interface CreditsCustomerPost200Response {
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof CreditsCustomerPost200Response
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface CreditsPreferences
 */
export interface CreditsPreferences {
    /**
     * 
     * @type {Array<CreditPreference>}
     * @memberof CreditsPreferences
     */
    'items': Array<CreditPreference>;
}
/**
 * 
 * @export
 * @interface CreditsPreferencesPostRequest
 */
export interface CreditsPreferencesPostRequest {
    /**
     * 
     * @type {Array<CreditPreference>}
     * @memberof CreditsPreferencesPostRequest
     */
    'items': Array<CreditPreference>;
}
/**
 * 
 * @export
 * @interface CustomerAutoRenewal
 */
export interface CustomerAutoRenewal {
    /**
     * The ID of the subscription that was created for this credit transaction.
     * @type {string}
     * @memberof CustomerAutoRenewal
     */
    'subscriptionId': string;
    /**
     * Number of units consumed per period
     * @type {number}
     * @memberof CustomerAutoRenewal
     */
    'units': number;
    /**
     * Number of bonus units
     * @type {number}
     * @memberof CustomerAutoRenewal
     */
    'bonusUnits': number;
    /**
     * 
     * @type {AutoRenewalPeriod}
     * @memberof CustomerAutoRenewal
     */
    'period': AutoRenewalPeriod;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CustomerAutoRenewal
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CustomerAutoRenewal
     */
    'nextChargeAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerAutoRenewal
     */
    'status': CustomerAutoRenewalStatusEnum;
    /**
     * The redeemed coupon ID
     * @type {string}
     * @memberof CustomerAutoRenewal
     */
    'currentRedeemedCouponId'?: string;
}

export const CustomerAutoRenewalStatusEnum = {
    Active: 'active',
    Cancelled: 'cancelled',
    Overdue: 'overdue'
} as const;

export type CustomerAutoRenewalStatusEnum = typeof CustomerAutoRenewalStatusEnum[keyof typeof CustomerAutoRenewalStatusEnum];

/**
 * 
 * @export
 * @interface CustomerAutoRenewalWRedeemedCoupon
 */
export interface CustomerAutoRenewalWRedeemedCoupon {
    /**
     * The ID of the subscription that was created for this credit transaction.
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'subscriptionId': string;
    /**
     * Number of units consumed per period
     * @type {number}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'units': number;
    /**
     * Number of bonus units
     * @type {number}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'bonusUnits': number;
    /**
     * 
     * @type {AutoRenewalPeriod}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'period': AutoRenewalPeriod;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'nextChargeAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'status': CustomerAutoRenewalWRedeemedCouponStatusEnum;
    /**
     * The redeemed coupon ID
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'currentRedeemedCouponId'?: string;
    /**
     * 
     * @type {CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'currentRedeemedCoupon'?: CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon;
}

export const CustomerAutoRenewalWRedeemedCouponStatusEnum = {
    Active: 'active',
    Cancelled: 'cancelled',
    Overdue: 'overdue'
} as const;

export type CustomerAutoRenewalWRedeemedCouponStatusEnum = typeof CustomerAutoRenewalWRedeemedCouponStatusEnum[keyof typeof CustomerAutoRenewalWRedeemedCouponStatusEnum];

/**
 * 
 * @export
 * @interface CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon
 */
export interface CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon {
    /**
     * The redeemed coupon ID
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon
     */
    'id': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon
     */
    'createdAt': string;
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon
     */
    'couponId': string;
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon
     */
    'customerId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon
     */
    'expiresAt'?: string | null;
    /**
     * Number of credits saved by using this coupon
     * @type {number}
     * @memberof CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon
     */
    'creditsSaved'?: number;
    /**
     * 
     * @type {Coupon}
     * @memberof CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon
     */
    'coupon'?: Coupon;
}
/**
 * 
 * @export
 * @interface DateRange
 */
interface DateRange {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DateRange
     */
    'from': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DateRange
     */
    'to': string;
}
/**
 * 
 * @export
 * @interface DefinedSingleConsumptionMetadata
 */
export interface DefinedSingleConsumptionMetadata {
    /**
     * Cost of the consumption
     * @type {number}
     * @memberof DefinedSingleConsumptionMetadata
     */
    'perUnitCost': number;
}
/**
 * List of features
 * @export
 * @enum {string}
 */

export const Feature = {
    TeamInbox: 'team-inbox',
    ChatHistorySync: 'chat-history-sync',
    CustomMarketingMessage: 'custom-marketing-message',
    Audience: 'audience',
    Notifications: 'notifications',
    KeywordReply: 'keyword-reply',
    Broadcast: 'broadcast',
    MessageFlows: 'message-flows',
    Shop: 'shop',
    Autocomplete: 'autocomplete'
} as const;

export type Feature = typeof Feature[keyof typeof Feature];


/**
 * @type FeatureConfig
 * @export
 */
export type FeatureConfig = Array<Feature> | string;

/**
 * 
 * @export
 * @interface FloatAmountWithCurrency
 */
export interface FloatAmountWithCurrency {
    /**
     * The amount in dollar value
     * @type {number}
     * @memberof FloatAmountWithCurrency
     */
    'amount': number;
    /**
     * ISO country code for currency in lowercase
     * @type {string}
     * @memberof FloatAmountWithCurrency
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface GetPartner200Response
 */
export interface GetPartner200Response {
    /**
     * 
     * @type {string}
     * @memberof GetPartner200Response
     */
    'partnerAdmin'?: string;
}
/**
 * 
 * @export
 * @interface LegacyCanConsumeOpts
 */
export interface LegacyCanConsumeOpts {
    /**
     * 
     * @type {LimitedItem}
     * @memberof LegacyCanConsumeOpts
     */
    'item': LimitedItem;
    /**
     * 
     * @type {string}
     * @memberof LegacyCanConsumeOpts
     */
    'accountId'?: string;
}


/**
 * 
 * @export
 * @interface LimitationMap
 */
export interface LimitationMap {
    /**
     * The number of messages that can be sent per month. This is reset every month.
     * @type {number}
     * @memberof LimitationMap
     */
    'messages'?: number;
    /**
     * The number of team members allowed in the team. This usage carries over to the next month.
     * @type {number}
     * @memberof LimitationMap
     */
    'seats'?: number;
    /**
     * The number of Inbox accounts allowed in the team. This usage carries over to the next month.
     * @type {number}
     * @memberof LimitationMap
     */
    'fullAccount'?: number;
    /**
     * The number of API accounts used on a per-day basis. This is reset every month.
     * @type {number}
     * @memberof LimitationMap
     */
    'limitedMsgNoHistoryAccountDay'?: number;
    /**
     * The number of API accounts used on a per-day basis. This is reset every month.
     * @type {number}
     * @memberof LimitationMap
     */
    'unlimitedMsgHistoryAccountDay'?: number;
}
/**
 * List of items that are limited in quantity
 * @export
 * @enum {string}
 */

export const LimitedItem = {
    Messages: 'messages',
    Seats: 'seats',
    FullAccount: 'fullAccount',
    LimitedMsgNoHistoryAccountDay: 'limitedMsgNoHistoryAccountDay',
    UnlimitedMsgHistoryAccountDay: 'unlimitedMsgHistoryAccountDay'
} as const;

export type LimitedItem = typeof LimitedItem[keyof typeof LimitedItem];


/**
 * 
 * @export
 * @interface MiscBillingOptions
 */
export interface MiscBillingOptions {
    /**
     * The promotion code to use for this purchase.
     * @type {string}
     * @memberof MiscBillingOptions
     */
    'promotionCode'?: string;
    /**
     * Doesn\'t attempt to automatically charge the customer and always returns a payment link.
     * @type {boolean}
     * @memberof MiscBillingOptions
     */
    'alwaysReturnLink'?: boolean;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MiscBillingOptions
     */
    'startDate'?: string;
}
/**
 * 
 * @export
 * @interface MiscPreference
 */
export interface MiscPreference {
    /**
     * 
     * @type {string}
     * @memberof MiscPreference
     */
    'category': MiscPreferenceCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof MiscPreference
     */
    'key': MiscPreferenceKeyEnum;
    /**
     * 
     * @type {CreditAmountObj}
     * @memberof MiscPreference
     */
    'data': CreditAmountObj;
    /**
     * 
     * @type {CountryTier}
     * @memberof MiscPreference
     */
    'tier'?: CountryTier;
}

export const MiscPreferenceCategoryEnum = {
    Misc: 'misc'
} as const;

export type MiscPreferenceCategoryEnum = typeof MiscPreferenceCategoryEnum[keyof typeof MiscPreferenceCategoryEnum];
export const MiscPreferenceKeyEnum = {
    NewSignupCredits: 'newSignupCredits',
    ExpiryIntervalMonths: 'expiryIntervalMonths',
    YearlyBonusCreditsPercentage: 'yearlyBonusCreditsPercentage'
} as const;

export type MiscPreferenceKeyEnum = typeof MiscPreferenceKeyEnum[keyof typeof MiscPreferenceKeyEnum];

/**
 * 
 * @export
 * @interface ModifySupportPlan
 */
export interface ModifySupportPlan {
    /**
     * The type of support plan. This can be either consultation/support_plan or null to remove the support plan.
     * @type {string}
     * @memberof ModifySupportPlan
     */
    'type': ModifySupportPlanTypeEnum | null;
    /**
     * 
     * @type {ModifySupportPlanConfig}
     * @memberof ModifySupportPlan
     */
    'config'?: ModifySupportPlanConfig;
}

export const ModifySupportPlanTypeEnum = {
    ConsultationSupportPlanLvl1: 'consultation/support_plan_lvl1',
    ConsultationSupportPlanLvl2: 'consultation/support_plan_lvl2'
} as const;

export type ModifySupportPlanTypeEnum = typeof ModifySupportPlanTypeEnum[keyof typeof ModifySupportPlanTypeEnum];

/**
 * 
 * @export
 * @interface ModifySupportPlanConfigDuration
 */
export interface ModifySupportPlanConfigDuration {
    /**
     * The number of months to purchase for, by default, the support plan will continue forever.
     * @type {number}
     * @memberof ModifySupportPlanConfigDuration
     */
    'months': number;
    /**
     * If true, the support plan will be charged as a one-time charge. If false, the support plan will be charged monthly.
     * @type {boolean}
     * @memberof ModifySupportPlanConfigDuration
     */
    'oneTimeCharge'?: boolean;
}
/**
 * 
 * @export
 * @interface NotificationPreference
 */
export interface NotificationPreference {
    /**
     * 
     * @type {string}
     * @memberof NotificationPreference
     */
    'category': NotificationPreferenceCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof NotificationPreference
     */
    'key': NotificationPreferenceKeyEnum;
    /**
     * 
     * @type {NotificationPreferenceData}
     * @memberof NotificationPreference
     */
    'data': NotificationPreferenceData;
}

export const NotificationPreferenceCategoryEnum = {
    Notification: 'notification'
} as const;

export type NotificationPreferenceCategoryEnum = typeof NotificationPreferenceCategoryEnum[keyof typeof NotificationPreferenceCategoryEnum];
export const NotificationPreferenceKeyEnum = {
    Subscribed: 'subscribed',
    Unsubscribed: 'unsubscribed'
} as const;

export type NotificationPreferenceKeyEnum = typeof NotificationPreferenceKeyEnum[keyof typeof NotificationPreferenceKeyEnum];

/**
 * Map describing threshholds for notifications. The threshhold for subscribed users is in % of their recurring credits. The threshhold for unsubscribed users is in absolute credits.
 * @export
 * @interface NotificationPreferenceData
 */
export interface NotificationPreferenceData {
    /**
     * 
     * @type {number}
     * @memberof NotificationPreferenceData
     */
    'danger': number;
    /**
     * 
     * @type {number}
     * @memberof NotificationPreferenceData
     */
    'warning': number;
}
/**
 * Object which stores referral code details
 * @export
 * @interface PartnerReferral
 */
export interface PartnerReferral {
    /**
     * referralCode string; ID for the code
     * @type {string}
     * @memberof PartnerReferral
     */
    'referralCode': string;
    /**
     * ID of the stripe price, the usage of this referral code will give access to
     * @type {string}
     * @memberof PartnerReferral
     */
    'stripePriceId': string | null;
    /**
     * 
     * @type {StripePrice}
     * @memberof PartnerReferral
     */
    'stripePrice'?: StripePrice;
    /**
     * teamId of partnerAdmin associated with the referralCode
     * @type {string}
     * @memberof PartnerReferral
     */
    'partnerAdminTeam': string;
    /**
     * partnerAdmin of team associated with the referralCode
     * @type {string}
     * @memberof PartnerReferral
     */
    'partnerAdmin': string;
    /**
     * Time the product can be used for in days
     * @type {number}
     * @memberof PartnerReferral
     */
    'usagePeriodDays': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PartnerReferral
     */
    'referralCodeExpiry'?: string;
    /**
     * userId of creator of the code
     * @type {string}
     * @memberof PartnerReferral
     */
    'createdBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PartnerReferral
     */
    'createdAt': string;
    /**
     * number of credits to be given when the referral code is used
     * @type {number}
     * @memberof PartnerReferral
     */
    'credits'?: number;
}
/**
 * options to generate partnerReferral
 * @export
 * @interface PartnerReferralCreateOptions
 */
export interface PartnerReferralCreateOptions {
    /**
     * ID of the product that\'ll be given for free when the referral code is used
     * @type {string}
     * @memberof PartnerReferralCreateOptions
     */
    'stripePriceId': string | null;
    /**
     * time the product can be used for in days
     * @type {number}
     * @memberof PartnerReferralCreateOptions
     */
    'usagePeriodDays': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PartnerReferralCreateOptions
     */
    'referralCodeExpiry'?: string;
    /**
     * a string to be appended to the generated referral code
     * @type {string}
     * @memberof PartnerReferralCreateOptions
     */
    'includeInReferralCode'?: string;
    /**
     * number of credits to be given when the referral code is used
     * @type {number}
     * @memberof PartnerReferralCreateOptions
     */
    'credits'?: number;
}
/**
 * 
 * @export
 * @interface PartnerReferralsGet200Response
 */
export interface PartnerReferralsGet200Response {
    /**
     * 
     * @type {Array<PartnerReferral>}
     * @memberof PartnerReferralsGet200Response
     */
    'items': Array<PartnerReferral>;
    /**
     * 
     * @type {number}
     * @memberof PartnerReferralsGet200Response
     */
    'nextPageCursor'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartnerReferralsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface PartnerReferralsPost200Response
 */
export interface PartnerReferralsPost200Response {
    /**
     * 
     * @type {string}
     * @memberof PartnerReferralsPost200Response
     */
    'referralCode': string;
}
/**
 * 
 * @export
 * @interface PaymentData
 */
export interface PaymentData {
    /**
     * 
     * @type {string}
     * @memberof PaymentData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentData
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {AmountWithCurrency}
     * @memberof PaymentData
     */
    'amount': AmountWithCurrency;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PaymentData
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface PaymentRequest
 */
export interface PaymentRequest {
    /**
     * URL to pay for the credits. If empty, the payment has already been made.
     * @type {string}
     * @memberof PaymentRequest
     */
    'paymentUrl': string;
}
/**
 * 
 * @export
 * @interface PostPaymentAction
 */
export interface PostPaymentAction {
    /**
     * 
     * @type {string}
     * @memberof PostPaymentAction
     */
    'type': PostPaymentActionTypeEnum;
    /**
     * 
     * @type {ModifySupportPlan}
     * @memberof PostPaymentAction
     */
    'data': ModifySupportPlan;
}

export const PostPaymentActionTypeEnum = {
    ModifySupportPlan: 'modifySupportPlan'
} as const;

export type PostPaymentActionTypeEnum = typeof PostPaymentActionTypeEnum[keyof typeof PostPaymentActionTypeEnum];

/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * The ID of a product
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * 
     * @type {ProductAccess}
     * @memberof Product
     */
    'access': ProductAccess;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Product
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Product
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<StripePrice>}
     * @memberof Product
     */
    'stripePrices'?: Array<StripePrice>;
}
/**
 * 
 * @export
 * @interface ProductAccess
 */
export interface ProductAccess {
    /**
     * 
     * @type {FeatureConfig}
     * @memberof ProductAccess
     */
    'features': FeatureConfig;
    /**
     * 
     * @type {LimitationMap}
     * @memberof ProductAccess
     */
    'limits': LimitationMap;
}
/**
 * 
 * @export
 * @interface ProductCreate
 */
export interface ProductCreate {
    /**
     * 
     * @type {string}
     * @memberof ProductCreate
     */
    'name': string;
    /**
     * 
     * @type {ProductAccess}
     * @memberof ProductCreate
     */
    'access': ProductAccess;
}
/**
 * 
 * @export
 * @interface ProductUpdate
 */
export interface ProductUpdate {
    /**
     * 
     * @type {ProductAccess}
     * @memberof ProductUpdate
     */
    'access'?: ProductAccess;
    /**
     * Attach/detach some stripe price IDs
     * @type {Array<StripePriceAttachmentUpdate>}
     * @memberof ProductUpdate
     */
    'stripePriceIds'?: Array<StripePriceAttachmentUpdate>;
}
/**
 * 
 * @export
 * @interface ProductsGet200Response
 */
export interface ProductsGet200Response {
    /**
     * 
     * @type {Array<Product>}
     * @memberof ProductsGet200Response
     */
    'items': Array<Product>;
}
/**
 * 
 * @export
 * @interface ProductsSelectionInner
 */
export interface ProductsSelectionInner {
    /**
     * The ID of a product
     * @type {string}
     * @memberof ProductsSelectionInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductsSelectionInner
     */
    'stripePriceId': string;
    /**
     * 
     * @type {number}
     * @memberof ProductsSelectionInner
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface PurchaseTierPreference
 */
export interface PurchaseTierPreference {
    /**
     * 
     * @type {string}
     * @memberof PurchaseTierPreference
     */
    'category': PurchaseTierPreferenceCategoryEnum;
    /**
     * Unique string to identify the tier
     * @type {string}
     * @memberof PurchaseTierPreference
     */
    'key': string;
    /**
     * 
     * @type {CountryTier}
     * @memberof PurchaseTierPreference
     */
    'tier'?: CountryTier;
    /**
     * 
     * @type {CreditPurchaseTier}
     * @memberof PurchaseTierPreference
     */
    'data': CreditPurchaseTier;
}

export const PurchaseTierPreferenceCategoryEnum = {
    Tier: 'tier'
} as const;

export type PurchaseTierPreferenceCategoryEnum = typeof PurchaseTierPreferenceCategoryEnum[keyof typeof PurchaseTierPreferenceCategoryEnum];

/**
 * 
 * @export
 * @interface RecTxMetadata
 */
export interface RecTxMetadata {
    /**
     * The redeemed coupon ID
     * @type {string}
     * @memberof RecTxMetadata
     */
    'redeemedCouponId'?: string;
    /**
     * 
     * @type {number}
     * @memberof RecTxMetadata
     */
    'percentageOff'?: number;
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof RecTxMetadata
     */
    'couponId'?: string;
    /**
     * If this recurring charge was resynced after another recurring sub was cancelled, this will be the number of units that were charged previously. 
     * @type {number}
     * @memberof RecTxMetadata
     */
    'previousChargeUnits'?: number;
    /**
     * Number of times this recurring charge was resynced after another recurring sub was cancelled.
     * @type {number}
     * @memberof RecTxMetadata
     */
    'nextChargeResyncs'?: number;
}
/**
 * 
 * @export
 * @interface RecurringConsumptionMetadata
 */
export interface RecurringConsumptionMetadata {
    /**
     * 
     * @type {Array<CreditConsumptionTier>}
     * @memberof RecurringConsumptionMetadata
     */
    'tiers': Array<CreditConsumptionTier>;
}
/**
 * 
 * @export
 * @interface RecurringConsumptionPreference
 */
export interface RecurringConsumptionPreference {
    /**
     * 
     * @type {string}
     * @memberof RecurringConsumptionPreference
     */
    'category': RecurringConsumptionPreferenceCategoryEnum;
    /**
     * 
     * @type {RecurringCreditConsumptionType}
     * @memberof RecurringConsumptionPreference
     */
    'key': RecurringCreditConsumptionType;
    /**
     * 
     * @type {CountryTier}
     * @memberof RecurringConsumptionPreference
     */
    'tier'?: CountryTier;
    /**
     * 
     * @type {RecurringConsumptionMetadata}
     * @memberof RecurringConsumptionPreference
     */
    'data': RecurringConsumptionMetadata;
}

export const RecurringConsumptionPreferenceCategoryEnum = {
    RecurringConsumption: 'recurring_consumption'
} as const;

export type RecurringConsumptionPreferenceCategoryEnum = typeof RecurringConsumptionPreferenceCategoryEnum[keyof typeof RecurringConsumptionPreferenceCategoryEnum];

/**
 * A recurring credit consumption is a credit consumption that is automatically renewed every month
 * @export
 * @interface RecurringCreditConsumption
 */
export interface RecurringCreditConsumption {
    /**
     * ID of a recurring credit consumption
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'id': string;
    /**
     * 
     * @type {RecurringCreditConsumptionType}
     * @memberof RecurringCreditConsumption
     */
    'type': RecurringCreditConsumptionType;
    /**
     * Number of units to consume at the next charge
     * @type {number}
     * @memberof RecurringCreditConsumption
     */
    'nextChargeUnits': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'createdAt': string;
    /**
     * If true, the consumption is considered manually cancelled
     * @type {boolean}
     * @memberof RecurringCreditConsumption
     */
    'cancelled'?: boolean;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'nextChargeAt': string;
    /**
     * The date at which this consumption ends. This is only present if the consumption is expiring.
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'expiresAt'?: string | null;
    /**
     * The date at which this consumption ended. Present if either cancelled or ended. If this is set, the consumption is considered ended.
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'endedAt'?: string | null;
    /**
     * The ID of a user
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'doneBy': string;
    /**
     * 
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'teamId'?: string;
    /**
     * The ID of the object that was consumed. (createdAt, objectId) will be enforced to be unique.
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'objectId': string;
    /**
     * 
     * @type {RecTxMetadata}
     * @memberof RecurringCreditConsumption
     */
    'metadata'?: RecTxMetadata;
}


/**
 * 
 * @export
 * @interface RecurringCreditConsumptionCreate
 */
export interface RecurringCreditConsumptionCreate {
    /**
     * 
     * @type {RecurringCreditConsumptionType}
     * @memberof RecurringCreditConsumptionCreate
     */
    'type': RecurringCreditConsumptionType;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RecurringCreditConsumptionCreate
     */
    'createdAt'?: string;
    /**
     * The ID of a team
     * @type {string}
     * @memberof RecurringCreditConsumptionCreate
     */
    'teamId': string;
    /**
     * The ID of the object that was consumed. (createdAt, objectId) will be enforced to be unique.
     * @type {string}
     * @memberof RecurringCreditConsumptionCreate
     */
    'objectId': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RecurringCreditConsumptionCreate
     */
    'metadata'?: { [key: string]: any; };
    /**
     * Number of units to consume at the first charge
     * @type {number}
     * @memberof RecurringCreditConsumptionCreate
     */
    'units'?: number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RecurringCreditConsumptionCreate
     */
    'expiresAt'?: string | null;
}


/**
 * Enum of all the types of recurring credit consumption. Category of consumptions are separated by a slash.
 * @export
 * @enum {string}
 */

export const RecurringCreditConsumptionType = {
    ChannelWa: 'channel/wa',
    ChannelTiktok: 'channel/tiktok',
    ChannelMessenger: 'channel/messenger',
    ChannelWaBusinessApi: 'channel/wa-business-api',
    ChannelMail: 'channel/mail',
    ChannelSms: 'channel/sms',
    ConsultationSupportPlanLvl1: 'consultation/support_plan_lvl1',
    ConsultationSupportPlanLvl2: 'consultation/support_plan_lvl2',
    User: 'user',
    CallChannel: 'call_channel',
    AnalyticsDashboard: 'analytics_dashboard'
} as const;

export type RecurringCreditConsumptionType = typeof RecurringCreditConsumptionType[keyof typeof RecurringCreditConsumptionType];


/**
 * 
 * @export
 * @interface RecurringCreditsGet200Response
 */
export interface RecurringCreditsGet200Response {
    /**
     * 
     * @type {Array<RecurringCreditConsumption>}
     * @memberof RecurringCreditsGet200Response
     */
    'items': Array<RecurringCreditConsumption>;
    /**
     * 
     * @type {string}
     * @memberof RecurringCreditsGet200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {number}
     * @memberof RecurringCreditsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface RecurringCreditsGetDateRageParameter
 */
export interface RecurringCreditsGetDateRageParameter {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RecurringCreditsGetDateRageParameter
     */
    'from'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RecurringCreditsGetDateRageParameter
     */
    'to'?: string;
}
/**
 * 
 * @export
 * @interface RedeemedCoupon
 */
export interface RedeemedCoupon {
    /**
     * The redeemed coupon ID
     * @type {string}
     * @memberof RedeemedCoupon
     */
    'id': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RedeemedCoupon
     */
    'createdAt': string;
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof RedeemedCoupon
     */
    'couponId': string;
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof RedeemedCoupon
     */
    'customerId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RedeemedCoupon
     */
    'expiresAt'?: string | null;
    /**
     * Number of credits saved by using this coupon
     * @type {number}
     * @memberof RedeemedCoupon
     */
    'creditsSaved'?: number;
}
/**
 * @type SingleConsumptionMetadata
 * @export
 */
export type SingleConsumptionMetadata = DefinedSingleConsumptionMetadata | VariableSingleConsumptionMetadata;

/**
 * 
 * @export
 * @interface SingleConsumptionPreference
 */
export interface SingleConsumptionPreference {
    /**
     * 
     * @type {string}
     * @memberof SingleConsumptionPreference
     */
    'category': SingleConsumptionPreferenceCategoryEnum;
    /**
     * 
     * @type {CreditConsumptionType}
     * @memberof SingleConsumptionPreference
     */
    'key': CreditConsumptionType;
    /**
     * 
     * @type {CountryTier}
     * @memberof SingleConsumptionPreference
     */
    'tier'?: CountryTier;
    /**
     * 
     * @type {SingleConsumptionMetadata}
     * @memberof SingleConsumptionPreference
     */
    'data': SingleConsumptionMetadata;
}

export const SingleConsumptionPreferenceCategoryEnum = {
    SingleConsumption: 'single_consumption'
} as const;

export type SingleConsumptionPreferenceCategoryEnum = typeof SingleConsumptionPreferenceCategoryEnum[keyof typeof SingleConsumptionPreferenceCategoryEnum];

/**
 * 
 * @export
 * @interface StripeCheckout200Response
 */
export interface StripeCheckout200Response {
    /**
     * 
     * @type {string}
     * @memberof StripeCheckout200Response
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof StripeCheckout200Response
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface StripeCouponData
 */
export interface StripeCouponData {
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof StripeCouponData
     */
    'id': string;
    /**
     * 
     * @type {FloatAmountWithCurrency}
     * @memberof StripeCouponData
     */
    'amountOff'?: FloatAmountWithCurrency;
    /**
     * The percentage off the coupon provides
     * @type {number}
     * @memberof StripeCouponData
     */
    'percentageOff'?: number;
    /**
     * 
     * @type {FloatAmountWithCurrency}
     * @memberof StripeCouponData
     */
    'minAmount'?: FloatAmountWithCurrency;
    /**
     * The duration the coupon is valid for. Can be one of forever, once, or repeating.
     * @type {string}
     * @memberof StripeCouponData
     */
    'duration': StripeCouponDataDurationEnum;
}

export const StripeCouponDataDurationEnum = {
    Forever: 'forever',
    Once: 'once'
} as const;

export type StripeCouponDataDurationEnum = typeof StripeCouponDataDurationEnum[keyof typeof StripeCouponDataDurationEnum];

/**
 * @type StripeCustomerCreate
 * @export
 */
export type StripeCustomerCreate = StripeCustomerCreateOneOf | StripeCustomerCreateOneOf1;

/**
 * Provide to link an existing stripe customer
 * @export
 * @interface StripeCustomerCreateOneOf
 */
export interface StripeCustomerCreateOneOf {
    /**
     * 
     * @type {string}
     * @memberof StripeCustomerCreateOneOf
     */
    'id': string;
}
/**
 * Provide to create a new stripe customer
 * @export
 * @interface StripeCustomerCreateOneOf1
 */
export interface StripeCustomerCreateOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof StripeCustomerCreateOneOf1
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof StripeCustomerCreateOneOf1
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof StripeCustomerCreateOneOf1
     */
    'phoneNumber'?: string;
}
/**
 * 
 * @export
 * @interface StripeMetadata
 */
export interface StripeMetadata {
    /**
     * The URL of the invoice that was created for this credit transaction.
     * @type {string}
     * @memberof StripeMetadata
     */
    'invoiceUrl': string;
    /**
     * The ID of the line item that was created for this credit transaction.
     * @type {string}
     * @memberof StripeMetadata
     */
    'lineItemId': string;
    /**
     * Fraction of the total amount that was paid for this credit transaction. Anything less than 1 means that some or all of the amount is refunded/due.
     * @type {number}
     * @memberof StripeMetadata
     */
    'paidFraction': number;
}
/**
 * 
 * @export
 * @interface StripePaymentIntent
 */
export interface StripePaymentIntent {
    /**
     * 
     * @type {string}
     * @memberof StripePaymentIntent
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StripePaymentIntent
     */
    'customer'?: string;
    /**
     * 
     * @type {number}
     * @memberof StripePaymentIntent
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof StripePaymentIntent
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof StripePaymentIntent
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof StripePaymentIntent
     */
    'created'?: number;
}
/**
 * 
 * @export
 * @interface StripePaymentIntentsGet200Response
 */
export interface StripePaymentIntentsGet200Response {
    /**
     * 
     * @type {Array<StripePaymentIntent>}
     * @memberof StripePaymentIntentsGet200Response
     */
    'paymentIntents': Array<StripePaymentIntent>;
}
/**
 * 
 * @export
 * @interface StripePrice
 */
export interface StripePrice {
    /**
     * 
     * @type {string}
     * @memberof StripePrice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StripePrice
     */
    'productName'?: string;
    /**
     * 
     * @type {BillingPeriod}
     * @memberof StripePrice
     */
    'period': BillingPeriod;
    /**
     * 
     * @type {AmountWithCurrency}
     * @memberof StripePrice
     */
    'amount': AmountWithCurrency;
    /**
     * ISO 3166-1 alpha-2 country code, or \"default\" to get the default prices
     * @type {string}
     * @memberof StripePrice
     */
    'region'?: string;
}


/**
 * Update a stripe price ID attachment. Supply ID to attach, or supply remove=true to detach. Supply region to mark price to a specific region.
 * @export
 * @interface StripePriceAttachmentUpdate
 */
export interface StripePriceAttachmentUpdate {
    /**
     * 
     * @type {string}
     * @memberof StripePriceAttachmentUpdate
     */
    'id': string;
    /**
     * ISO 3166-1 alpha-2 country code, or \"default\" to get the default prices
     * @type {string}
     * @memberof StripePriceAttachmentUpdate
     */
    'region'?: string;
    /**
     * Remove this stripe price ID from the product
     * @type {boolean}
     * @memberof StripePriceAttachmentUpdate
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface StripePricesGet200Response
 */
export interface StripePricesGet200Response {
    /**
     * 
     * @type {Array<StripePrice>}
     * @memberof StripePricesGet200Response
     */
    'items': Array<StripePrice>;
    /**
     * 
     * @type {string}
     * @memberof StripePricesGet200Response
     */
    'nextPageCursor'?: string;
}
/**
 * 
 * @export
 * @interface StripeSubscriptionItem
 */
export interface StripeSubscriptionItem {
    /**
     * 
     * @type {string}
     * @memberof StripeSubscriptionItem
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface SubscribedProduct
 */
export interface SubscribedProduct {
    /**
     * 
     * @type {Product}
     * @memberof SubscribedProduct
     */
    'product'?: Product;
    /**
     * 
     * @type {string}
     * @memberof SubscribedProduct
     */
    'productId': string;
    /**
     * The stripe price ID that was used to purchase this subscription product
     * @type {string}
     * @memberof SubscribedProduct
     */
    'stripePriceId': string;
    /**
     * 
     * @type {number}
     * @memberof SubscribedProduct
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * The ID of a subscription
     * @type {string}
     * @memberof Subscription
     */
    'id': string;
    /**
     * The ID of a team
     * @type {string}
     * @memberof Subscription
     */
    'teamId'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Subscription
     */
    'startDate': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Subscription
     */
    'endDate'?: string;
    /**
     * Reason for voiding the subscription
     * @type {string}
     * @memberof Subscription
     */
    'voidReason'?: string;
    /**
     * 
     * @type {SubscriptionStripeData}
     * @memberof Subscription
     */
    'stripe'?: SubscriptionStripeData;
    /**
     * 
     * @type {Array<SubscribedProduct>}
     * @memberof Subscription
     */
    'products'?: Array<SubscribedProduct>;
    /**
     * 
     * @type {AutoChargeProduct}
     * @memberof Subscription
     */
    'autoCharge'?: AutoChargeProduct;
}
/**
 * 
 * @export
 * @interface SubscriptionCreate
 */
export interface SubscriptionCreate {
    /**
     * The ID of a team
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'teamId': string;
    /**
     * 
     * @type {Array<ProductsSelectionInner>}
     * @memberof SubscriptionCreate
     */
    'products': Array<ProductsSelectionInner>;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'startDate'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'endDate'?: string;
    /**
     * Extra days to add to the subscription. Invalid request with endDate.
     * @type {number}
     * @memberof SubscriptionCreate
     */
    'extraDays'?: number;
    /**
     * Free trial days to add to the subscription. Invalid request with endDate, extraDays, or nextCycleAnchor, and createOnStripe=false.
     * @type {number}
     * @memberof SubscriptionCreate
     */
    'freeTrialDays'?: number;
    /**
     * Anchor the next cycle to a specific date. Invalid request with endDate. Only valid for stripe subscriptions.
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'nextCycleAnchor'?: string;
    /**
     * Create the subscription on stripe. Will create the subscription on stripe if true. Only works if the customer has a payment method and it can be charged automatically.
     * @type {boolean}
     * @memberof SubscriptionCreate
     */
    'createOnStripe': boolean;
    /**
     * Refresh access after creating the subscription.
     * @type {boolean}
     * @memberof SubscriptionCreate
     */
    'refreshAccess'?: boolean;
}
/**
 * 
 * @export
 * @interface SubscriptionStripeData
 */
export interface SubscriptionStripeData {
    /**
     * The ID of a subscription
     * @type {string}
     * @memberof SubscriptionStripeData
     */
    'subscriptionId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof SubscriptionStripeData
     */
    'nextRenewalDate'?: string;
    /**
     * 
     * @type {Array<StripeSubscriptionItem>}
     * @memberof SubscriptionStripeData
     */
    'items': Array<StripeSubscriptionItem>;
    /**
     * 
     * @type {Array<PaymentData>}
     * @memberof SubscriptionStripeData
     */
    'payments': Array<PaymentData>;
}
/**
 * 
 * @export
 * @interface SubscriptionUpdate
 */
export interface SubscriptionUpdate {
    /**
     * Cancel the subscription. Will set the end date to the end of the current period. Features will continue to work until the end of the period.
     * @type {boolean}
     * @memberof SubscriptionUpdate
     */
    'cancel'?: boolean;
    /**
     * Reason for voiding the subscription. Will cancel the subscription if provided. Will set the end date to now.
     * @type {string}
     * @memberof SubscriptionUpdate
     */
    'voidReason'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionsGet200Response
 */
interface SubscriptionsGet200Response {
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof SubscriptionsGet200Response
     */
    'items': Array<Subscription>;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionsGet200Response
     */
    'nextPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface TeamDetail
 */
export interface TeamDetail {
    /**
     * The ID of a team
     * @type {string}
     * @memberof TeamDetail
     */
    'id': string;
    /**
     * 
     * @type {Access}
     * @memberof TeamDetail
     */
    'access': Access;
    /**
     * 
     * @type {LimitationMap}
     * @memberof TeamDetail
     */
    'usage': LimitationMap;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TeamDetail
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TeamDetail
     */
    'updatedAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TeamDetail
     */
    'lastAccessComputedAt': string;
    /**
     * 
     * @type {Array<LimitedItem>}
     * @memberof TeamDetail
     */
    'autoChargeItems': Array<LimitedItem>;
    /**
     * 
     * @type {string}
     * @memberof TeamDetail
     */
    'stripeCustomerId'?: string;
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof TeamDetail
     */
    'subscriptions'?: Array<Subscription>;
    /**
     * 
     * @type {string}
     * @memberof TeamDetail
     */
    'partnership'?: string;
}
/**
 * 
 * @export
 * @interface TeamDetailCreate
 */
export interface TeamDetailCreate {
    /**
     * The ID of a team
     * @type {string}
     * @memberof TeamDetailCreate
     */
    'id': string;
    /**
     * 
     * @type {Set<LimitedItem>}
     * @memberof TeamDetailCreate
     */
    'autoChargeItems'?: Set<LimitedItem>;
    /**
     * 
     * @type {StripeCustomerCreate}
     * @memberof TeamDetailCreate
     */
    'stripeCustomer': StripeCustomerCreate;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailCreate
     */
    'partnership'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailCreate
     */
    'referralCode'?: string;
}
/**
 * 
 * @export
 * @interface TeamDetailUpdate
 */
export interface TeamDetailUpdate {
    /**
     * 
     * @type {Set<LimitedItem>}
     * @memberof TeamDetailUpdate
     */
    'autoChargeItems'?: Set<LimitedItem>;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailUpdate
     */
    'stripeCustomerId'?: string;
    /**
     * 
     * @type {LimitationMap}
     * @memberof TeamDetailUpdate
     */
    'usage'?: LimitationMap;
}
/**
 * 
 * @export
 * @interface TxMetadata
 */
export interface TxMetadata {
    [key: string]: any;

    /**
     * The redeemed coupon ID
     * @type {string}
     * @memberof TxMetadata
     */
    'redeemedCouponId'?: string;
    /**
     * 
     * @type {number}
     * @memberof TxMetadata
     */
    'percentageOff'?: number;
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof TxMetadata
     */
    'couponId'?: string;
}
/**
 * 
 * @export
 * @interface UnlockPreference
 */
export interface UnlockPreference {
    /**
     * 
     * @type {string}
     * @memberof UnlockPreference
     */
    'category': UnlockPreferenceCategoryEnum;
    /**
     * 
     * @type {CreditUnlockType}
     * @memberof UnlockPreference
     */
    'key': CreditUnlockType;
    /**
     * 
     * @type {CountryTier}
     * @memberof UnlockPreference
     */
    'tier'?: CountryTier;
    /**
     * 
     * @type {CreditUnlockMetadata}
     * @memberof UnlockPreference
     */
    'data': CreditUnlockMetadata;
}

export const UnlockPreferenceCategoryEnum = {
    Unlock: 'unlock'
} as const;

export type UnlockPreferenceCategoryEnum = typeof UnlockPreferenceCategoryEnum[keyof typeof UnlockPreferenceCategoryEnum];

/**
 * 
 * @export
 * @interface VariableSingleConsumptionMetadata
 */
export interface VariableSingleConsumptionMetadata {
    /**
     * 
     * @type {string}
     * @memberof VariableSingleConsumptionMetadata
     */
    'type': VariableSingleConsumptionMetadataTypeEnum;
    /**
     * Some data used to configure the correct price of the consumption
     * @type {{ [key: string]: any; }}
     * @memberof VariableSingleConsumptionMetadata
     */
    'data': { [key: string]: any; };
}

export const VariableSingleConsumptionMetadataTypeEnum = {
    Custom: 'custom'
} as const;

export type VariableSingleConsumptionMetadataTypeEnum = typeof VariableSingleConsumptionMetadataTypeEnum[keyof typeof VariableSingleConsumptionMetadataTypeEnum];

/**
 * Pricing of each item in credits
 * @export
 * @interface WabaPricingData
 */
export interface WabaPricingData {
    /**
     * 
     * @type {number}
     * @memberof WabaPricingData
     */
    'authentication'?: number;
    /**
     * 
     * @type {number}
     * @memberof WabaPricingData
     */
    'service'?: number;
    /**
     * 
     * @type {number}
     * @memberof WabaPricingData
     */
    'marketing'?: number;
    /**
     * 
     * @type {number}
     * @memberof WabaPricingData
     */
    'utility'?: number;
}

/**
 * AutoChargeProductsApi - axios parameter creator
 * @export
 */
export const AutoChargeProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - If usage < limit, then no action is taken - If usage >= limit, then:   - a metered subscription is created, if it doesn\'t exist   - fails if cannot be auto-charged
         * @summary Prepares the team for auto charge
         * @param {LimitedItem} item 
         * @param {string} [accountId] The account ID to prepare usage for. Relevant for messages only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsPrepare: async (item: LimitedItem, accountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('autoChargeProductsPrepare', 'item', item)
            const localVarPath = `/auto-charge-products/prepare/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutoChargeProductsApi - functional programming interface
 * @export
 */
export const AutoChargeProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutoChargeProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * - If usage < limit, then no action is taken - If usage >= limit, then:   - a metered subscription is created, if it doesn\'t exist   - fails if cannot be auto-charged
         * @summary Prepares the team for auto charge
         * @param {LimitedItem} item 
         * @param {string} [accountId] The account ID to prepare usage for. Relevant for messages only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoChargeProductsPrepare(item: LimitedItem, accountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoChargeProductsPrepare200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoChargeProductsPrepare(item, accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutoChargeProductsApi.autoChargeProductsPrepare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AutoChargeProductsApi - factory interface
 * @export
 */
export const AutoChargeProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutoChargeProductsApiFp(configuration)
    return {
        /**
         * - If usage < limit, then no action is taken - If usage >= limit, then:   - a metered subscription is created, if it doesn\'t exist   - fails if cannot be auto-charged
         * @summary Prepares the team for auto charge
         * @param {AutoChargeProductsApiAutoChargeProductsPrepareRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsPrepare(requestParameters: AutoChargeProductsApiAutoChargeProductsPrepareRequest, options?: RawAxiosRequestConfig): AxiosPromise<AutoChargeProductsPrepare200Response> {
            return localVarFp.autoChargeProductsPrepare(requestParameters.item, requestParameters.accountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for autoChargeProductsPrepare operation in AutoChargeProductsApi.
 * @export
 * @interface AutoChargeProductsApiAutoChargeProductsPrepareRequest
 */
export interface AutoChargeProductsApiAutoChargeProductsPrepareRequest {
    /**
     * 
     * @type {LimitedItem}
     * @memberof AutoChargeProductsApiAutoChargeProductsPrepare
     */
    readonly item: LimitedItem

    /**
     * The account ID to prepare usage for. Relevant for messages only.
     * @type {string}
     * @memberof AutoChargeProductsApiAutoChargeProductsPrepare
     */
    readonly accountId?: string
}

/**
 * AutoChargeProductsApi - object-oriented interface
 * @export
 * @class AutoChargeProductsApi
 * @extends {BaseAPI}
 */
export class AutoChargeProductsApi extends BaseAPI {
    /**
     * - If usage < limit, then no action is taken - If usage >= limit, then:   - a metered subscription is created, if it doesn\'t exist   - fails if cannot be auto-charged
     * @summary Prepares the team for auto charge
     * @param {AutoChargeProductsApiAutoChargeProductsPrepareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoChargeProductsApi
     */
    public autoChargeProductsPrepare(requestParameters: AutoChargeProductsApiAutoChargeProductsPrepareRequest, options?: RawAxiosRequestConfig) {
        return AutoChargeProductsApiFp(this.configuration).autoChargeProductsPrepare(requestParameters.item, requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CouponCodesApi - axios parameter creator
 * @export
 */
export const CouponCodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get and verify coupon data from Stripe
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsGet: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('couponsGet', 'code', code)
            const localVarPath = `/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Chatdaddy coupon data
         * @param {number} [count] 
         * @param {boolean} [returnTotal] Return total number of coupons
         * @param {string} [cursor] 
         * @param {string} [q] Search by partial coupon id
         * @param {string} [id] Filter by coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCouponsGet: async (count?: number, returnTotal?: boolean, cursor?: string, q?: string, id?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a coupon by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCouponsGetId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('creditsCouponsGetId', 'id', id)
            const localVarPath = `/v2/credits/coupons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get coupon redemptions
         * @param {number} [count] 
         * @param {boolean} [returnTotal] Return total number of redemptions
         * @param {string} [cursor] 
         * @param {string} [q] Search by partial redeemed coupon id
         * @param {string} [couponId] Filter by coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCouponsRedemptionsGet: async (count?: number, returnTotal?: boolean, cursor?: string, q?: string, couponId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/coupons/redemptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (couponId !== undefined) {
                localVarQueryParameter['couponId'] = couponId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CouponCodesApi - functional programming interface
 * @export
 */
export const CouponCodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CouponCodesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get and verify coupon data from Stripe
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsGet(code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeCouponData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsGet(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponCodesApi.couponsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Chatdaddy coupon data
         * @param {number} [count] 
         * @param {boolean} [returnTotal] Return total number of coupons
         * @param {string} [cursor] 
         * @param {string} [q] Search by partial coupon id
         * @param {string} [id] Filter by coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsCouponsGet(count?: number, returnTotal?: boolean, cursor?: string, q?: string, id?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditsCouponsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsCouponsGet(count, returnTotal, cursor, q, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponCodesApi.creditsCouponsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a coupon by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsCouponsGetId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Coupon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsCouponsGetId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponCodesApi.creditsCouponsGetId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get coupon redemptions
         * @param {number} [count] 
         * @param {boolean} [returnTotal] Return total number of redemptions
         * @param {string} [cursor] 
         * @param {string} [q] Search by partial redeemed coupon id
         * @param {string} [couponId] Filter by coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsCouponsRedemptionsGet(count?: number, returnTotal?: boolean, cursor?: string, q?: string, couponId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditsCouponsRedemptionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsCouponsRedemptionsGet(count, returnTotal, cursor, q, couponId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponCodesApi.creditsCouponsRedemptionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CouponCodesApi - factory interface
 * @export
 */
export const CouponCodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CouponCodesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get and verify coupon data from Stripe
         * @param {CouponCodesApiCouponsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsGet(requestParameters: CouponCodesApiCouponsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<StripeCouponData> {
            return localVarFp.couponsGet(requestParameters.code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Chatdaddy coupon data
         * @param {CouponCodesApiCreditsCouponsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCouponsGet(requestParameters: CouponCodesApiCreditsCouponsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CreditsCouponsGet200Response> {
            return localVarFp.creditsCouponsGet(requestParameters.count, requestParameters.returnTotal, requestParameters.cursor, requestParameters.q, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a coupon by ID
         * @param {CouponCodesApiCreditsCouponsGetIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCouponsGetId(requestParameters: CouponCodesApiCreditsCouponsGetIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<Coupon> {
            return localVarFp.creditsCouponsGetId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get coupon redemptions
         * @param {CouponCodesApiCreditsCouponsRedemptionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCouponsRedemptionsGet(requestParameters: CouponCodesApiCreditsCouponsRedemptionsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CreditsCouponsRedemptionsGet200Response> {
            return localVarFp.creditsCouponsRedemptionsGet(requestParameters.count, requestParameters.returnTotal, requestParameters.cursor, requestParameters.q, requestParameters.couponId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for couponsGet operation in CouponCodesApi.
 * @export
 * @interface CouponCodesApiCouponsGetRequest
 */
export interface CouponCodesApiCouponsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof CouponCodesApiCouponsGet
     */
    readonly code: string
}

/**
 * Request parameters for creditsCouponsGet operation in CouponCodesApi.
 * @export
 * @interface CouponCodesApiCreditsCouponsGetRequest
 */
export interface CouponCodesApiCreditsCouponsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof CouponCodesApiCreditsCouponsGet
     */
    readonly count?: number

    /**
     * Return total number of coupons
     * @type {boolean}
     * @memberof CouponCodesApiCreditsCouponsGet
     */
    readonly returnTotal?: boolean

    /**
     * 
     * @type {string}
     * @memberof CouponCodesApiCreditsCouponsGet
     */
    readonly cursor?: string

    /**
     * Search by partial coupon id
     * @type {string}
     * @memberof CouponCodesApiCreditsCouponsGet
     */
    readonly q?: string

    /**
     * Filter by coupon ID
     * @type {string}
     * @memberof CouponCodesApiCreditsCouponsGet
     */
    readonly id?: string
}

/**
 * Request parameters for creditsCouponsGetId operation in CouponCodesApi.
 * @export
 * @interface CouponCodesApiCreditsCouponsGetIdRequest
 */
export interface CouponCodesApiCreditsCouponsGetIdRequest {
    /**
     * 
     * @type {string}
     * @memberof CouponCodesApiCreditsCouponsGetId
     */
    readonly id: string
}

/**
 * Request parameters for creditsCouponsRedemptionsGet operation in CouponCodesApi.
 * @export
 * @interface CouponCodesApiCreditsCouponsRedemptionsGetRequest
 */
export interface CouponCodesApiCreditsCouponsRedemptionsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof CouponCodesApiCreditsCouponsRedemptionsGet
     */
    readonly count?: number

    /**
     * Return total number of redemptions
     * @type {boolean}
     * @memberof CouponCodesApiCreditsCouponsRedemptionsGet
     */
    readonly returnTotal?: boolean

    /**
     * 
     * @type {string}
     * @memberof CouponCodesApiCreditsCouponsRedemptionsGet
     */
    readonly cursor?: string

    /**
     * Search by partial redeemed coupon id
     * @type {string}
     * @memberof CouponCodesApiCreditsCouponsRedemptionsGet
     */
    readonly q?: string

    /**
     * Filter by coupon ID
     * @type {string}
     * @memberof CouponCodesApiCreditsCouponsRedemptionsGet
     */
    readonly couponId?: string
}

/**
 * CouponCodesApi - object-oriented interface
 * @export
 * @class CouponCodesApi
 * @extends {BaseAPI}
 */
export class CouponCodesApi extends BaseAPI {
    /**
     * 
     * @summary Get and verify coupon data from Stripe
     * @param {CouponCodesApiCouponsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponCodesApi
     */
    public couponsGet(requestParameters: CouponCodesApiCouponsGetRequest, options?: RawAxiosRequestConfig) {
        return CouponCodesApiFp(this.configuration).couponsGet(requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Chatdaddy coupon data
     * @param {CouponCodesApiCreditsCouponsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponCodesApi
     */
    public creditsCouponsGet(requestParameters: CouponCodesApiCreditsCouponsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return CouponCodesApiFp(this.configuration).creditsCouponsGet(requestParameters.count, requestParameters.returnTotal, requestParameters.cursor, requestParameters.q, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a coupon by ID
     * @param {CouponCodesApiCreditsCouponsGetIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponCodesApi
     */
    public creditsCouponsGetId(requestParameters: CouponCodesApiCreditsCouponsGetIdRequest, options?: RawAxiosRequestConfig) {
        return CouponCodesApiFp(this.configuration).creditsCouponsGetId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get coupon redemptions
     * @param {CouponCodesApiCreditsCouponsRedemptionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponCodesApi
     */
    public creditsCouponsRedemptionsGet(requestParameters: CouponCodesApiCreditsCouponsRedemptionsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return CouponCodesApiFp(this.configuration).creditsCouponsRedemptionsGet(requestParameters.count, requestParameters.returnTotal, requestParameters.cursor, requestParameters.q, requestParameters.couponId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CreditsApi - axios parameter creator
 * @export
 */
export const CreditsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel the current auto-renewal credit sub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoRenewalCancel: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/auto-renewal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create/update the auto-renewal credit sub
         * @param {CreditAutoRenewalUpdate} [creditAutoRenewalUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoRenewalPost: async (creditAutoRenewalUpdate?: CreditAutoRenewalUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/auto-renewal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditAutoRenewalUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {CreditConsumptionType} type The type of consumption
         * @param {number} quantity The number of times to consume the given type
         * @param {LegacyCanConsumeOpts} [legacyOpts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canConsumeCredits: async (type: CreditConsumptionType, quantity: number, legacyOpts?: LegacyCanConsumeOpts, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('canConsumeCredits', 'type', type)
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('canConsumeCredits', 'quantity', quantity)
            const localVarPath = `/v2/credits/can-consume`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (quantity !== undefined) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (legacyOpts !== undefined) {
                for (const [key, value] of Object.entries(legacyOpts)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {RecurringCreditConsumptionType} type The type of consumption
         * @param {LegacyCanConsumeOpts} [legacyOpts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canConsumeRecurringCredits: async (type: RecurringCreditConsumptionType, legacyOpts?: LegacyCanConsumeOpts, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('canConsumeRecurringCredits', 'type', type)
            const localVarPath = `/v2/credits/can-consume-recurring`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (legacyOpts !== undefined) {
                for (const [key, value] of Object.entries(legacyOpts)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new single use credit consumption record
         * @param {CreditConsumptionPostRequest} [creditConsumptionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditConsumptionPost: async (creditConsumptionPostRequest?: CreditConsumptionPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/consumption`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditConsumptionPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of gains your team has received
         * @param {string} [customerId] Filter by customerId.
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {Array<CreditGainType>} [type] 
         * @param {DateRange} [createdAt] 
         * @param {CreditGainStatus} [status] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditGainsGet: async (customerId?: string, count?: number, cursor?: string, type?: Array<CreditGainType>, createdAt?: DateRange, status?: CreditGainStatus, returnTotal?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/gains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ"], configuration)

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (createdAt !== undefined) {
                for (const [key, value] of Object.entries(createdAt)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transaction history
         * @param {string} [teamId] Filter by teamId
         * @param {string} [customerId] Filter by customerId
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {Array<CreditBalanceEffectType>} [type] 
         * @param {CreditTxsGetEffectTypeEnum} [effectType] 
         * @param {Array<string>} [id] 
         * @param {DateRange} [createdAt] 
         * @param {string} [doneBy] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditTxsGet: async (teamId?: string, customerId?: string, count?: number, cursor?: string, type?: Array<CreditBalanceEffectType>, effectType?: CreditTxsGetEffectTypeEnum, id?: Array<string>, createdAt?: DateRange, doneBy?: string, returnTotal?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/consumption`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ"], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (effectType !== undefined) {
                localVarQueryParameter['effectType'] = effectType;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                for (const [key, value] of Object.entries(createdAt)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (doneBy !== undefined) {
                localVarQueryParameter['doneBy'] = doneBy;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the customer\'s credit details
         * @param {boolean} [returnAutoRenewal] Return the auto-renewal subscription details. PAYMENTS_READ scope is required.
         * @param {boolean} [returnSupportPlan] Return the support plan details.
         * @param {boolean} [returnRecurringPlans] Return the support plan details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerGet: async (returnAutoRenewal?: boolean, returnSupportPlan?: boolean, returnRecurringPlans?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (returnAutoRenewal !== undefined) {
                localVarQueryParameter['returnAutoRenewal'] = returnAutoRenewal;
            }

            if (returnSupportPlan !== undefined) {
                localVarQueryParameter['returnSupportPlan'] = returnSupportPlan;
            }

            if (returnRecurringPlans !== undefined) {
                localVarQueryParameter['returnRecurringPlans'] = returnRecurringPlans;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refreshes the customer\'s subscription & any other purchased items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerRefresh: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/customer/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get metadata for credit consumptions and unlocks
         * @param {string} [region] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsPreferencesGet: async (region?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create/update/cancel the support plan
         * @param {ModifySupportPlan} [modifySupportPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySupportPlan: async (modifySupportPlan?: ModifySupportPlan, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/support-plan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifySupportPlan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recurring credit consumptions
         * @param {string} [teamId] Filter by teamId
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {RecurringCreditConsumptionType} [type] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {string} [doneBy] Filter by the user who created the consumption
         * @param {RecurringCreditsGetDateRageParameter} [dateRage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recurringCreditsGet: async (teamId?: string, count?: number, cursor?: string, type?: RecurringCreditConsumptionType, returnTotal?: boolean, doneBy?: string, dateRage?: RecurringCreditsGetDateRageParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/recurring`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ"], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }

            if (doneBy !== undefined) {
                localVarQueryParameter['doneBy'] = doneBy;
            }

            if (dateRage !== undefined) {
                for (const [key, value] of Object.entries(dateRage)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new recurring credit consumption record
         * @param {RecurringCreditConsumptionCreate} [recurringCreditConsumptionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRecurringConsumption: async (recurringCreditConsumptionCreate?: RecurringCreditConsumptionCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/recurring`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recurringCreditConsumptionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop a recurring credit consumption
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRecurringConsumption: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stopRecurringConsumption', 'id', id)
            const localVarPath = `/v2/credits/recurring/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Top up credits
         * @param {CreditTopUpOptions} [creditTopUpOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topUpCreditsPost: async (creditTopUpOptions?: CreditTopUpOptions, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/topup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditTopUpOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditsApi - functional programming interface
 * @export
 */
export const CreditsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel the current auto-renewal credit sub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoRenewalCancel(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoRenewalCancel(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.autoRenewalCancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create/update the auto-renewal credit sub
         * @param {CreditAutoRenewalUpdate} [creditAutoRenewalUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoRenewalPost(creditAutoRenewalUpdate?: CreditAutoRenewalUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoRenewalPost(creditAutoRenewalUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.autoRenewalPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {CreditConsumptionType} type The type of consumption
         * @param {number} quantity The number of times to consume the given type
         * @param {LegacyCanConsumeOpts} [legacyOpts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async canConsumeCredits(type: CreditConsumptionType, quantity: number, legacyOpts?: LegacyCanConsumeOpts, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCanConsumeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.canConsumeCredits(type, quantity, legacyOpts, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.canConsumeCredits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {RecurringCreditConsumptionType} type The type of consumption
         * @param {LegacyCanConsumeOpts} [legacyOpts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async canConsumeRecurringCredits(type: RecurringCreditConsumptionType, legacyOpts?: LegacyCanConsumeOpts, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCanConsumeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.canConsumeRecurringCredits(type, legacyOpts, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.canConsumeRecurringCredits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new single use credit consumption record
         * @param {CreditConsumptionPostRequest} [creditConsumptionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditConsumptionPost(creditConsumptionPostRequest?: CreditConsumptionPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreditTransactionRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditConsumptionPost(creditConsumptionPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.creditConsumptionPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get list of gains your team has received
         * @param {string} [customerId] Filter by customerId.
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {Array<CreditGainType>} [type] 
         * @param {DateRange} [createdAt] 
         * @param {CreditGainStatus} [status] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditGainsGet(customerId?: string, count?: number, cursor?: string, type?: Array<CreditGainType>, createdAt?: DateRange, status?: CreditGainStatus, returnTotal?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditGainsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditGainsGet(customerId, count, cursor, type, createdAt, status, returnTotal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.creditGainsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get transaction history
         * @param {string} [teamId] Filter by teamId
         * @param {string} [customerId] Filter by customerId
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {Array<CreditBalanceEffectType>} [type] 
         * @param {CreditTxsGetEffectTypeEnum} [effectType] 
         * @param {Array<string>} [id] 
         * @param {DateRange} [createdAt] 
         * @param {string} [doneBy] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditTxsGet(teamId?: string, customerId?: string, count?: number, cursor?: string, type?: Array<CreditBalanceEffectType>, effectType?: CreditTxsGetEffectTypeEnum, id?: Array<string>, createdAt?: DateRange, doneBy?: string, returnTotal?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditTxsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditTxsGet(teamId, customerId, count, cursor, type, effectType, id, createdAt, doneBy, returnTotal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.creditTxsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the customer\'s credit details
         * @param {boolean} [returnAutoRenewal] Return the auto-renewal subscription details. PAYMENTS_READ scope is required.
         * @param {boolean} [returnSupportPlan] Return the support plan details.
         * @param {boolean} [returnRecurringPlans] Return the support plan details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsCustomerGet(returnAutoRenewal?: boolean, returnSupportPlan?: boolean, returnRecurringPlans?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCustomer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsCustomerGet(returnAutoRenewal, returnSupportPlan, returnRecurringPlans, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.creditsCustomerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refreshes the customer\'s subscription & any other purchased items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsCustomerRefresh(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsCustomerRefresh(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.creditsCustomerRefresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get metadata for credit consumptions and unlocks
         * @param {string} [region] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsPreferencesGet(region?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditsPreferences>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsPreferencesGet(region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.creditsPreferencesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create/update/cancel the support plan
         * @param {ModifySupportPlan} [modifySupportPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifySupportPlan(modifySupportPlan?: ModifySupportPlan, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurringCreditConsumption>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifySupportPlan(modifySupportPlan, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.modifySupportPlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get recurring credit consumptions
         * @param {string} [teamId] Filter by teamId
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {RecurringCreditConsumptionType} [type] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {string} [doneBy] Filter by the user who created the consumption
         * @param {RecurringCreditsGetDateRageParameter} [dateRage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recurringCreditsGet(teamId?: string, count?: number, cursor?: string, type?: RecurringCreditConsumptionType, returnTotal?: boolean, doneBy?: string, dateRage?: RecurringCreditsGetDateRageParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurringCreditsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recurringCreditsGet(teamId, count, cursor, type, returnTotal, doneBy, dateRage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.recurringCreditsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new recurring credit consumption record
         * @param {RecurringCreditConsumptionCreate} [recurringCreditConsumptionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRecurringConsumption(recurringCreditConsumptionCreate?: RecurringCreditConsumptionCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurringCreditConsumption>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRecurringConsumption(recurringCreditConsumptionCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.startRecurringConsumption']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stop a recurring credit consumption
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopRecurringConsumption(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopRecurringConsumption(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.stopRecurringConsumption']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Top up credits
         * @param {CreditTopUpOptions} [creditTopUpOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topUpCreditsPost(creditTopUpOptions?: CreditTopUpOptions, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topUpCreditsPost(creditTopUpOptions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditsApi.topUpCreditsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CreditsApi - factory interface
 * @export
 */
export const CreditsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditsApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel the current auto-renewal credit sub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoRenewalCancel(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.autoRenewalCancel(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create/update the auto-renewal credit sub
         * @param {CreditsApiAutoRenewalPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoRenewalPost(requestParameters: CreditsApiAutoRenewalPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaymentRequest> {
            return localVarFp.autoRenewalPost(requestParameters.creditAutoRenewalUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {CreditsApiCanConsumeCreditsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canConsumeCredits(requestParameters: CreditsApiCanConsumeCreditsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreditCanConsumeResponse> {
            return localVarFp.canConsumeCredits(requestParameters.type, requestParameters.quantity, requestParameters.legacyOpts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {CreditsApiCanConsumeRecurringCreditsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canConsumeRecurringCredits(requestParameters: CreditsApiCanConsumeRecurringCreditsRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreditCanConsumeResponse> {
            return localVarFp.canConsumeRecurringCredits(requestParameters.type, requestParameters.legacyOpts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new single use credit consumption record
         * @param {CreditsApiCreditConsumptionPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditConsumptionPost(requestParameters: CreditsApiCreditConsumptionPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<CreditTransactionRecord>> {
            return localVarFp.creditConsumptionPost(requestParameters.creditConsumptionPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of gains your team has received
         * @param {CreditsApiCreditGainsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditGainsGet(requestParameters: CreditsApiCreditGainsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CreditGainsGet200Response> {
            return localVarFp.creditGainsGet(requestParameters.customerId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.createdAt, requestParameters.status, requestParameters.returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transaction history
         * @param {CreditsApiCreditTxsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditTxsGet(requestParameters: CreditsApiCreditTxsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CreditTxsGet200Response> {
            return localVarFp.creditTxsGet(requestParameters.teamId, requestParameters.customerId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.effectType, requestParameters.id, requestParameters.createdAt, requestParameters.doneBy, requestParameters.returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the customer\'s credit details
         * @param {CreditsApiCreditsCustomerGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerGet(requestParameters: CreditsApiCreditsCustomerGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CreditCustomer> {
            return localVarFp.creditsCustomerGet(requestParameters.returnAutoRenewal, requestParameters.returnSupportPlan, requestParameters.returnRecurringPlans, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refreshes the customer\'s subscription & any other purchased items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerRefresh(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.creditsCustomerRefresh(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get metadata for credit consumptions and unlocks
         * @param {CreditsApiCreditsPreferencesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsPreferencesGet(requestParameters: CreditsApiCreditsPreferencesGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CreditsPreferences> {
            return localVarFp.creditsPreferencesGet(requestParameters.region, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create/update/cancel the support plan
         * @param {CreditsApiModifySupportPlanRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySupportPlan(requestParameters: CreditsApiModifySupportPlanRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<RecurringCreditConsumption> {
            return localVarFp.modifySupportPlan(requestParameters.modifySupportPlan, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recurring credit consumptions
         * @param {CreditsApiRecurringCreditsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recurringCreditsGet(requestParameters: CreditsApiRecurringCreditsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<RecurringCreditsGet200Response> {
            return localVarFp.recurringCreditsGet(requestParameters.teamId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.returnTotal, requestParameters.doneBy, requestParameters.dateRage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new recurring credit consumption record
         * @param {CreditsApiStartRecurringConsumptionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRecurringConsumption(requestParameters: CreditsApiStartRecurringConsumptionRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<RecurringCreditConsumption> {
            return localVarFp.startRecurringConsumption(requestParameters.recurringCreditConsumptionCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop a recurring credit consumption
         * @param {CreditsApiStopRecurringConsumptionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRecurringConsumption(requestParameters: CreditsApiStopRecurringConsumptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stopRecurringConsumption(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Top up credits
         * @param {CreditsApiTopUpCreditsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topUpCreditsPost(requestParameters: CreditsApiTopUpCreditsPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PaymentRequest> {
            return localVarFp.topUpCreditsPost(requestParameters.creditTopUpOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for autoRenewalPost operation in CreditsApi.
 * @export
 * @interface CreditsApiAutoRenewalPostRequest
 */
export interface CreditsApiAutoRenewalPostRequest {
    /**
     * 
     * @type {CreditAutoRenewalUpdate}
     * @memberof CreditsApiAutoRenewalPost
     */
    readonly creditAutoRenewalUpdate?: CreditAutoRenewalUpdate
}

/**
 * Request parameters for canConsumeCredits operation in CreditsApi.
 * @export
 * @interface CreditsApiCanConsumeCreditsRequest
 */
export interface CreditsApiCanConsumeCreditsRequest {
    /**
     * The type of consumption
     * @type {CreditConsumptionType}
     * @memberof CreditsApiCanConsumeCredits
     */
    readonly type: CreditConsumptionType

    /**
     * The number of times to consume the given type
     * @type {number}
     * @memberof CreditsApiCanConsumeCredits
     */
    readonly quantity: number

    /**
     * 
     * @type {LegacyCanConsumeOpts}
     * @memberof CreditsApiCanConsumeCredits
     */
    readonly legacyOpts?: LegacyCanConsumeOpts
}

/**
 * Request parameters for canConsumeRecurringCredits operation in CreditsApi.
 * @export
 * @interface CreditsApiCanConsumeRecurringCreditsRequest
 */
export interface CreditsApiCanConsumeRecurringCreditsRequest {
    /**
     * The type of consumption
     * @type {RecurringCreditConsumptionType}
     * @memberof CreditsApiCanConsumeRecurringCredits
     */
    readonly type: RecurringCreditConsumptionType

    /**
     * 
     * @type {LegacyCanConsumeOpts}
     * @memberof CreditsApiCanConsumeRecurringCredits
     */
    readonly legacyOpts?: LegacyCanConsumeOpts
}

/**
 * Request parameters for creditConsumptionPost operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditConsumptionPostRequest
 */
export interface CreditsApiCreditConsumptionPostRequest {
    /**
     * 
     * @type {CreditConsumptionPostRequest}
     * @memberof CreditsApiCreditConsumptionPost
     */
    readonly creditConsumptionPostRequest?: CreditConsumptionPostRequest
}

/**
 * Request parameters for creditGainsGet operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditGainsGetRequest
 */
export interface CreditsApiCreditGainsGetRequest {
    /**
     * Filter by customerId.
     * @type {string}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly customerId?: string

    /**
     * 
     * @type {number}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly cursor?: string

    /**
     * 
     * @type {Array<CreditGainType>}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly type?: Array<CreditGainType>

    /**
     * 
     * @type {DateRange}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly createdAt?: DateRange

    /**
     * 
     * @type {CreditGainStatus}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly status?: CreditGainStatus

    /**
     * Return total number of consumptions
     * @type {boolean}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for creditTxsGet operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditTxsGetRequest
 */
export interface CreditsApiCreditTxsGetRequest {
    /**
     * Filter by teamId
     * @type {string}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly teamId?: string

    /**
     * Filter by customerId
     * @type {string}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly customerId?: string

    /**
     * 
     * @type {number}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly cursor?: string

    /**
     * 
     * @type {Array<CreditBalanceEffectType>}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly type?: Array<CreditBalanceEffectType>

    /**
     * 
     * @type {'gain' | 'consume'}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly effectType?: CreditTxsGetEffectTypeEnum

    /**
     * 
     * @type {Array<string>}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly id?: Array<string>

    /**
     * 
     * @type {DateRange}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly createdAt?: DateRange

    /**
     * 
     * @type {string}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly doneBy?: string

    /**
     * Return total number of consumptions
     * @type {boolean}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for creditsCustomerGet operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditsCustomerGetRequest
 */
export interface CreditsApiCreditsCustomerGetRequest {
    /**
     * Return the auto-renewal subscription details. PAYMENTS_READ scope is required.
     * @type {boolean}
     * @memberof CreditsApiCreditsCustomerGet
     */
    readonly returnAutoRenewal?: boolean

    /**
     * Return the support plan details.
     * @type {boolean}
     * @memberof CreditsApiCreditsCustomerGet
     */
    readonly returnSupportPlan?: boolean

    /**
     * Return the support plan details.
     * @type {boolean}
     * @memberof CreditsApiCreditsCustomerGet
     */
    readonly returnRecurringPlans?: boolean
}

/**
 * Request parameters for creditsPreferencesGet operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditsPreferencesGetRequest
 */
export interface CreditsApiCreditsPreferencesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditsApiCreditsPreferencesGet
     */
    readonly region?: string
}

/**
 * Request parameters for modifySupportPlan operation in CreditsApi.
 * @export
 * @interface CreditsApiModifySupportPlanRequest
 */
export interface CreditsApiModifySupportPlanRequest {
    /**
     * 
     * @type {ModifySupportPlan}
     * @memberof CreditsApiModifySupportPlan
     */
    readonly modifySupportPlan?: ModifySupportPlan
}

/**
 * Request parameters for recurringCreditsGet operation in CreditsApi.
 * @export
 * @interface CreditsApiRecurringCreditsGetRequest
 */
export interface CreditsApiRecurringCreditsGetRequest {
    /**
     * Filter by teamId
     * @type {string}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly teamId?: string

    /**
     * 
     * @type {number}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly cursor?: string

    /**
     * 
     * @type {RecurringCreditConsumptionType}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly type?: RecurringCreditConsumptionType

    /**
     * Return total number of consumptions
     * @type {boolean}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly returnTotal?: boolean

    /**
     * Filter by the user who created the consumption
     * @type {string}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly doneBy?: string

    /**
     * 
     * @type {RecurringCreditsGetDateRageParameter}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly dateRage?: RecurringCreditsGetDateRageParameter
}

/**
 * Request parameters for startRecurringConsumption operation in CreditsApi.
 * @export
 * @interface CreditsApiStartRecurringConsumptionRequest
 */
export interface CreditsApiStartRecurringConsumptionRequest {
    /**
     * 
     * @type {RecurringCreditConsumptionCreate}
     * @memberof CreditsApiStartRecurringConsumption
     */
    readonly recurringCreditConsumptionCreate?: RecurringCreditConsumptionCreate
}

/**
 * Request parameters for stopRecurringConsumption operation in CreditsApi.
 * @export
 * @interface CreditsApiStopRecurringConsumptionRequest
 */
export interface CreditsApiStopRecurringConsumptionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditsApiStopRecurringConsumption
     */
    readonly id: string
}

/**
 * Request parameters for topUpCreditsPost operation in CreditsApi.
 * @export
 * @interface CreditsApiTopUpCreditsPostRequest
 */
export interface CreditsApiTopUpCreditsPostRequest {
    /**
     * 
     * @type {CreditTopUpOptions}
     * @memberof CreditsApiTopUpCreditsPost
     */
    readonly creditTopUpOptions?: CreditTopUpOptions
}

/**
 * CreditsApi - object-oriented interface
 * @export
 * @class CreditsApi
 * @extends {BaseAPI}
 */
export class CreditsApi extends BaseAPI {
    /**
     * 
     * @summary Cancel the current auto-renewal credit sub
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public autoRenewalCancel(options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).autoRenewalCancel(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create/update the auto-renewal credit sub
     * @param {CreditsApiAutoRenewalPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public autoRenewalPost(requestParameters: CreditsApiAutoRenewalPostRequest = {}, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).autoRenewalPost(requestParameters.creditAutoRenewalUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if the team can consume the given quantity of credits
     * @param {CreditsApiCanConsumeCreditsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public canConsumeCredits(requestParameters: CreditsApiCanConsumeCreditsRequest, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).canConsumeCredits(requestParameters.type, requestParameters.quantity, requestParameters.legacyOpts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if the team can consume the given quantity of credits
     * @param {CreditsApiCanConsumeRecurringCreditsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public canConsumeRecurringCredits(requestParameters: CreditsApiCanConsumeRecurringCreditsRequest, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).canConsumeRecurringCredits(requestParameters.type, requestParameters.legacyOpts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new single use credit consumption record
     * @param {CreditsApiCreditConsumptionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditConsumptionPost(requestParameters: CreditsApiCreditConsumptionPostRequest = {}, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditConsumptionPost(requestParameters.creditConsumptionPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of gains your team has received
     * @param {CreditsApiCreditGainsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditGainsGet(requestParameters: CreditsApiCreditGainsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditGainsGet(requestParameters.customerId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.createdAt, requestParameters.status, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transaction history
     * @param {CreditsApiCreditTxsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditTxsGet(requestParameters: CreditsApiCreditTxsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditTxsGet(requestParameters.teamId, requestParameters.customerId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.effectType, requestParameters.id, requestParameters.createdAt, requestParameters.doneBy, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the customer\'s credit details
     * @param {CreditsApiCreditsCustomerGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditsCustomerGet(requestParameters: CreditsApiCreditsCustomerGetRequest = {}, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditsCustomerGet(requestParameters.returnAutoRenewal, requestParameters.returnSupportPlan, requestParameters.returnRecurringPlans, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refreshes the customer\'s subscription & any other purchased items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditsCustomerRefresh(options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditsCustomerRefresh(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get metadata for credit consumptions and unlocks
     * @param {CreditsApiCreditsPreferencesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditsPreferencesGet(requestParameters: CreditsApiCreditsPreferencesGetRequest = {}, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditsPreferencesGet(requestParameters.region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create/update/cancel the support plan
     * @param {CreditsApiModifySupportPlanRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public modifySupportPlan(requestParameters: CreditsApiModifySupportPlanRequest = {}, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).modifySupportPlan(requestParameters.modifySupportPlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recurring credit consumptions
     * @param {CreditsApiRecurringCreditsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public recurringCreditsGet(requestParameters: CreditsApiRecurringCreditsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).recurringCreditsGet(requestParameters.teamId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.returnTotal, requestParameters.doneBy, requestParameters.dateRage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new recurring credit consumption record
     * @param {CreditsApiStartRecurringConsumptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public startRecurringConsumption(requestParameters: CreditsApiStartRecurringConsumptionRequest = {}, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).startRecurringConsumption(requestParameters.recurringCreditConsumptionCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop a recurring credit consumption
     * @param {CreditsApiStopRecurringConsumptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public stopRecurringConsumption(requestParameters: CreditsApiStopRecurringConsumptionRequest, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).stopRecurringConsumption(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Top up credits
     * @param {CreditsApiTopUpCreditsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public topUpCreditsPost(requestParameters: CreditsApiTopUpCreditsPostRequest = {}, options?: RawAxiosRequestConfig) {
        return CreditsApiFp(this.configuration).topUpCreditsPost(requestParameters.creditTopUpOptions, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CreditTxsGetEffectTypeEnum = {
    Gain: 'gain',
    Consume: 'consume'
} as const;
export type CreditTxsGetEffectTypeEnum = typeof CreditTxsGetEffectTypeEnum[keyof typeof CreditTxsGetEffectTypeEnum];


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch All Available Products
         * @param {string} [region] The region to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet: async (region?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch All Available Products
         * @param {string} [region] The region to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGet(region?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGet(region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.productsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch All Available Products
         * @param {ProductsApiProductsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet(requestParameters: ProductsApiProductsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ProductsGet200Response> {
            return localVarFp.productsGet(requestParameters.region, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for productsGet operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsGetRequest
 */
export interface ProductsApiProductsGetRequest {
    /**
     * The region to filter by
     * @type {string}
     * @memberof ProductsApiProductsGet
     */
    readonly region?: string
}

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch All Available Products
     * @param {ProductsApiProductsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsGet(requestParameters: ProductsApiProductsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsGet(requestParameters.region, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReferralsApi - axios parameter creator
 * @export
 */
export const ReferralsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartner: async (referralCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'referralCode' is not null or undefined
            assertParamExists('getPartner', 'referralCode', referralCode)
            const localVarPath = `/partner-referral/get-partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (referralCode !== undefined) {
                localVarQueryParameter['referralCode'] = referralCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferralsApi - functional programming interface
 * @export
 */
export const ReferralsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferralsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartner(referralCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPartner200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartner(referralCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralsApi.getPartner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReferralsApi - factory interface
 * @export
 */
export const ReferralsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferralsApiFp(configuration)
    return {
        /**
         * 
         * @param {ReferralsApiGetPartnerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartner(requestParameters: ReferralsApiGetPartnerRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetPartner200Response> {
            return localVarFp.getPartner(requestParameters.referralCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPartner operation in ReferralsApi.
 * @export
 * @interface ReferralsApiGetPartnerRequest
 */
export interface ReferralsApiGetPartnerRequest {
    /**
     * 
     * @type {string}
     * @memberof ReferralsApiGetPartner
     */
    readonly referralCode: string
}

/**
 * ReferralsApi - object-oriented interface
 * @export
 * @class ReferralsApi
 * @extends {BaseAPI}
 */
export class ReferralsApi extends BaseAPI {
    /**
     * 
     * @param {ReferralsApiGetPartnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public getPartner(requestParameters: ReferralsApiGetPartnerRequest, options?: RawAxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).getPartner(requestParameters.referralCode, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StripeApi - axios parameter creator
 * @export
 */
export const StripeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {string} returnUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingSessionPost: async (returnUrl: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'returnUrl' is not null or undefined
            assertParamExists('billingSessionPost', 'returnUrl', returnUrl)
            const localVarPath = `/billing-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a checkout session
         * @param {CheckoutCreateOptions} [checkoutCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeCheckout: async (checkoutCreateOptions?: CheckoutCreateOptions, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/checkout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutCreateOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {string} returnUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingSessionPost(returnUrl: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingSessionPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingSessionPost(returnUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeApi.billingSessionPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a checkout session
         * @param {CheckoutCreateOptions} [checkoutCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeCheckout(checkoutCreateOptions?: CheckoutCreateOptions, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeCheckout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripeCheckout(checkoutCreateOptions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeApi.stripeCheckout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {StripeApiBillingSessionPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingSessionPost(requestParameters: StripeApiBillingSessionPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<BillingSessionPost200Response> {
            return localVarFp.billingSessionPost(requestParameters.returnUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a checkout session
         * @param {StripeApiStripeCheckoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeCheckout(requestParameters: StripeApiStripeCheckoutRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<StripeCheckout200Response> {
            return localVarFp.stripeCheckout(requestParameters.checkoutCreateOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for billingSessionPost operation in StripeApi.
 * @export
 * @interface StripeApiBillingSessionPostRequest
 */
export interface StripeApiBillingSessionPostRequest {
    /**
     * 
     * @type {string}
     * @memberof StripeApiBillingSessionPost
     */
    readonly returnUrl: string
}

/**
 * Request parameters for stripeCheckout operation in StripeApi.
 * @export
 * @interface StripeApiStripeCheckoutRequest
 */
export interface StripeApiStripeCheckoutRequest {
    /**
     * 
     * @type {CheckoutCreateOptions}
     * @memberof StripeApiStripeCheckout
     */
    readonly checkoutCreateOptions?: CheckoutCreateOptions
}

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
    /**
     * 
     * @summary Create a new billing portal session to manage payment details
     * @param {StripeApiBillingSessionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public billingSessionPost(requestParameters: StripeApiBillingSessionPostRequest, options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).billingSessionPost(requestParameters.returnUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a checkout session
     * @param {StripeApiStripeCheckoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public stripeCheckout(requestParameters: StripeApiStripeCheckoutRequest = {}, options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).stripeCheckout(requestParameters.checkoutCreateOptions, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the list of subscriptions
         * @param {string} [teamId] Filter by teamId
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {string} [q] Search by subscription ID, team ID or product name
         * @param {boolean} [includeFreeTier] Include free tier subscriptions
         * @param {SubscriptionsGetSortByEnum} [sortBy] Sort by the given field
         * @param {SubscriptionsGetSortDirectionEnum} [sortDirection] Sort direction
         * @param {string} [endsOrRenewsAfter] Filter subscriptions that end or renew after the given date
         * @param {string} [endsOrRenewsBefore] Filter subscriptions that end or renew before the given date
         * @param {boolean} [stripeOnly] Filter subscriptions that are only in Stripe
         * @param {Array<string>} [product] Filter subscriptions by product
         * @param {boolean} [returnTotal] Return total number of subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsGet: async (teamId?: string, count?: number, page?: number, q?: string, includeFreeTier?: boolean, sortBy?: SubscriptionsGetSortByEnum, sortDirection?: SubscriptionsGetSortDirectionEnum, endsOrRenewsAfter?: string, endsOrRenewsBefore?: string, stripeOnly?: boolean, product?: Array<string>, returnTotal?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ"], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (includeFreeTier !== undefined) {
                localVarQueryParameter['includeFreeTier'] = includeFreeTier;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }

            if (endsOrRenewsAfter !== undefined) {
                localVarQueryParameter['endsOrRenewsAfter'] = (endsOrRenewsAfter as any instanceof Date) ?
                    (endsOrRenewsAfter as any).toISOString() :
                    endsOrRenewsAfter;
            }

            if (endsOrRenewsBefore !== undefined) {
                localVarQueryParameter['endsOrRenewsBefore'] = (endsOrRenewsBefore as any instanceof Date) ?
                    (endsOrRenewsBefore as any).toISOString() :
                    endsOrRenewsBefore;
            }

            if (stripeOnly !== undefined) {
                localVarQueryParameter['stripeOnly'] = stripeOnly;
            }

            if (product) {
                localVarQueryParameter['product'] = product;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a subscription\'s properties
         * @param {string} id 
         * @param {SubscriptionUpdate} [subscriptionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPatch: async (id: string, subscriptionUpdate?: SubscriptionUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subscriptionsPatch', 'id', id)
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the list of subscriptions
         * @param {string} [teamId] Filter by teamId
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {string} [q] Search by subscription ID, team ID or product name
         * @param {boolean} [includeFreeTier] Include free tier subscriptions
         * @param {SubscriptionsGetSortByEnum} [sortBy] Sort by the given field
         * @param {SubscriptionsGetSortDirectionEnum} [sortDirection] Sort direction
         * @param {string} [endsOrRenewsAfter] Filter subscriptions that end or renew after the given date
         * @param {string} [endsOrRenewsBefore] Filter subscriptions that end or renew before the given date
         * @param {boolean} [stripeOnly] Filter subscriptions that are only in Stripe
         * @param {Array<string>} [product] Filter subscriptions by product
         * @param {boolean} [returnTotal] Return total number of subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsGet(teamId?: string, count?: number, page?: number, q?: string, includeFreeTier?: boolean, sortBy?: SubscriptionsGetSortByEnum, sortDirection?: SubscriptionsGetSortDirectionEnum, endsOrRenewsAfter?: string, endsOrRenewsBefore?: string, stripeOnly?: boolean, product?: Array<string>, returnTotal?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsGet(teamId, count, page, q, includeFreeTier, sortBy, sortDirection, endsOrRenewsAfter, endsOrRenewsBefore, stripeOnly, product, returnTotal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.subscriptionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a subscription\'s properties
         * @param {string} id 
         * @param {SubscriptionUpdate} [subscriptionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsPatch(id: string, subscriptionUpdate?: SubscriptionUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsPatch(id, subscriptionUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.subscriptionsPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the list of subscriptions
         * @param {SubscriptionsApiSubscriptionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsGet(requestParameters: SubscriptionsApiSubscriptionsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionsGet200Response> {
            return localVarFp.subscriptionsGet(requestParameters.teamId, requestParameters.count, requestParameters.page, requestParameters.q, requestParameters.includeFreeTier, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.endsOrRenewsAfter, requestParameters.endsOrRenewsBefore, requestParameters.stripeOnly, requestParameters.product, requestParameters.returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a subscription\'s properties
         * @param {SubscriptionsApiSubscriptionsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPatch(requestParameters: SubscriptionsApiSubscriptionsPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.subscriptionsPatch(requestParameters.id, requestParameters.subscriptionUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for subscriptionsGet operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiSubscriptionsGetRequest
 */
export interface SubscriptionsApiSubscriptionsGetRequest {
    /**
     * Filter by teamId
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly teamId?: string

    /**
     * 
     * @type {number}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly count?: number

    /**
     * 
     * @type {number}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly page?: number

    /**
     * Search by subscription ID, team ID or product name
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly q?: string

    /**
     * Include free tier subscriptions
     * @type {boolean}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly includeFreeTier?: boolean

    /**
     * Sort by the given field
     * @type {'startDate' | 'endOrNextRenewalDate'}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly sortBy?: SubscriptionsGetSortByEnum

    /**
     * Sort direction
     * @type {'asc' | 'desc'}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly sortDirection?: SubscriptionsGetSortDirectionEnum

    /**
     * Filter subscriptions that end or renew after the given date
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly endsOrRenewsAfter?: string

    /**
     * Filter subscriptions that end or renew before the given date
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly endsOrRenewsBefore?: string

    /**
     * Filter subscriptions that are only in Stripe
     * @type {boolean}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly stripeOnly?: boolean

    /**
     * Filter subscriptions by product
     * @type {Array<string>}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly product?: Array<string>

    /**
     * Return total number of subscriptions
     * @type {boolean}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for subscriptionsPatch operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiSubscriptionsPatchRequest
 */
export interface SubscriptionsApiSubscriptionsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsPatch
     */
    readonly id: string

    /**
     * 
     * @type {SubscriptionUpdate}
     * @memberof SubscriptionsApiSubscriptionsPatch
     */
    readonly subscriptionUpdate?: SubscriptionUpdate
}

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * 
     * @summary Get the list of subscriptions
     * @param {SubscriptionsApiSubscriptionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsGet(requestParameters: SubscriptionsApiSubscriptionsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscriptionsGet(requestParameters.teamId, requestParameters.count, requestParameters.page, requestParameters.q, requestParameters.includeFreeTier, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.endsOrRenewsAfter, requestParameters.endsOrRenewsBefore, requestParameters.stripeOnly, requestParameters.product, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a subscription\'s properties
     * @param {SubscriptionsApiSubscriptionsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsPatch(requestParameters: SubscriptionsApiSubscriptionsPatchRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscriptionsPatch(requestParameters.id, requestParameters.subscriptionUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SubscriptionsGetSortByEnum = {
    StartDate: 'startDate',
    EndOrNextRenewalDate: 'endOrNextRenewalDate'
} as const;
export type SubscriptionsGetSortByEnum = typeof SubscriptionsGetSortByEnum[keyof typeof SubscriptionsGetSortByEnum];
/**
 * @export
 */
export const SubscriptionsGetSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type SubscriptionsGetSortDirectionEnum = typeof SubscriptionsGetSortDirectionEnum[keyof typeof SubscriptionsGetSortDirectionEnum];


/**
 * TeamDetailApi - axios parameter creator
 * @export
 */
export const TeamDetailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If the account is an independent account, the access details for the account are returned. Otherwise, the team\'s access details are returned.
         * @summary Get the access details for the given account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailAccountAccessGet: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('teamDetailAccountAccessGet', 'accountId', accountId)
            const localVarPath = `/team-detail/account-access/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the team\'s subscription and payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/team-detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the team\'s subscription and payment details
         * @param {TeamDetailUpdate} [teamDetailUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailPatch: async (teamDetailUpdate?: TeamDetailUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/team-detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamDetailUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the access given by subscriptions
         * @param {boolean} [refreshUsage] Refreshes usage statistics as well
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailRefreshAccess: async (refreshUsage?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/team-detail/refresh-access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)

            if (refreshUsage !== undefined) {
                localVarQueryParameter['refreshUsage'] = refreshUsage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamDetailApi - functional programming interface
 * @export
 */
export const TeamDetailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamDetailApiAxiosParamCreator(configuration)
    return {
        /**
         * If the account is an independent account, the access details for the account are returned. Otherwise, the team\'s access details are returned.
         * @summary Get the access details for the given account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailAccountAccessGet(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountAccessDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailAccountAccessGet(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamDetailApi.teamDetailAccountAccessGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the team\'s subscription and payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamDetailApi.teamDetailGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the team\'s subscription and payment details
         * @param {TeamDetailUpdate} [teamDetailUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailPatch(teamDetailUpdate?: TeamDetailUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailPatch(teamDetailUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamDetailApi.teamDetailPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the access given by subscriptions
         * @param {boolean} [refreshUsage] Refreshes usage statistics as well
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailRefreshAccess(refreshUsage?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailRefreshAccess(refreshUsage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamDetailApi.teamDetailRefreshAccess']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamDetailApi - factory interface
 * @export
 */
export const TeamDetailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamDetailApiFp(configuration)
    return {
        /**
         * If the account is an independent account, the access details for the account are returned. Otherwise, the team\'s access details are returned.
         * @summary Get the access details for the given account
         * @param {TeamDetailApiTeamDetailAccountAccessGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailAccountAccessGet(requestParameters: TeamDetailApiTeamDetailAccountAccessGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountAccessDetail> {
            return localVarFp.teamDetailAccountAccessGet(requestParameters.accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the team\'s subscription and payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailGet(options?: RawAxiosRequestConfig): AxiosPromise<TeamDetail> {
            return localVarFp.teamDetailGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the team\'s subscription and payment details
         * @param {TeamDetailApiTeamDetailPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailPatch(requestParameters: TeamDetailApiTeamDetailPatchRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.teamDetailPatch(requestParameters.teamDetailUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the access given by subscriptions
         * @param {TeamDetailApiTeamDetailRefreshAccessRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailRefreshAccess(requestParameters: TeamDetailApiTeamDetailRefreshAccessRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.teamDetailRefreshAccess(requestParameters.refreshUsage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for teamDetailAccountAccessGet operation in TeamDetailApi.
 * @export
 * @interface TeamDetailApiTeamDetailAccountAccessGetRequest
 */
export interface TeamDetailApiTeamDetailAccountAccessGetRequest {
    /**
     * 
     * @type {string}
     * @memberof TeamDetailApiTeamDetailAccountAccessGet
     */
    readonly accountId: string
}

/**
 * Request parameters for teamDetailPatch operation in TeamDetailApi.
 * @export
 * @interface TeamDetailApiTeamDetailPatchRequest
 */
export interface TeamDetailApiTeamDetailPatchRequest {
    /**
     * 
     * @type {TeamDetailUpdate}
     * @memberof TeamDetailApiTeamDetailPatch
     */
    readonly teamDetailUpdate?: TeamDetailUpdate
}

/**
 * Request parameters for teamDetailRefreshAccess operation in TeamDetailApi.
 * @export
 * @interface TeamDetailApiTeamDetailRefreshAccessRequest
 */
export interface TeamDetailApiTeamDetailRefreshAccessRequest {
    /**
     * Refreshes usage statistics as well
     * @type {boolean}
     * @memberof TeamDetailApiTeamDetailRefreshAccess
     */
    readonly refreshUsage?: boolean
}

/**
 * TeamDetailApi - object-oriented interface
 * @export
 * @class TeamDetailApi
 * @extends {BaseAPI}
 */
export class TeamDetailApi extends BaseAPI {
    /**
     * If the account is an independent account, the access details for the account are returned. Otherwise, the team\'s access details are returned.
     * @summary Get the access details for the given account
     * @param {TeamDetailApiTeamDetailAccountAccessGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailAccountAccessGet(requestParameters: TeamDetailApiTeamDetailAccountAccessGetRequest, options?: RawAxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailAccountAccessGet(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the team\'s subscription and payment details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailGet(options?: RawAxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the team\'s subscription and payment details
     * @param {TeamDetailApiTeamDetailPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailPatch(requestParameters: TeamDetailApiTeamDetailPatchRequest = {}, options?: RawAxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailPatch(requestParameters.teamDetailUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
     * @summary Refreshes the access given by subscriptions
     * @param {TeamDetailApiTeamDetailRefreshAccessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailRefreshAccess(requestParameters: TeamDetailApiTeamDetailRefreshAccessRequest = {}, options?: RawAxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailRefreshAccess(requestParameters.refreshUsage, options).then((request) => request(this.axios, this.basePath));
    }
}



