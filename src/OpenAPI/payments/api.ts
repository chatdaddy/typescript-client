const BASE_PATH = "https://api-payments.chatdaddy.tech".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Payments Service
 * Manage all payment/subscription related operations
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: info@chatdaddy.tech
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * 
     * @type {Array<Feature>}
     * @memberof Access
     */
    'features': Array<Feature>;
    /**
     * 
     * @type {LimitationMap}
     * @memberof Access
     */
    'limits': LimitationMap;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Access
     */
    'lastExpiryOrRenewalDate'?: string;
}
/**
 * 
 * @export
 * @interface AccountAccess
 */
export interface AccountAccess {
    /**
     * 
     * @type {Array<AccountFeature>}
     * @memberof AccountAccess
     */
    'features': Array<AccountFeature>;
    /**
     * 
     * @type {AccountLimitationMap}
     * @memberof AccountAccess
     */
    'limits': AccountLimitationMap;
}
/**
 * 
 * @export
 * @interface AccountAccessDetail
 */
export interface AccountAccessDetail {
    /**
     * 
     * @type {AccountAccess}
     * @memberof AccountAccessDetail
     */
    'access': AccountAccess;
    /**
     * 
     * @type {LimitationMap}
     * @memberof AccountAccessDetail
     */
    'usage': LimitationMap;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AccountFeature = {
    TeamInbox: 'team-inbox',
    CustomMarketingMessage: 'custom-marketing-message',
    ChatHistorySync: 'chat-history-sync'
} as const;

export type AccountFeature = typeof AccountFeature[keyof typeof AccountFeature];


/**
 * 
 * @export
 * @interface AccountLimitationMap
 */
export interface AccountLimitationMap {
    /**
     * The number of messages that can be sent per month.
     * @type {number}
     * @memberof AccountLimitationMap
     */
    'messages'?: number;
}
/**
 * 
 * @export
 * @interface AmountWithCurrency
 */
export interface AmountWithCurrency {
    /**
     * The amount in cents. So 100 is $1.00
     * @type {number}
     * @memberof AmountWithCurrency
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof AmountWithCurrency
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface AutoChargeProduct
 */
export interface AutoChargeProduct {
    /**
     * 
     * @type {LimitedItem}
     * @memberof AutoChargeProduct
     */
    'item': LimitedItem;
    /**
     * 
     * @type {string}
     * @memberof AutoChargeProduct
     */
    'stripePriceId': string;
}


/**
 * 
 * @export
 * @interface AutoChargeProductSet
 */
export interface AutoChargeProductSet {
    /**
     * 
     * @type {LimitedItem}
     * @memberof AutoChargeProductSet
     */
    'item': LimitedItem;
    /**
     * If null, auto charge for this item is disabled. Otherwise, this is the stripe price ID to charge for this item.
     * @type {string}
     * @memberof AutoChargeProductSet
     */
    'stripePriceId': string | null;
}


/**
 * 
 * @export
 * @interface AutoChargeProductsGet200Response
 */
export interface AutoChargeProductsGet200Response {
    /**
     * 
     * @type {Array<AutoChargeProduct>}
     * @memberof AutoChargeProductsGet200Response
     */
    'items': Array<AutoChargeProduct>;
}
/**
 * 
 * @export
 * @interface AutoChargeProductsPrepare200Response
 */
export interface AutoChargeProductsPrepare200Response {
    /**
     * 
     * @type {Access}
     * @memberof AutoChargeProductsPrepare200Response
     */
    'access': Access;
    /**
     * 
     * @type {LimitationMap}
     * @memberof AutoChargeProductsPrepare200Response
     */
    'usage': LimitationMap;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AutoRenewalPeriod = {
    Quarter: 'quarter',
    Year: 'year'
} as const;

export type AutoRenewalPeriod = typeof AutoRenewalPeriod[keyof typeof AutoRenewalPeriod];


/**
 * 
 * @export
 * @enum {string}
 */

export const BillingPeriod = {
    Month: 'month',
    Quarter: 'quarter',
    Year: 'year'
} as const;

export type BillingPeriod = typeof BillingPeriod[keyof typeof BillingPeriod];


/**
 * 
 * @export
 * @interface BillingSessionPost200Response
 */
export interface BillingSessionPost200Response {
    /**
     * 
     * @type {string}
     * @memberof BillingSessionPost200Response
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof BillingSessionPost200Response
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface CheckoutCreateOptions
 */
export interface CheckoutCreateOptions {
    /**
     * 
     * @type {CheckoutCreateOptionsCallbackUrls}
     * @memberof CheckoutCreateOptions
     */
    'callbackUrls': CheckoutCreateOptionsCallbackUrls;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateOptions
     */
    'coupon'?: string;
    /**
     * 
     * @type {Array<ProductsSelectionInner>}
     * @memberof CheckoutCreateOptions
     */
    'products': Array<ProductsSelectionInner>;
    /**
     * Add extra days to a subscription. Can only set using admin access
     * @type {number}
     * @memberof CheckoutCreateOptions
     */
    'extraDays'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CheckoutCreateOptions
     */
    'disableAutoRenew'?: boolean;
}
/**
 * 
 * @export
 * @interface CheckoutCreateOptionsCallbackUrls
 */
export interface CheckoutCreateOptionsCallbackUrls {
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateOptionsCallbackUrls
     */
    'success': string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateOptionsCallbackUrls
     */
    'failure': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CountryTier = {
    Tier1: 'tier1',
    Tier2: 'tier2',
    Tier3: 'tier3',
    Tier4: 'tier4'
} as const;

export type CountryTier = typeof CountryTier[keyof typeof CountryTier];


/**
 * 
 * @export
 * @interface CouponCodeCreateOptions
 */
export interface CouponCodeCreateOptions {
    /**
     * 
     * @type {string}
     * @memberof CouponCodeCreateOptions
     */
    'category': string;
    /**
     * limit coupon code to products
     * @type {Array<string>}
     * @memberof CouponCodeCreateOptions
     */
    'products'?: Array<string>;
    /**
     * set free trial. Can only set using admin access
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'freeTrialDays'?: number;
    /**
     * Add extra days to a subscription. Can only set using admin access
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'extraDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'discountPercentageOff': number;
}
/**
 * 
 * @export
 * @interface CouponsPost200Response
 */
export interface CouponsPost200Response {
    /**
     * 
     * @type {string}
     * @memberof CouponsPost200Response
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface CreditAutoRenewalUpdate
 */
export interface CreditAutoRenewalUpdate {
    /**
     * 
     * @type {AutoRenewalPeriod}
     * @memberof CreditAutoRenewalUpdate
     */
    'period': AutoRenewalPeriod;
    /**
     * 
     * @type {CreditUnitsPurchaseOpts}
     * @memberof CreditAutoRenewalUpdate
     */
    'units': CreditUnitsPurchaseOpts;
    /**
     * 
     * @type {MiscBillingOptions}
     * @memberof CreditAutoRenewalUpdate
     */
    'options'?: MiscBillingOptions;
}


/**
 * @type CreditBalanceEffectType
 * All the ways a team\'s credit balance can be affected.
 * @export
 */
export type CreditBalanceEffectType = CreditConsumptionType | CreditGainType | RecurringCreditConsumptionType;

/**
 * 
 * @export
 * @interface CreditCanConsumeResponse
 */
export interface CreditCanConsumeResponse {
    /**
     * 
     * @type {Array<CreditUnlockType>}
     * @memberof CreditCanConsumeResponse
     */
    'unlocks': Array<CreditUnlockType>;
}
/**
 * 
 * @export
 * @interface CreditConsumptionCreate
 */
export interface CreditConsumptionCreate {
    /**
     * 
     * @type {CreditConsumptionType}
     * @memberof CreditConsumptionCreate
     */
    'type': CreditConsumptionType;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CreditConsumptionCreate
     */
    'createdAt'?: string;
    /**
     * The ID of the object that was consumed. (createdAt, objectId) will be enforced to be unique.
     * @type {string}
     * @memberof CreditConsumptionCreate
     */
    'objectId': string;
    /**
     * The ID of a team
     * @type {string}
     * @memberof CreditConsumptionCreate
     */
    'teamId': string;
    /**
     * Multiplier for the number of units to consume of this consumption type. For eg. if multiplier is 2, and each consumption of this type consumes 5 units, then 10 units will be consumed.
     * @type {number}
     * @memberof CreditConsumptionCreate
     */
    'multiplier'?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CreditConsumptionCreate
     */
    'metadata'?: { [key: string]: any; };
}


/**
 * 
 * @export
 * @interface CreditConsumptionPostRequest
 */
export interface CreditConsumptionPostRequest {
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof CreditConsumptionPostRequest
     */
    'customerId': string;
    /**
     * 
     * @type {Array<CreditConsumptionCreate>}
     * @memberof CreditConsumptionPostRequest
     */
    'items': Array<CreditConsumptionCreate>;
}
/**
 * 
 * @export
 * @interface CreditConsumptionRecordData
 */
export interface CreditConsumptionRecordData {
    /**
     * 
     * @type {CreditConsumptionRecordDataType}
     * @memberof CreditConsumptionRecordData
     */
    'type': CreditConsumptionRecordDataType;
    /**
     * 
     * @type {string}
     * @memberof CreditConsumptionRecordData
     */
    'teamId'?: string;
    /**
     * ID of a recurring credit consumption
     * @type {string}
     * @memberof CreditConsumptionRecordData
     */
    'recurringConsumptionId'?: string;
}
/**
 * @type CreditConsumptionRecordDataType
 * @export
 */
export type CreditConsumptionRecordDataType = CreditConsumptionType | RecurringCreditConsumptionType;

/**
 * 
 * @export
 * @interface CreditConsumptionTier
 */
export interface CreditConsumptionTier {
    /**
     * Cost per unit of consumption
     * @type {number}
     * @memberof CreditConsumptionTier
     */
    'perUnitCost': number;
    /**
     * Maximum number of items that can be consumed before the next tier is used. This limit is inclusive as well. Undefined means no cap.
     * @type {number}
     * @memberof CreditConsumptionTier
     */
    'maxItems'?: number;
}
/**
 * Enum of all the types of single-use credit consumption. This is used to track the usage of credits. Category of consumptions are separated by a slash.
 * @export
 * @enum {string}
 */

export const CreditConsumptionType = {
    MessageSentWa: 'message_sent/wa',
    MessageSentTiktok: 'message_sent/tiktok',
    MessageSentWaBusinessApi: 'message_sent/wa-business-api',
    MessageSentMessenger: 'message_sent/messenger',
    MessageSentMail: 'message_sent/mail',
    IntegrationNotification: 'integration/notification',
    IntegrationPayment: 'integration/payment',
    Broadcast: 'broadcast',
    MsgFlow: 'msg_flow',
    KeywordReply: 'keyword_reply',
    Tag: 'tag',
    CustomField: 'custom_field',
    Dashboard: 'dashboard',
    Product: 'product',
    AiChatbot: 'ai_chatbot',
    Consultation1h: 'consultation/1h',
    AdminDiscretionary: 'admin/discretionary',
    AdminRefund: 'admin/refund',
    AdminExpiredCreditGain: 'admin/expired_credit_gain'
} as const;

export type CreditConsumptionType = typeof CreditConsumptionType[keyof typeof CreditConsumptionType];


/**
 * 
 * @export
 * @interface CreditCustomer
 */
export interface CreditCustomer {
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof CreditCustomer
     */
    'id': string;
    /**
     * Total number of units available for consumption
     * @type {number}
     * @memberof CreditCustomer
     */
    'unitsAvailable': number;
    /**
     * Number of units consumed per period.
     * @type {number}
     * @memberof CreditCustomer
     */
    'recurringConsumptionUnits': number;
    /**
     * List of features that have been unlocked.
     * @type {Array<CreditUnlockType>}
     * @memberof CreditCustomer
     */
    'unlockedFeatures': Array<CreditUnlockType>;
    /**
     * 
     * @type {CustomerAutoRenewal}
     * @memberof CreditCustomer
     */
    'autoRenewal'?: CustomerAutoRenewal;
    /**
     * 
     * @type {CountryTier}
     * @memberof CreditCustomer
     */
    'tier': CountryTier;
    /**
     * 
     * @type {CreditLevelStatus}
     * @memberof CreditCustomer
     */
    'creditLevelStatus'?: CreditLevelStatus | null;
    /**
     * The partnership to use for this customer. This is only used if the customer is new.
     * @type {string}
     * @memberof CreditCustomer
     */
    'partnership'?: string;
    /**
     * Region from which the customer is from.
     * @type {string}
     * @memberof CreditCustomer
     */
    'region': string;
    /**
     * ID of the Stripe account that was created for this customer.
     * @type {string}
     * @memberof CreditCustomer
     */
    'stripeAccountId'?: string;
}


/**
 * 
 * @export
 * @interface CreditCustomerAllOf
 */
export interface CreditCustomerAllOf {
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof CreditCustomerAllOf
     */
    'id': string;
    /**
     * Total number of units available for consumption
     * @type {number}
     * @memberof CreditCustomerAllOf
     */
    'unitsAvailable': number;
    /**
     * Number of units consumed per period.
     * @type {number}
     * @memberof CreditCustomerAllOf
     */
    'recurringConsumptionUnits': number;
    /**
     * List of features that have been unlocked.
     * @type {Array<CreditUnlockType>}
     * @memberof CreditCustomerAllOf
     */
    'unlockedFeatures': Array<CreditUnlockType>;
    /**
     * 
     * @type {CustomerAutoRenewal}
     * @memberof CreditCustomerAllOf
     */
    'autoRenewal'?: CustomerAutoRenewal;
    /**
     * 
     * @type {CountryTier}
     * @memberof CreditCustomerAllOf
     */
    'tier': CountryTier;
    /**
     * 
     * @type {CreditLevelStatus}
     * @memberof CreditCustomerAllOf
     */
    'creditLevelStatus'?: CreditLevelStatus | null;
}


/**
 * 
 * @export
 * @interface CreditCustomerMetadata
 */
export interface CreditCustomerMetadata {
    /**
     * The partnership to use for this customer. This is only used if the customer is new.
     * @type {string}
     * @memberof CreditCustomerMetadata
     */
    'partnership'?: string;
    /**
     * Region from which the customer is from.
     * @type {string}
     * @memberof CreditCustomerMetadata
     */
    'region': string;
    /**
     * ID of the Stripe account that was created for this customer.
     * @type {string}
     * @memberof CreditCustomerMetadata
     */
    'stripeAccountId'?: string;
}
/**
 * 
 * @export
 * @interface CreditCustomerPost
 */
export interface CreditCustomerPost {
    /**
     * 
     * @type {StripeCustomerCreate}
     * @memberof CreditCustomerPost
     */
    'stripeCustomer': StripeCustomerCreate;
    /**
     * 
     * @type {CreditCustomerMetadata}
     * @memberof CreditCustomerPost
     */
    'metadata': CreditCustomerMetadata;
    /**
     * The referral code to use for this customer. This is only used if the customer is new.
     * @type {string}
     * @memberof CreditCustomerPost
     */
    'referralCode'?: string;
}
/**
 * 
 * @export
 * @interface CreditGain
 */
export interface CreditGain {
    /**
     * ID of a credit gain
     * @type {string}
     * @memberof CreditGain
     */
    'id': string;
    /**
     * 
     * @type {CreditGainType}
     * @memberof CreditGain
     */
    'type': CreditGainType;
    /**
     * Number of units gained
     * @type {number}
     * @memberof CreditGain
     */
    'units': number;
    /**
     * Number of units left in this gain. Credits are consumed bottom up, i.e. credits from the oldest gain are consumed first.
     * @type {number}
     * @memberof CreditGain
     */
    'unitsLeft': number;
    /**
     * 
     * @type {CreditGainStatus}
     * @memberof CreditGain
     */
    'status': CreditGainStatus;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CreditGain
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreditGain
     */
    'expiresAt'?: string;
    /**
     * The ID of a user
     * @type {string}
     * @memberof CreditGain
     */
    'doneBy': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CreditGain
     */
    'metadata'?: { [key: string]: any; };
    /**
     * 
     * @type {StripeMetadata}
     * @memberof CreditGain
     */
    'stripe'?: StripeMetadata;
    /**
     * 
     * @type {FloatAmountWithCurrency}
     * @memberof CreditGain
     */
    'amountPaid': FloatAmountWithCurrency;
}


/**
 * 
 * @export
 * @interface CreditGainCreate
 */
export interface CreditGainCreate {
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof CreditGainCreate
     */
    'customerId': string;
    /**
     * Number of units gained
     * @type {number}
     * @memberof CreditGainCreate
     */
    'units': number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CreditGainCreate
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface CreditGainRecordData
 */
export interface CreditGainRecordData {
    /**
     * 
     * @type {CreditGainType}
     * @memberof CreditGainRecordData
     */
    'type': CreditGainType;
    /**
     * 
     * @type {CreditGainRecordDataGain}
     * @memberof CreditGainRecordData
     */
    'gain'?: CreditGainRecordDataGain;
}


/**
 * 
 * @export
 * @interface CreditGainRecordDataGain
 */
export interface CreditGainRecordDataGain {
    /**
     * 
     * @type {StripeMetadata}
     * @memberof CreditGainRecordDataGain
     */
    'stripe'?: StripeMetadata;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CreditGainStatus = {
    Paid: 'paid',
    PendingPayment: 'pending_payment',
    Expired: 'expired'
} as const;

export type CreditGainStatus = typeof CreditGainStatus[keyof typeof CreditGainStatus];


/**
 * Different ways to categorise credits being added to the team\'s account.
 * @export
 * @enum {string}
 */

export const CreditGainType = {
    AutoRenewal: 'auto_renewal',
    TopUp: 'top_up',
    Bonus: 'bonus'
} as const;

export type CreditGainType = typeof CreditGainType[keyof typeof CreditGainType];


/**
 * 
 * @export
 * @interface CreditGainsGet200Response
 */
export interface CreditGainsGet200Response {
    /**
     * 
     * @type {Array<CreditGain>}
     * @memberof CreditGainsGet200Response
     */
    'items': Array<CreditGain>;
    /**
     * 
     * @type {string}
     * @memberof CreditGainsGet200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditGainsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CreditLevelStatus = {
    Danger: 'danger',
    Warning: 'warning'
} as const;

export type CreditLevelStatus = typeof CreditLevelStatus[keyof typeof CreditLevelStatus];


/**
 * @type CreditPreference
 * @export
 */
export type CreditPreference = MiscPreference | NotificationPreference | PurchaseTierPreference | RecurringConsumptionPreference | SingleConsumptionPreference | StripePreference | UnlockPreference;

/**
 * A tier of credits that can be purchased. Credits can only be purchased in multiples of the step size. The tier is to be used exactly as is for top-up purchases, and must be  multiplied by the number of months for recurring purchases.
 * @export
 * @interface CreditPurchaseTier
 */
export interface CreditPurchaseTier {
    /**
     * Step size for the tier. This is the minimum number of credits that can be purchased at once in this tier. This will increase with tier
     * @type {number}
     * @memberof CreditPurchaseTier
     */
    'step': number;
    /**
     * Maximum number of units to purchase. This limit is inclusive. Undefined means no cap. If cap is 100 & if the user purchases 101 credits, they\'ll move to the next tier.
     * @type {number}
     * @memberof CreditPurchaseTier
     */
    'maxUnits'?: number;
}
/**
 * 
 * @export
 * @interface CreditStripePrice
 */
export interface CreditStripePrice {
    /**
     * Cost per credit in terms of fiat currency.
     * @type {number}
     * @memberof CreditStripePrice
     */
    'costPerCredit': number;
    /**
     * ISO country code for currency
     * @type {string}
     * @memberof CreditStripePrice
     */
    'currency': string;
    /**
     * 
     * @type {CreditStripePricePriceIds}
     * @memberof CreditStripePrice
     */
    'priceIds': CreditStripePricePriceIds;
}
/**
 * 
 * @export
 * @interface CreditStripePricePriceIds
 */
export interface CreditStripePricePriceIds {
    /**
     * The ID of the price in Stripe. This is used to identify the price in Stripe. For credit billing, ensure that the price ID has the following prefixs for the respective billing types: - recurring: auto_renew_credit - top_up: top_up_credit - bonus: bonus_credit
     * @type {string}
     * @memberof CreditStripePricePriceIds
     */
    'quarter': string;
    /**
     * The ID of the price in Stripe. This is used to identify the price in Stripe. For credit billing, ensure that the price ID has the following prefixs for the respective billing types: - recurring: auto_renew_credit - top_up: top_up_credit - bonus: bonus_credit
     * @type {string}
     * @memberof CreditStripePricePriceIds
     */
    'year': string;
    /**
     * The ID of the price in Stripe. This is used to identify the price in Stripe. For credit billing, ensure that the price ID has the following prefixs for the respective billing types: - recurring: auto_renew_credit - top_up: top_up_credit - bonus: bonus_credit
     * @type {string}
     * @memberof CreditStripePricePriceIds
     */
    'oneTime': string;
}
/**
 * 
 * @export
 * @interface CreditTopUpOptions
 */
export interface CreditTopUpOptions {
    /**
     * 
     * @type {CreditUnitsPurchaseOpts}
     * @memberof CreditTopUpOptions
     */
    'units': CreditUnitsPurchaseOpts;
    /**
     * 
     * @type {MiscBillingOptions}
     * @memberof CreditTopUpOptions
     */
    'options'?: MiscBillingOptions;
}
/**
 * 
 * @export
 * @interface CreditTransactionBase
 */
export interface CreditTransactionBase {
    /**
     * ID of a credit consumption. IDs are chronological.
     * @type {string}
     * @memberof CreditTransactionBase
     */
    'id': string;
    /**
     * Number of units consumed/credited. Positive for credit, negative for consumption.
     * @type {number}
     * @memberof CreditTransactionBase
     */
    'units': number;
    /**
     * The ID of a user
     * @type {string}
     * @memberof CreditTransactionBase
     */
    'doneBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CreditTransactionBase
     */
    'createdAt': string;
    /**
     * The ID of the object that was consumed, or the ID of the gain that created this tx record. (createdAt, objectId) will be enforced to be unique.
     * @type {string}
     * @memberof CreditTransactionBase
     */
    'objectId': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CreditTransactionBase
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * A record of a credit transaction. This could be a gain or a consumption record & is immutable.
 * @export
 * @interface CreditTransactionRecord
 */
export interface CreditTransactionRecord {
    /**
     * ID of a credit consumption. IDs are chronological.
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'id': string;
    /**
     * Number of units consumed/credited. Positive for credit, negative for consumption.
     * @type {number}
     * @memberof CreditTransactionRecord
     */
    'units': number;
    /**
     * The ID of a user
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'doneBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'createdAt': string;
    /**
     * The ID of the object that was consumed, or the ID of the gain that created this tx record. (createdAt, objectId) will be enforced to be unique.
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'objectId': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CreditTransactionRecord
     */
    'metadata'?: { [key: string]: any; };
    /**
     * 
     * @type {CreditConsumptionRecordDataType}
     * @memberof CreditTransactionRecord
     */
    'type': CreditConsumptionRecordDataType;
    /**
     * 
     * @type {CreditGainRecordDataGain}
     * @memberof CreditTransactionRecord
     */
    'gain'?: CreditGainRecordDataGain;
    /**
     * 
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'teamId'?: string;
    /**
     * ID of a recurring credit consumption
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'recurringConsumptionId'?: string;
}
/**
 * 
 * @export
 * @interface CreditTxsGet200Response
 */
export interface CreditTxsGet200Response {
    /**
     * 
     * @type {Array<CreditTransactionRecord>}
     * @memberof CreditTxsGet200Response
     */
    'items': Array<CreditTransactionRecord>;
    /**
     * 
     * @type {string}
     * @memberof CreditTxsGet200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditTxsGet200Response
     */
    'total'?: number;
}
/**
 * Options for purchasing credits. The total units are computed as the maxUnits of the previous tier from the specified tier, plus the step size of the specified tier multiplied by the number of steps specified. Essentially:   totalUnits = prev(maxUnits) + current(step) * steps
 * @export
 * @interface CreditUnitsPurchaseOpts
 */
export interface CreditUnitsPurchaseOpts {
    /**
     * 
     * @type {string}
     * @memberof CreditUnitsPurchaseOpts
     */
    'tier': string;
    /**
     * 
     * @type {number}
     * @memberof CreditUnitsPurchaseOpts
     */
    'steps': number;
}
/**
 * 
 * @export
 * @interface CreditUnlockMetadata
 */
export interface CreditUnlockMetadata {
    /**
     * Minimum number of auto renewing credits required to unlock this feature. Period of consumption is not considered.
     * @type {number}
     * @memberof CreditUnlockMetadata
     */
    'minRecurringCredits': number;
}
/**
 * Enum of all the types of credit unlocks. These are unlocked at a certain auto-renewal credit threshhold.
 * @export
 * @enum {string}
 */

export const CreditUnlockType = {
    ExportMsgFlow: 'export/msg_flow',
    ExportContacts: 'export/contacts',
    ExportTags: 'export/tags',
    ExportCustomFields: 'export/custom_fields',
    ExportProducts: 'export/products',
    RemoveMarketingMessage: 'remove_marketing_message'
} as const;

export type CreditUnlockType = typeof CreditUnlockType[keyof typeof CreditUnlockType];


/**
 * 
 * @export
 * @interface CreditsCustomerPost200Response
 */
export interface CreditsCustomerPost200Response {
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof CreditsCustomerPost200Response
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface CreditsPreferences
 */
export interface CreditsPreferences {
    /**
     * 
     * @type {Array<CreditPreference>}
     * @memberof CreditsPreferences
     */
    'items': Array<CreditPreference>;
}
/**
 * 
 * @export
 * @interface CreditsPreferencesPostRequest
 */
export interface CreditsPreferencesPostRequest {
    /**
     * 
     * @type {Array<CreditPreference>}
     * @memberof CreditsPreferencesPostRequest
     */
    'items': Array<CreditPreference>;
}
/**
 * 
 * @export
 * @interface CustomerAutoRenewal
 */
export interface CustomerAutoRenewal {
    /**
     * The ID of the subscription that was created for this credit transaction.
     * @type {string}
     * @memberof CustomerAutoRenewal
     */
    'subscriptionId': string;
    /**
     * Number of units consumed per period
     * @type {number}
     * @memberof CustomerAutoRenewal
     */
    'units': number;
    /**
     * Number of bonus units
     * @type {number}
     * @memberof CustomerAutoRenewal
     */
    'bonusUnits': number;
    /**
     * 
     * @type {AutoRenewalPeriod}
     * @memberof CustomerAutoRenewal
     */
    'period': AutoRenewalPeriod;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CustomerAutoRenewal
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CustomerAutoRenewal
     */
    'nextChargeAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerAutoRenewal
     */
    'status': CustomerAutoRenewalStatusEnum;
}

export const CustomerAutoRenewalStatusEnum = {
    Active: 'active',
    Cancelled: 'cancelled',
    Overdue: 'overdue'
} as const;

export type CustomerAutoRenewalStatusEnum = typeof CustomerAutoRenewalStatusEnum[keyof typeof CustomerAutoRenewalStatusEnum];

/**
 * 
 * @export
 * @interface DateRange
 */
interface DateRange {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DateRange
     */
    'from': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DateRange
     */
    'to': string;
}
/**
 * List of features
 * @export
 * @enum {string}
 */

export const Feature = {
    TeamInbox: 'team-inbox',
    ChatHistorySync: 'chat-history-sync',
    CustomMarketingMessage: 'custom-marketing-message',
    Audience: 'audience',
    Notifications: 'notifications',
    KeywordReply: 'keyword-reply',
    Broadcast: 'broadcast',
    MessageFlows: 'message-flows',
    Shop: 'shop',
    Autocomplete: 'autocomplete'
} as const;

export type Feature = typeof Feature[keyof typeof Feature];


/**
 * @type FeatureConfig
 * @export
 */
export type FeatureConfig = Array<Feature> | string;

/**
 * 
 * @export
 * @interface FloatAmountWithCurrency
 */
export interface FloatAmountWithCurrency {
    /**
     * The amount in dollar value
     * @type {number}
     * @memberof FloatAmountWithCurrency
     */
    'amount': number;
    /**
     * ISO country code for currency in lowercase
     * @type {string}
     * @memberof FloatAmountWithCurrency
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface GetPartner200Response
 */
export interface GetPartner200Response {
    /**
     * 
     * @type {string}
     * @memberof GetPartner200Response
     */
    'partnerAdmin'?: string;
}
/**
 * 
 * @export
 * @interface LegacyCanConsumeOpts
 */
export interface LegacyCanConsumeOpts {
    /**
     * 
     * @type {LimitedItem}
     * @memberof LegacyCanConsumeOpts
     */
    'item': LimitedItem;
    /**
     * 
     * @type {string}
     * @memberof LegacyCanConsumeOpts
     */
    'accountId'?: string;
}


/**
 * 
 * @export
 * @interface LimitationMap
 */
export interface LimitationMap {
    /**
     * The number of messages that can be sent per month. This is reset every month.
     * @type {number}
     * @memberof LimitationMap
     */
    'messages'?: number;
    /**
     * The number of team members allowed in the team. This usage carries over to the next month.
     * @type {number}
     * @memberof LimitationMap
     */
    'seats'?: number;
    /**
     * The number of Inbox accounts allowed in the team. This usage carries over to the next month.
     * @type {number}
     * @memberof LimitationMap
     */
    'fullAccount'?: number;
    /**
     * The number of API accounts used on a per-day basis. This is reset every month.
     * @type {number}
     * @memberof LimitationMap
     */
    'limitedMsgNoHistoryAccountDay'?: number;
    /**
     * The number of API accounts used on a per-day basis. This is reset every month.
     * @type {number}
     * @memberof LimitationMap
     */
    'unlimitedMsgHistoryAccountDay'?: number;
}
/**
 * List of items that are limited in quantity
 * @export
 * @enum {string}
 */

export const LimitedItem = {
    Messages: 'messages',
    Seats: 'seats',
    FullAccount: 'fullAccount',
    LimitedMsgNoHistoryAccountDay: 'limitedMsgNoHistoryAccountDay',
    UnlimitedMsgHistoryAccountDay: 'unlimitedMsgHistoryAccountDay'
} as const;

export type LimitedItem = typeof LimitedItem[keyof typeof LimitedItem];


/**
 * 
 * @export
 * @interface MiscBillingOptions
 */
export interface MiscBillingOptions {
    /**
     * The promotion code to use for this purchase.
     * @type {string}
     * @memberof MiscBillingOptions
     */
    'promotionCode'?: string;
}
/**
 * 
 * @export
 * @interface MiscPreference
 */
export interface MiscPreference {
    /**
     * 
     * @type {string}
     * @memberof MiscPreference
     */
    'category': MiscPreferenceCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof MiscPreference
     */
    'key': MiscPreferenceKeyEnum;
    /**
     * 
     * @type {MiscPreferenceData}
     * @memberof MiscPreference
     */
    'data': MiscPreferenceData;
}

export const MiscPreferenceCategoryEnum = {
    Misc: 'misc'
} as const;

export type MiscPreferenceCategoryEnum = typeof MiscPreferenceCategoryEnum[keyof typeof MiscPreferenceCategoryEnum];
export const MiscPreferenceKeyEnum = {
    NewSignupCredits: 'newSignupCredits',
    ExpiryIntervalMonths: 'expiryIntervalMonths',
    YearlyBonusCreditsPercentage: 'yearlyBonusCreditsPercentage'
} as const;

export type MiscPreferenceKeyEnum = typeof MiscPreferenceKeyEnum[keyof typeof MiscPreferenceKeyEnum];

/**
 * 
 * @export
 * @interface MiscPreferenceData
 */
export interface MiscPreferenceData {
    /**
     * 
     * @type {number}
     * @memberof MiscPreferenceData
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface NotificationPreference
 */
export interface NotificationPreference {
    /**
     * 
     * @type {string}
     * @memberof NotificationPreference
     */
    'category': NotificationPreferenceCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof NotificationPreference
     */
    'key': NotificationPreferenceKeyEnum;
    /**
     * 
     * @type {NotificationPreferenceData}
     * @memberof NotificationPreference
     */
    'data': NotificationPreferenceData;
}

export const NotificationPreferenceCategoryEnum = {
    Notification: 'notification'
} as const;

export type NotificationPreferenceCategoryEnum = typeof NotificationPreferenceCategoryEnum[keyof typeof NotificationPreferenceCategoryEnum];
export const NotificationPreferenceKeyEnum = {
    Subscribed: 'subscribed',
    Unsubscribed: 'unsubscribed'
} as const;

export type NotificationPreferenceKeyEnum = typeof NotificationPreferenceKeyEnum[keyof typeof NotificationPreferenceKeyEnum];

/**
 * Map describing threshholds for notifications. The threshhold for subscribed users is in % of their recurring credits. The threshhold for unsubscribed users is in absolute credits.
 * @export
 * @interface NotificationPreferenceData
 */
export interface NotificationPreferenceData {
    /**
     * 
     * @type {number}
     * @memberof NotificationPreferenceData
     */
    'danger': number;
    /**
     * 
     * @type {number}
     * @memberof NotificationPreferenceData
     */
    'warning': number;
}
/**
 * Object which stores referral code details
 * @export
 * @interface PartnerReferral
 */
export interface PartnerReferral {
    /**
     * referralCode string; ID for the code
     * @type {string}
     * @memberof PartnerReferral
     */
    'referralCode': string;
    /**
     * ID of the stripe price, the usage of this referral code will give access to
     * @type {string}
     * @memberof PartnerReferral
     */
    'stripePriceId': string | null;
    /**
     * 
     * @type {StripePrice}
     * @memberof PartnerReferral
     */
    'stripePrice'?: StripePrice;
    /**
     * teamId of partnerAdmin associated with the referralCode
     * @type {string}
     * @memberof PartnerReferral
     */
    'partnerAdminTeam': string;
    /**
     * partnerAdmin of team associated with the referralCode
     * @type {string}
     * @memberof PartnerReferral
     */
    'partnerAdmin': string;
    /**
     * Time the product can be used for in days
     * @type {number}
     * @memberof PartnerReferral
     */
    'usagePeriodDays': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PartnerReferral
     */
    'referralCodeExpiry'?: string;
    /**
     * userId of creator of the code
     * @type {string}
     * @memberof PartnerReferral
     */
    'createdBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PartnerReferral
     */
    'createdAt': string;
    /**
     * number of credits to be given when the referral code is used
     * @type {number}
     * @memberof PartnerReferral
     */
    'credits'?: number;
}
/**
 * options to generate partnerReferral
 * @export
 * @interface PartnerReferralCreateOptions
 */
export interface PartnerReferralCreateOptions {
    /**
     * ID of the product that\'ll be given for free when the referral code is used
     * @type {string}
     * @memberof PartnerReferralCreateOptions
     */
    'stripePriceId': string | null;
    /**
     * time the product can be used for in days
     * @type {number}
     * @memberof PartnerReferralCreateOptions
     */
    'usagePeriodDays': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PartnerReferralCreateOptions
     */
    'referralCodeExpiry'?: string;
    /**
     * a string to be appended to the generated referral code
     * @type {string}
     * @memberof PartnerReferralCreateOptions
     */
    'includeInReferralCode'?: string;
    /**
     * number of credits to be given when the referral code is used
     * @type {number}
     * @memberof PartnerReferralCreateOptions
     */
    'credits'?: number;
}
/**
 * 
 * @export
 * @interface PartnerReferralsGet200Response
 */
export interface PartnerReferralsGet200Response {
    /**
     * 
     * @type {Array<PartnerReferral>}
     * @memberof PartnerReferralsGet200Response
     */
    'items': Array<PartnerReferral>;
    /**
     * 
     * @type {number}
     * @memberof PartnerReferralsGet200Response
     */
    'nextPageCursor'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartnerReferralsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface PartnerReferralsPost200Response
 */
export interface PartnerReferralsPost200Response {
    /**
     * 
     * @type {string}
     * @memberof PartnerReferralsPost200Response
     */
    'referralCode': string;
}
/**
 * 
 * @export
 * @interface PaymentData
 */
export interface PaymentData {
    /**
     * 
     * @type {string}
     * @memberof PaymentData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentData
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {AmountWithCurrency}
     * @memberof PaymentData
     */
    'amount': AmountWithCurrency;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PaymentData
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface PaymentRequest
 */
export interface PaymentRequest {
    /**
     * URL to pay for the credits. If empty, the payment has already been made.
     * @type {string}
     * @memberof PaymentRequest
     */
    'paymentUrl': string;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * The ID of a product
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * 
     * @type {ProductAccess}
     * @memberof Product
     */
    'access': ProductAccess;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Product
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Product
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<StripePrice>}
     * @memberof Product
     */
    'stripePrices'?: Array<StripePrice>;
}
/**
 * 
 * @export
 * @interface ProductAccess
 */
export interface ProductAccess {
    /**
     * 
     * @type {FeatureConfig}
     * @memberof ProductAccess
     */
    'features': FeatureConfig;
    /**
     * 
     * @type {LimitationMap}
     * @memberof ProductAccess
     */
    'limits': LimitationMap;
}
/**
 * 
 * @export
 * @interface ProductCreate
 */
export interface ProductCreate {
    /**
     * 
     * @type {string}
     * @memberof ProductCreate
     */
    'name': string;
    /**
     * 
     * @type {ProductAccess}
     * @memberof ProductCreate
     */
    'access': ProductAccess;
}
/**
 * 
 * @export
 * @interface ProductUpdate
 */
export interface ProductUpdate {
    /**
     * 
     * @type {ProductAccess}
     * @memberof ProductUpdate
     */
    'access'?: ProductAccess;
    /**
     * Attach/detach some stripe price IDs
     * @type {Array<StripePriceAttachmentUpdate>}
     * @memberof ProductUpdate
     */
    'stripePriceIds'?: Array<StripePriceAttachmentUpdate>;
}
/**
 * 
 * @export
 * @interface ProductsGet200Response
 */
export interface ProductsGet200Response {
    /**
     * 
     * @type {Array<Product>}
     * @memberof ProductsGet200Response
     */
    'items': Array<Product>;
}
/**
 * 
 * @export
 * @interface ProductsSelectionInner
 */
export interface ProductsSelectionInner {
    /**
     * The ID of a product
     * @type {string}
     * @memberof ProductsSelectionInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductsSelectionInner
     */
    'stripePriceId': string;
    /**
     * 
     * @type {number}
     * @memberof ProductsSelectionInner
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface PurchaseTierPreference
 */
export interface PurchaseTierPreference {
    /**
     * 
     * @type {string}
     * @memberof PurchaseTierPreference
     */
    'category': PurchaseTierPreferenceCategoryEnum;
    /**
     * Unique string to identify the tier
     * @type {string}
     * @memberof PurchaseTierPreference
     */
    'key': string;
    /**
     * 
     * @type {CreditPurchaseTier}
     * @memberof PurchaseTierPreference
     */
    'data': CreditPurchaseTier;
}

export const PurchaseTierPreferenceCategoryEnum = {
    Tier: 'tier'
} as const;

export type PurchaseTierPreferenceCategoryEnum = typeof PurchaseTierPreferenceCategoryEnum[keyof typeof PurchaseTierPreferenceCategoryEnum];

/**
 * 
 * @export
 * @interface RecurringConsumptionMetadata
 */
export interface RecurringConsumptionMetadata {
    /**
     * 
     * @type {Array<CreditConsumptionTier>}
     * @memberof RecurringConsumptionMetadata
     */
    'tiers': Array<CreditConsumptionTier>;
}
/**
 * 
 * @export
 * @interface RecurringConsumptionPreference
 */
export interface RecurringConsumptionPreference {
    /**
     * 
     * @type {string}
     * @memberof RecurringConsumptionPreference
     */
    'category': RecurringConsumptionPreferenceCategoryEnum;
    /**
     * 
     * @type {RecurringCreditConsumptionType}
     * @memberof RecurringConsumptionPreference
     */
    'key': RecurringCreditConsumptionType;
    /**
     * 
     * @type {SomeRecurringConsumptionMetadata}
     * @memberof RecurringConsumptionPreference
     */
    'data': SomeRecurringConsumptionMetadata;
}

export const RecurringConsumptionPreferenceCategoryEnum = {
    RecurringConsumption: 'recurring_consumption'
} as const;

export type RecurringConsumptionPreferenceCategoryEnum = typeof RecurringConsumptionPreferenceCategoryEnum[keyof typeof RecurringConsumptionPreferenceCategoryEnum];

/**
 * A recurring credit consumption is a credit consumption that is automatically renewed every month
 * @export
 * @interface RecurringCreditConsumption
 */
export interface RecurringCreditConsumption {
    /**
     * ID of a recurring credit consumption
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'id': string;
    /**
     * 
     * @type {RecurringCreditConsumptionType}
     * @memberof RecurringCreditConsumption
     */
    'type': RecurringCreditConsumptionType;
    /**
     * Number of units to consume at the next charge
     * @type {number}
     * @memberof RecurringCreditConsumption
     */
    'nextChargeUnits': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'cancelledAt'?: string | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'nextChargeAt': string;
    /**
     * The ID of a user
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'doneBy': string;
    /**
     * 
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'teamId'?: string;
    /**
     * The ID of the object that was consumed. (createdAt, objectId) will be enforced to be unique.
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'objectId': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RecurringCreditConsumption
     */
    'metadata'?: { [key: string]: any; };
}


/**
 * 
 * @export
 * @interface RecurringCreditConsumptionCreate
 */
export interface RecurringCreditConsumptionCreate {
    /**
     * 
     * @type {RecurringCreditConsumptionType}
     * @memberof RecurringCreditConsumptionCreate
     */
    'type': RecurringCreditConsumptionType;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RecurringCreditConsumptionCreate
     */
    'createdAt'?: string;
    /**
     * The ID of a team
     * @type {string}
     * @memberof RecurringCreditConsumptionCreate
     */
    'teamId': string;
    /**
     * The ID of the object that was consumed. (createdAt, objectId) will be enforced to be unique.
     * @type {string}
     * @memberof RecurringCreditConsumptionCreate
     */
    'objectId': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RecurringCreditConsumptionCreate
     */
    'metadata'?: { [key: string]: any; };
}


/**
 * Enum of all the types of recurring credit consumption. Category of consumptions are separated by a slash.
 * @export
 * @enum {string}
 */

export const RecurringCreditConsumptionType = {
    ChannelWa: 'channel/wa',
    ChannelTiktok: 'channel/tiktok',
    ChannelMessenger: 'channel/messenger',
    ChannelWaBusinessApi: 'channel/wa-business-api',
    ChannelMail: 'channel/mail',
    User: 'user'
} as const;

export type RecurringCreditConsumptionType = typeof RecurringCreditConsumptionType[keyof typeof RecurringCreditConsumptionType];


/**
 * 
 * @export
 * @interface RecurringCreditsGet200Response
 */
export interface RecurringCreditsGet200Response {
    /**
     * 
     * @type {Array<RecurringCreditConsumption>}
     * @memberof RecurringCreditsGet200Response
     */
    'items': Array<RecurringCreditConsumption>;
    /**
     * 
     * @type {string}
     * @memberof RecurringCreditsGet200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {number}
     * @memberof RecurringCreditsGet200Response
     */
    'total'?: number;
}
/**
 * Use this to define the price of credits for different regions.
 * @export
 * @interface RegionSpecificRecurringConsumptionMetadata
 */
export interface RegionSpecificRecurringConsumptionMetadata {
    /**
     * 
     * @type {RecurringConsumptionMetadata}
     * @memberof RegionSpecificRecurringConsumptionMetadata
     */
    'tier1'?: RecurringConsumptionMetadata;
    /**
     * 
     * @type {RecurringConsumptionMetadata}
     * @memberof RegionSpecificRecurringConsumptionMetadata
     */
    'tier2'?: RecurringConsumptionMetadata;
    /**
     * 
     * @type {RecurringConsumptionMetadata}
     * @memberof RegionSpecificRecurringConsumptionMetadata
     */
    'tier3'?: RecurringConsumptionMetadata;
}
/**
 * Use this to define the price of credits for different regions.
 * @export
 * @interface RegionSpecificSingleConsumptionMetadata
 */
export interface RegionSpecificSingleConsumptionMetadata {
    /**
     * 
     * @type {SingleConsumptionMetadata}
     * @memberof RegionSpecificSingleConsumptionMetadata
     */
    'tier1'?: SingleConsumptionMetadata;
    /**
     * 
     * @type {SingleConsumptionMetadata}
     * @memberof RegionSpecificSingleConsumptionMetadata
     */
    'tier2'?: SingleConsumptionMetadata;
    /**
     * 
     * @type {SingleConsumptionMetadata}
     * @memberof RegionSpecificSingleConsumptionMetadata
     */
    'tier3'?: SingleConsumptionMetadata;
}
/**
 * 
 * @export
 * @interface SingleConsumptionMetadata
 */
export interface SingleConsumptionMetadata {
    /**
     * Cost of the consumption
     * @type {number}
     * @memberof SingleConsumptionMetadata
     */
    'perUnitCost': number;
}
/**
 * 
 * @export
 * @interface SingleConsumptionPreference
 */
export interface SingleConsumptionPreference {
    /**
     * 
     * @type {string}
     * @memberof SingleConsumptionPreference
     */
    'category': SingleConsumptionPreferenceCategoryEnum;
    /**
     * 
     * @type {CreditConsumptionType}
     * @memberof SingleConsumptionPreference
     */
    'key': CreditConsumptionType;
    /**
     * 
     * @type {SomeSingleConsumptionMetadata}
     * @memberof SingleConsumptionPreference
     */
    'data': SomeSingleConsumptionMetadata;
}

export const SingleConsumptionPreferenceCategoryEnum = {
    SingleConsumption: 'single_consumption'
} as const;

export type SingleConsumptionPreferenceCategoryEnum = typeof SingleConsumptionPreferenceCategoryEnum[keyof typeof SingleConsumptionPreferenceCategoryEnum];

/**
 * @type SomeRecurringConsumptionMetadata
 * @export
 */
export type SomeRecurringConsumptionMetadata = RecurringConsumptionMetadata | RegionSpecificRecurringConsumptionMetadata;

/**
 * @type SomeSingleConsumptionMetadata
 * @export
 */
export type SomeSingleConsumptionMetadata = RegionSpecificSingleConsumptionMetadata | SingleConsumptionMetadata;

/**
 * 
 * @export
 * @interface StripeCheckout200Response
 */
export interface StripeCheckout200Response {
    /**
     * 
     * @type {string}
     * @memberof StripeCheckout200Response
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof StripeCheckout200Response
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface StripeCouponData
 */
export interface StripeCouponData {
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof StripeCouponData
     */
    'id': string;
    /**
     * 
     * @type {FloatAmountWithCurrency}
     * @memberof StripeCouponData
     */
    'amountOff'?: FloatAmountWithCurrency;
    /**
     * The percentage off the coupon provides
     * @type {number}
     * @memberof StripeCouponData
     */
    'percentageOff'?: number;
    /**
     * 
     * @type {FloatAmountWithCurrency}
     * @memberof StripeCouponData
     */
    'minAmount'?: FloatAmountWithCurrency;
    /**
     * The duration the coupon is valid for. Can be one of forever, once, or repeating.
     * @type {string}
     * @memberof StripeCouponData
     */
    'duration': StripeCouponDataDurationEnum;
}

export const StripeCouponDataDurationEnum = {
    Forever: 'forever',
    Once: 'once'
} as const;

export type StripeCouponDataDurationEnum = typeof StripeCouponDataDurationEnum[keyof typeof StripeCouponDataDurationEnum];

/**
 * @type StripeCustomerCreate
 * @export
 */
export type StripeCustomerCreate = StripeCustomerCreateOneOf | StripeCustomerCreateOneOf1;

/**
 * Provide to link an existing stripe customer
 * @export
 * @interface StripeCustomerCreateOneOf
 */
export interface StripeCustomerCreateOneOf {
    /**
     * 
     * @type {string}
     * @memberof StripeCustomerCreateOneOf
     */
    'id': string;
}
/**
 * Provide to create a new stripe customer
 * @export
 * @interface StripeCustomerCreateOneOf1
 */
export interface StripeCustomerCreateOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof StripeCustomerCreateOneOf1
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof StripeCustomerCreateOneOf1
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof StripeCustomerCreateOneOf1
     */
    'phoneNumber'?: string;
}
/**
 * 
 * @export
 * @interface StripeMetadata
 */
export interface StripeMetadata {
    /**
     * The URL of the invoice that was created for this credit transaction.
     * @type {string}
     * @memberof StripeMetadata
     */
    'invoiceUrl': string;
    /**
     * The ID of the line item that was created for this credit transaction.
     * @type {string}
     * @memberof StripeMetadata
     */
    'lineItemId': string;
    /**
     * Fraction of the total amount that was paid for this credit transaction. Anything less than 1 means that some or all of the amount is refunded/due.
     * @type {number}
     * @memberof StripeMetadata
     */
    'paidFraction': number;
}
/**
 * 
 * @export
 * @interface StripePreference
 */
export interface StripePreference {
    /**
     * 
     * @type {string}
     * @memberof StripePreference
     */
    'category': StripePreferenceCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof StripePreference
     */
    'key': StripePreferenceKeyEnum;
    /**
     * 
     * @type {CreditStripePrice}
     * @memberof StripePreference
     */
    'data': CreditStripePrice;
}

export const StripePreferenceCategoryEnum = {
    Stripe: 'stripe'
} as const;

export type StripePreferenceCategoryEnum = typeof StripePreferenceCategoryEnum[keyof typeof StripePreferenceCategoryEnum];
export const StripePreferenceKeyEnum = {
    AutoRenewal: 'autoRenewal',
    TopUp: 'topUp',
    Bonus: 'bonus'
} as const;

export type StripePreferenceKeyEnum = typeof StripePreferenceKeyEnum[keyof typeof StripePreferenceKeyEnum];

/**
 * 
 * @export
 * @interface StripePrice
 */
export interface StripePrice {
    /**
     * 
     * @type {string}
     * @memberof StripePrice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StripePrice
     */
    'productName'?: string;
    /**
     * 
     * @type {BillingPeriod}
     * @memberof StripePrice
     */
    'period': BillingPeriod;
    /**
     * 
     * @type {AmountWithCurrency}
     * @memberof StripePrice
     */
    'amount': AmountWithCurrency;
    /**
     * ISO 3166-1 alpha-2 country code, or \"default\" to get the default prices
     * @type {string}
     * @memberof StripePrice
     */
    'region'?: string;
}


/**
 * Update a stripe price ID attachment. Supply ID to attach, or supply remove=true to detach. Supply region to mark price to a specific region.
 * @export
 * @interface StripePriceAttachmentUpdate
 */
export interface StripePriceAttachmentUpdate {
    /**
     * 
     * @type {string}
     * @memberof StripePriceAttachmentUpdate
     */
    'id': string;
    /**
     * ISO 3166-1 alpha-2 country code, or \"default\" to get the default prices
     * @type {string}
     * @memberof StripePriceAttachmentUpdate
     */
    'region'?: string;
    /**
     * Remove this stripe price ID from the product
     * @type {boolean}
     * @memberof StripePriceAttachmentUpdate
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface StripePricesGet200Response
 */
export interface StripePricesGet200Response {
    /**
     * 
     * @type {Array<StripePrice>}
     * @memberof StripePricesGet200Response
     */
    'items': Array<StripePrice>;
    /**
     * 
     * @type {string}
     * @memberof StripePricesGet200Response
     */
    'nextPageCursor'?: string;
}
/**
 * 
 * @export
 * @interface StripeSubscriptionItem
 */
export interface StripeSubscriptionItem {
    /**
     * 
     * @type {string}
     * @memberof StripeSubscriptionItem
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface SubscribedProduct
 */
export interface SubscribedProduct {
    /**
     * 
     * @type {Product}
     * @memberof SubscribedProduct
     */
    'product'?: Product;
    /**
     * 
     * @type {string}
     * @memberof SubscribedProduct
     */
    'productId': string;
    /**
     * The stripe price ID that was used to purchase this subscription product
     * @type {string}
     * @memberof SubscribedProduct
     */
    'stripePriceId': string;
    /**
     * 
     * @type {number}
     * @memberof SubscribedProduct
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * The ID of a subscription
     * @type {string}
     * @memberof Subscription
     */
    'id': string;
    /**
     * The ID of a team
     * @type {string}
     * @memberof Subscription
     */
    'teamId'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Subscription
     */
    'startDate': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Subscription
     */
    'endDate'?: string;
    /**
     * Reason for voiding the subscription
     * @type {string}
     * @memberof Subscription
     */
    'voidReason'?: string;
    /**
     * 
     * @type {SubscriptionStripeData}
     * @memberof Subscription
     */
    'stripe'?: SubscriptionStripeData;
    /**
     * 
     * @type {Array<SubscribedProduct>}
     * @memberof Subscription
     */
    'products'?: Array<SubscribedProduct>;
    /**
     * 
     * @type {AutoChargeProduct}
     * @memberof Subscription
     */
    'autoCharge'?: AutoChargeProduct;
}
/**
 * 
 * @export
 * @interface SubscriptionCreate
 */
export interface SubscriptionCreate {
    /**
     * The ID of a team
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'teamId': string;
    /**
     * 
     * @type {Array<ProductsSelectionInner>}
     * @memberof SubscriptionCreate
     */
    'products': Array<ProductsSelectionInner>;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'startDate'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'endDate'?: string;
    /**
     * Extra days to add to the subscription. Invalid request with endDate.
     * @type {number}
     * @memberof SubscriptionCreate
     */
    'extraDays'?: number;
    /**
     * Free trial days to add to the subscription. Invalid request with endDate, extraDays, or nextCycleAnchor, and createOnStripe=false.
     * @type {number}
     * @memberof SubscriptionCreate
     */
    'freeTrialDays'?: number;
    /**
     * Anchor the next cycle to a specific date. Invalid request with endDate. Only valid for stripe subscriptions.
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'nextCycleAnchor'?: string;
    /**
     * Create the subscription on stripe. Will create the subscription on stripe if true. Only works if the customer has a payment method and it can be charged automatically.
     * @type {boolean}
     * @memberof SubscriptionCreate
     */
    'createOnStripe': boolean;
    /**
     * Refresh access after creating the subscription.
     * @type {boolean}
     * @memberof SubscriptionCreate
     */
    'refreshAccess'?: boolean;
}
/**
 * 
 * @export
 * @interface SubscriptionStripeData
 */
export interface SubscriptionStripeData {
    /**
     * The ID of a subscription
     * @type {string}
     * @memberof SubscriptionStripeData
     */
    'subscriptionId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof SubscriptionStripeData
     */
    'nextRenewalDate'?: string;
    /**
     * 
     * @type {Array<StripeSubscriptionItem>}
     * @memberof SubscriptionStripeData
     */
    'items': Array<StripeSubscriptionItem>;
    /**
     * 
     * @type {Array<PaymentData>}
     * @memberof SubscriptionStripeData
     */
    'payments': Array<PaymentData>;
}
/**
 * 
 * @export
 * @interface SubscriptionUpdate
 */
export interface SubscriptionUpdate {
    /**
     * Cancel the subscription. Will set the end date to the end of the current period. Features will continue to work until the end of the period.
     * @type {boolean}
     * @memberof SubscriptionUpdate
     */
    'cancel'?: boolean;
    /**
     * Reason for voiding the subscription. Will cancel the subscription if provided. Will set the end date to now.
     * @type {string}
     * @memberof SubscriptionUpdate
     */
    'voidReason'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionsGet200Response
 */
interface SubscriptionsGet200Response {
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof SubscriptionsGet200Response
     */
    'items': Array<Subscription>;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionsGet200Response
     */
    'nextPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface TeamDetail
 */
export interface TeamDetail {
    /**
     * The ID of a team
     * @type {string}
     * @memberof TeamDetail
     */
    'id': string;
    /**
     * 
     * @type {Access}
     * @memberof TeamDetail
     */
    'access': Access;
    /**
     * 
     * @type {LimitationMap}
     * @memberof TeamDetail
     */
    'usage': LimitationMap;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TeamDetail
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TeamDetail
     */
    'updatedAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TeamDetail
     */
    'lastAccessComputedAt': string;
    /**
     * 
     * @type {Array<LimitedItem>}
     * @memberof TeamDetail
     */
    'autoChargeItems': Array<LimitedItem>;
    /**
     * 
     * @type {string}
     * @memberof TeamDetail
     */
    'stripeCustomerId'?: string;
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof TeamDetail
     */
    'subscriptions'?: Array<Subscription>;
    /**
     * 
     * @type {string}
     * @memberof TeamDetail
     */
    'partnership'?: string;
}
/**
 * 
 * @export
 * @interface TeamDetailCreate
 */
export interface TeamDetailCreate {
    /**
     * The ID of a team
     * @type {string}
     * @memberof TeamDetailCreate
     */
    'id': string;
    /**
     * 
     * @type {Set<LimitedItem>}
     * @memberof TeamDetailCreate
     */
    'autoChargeItems'?: Set<LimitedItem>;
    /**
     * 
     * @type {StripeCustomerCreate}
     * @memberof TeamDetailCreate
     */
    'stripeCustomer': StripeCustomerCreate;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailCreate
     */
    'partnership'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailCreate
     */
    'referralCode'?: string;
}
/**
 * 
 * @export
 * @interface TeamDetailUpdate
 */
export interface TeamDetailUpdate {
    /**
     * 
     * @type {Set<LimitedItem>}
     * @memberof TeamDetailUpdate
     */
    'autoChargeItems'?: Set<LimitedItem>;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailUpdate
     */
    'stripeCustomerId'?: string;
    /**
     * 
     * @type {LimitationMap}
     * @memberof TeamDetailUpdate
     */
    'usage'?: LimitationMap;
}
/**
 * 
 * @export
 * @interface UnlockPreference
 */
export interface UnlockPreference {
    /**
     * 
     * @type {string}
     * @memberof UnlockPreference
     */
    'category': UnlockPreferenceCategoryEnum;
    /**
     * 
     * @type {CreditUnlockType}
     * @memberof UnlockPreference
     */
    'key': CreditUnlockType;
    /**
     * 
     * @type {CreditUnlockMetadata}
     * @memberof UnlockPreference
     */
    'data': CreditUnlockMetadata;
}

export const UnlockPreferenceCategoryEnum = {
    Unlock: 'unlock'
} as const;

export type UnlockPreferenceCategoryEnum = typeof UnlockPreferenceCategoryEnum[keyof typeof UnlockPreferenceCategoryEnum];


/**
 * AutoChargeProductsApi - axios parameter creator
 * @export
 */
export const AutoChargeProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch All Auto Charge Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auto-charge-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - If usage < limit, then no action is taken - If usage >= limit, then:   - a metered subscription is created, if it doesn\'t exist   - fails if cannot be auto-charged
         * @summary Prepares the team for auto charge
         * @param {LimitedItem} item 
         * @param {string} [accountId] The account ID to prepare usage for. Relevant for messages only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsPrepare: async (item: LimitedItem, accountId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('autoChargeProductsPrepare', 'item', item)
            const localVarPath = `/auto-charge-products/prepare/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets config for auto charge product
         * @param {AutoChargeProductSet} [autoChargeProductSet] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsSet: async (autoChargeProductSet?: AutoChargeProductSet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auto-charge-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoChargeProductSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutoChargeProductsApi - functional programming interface
 * @export
 */
export const AutoChargeProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutoChargeProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch All Auto Charge Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoChargeProductsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoChargeProductsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoChargeProductsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - If usage < limit, then no action is taken - If usage >= limit, then:   - a metered subscription is created, if it doesn\'t exist   - fails if cannot be auto-charged
         * @summary Prepares the team for auto charge
         * @param {LimitedItem} item 
         * @param {string} [accountId] The account ID to prepare usage for. Relevant for messages only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoChargeProductsPrepare(item: LimitedItem, accountId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoChargeProductsPrepare200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoChargeProductsPrepare(item, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sets config for auto charge product
         * @param {AutoChargeProductSet} [autoChargeProductSet] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoChargeProductsSet(autoChargeProductSet?: AutoChargeProductSet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoChargeProductsSet(autoChargeProductSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AutoChargeProductsApi - factory interface
 * @export
 */
export const AutoChargeProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutoChargeProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch All Auto Charge Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsGet(options?: AxiosRequestConfig): AxiosPromise<AutoChargeProductsGet200Response> {
            return localVarFp.autoChargeProductsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * - If usage < limit, then no action is taken - If usage >= limit, then:   - a metered subscription is created, if it doesn\'t exist   - fails if cannot be auto-charged
         * @summary Prepares the team for auto charge
         * @param {AutoChargeProductsApiAutoChargeProductsPrepareRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsPrepare(requestParameters: AutoChargeProductsApiAutoChargeProductsPrepareRequest, options?: AxiosRequestConfig): AxiosPromise<AutoChargeProductsPrepare200Response> {
            return localVarFp.autoChargeProductsPrepare(requestParameters.item, requestParameters.accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets config for auto charge product
         * @param {AutoChargeProductsApiAutoChargeProductsSetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsSet(requestParameters: AutoChargeProductsApiAutoChargeProductsSetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.autoChargeProductsSet(requestParameters.autoChargeProductSet, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for autoChargeProductsPrepare operation in AutoChargeProductsApi.
 * @export
 * @interface AutoChargeProductsApiAutoChargeProductsPrepareRequest
 */
export interface AutoChargeProductsApiAutoChargeProductsPrepareRequest {
    /**
     * 
     * @type {LimitedItem}
     * @memberof AutoChargeProductsApiAutoChargeProductsPrepare
     */
    readonly item: LimitedItem

    /**
     * The account ID to prepare usage for. Relevant for messages only.
     * @type {string}
     * @memberof AutoChargeProductsApiAutoChargeProductsPrepare
     */
    readonly accountId?: string
}

/**
 * Request parameters for autoChargeProductsSet operation in AutoChargeProductsApi.
 * @export
 * @interface AutoChargeProductsApiAutoChargeProductsSetRequest
 */
export interface AutoChargeProductsApiAutoChargeProductsSetRequest {
    /**
     * 
     * @type {AutoChargeProductSet}
     * @memberof AutoChargeProductsApiAutoChargeProductsSet
     */
    readonly autoChargeProductSet?: AutoChargeProductSet
}

/**
 * AutoChargeProductsApi - object-oriented interface
 * @export
 * @class AutoChargeProductsApi
 * @extends {BaseAPI}
 */
export class AutoChargeProductsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch All Auto Charge Products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoChargeProductsApi
     */
    public autoChargeProductsGet(options?: AxiosRequestConfig) {
        return AutoChargeProductsApiFp(this.configuration).autoChargeProductsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - If usage < limit, then no action is taken - If usage >= limit, then:   - a metered subscription is created, if it doesn\'t exist   - fails if cannot be auto-charged
     * @summary Prepares the team for auto charge
     * @param {AutoChargeProductsApiAutoChargeProductsPrepareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoChargeProductsApi
     */
    public autoChargeProductsPrepare(requestParameters: AutoChargeProductsApiAutoChargeProductsPrepareRequest, options?: AxiosRequestConfig) {
        return AutoChargeProductsApiFp(this.configuration).autoChargeProductsPrepare(requestParameters.item, requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets config for auto charge product
     * @param {AutoChargeProductsApiAutoChargeProductsSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoChargeProductsApi
     */
    public autoChargeProductsSet(requestParameters: AutoChargeProductsApiAutoChargeProductsSetRequest = {}, options?: AxiosRequestConfig) {
        return AutoChargeProductsApiFp(this.configuration).autoChargeProductsSet(requestParameters.autoChargeProductSet, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CouponCodesApi - axios parameter creator
 * @export
 */
export const CouponCodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get and verify coupon data from Stripe
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsGet: async (code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('couponsGet', 'code', code)
            const localVarPath = `/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a coupon code
         * @param {CouponCodeCreateOptions} [couponCodeCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsPost: async (couponCodeCreateOptions?: CouponCodeCreateOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(couponCodeCreateOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CouponCodesApi - functional programming interface
 * @export
 */
export const CouponCodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CouponCodesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get and verify coupon data from Stripe
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsGet(code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeCouponData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsGet(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate a coupon code
         * @param {CouponCodeCreateOptions} [couponCodeCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsPost(couponCodeCreateOptions?: CouponCodeCreateOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsPost(couponCodeCreateOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CouponCodesApi - factory interface
 * @export
 */
export const CouponCodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CouponCodesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get and verify coupon data from Stripe
         * @param {CouponCodesApiCouponsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsGet(requestParameters: CouponCodesApiCouponsGetRequest, options?: AxiosRequestConfig): AxiosPromise<StripeCouponData> {
            return localVarFp.couponsGet(requestParameters.code, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a coupon code
         * @param {CouponCodesApiCouponsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsPost(requestParameters: CouponCodesApiCouponsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CouponsPost200Response> {
            return localVarFp.couponsPost(requestParameters.couponCodeCreateOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for couponsGet operation in CouponCodesApi.
 * @export
 * @interface CouponCodesApiCouponsGetRequest
 */
export interface CouponCodesApiCouponsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof CouponCodesApiCouponsGet
     */
    readonly code: string
}

/**
 * Request parameters for couponsPost operation in CouponCodesApi.
 * @export
 * @interface CouponCodesApiCouponsPostRequest
 */
export interface CouponCodesApiCouponsPostRequest {
    /**
     * 
     * @type {CouponCodeCreateOptions}
     * @memberof CouponCodesApiCouponsPost
     */
    readonly couponCodeCreateOptions?: CouponCodeCreateOptions
}

/**
 * CouponCodesApi - object-oriented interface
 * @export
 * @class CouponCodesApi
 * @extends {BaseAPI}
 */
export class CouponCodesApi extends BaseAPI {
    /**
     * 
     * @summary Get and verify coupon data from Stripe
     * @param {CouponCodesApiCouponsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponCodesApi
     */
    public couponsGet(requestParameters: CouponCodesApiCouponsGetRequest, options?: AxiosRequestConfig) {
        return CouponCodesApiFp(this.configuration).couponsGet(requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a coupon code
     * @param {CouponCodesApiCouponsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponCodesApi
     */
    public couponsPost(requestParameters: CouponCodesApiCouponsPostRequest = {}, options?: AxiosRequestConfig) {
        return CouponCodesApiFp(this.configuration).couponsPost(requestParameters.couponCodeCreateOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreditsApi - axios parameter creator
 * @export
 */
export const CreditsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create/update the auto-renewal credit sub
         * @param {CreditAutoRenewalUpdate} [creditAutoRenewalUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoRenewalPost: async (creditAutoRenewalUpdate?: CreditAutoRenewalUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/auto-renewal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditAutoRenewalUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {CreditConsumptionType} type The type of consumption
         * @param {number} quantity The number of times to consume the given type
         * @param {LegacyCanConsumeOpts} [legacyOpts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canConsumeCredits: async (type: CreditConsumptionType, quantity: number, legacyOpts?: LegacyCanConsumeOpts, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('canConsumeCredits', 'type', type)
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('canConsumeCredits', 'quantity', quantity)
            const localVarPath = `/v2/credits/can-consume`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (quantity !== undefined) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (legacyOpts !== undefined) {
                localVarQueryParameter['legacyOpts'] = legacyOpts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {RecurringCreditConsumptionType} type The type of consumption
         * @param {LegacyCanConsumeOpts} [legacyOpts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canConsumeRecurringCredits: async (type: RecurringCreditConsumptionType, legacyOpts?: LegacyCanConsumeOpts, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('canConsumeRecurringCredits', 'type', type)
            const localVarPath = `/v2/credits/can-consume-recurring`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (legacyOpts !== undefined) {
                localVarQueryParameter['legacyOpts'] = legacyOpts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new single use credit consumption record
         * @param {CreditConsumptionPostRequest} [creditConsumptionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditConsumptionPost: async (creditConsumptionPostRequest?: CreditConsumptionPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/consumption`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditConsumptionPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of gains your team has received
         * @param {string} [customerId] Filter by customerId.
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {Array<CreditGainType>} [type] 
         * @param {DateRange} [createdAt] 
         * @param {CreditGainStatus} [status] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditGainsGet: async (customerId?: string, count?: number, cursor?: string, type?: Array<CreditGainType>, createdAt?: DateRange, status?: CreditGainStatus, returnTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/gains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ"], configuration)

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new credit gain
         * @param {CreditGainCreate} [creditGainCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditGainsPost: async (creditGainCreate?: CreditGainCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/gains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditGainCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transaction history
         * @param {string} [teamId] Filter by teamId
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {Array<CreditBalanceEffectType>} [type] 
         * @param {'gain' | 'consume'} [effectType] 
         * @param {Array<string>} [id] 
         * @param {DateRange} [createdAt] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditTxsGet: async (teamId?: string, count?: number, cursor?: string, type?: Array<CreditBalanceEffectType>, effectType?: 'gain' | 'consume', id?: Array<string>, createdAt?: DateRange, returnTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/consumption`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ"], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (effectType !== undefined) {
                localVarQueryParameter['effectType'] = effectType;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the customer\'s credit details
         * @param {boolean} [returnAutoRenewal] Return the auto-renewal subscription details. PAYMENTS_READ scope is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerGet: async (returnAutoRenewal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (returnAutoRenewal !== undefined) {
                localVarQueryParameter['returnAutoRenewal'] = returnAutoRenewal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new customer, or link the team to an existing customer
         * @param {CreditCustomerPost} [creditCustomerPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerPost: async (creditCustomerPost?: CreditCustomerPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditCustomerPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refreshes the customer\'s subscription & any other purchased items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerRefresh: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/customer/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get metadata for credit consumptions and unlocks
         * @param {string} [region] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsPreferencesGet: async (region?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the system credit preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsPreferencesGetAdmin: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/preferences/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the given credit preferences
         * @param {CreditsPreferencesPostRequest} [creditsPreferencesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsPreferencesPost: async (creditsPreferencesPostRequest?: CreditsPreferencesPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/preferences/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditsPreferencesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recurring credit consumptions
         * @param {string} [teamId] Filter by teamId
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {RecurringCreditConsumptionType} [type] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recurringCreditsGet: async (teamId?: string, count?: number, cursor?: string, type?: RecurringCreditConsumptionType, returnTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/recurring`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ"], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Top up credits
         * @param {CreditTopUpOptions} [creditTopUpOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topUpCreditsPost: async (creditTopUpOptions?: CreditTopUpOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/topup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditTopUpOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditsApi - functional programming interface
 * @export
 */
export const CreditsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create/update the auto-renewal credit sub
         * @param {CreditAutoRenewalUpdate} [creditAutoRenewalUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoRenewalPost(creditAutoRenewalUpdate?: CreditAutoRenewalUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoRenewalPost(creditAutoRenewalUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {CreditConsumptionType} type The type of consumption
         * @param {number} quantity The number of times to consume the given type
         * @param {LegacyCanConsumeOpts} [legacyOpts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async canConsumeCredits(type: CreditConsumptionType, quantity: number, legacyOpts?: LegacyCanConsumeOpts, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCanConsumeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.canConsumeCredits(type, quantity, legacyOpts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {RecurringCreditConsumptionType} type The type of consumption
         * @param {LegacyCanConsumeOpts} [legacyOpts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async canConsumeRecurringCredits(type: RecurringCreditConsumptionType, legacyOpts?: LegacyCanConsumeOpts, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCanConsumeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.canConsumeRecurringCredits(type, legacyOpts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new single use credit consumption record
         * @param {CreditConsumptionPostRequest} [creditConsumptionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditConsumptionPost(creditConsumptionPostRequest?: CreditConsumptionPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreditTransactionRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditConsumptionPost(creditConsumptionPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of gains your team has received
         * @param {string} [customerId] Filter by customerId.
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {Array<CreditGainType>} [type] 
         * @param {DateRange} [createdAt] 
         * @param {CreditGainStatus} [status] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditGainsGet(customerId?: string, count?: number, cursor?: string, type?: Array<CreditGainType>, createdAt?: DateRange, status?: CreditGainStatus, returnTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditGainsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditGainsGet(customerId, count, cursor, type, createdAt, status, returnTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new credit gain
         * @param {CreditGainCreate} [creditGainCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditGainsPost(creditGainCreate?: CreditGainCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditGain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditGainsPost(creditGainCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get transaction history
         * @param {string} [teamId] Filter by teamId
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {Array<CreditBalanceEffectType>} [type] 
         * @param {'gain' | 'consume'} [effectType] 
         * @param {Array<string>} [id] 
         * @param {DateRange} [createdAt] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditTxsGet(teamId?: string, count?: number, cursor?: string, type?: Array<CreditBalanceEffectType>, effectType?: 'gain' | 'consume', id?: Array<string>, createdAt?: DateRange, returnTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditTxsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditTxsGet(teamId, count, cursor, type, effectType, id, createdAt, returnTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the customer\'s credit details
         * @param {boolean} [returnAutoRenewal] Return the auto-renewal subscription details. PAYMENTS_READ scope is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsCustomerGet(returnAutoRenewal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCustomer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsCustomerGet(returnAutoRenewal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new customer, or link the team to an existing customer
         * @param {CreditCustomerPost} [creditCustomerPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsCustomerPost(creditCustomerPost?: CreditCustomerPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditsCustomerPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsCustomerPost(creditCustomerPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Refreshes the customer\'s subscription & any other purchased items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsCustomerRefresh(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsCustomerRefresh(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get metadata for credit consumptions and unlocks
         * @param {string} [region] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsPreferencesGet(region?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditsPreferences>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsPreferencesGet(region, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the system credit preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsPreferencesGetAdmin(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditsPreferences>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsPreferencesGetAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the given credit preferences
         * @param {CreditsPreferencesPostRequest} [creditsPreferencesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsPreferencesPost(creditsPreferencesPostRequest?: CreditsPreferencesPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsPreferencesPost(creditsPreferencesPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get recurring credit consumptions
         * @param {string} [teamId] Filter by teamId
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {RecurringCreditConsumptionType} [type] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recurringCreditsGet(teamId?: string, count?: number, cursor?: string, type?: RecurringCreditConsumptionType, returnTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurringCreditsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recurringCreditsGet(teamId, count, cursor, type, returnTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Top up credits
         * @param {CreditTopUpOptions} [creditTopUpOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topUpCreditsPost(creditTopUpOptions?: CreditTopUpOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topUpCreditsPost(creditTopUpOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreditsApi - factory interface
 * @export
 */
export const CreditsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create/update the auto-renewal credit sub
         * @param {CreditsApiAutoRenewalPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoRenewalPost(requestParameters: CreditsApiAutoRenewalPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PaymentRequest> {
            return localVarFp.autoRenewalPost(requestParameters.creditAutoRenewalUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {CreditsApiCanConsumeCreditsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canConsumeCredits(requestParameters: CreditsApiCanConsumeCreditsRequest, options?: AxiosRequestConfig): AxiosPromise<CreditCanConsumeResponse> {
            return localVarFp.canConsumeCredits(requestParameters.type, requestParameters.quantity, requestParameters.legacyOpts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {CreditsApiCanConsumeRecurringCreditsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canConsumeRecurringCredits(requestParameters: CreditsApiCanConsumeRecurringCreditsRequest, options?: AxiosRequestConfig): AxiosPromise<CreditCanConsumeResponse> {
            return localVarFp.canConsumeRecurringCredits(requestParameters.type, requestParameters.legacyOpts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new single use credit consumption record
         * @param {CreditsApiCreditConsumptionPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditConsumptionPost(requestParameters: CreditsApiCreditConsumptionPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<CreditTransactionRecord>> {
            return localVarFp.creditConsumptionPost(requestParameters.creditConsumptionPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of gains your team has received
         * @param {CreditsApiCreditGainsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditGainsGet(requestParameters: CreditsApiCreditGainsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CreditGainsGet200Response> {
            return localVarFp.creditGainsGet(requestParameters.customerId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.createdAt, requestParameters.status, requestParameters.returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new credit gain
         * @param {CreditsApiCreditGainsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditGainsPost(requestParameters: CreditsApiCreditGainsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CreditGain> {
            return localVarFp.creditGainsPost(requestParameters.creditGainCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transaction history
         * @param {CreditsApiCreditTxsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditTxsGet(requestParameters: CreditsApiCreditTxsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CreditTxsGet200Response> {
            return localVarFp.creditTxsGet(requestParameters.teamId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.effectType, requestParameters.id, requestParameters.createdAt, requestParameters.returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the customer\'s credit details
         * @param {CreditsApiCreditsCustomerGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerGet(requestParameters: CreditsApiCreditsCustomerGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CreditCustomer> {
            return localVarFp.creditsCustomerGet(requestParameters.returnAutoRenewal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new customer, or link the team to an existing customer
         * @param {CreditsApiCreditsCustomerPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerPost(requestParameters: CreditsApiCreditsCustomerPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CreditsCustomerPost200Response> {
            return localVarFp.creditsCustomerPost(requestParameters.creditCustomerPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refreshes the customer\'s subscription & any other purchased items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerRefresh(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.creditsCustomerRefresh(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get metadata for credit consumptions and unlocks
         * @param {CreditsApiCreditsPreferencesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsPreferencesGet(requestParameters: CreditsApiCreditsPreferencesGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CreditsPreferences> {
            return localVarFp.creditsPreferencesGet(requestParameters.region, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the system credit preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsPreferencesGetAdmin(options?: AxiosRequestConfig): AxiosPromise<CreditsPreferences> {
            return localVarFp.creditsPreferencesGetAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the given credit preferences
         * @param {CreditsApiCreditsPreferencesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsPreferencesPost(requestParameters: CreditsApiCreditsPreferencesPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.creditsPreferencesPost(requestParameters.creditsPreferencesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recurring credit consumptions
         * @param {CreditsApiRecurringCreditsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recurringCreditsGet(requestParameters: CreditsApiRecurringCreditsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<RecurringCreditsGet200Response> {
            return localVarFp.recurringCreditsGet(requestParameters.teamId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Top up credits
         * @param {CreditsApiTopUpCreditsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topUpCreditsPost(requestParameters: CreditsApiTopUpCreditsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PaymentRequest> {
            return localVarFp.topUpCreditsPost(requestParameters.creditTopUpOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for autoRenewalPost operation in CreditsApi.
 * @export
 * @interface CreditsApiAutoRenewalPostRequest
 */
export interface CreditsApiAutoRenewalPostRequest {
    /**
     * 
     * @type {CreditAutoRenewalUpdate}
     * @memberof CreditsApiAutoRenewalPost
     */
    readonly creditAutoRenewalUpdate?: CreditAutoRenewalUpdate
}

/**
 * Request parameters for canConsumeCredits operation in CreditsApi.
 * @export
 * @interface CreditsApiCanConsumeCreditsRequest
 */
export interface CreditsApiCanConsumeCreditsRequest {
    /**
     * The type of consumption
     * @type {CreditConsumptionType}
     * @memberof CreditsApiCanConsumeCredits
     */
    readonly type: CreditConsumptionType

    /**
     * The number of times to consume the given type
     * @type {number}
     * @memberof CreditsApiCanConsumeCredits
     */
    readonly quantity: number

    /**
     * 
     * @type {LegacyCanConsumeOpts}
     * @memberof CreditsApiCanConsumeCredits
     */
    readonly legacyOpts?: LegacyCanConsumeOpts
}

/**
 * Request parameters for canConsumeRecurringCredits operation in CreditsApi.
 * @export
 * @interface CreditsApiCanConsumeRecurringCreditsRequest
 */
export interface CreditsApiCanConsumeRecurringCreditsRequest {
    /**
     * The type of consumption
     * @type {RecurringCreditConsumptionType}
     * @memberof CreditsApiCanConsumeRecurringCredits
     */
    readonly type: RecurringCreditConsumptionType

    /**
     * 
     * @type {LegacyCanConsumeOpts}
     * @memberof CreditsApiCanConsumeRecurringCredits
     */
    readonly legacyOpts?: LegacyCanConsumeOpts
}

/**
 * Request parameters for creditConsumptionPost operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditConsumptionPostRequest
 */
export interface CreditsApiCreditConsumptionPostRequest {
    /**
     * 
     * @type {CreditConsumptionPostRequest}
     * @memberof CreditsApiCreditConsumptionPost
     */
    readonly creditConsumptionPostRequest?: CreditConsumptionPostRequest
}

/**
 * Request parameters for creditGainsGet operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditGainsGetRequest
 */
export interface CreditsApiCreditGainsGetRequest {
    /**
     * Filter by customerId.
     * @type {string}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly customerId?: string

    /**
     * 
     * @type {number}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly cursor?: string

    /**
     * 
     * @type {Array<CreditGainType>}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly type?: Array<CreditGainType>

    /**
     * 
     * @type {DateRange}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly createdAt?: DateRange

    /**
     * 
     * @type {CreditGainStatus}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly status?: CreditGainStatus

    /**
     * Return total number of consumptions
     * @type {boolean}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for creditGainsPost operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditGainsPostRequest
 */
export interface CreditsApiCreditGainsPostRequest {
    /**
     * 
     * @type {CreditGainCreate}
     * @memberof CreditsApiCreditGainsPost
     */
    readonly creditGainCreate?: CreditGainCreate
}

/**
 * Request parameters for creditTxsGet operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditTxsGetRequest
 */
export interface CreditsApiCreditTxsGetRequest {
    /**
     * Filter by teamId
     * @type {string}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly teamId?: string

    /**
     * 
     * @type {number}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly cursor?: string

    /**
     * 
     * @type {Array<CreditBalanceEffectType>}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly type?: Array<CreditBalanceEffectType>

    /**
     * 
     * @type {'gain' | 'consume'}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly effectType?: 'gain' | 'consume'

    /**
     * 
     * @type {Array<string>}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly id?: Array<string>

    /**
     * 
     * @type {DateRange}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly createdAt?: DateRange

    /**
     * Return total number of consumptions
     * @type {boolean}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for creditsCustomerGet operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditsCustomerGetRequest
 */
export interface CreditsApiCreditsCustomerGetRequest {
    /**
     * Return the auto-renewal subscription details. PAYMENTS_READ scope is required.
     * @type {boolean}
     * @memberof CreditsApiCreditsCustomerGet
     */
    readonly returnAutoRenewal?: boolean
}

/**
 * Request parameters for creditsCustomerPost operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditsCustomerPostRequest
 */
export interface CreditsApiCreditsCustomerPostRequest {
    /**
     * 
     * @type {CreditCustomerPost}
     * @memberof CreditsApiCreditsCustomerPost
     */
    readonly creditCustomerPost?: CreditCustomerPost
}

/**
 * Request parameters for creditsPreferencesGet operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditsPreferencesGetRequest
 */
export interface CreditsApiCreditsPreferencesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditsApiCreditsPreferencesGet
     */
    readonly region?: string
}

/**
 * Request parameters for creditsPreferencesPost operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditsPreferencesPostRequest
 */
export interface CreditsApiCreditsPreferencesPostRequest {
    /**
     * 
     * @type {CreditsPreferencesPostRequest}
     * @memberof CreditsApiCreditsPreferencesPost
     */
    readonly creditsPreferencesPostRequest?: CreditsPreferencesPostRequest
}

/**
 * Request parameters for recurringCreditsGet operation in CreditsApi.
 * @export
 * @interface CreditsApiRecurringCreditsGetRequest
 */
export interface CreditsApiRecurringCreditsGetRequest {
    /**
     * Filter by teamId
     * @type {string}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly teamId?: string

    /**
     * 
     * @type {number}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly cursor?: string

    /**
     * 
     * @type {RecurringCreditConsumptionType}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly type?: RecurringCreditConsumptionType

    /**
     * Return total number of consumptions
     * @type {boolean}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for topUpCreditsPost operation in CreditsApi.
 * @export
 * @interface CreditsApiTopUpCreditsPostRequest
 */
export interface CreditsApiTopUpCreditsPostRequest {
    /**
     * 
     * @type {CreditTopUpOptions}
     * @memberof CreditsApiTopUpCreditsPost
     */
    readonly creditTopUpOptions?: CreditTopUpOptions
}

/**
 * CreditsApi - object-oriented interface
 * @export
 * @class CreditsApi
 * @extends {BaseAPI}
 */
export class CreditsApi extends BaseAPI {
    /**
     * 
     * @summary Create/update the auto-renewal credit sub
     * @param {CreditsApiAutoRenewalPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public autoRenewalPost(requestParameters: CreditsApiAutoRenewalPostRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).autoRenewalPost(requestParameters.creditAutoRenewalUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if the team can consume the given quantity of credits
     * @param {CreditsApiCanConsumeCreditsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public canConsumeCredits(requestParameters: CreditsApiCanConsumeCreditsRequest, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).canConsumeCredits(requestParameters.type, requestParameters.quantity, requestParameters.legacyOpts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if the team can consume the given quantity of credits
     * @param {CreditsApiCanConsumeRecurringCreditsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public canConsumeRecurringCredits(requestParameters: CreditsApiCanConsumeRecurringCreditsRequest, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).canConsumeRecurringCredits(requestParameters.type, requestParameters.legacyOpts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new single use credit consumption record
     * @param {CreditsApiCreditConsumptionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditConsumptionPost(requestParameters: CreditsApiCreditConsumptionPostRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditConsumptionPost(requestParameters.creditConsumptionPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of gains your team has received
     * @param {CreditsApiCreditGainsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditGainsGet(requestParameters: CreditsApiCreditGainsGetRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditGainsGet(requestParameters.customerId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.createdAt, requestParameters.status, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new credit gain
     * @param {CreditsApiCreditGainsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditGainsPost(requestParameters: CreditsApiCreditGainsPostRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditGainsPost(requestParameters.creditGainCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transaction history
     * @param {CreditsApiCreditTxsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditTxsGet(requestParameters: CreditsApiCreditTxsGetRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditTxsGet(requestParameters.teamId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.effectType, requestParameters.id, requestParameters.createdAt, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the customer\'s credit details
     * @param {CreditsApiCreditsCustomerGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditsCustomerGet(requestParameters: CreditsApiCreditsCustomerGetRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditsCustomerGet(requestParameters.returnAutoRenewal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new customer, or link the team to an existing customer
     * @param {CreditsApiCreditsCustomerPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditsCustomerPost(requestParameters: CreditsApiCreditsCustomerPostRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditsCustomerPost(requestParameters.creditCustomerPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refreshes the customer\'s subscription & any other purchased items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditsCustomerRefresh(options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditsCustomerRefresh(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get metadata for credit consumptions and unlocks
     * @param {CreditsApiCreditsPreferencesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditsPreferencesGet(requestParameters: CreditsApiCreditsPreferencesGetRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditsPreferencesGet(requestParameters.region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the system credit preferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditsPreferencesGetAdmin(options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditsPreferencesGetAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the given credit preferences
     * @param {CreditsApiCreditsPreferencesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditsPreferencesPost(requestParameters: CreditsApiCreditsPreferencesPostRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditsPreferencesPost(requestParameters.creditsPreferencesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recurring credit consumptions
     * @param {CreditsApiRecurringCreditsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public recurringCreditsGet(requestParameters: CreditsApiRecurringCreditsGetRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).recurringCreditsGet(requestParameters.teamId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Top up credits
     * @param {CreditsApiTopUpCreditsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public topUpCreditsPost(requestParameters: CreditsApiTopUpCreditsPostRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).topUpCreditsPost(requestParameters.creditTopUpOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch All Available Products
         * @param {string} [region] The region to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet: async (region?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a product\'s properties
         * @param {string} id 
         * @param {ProductUpdate} [productUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPatch: async (id: string, productUpdate?: ProductUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsPatch', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new product
         * @param {ProductCreate} [productCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPost: async (productCreate?: ProductCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch All Available Products
         * @param {string} [region] The region to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGet(region?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGet(region, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a product\'s properties
         * @param {string} id 
         * @param {ProductUpdate} [productUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsPatch(id: string, productUpdate?: ProductUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsPatch(id, productUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new product
         * @param {ProductCreate} [productCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsPost(productCreate?: ProductCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsPost(productCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch All Available Products
         * @param {ProductsApiProductsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet(requestParameters: ProductsApiProductsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ProductsGet200Response> {
            return localVarFp.productsGet(requestParameters.region, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a product\'s properties
         * @param {ProductsApiProductsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPatch(requestParameters: ProductsApiProductsPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.productsPatch(requestParameters.id, requestParameters.productUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new product
         * @param {ProductsApiProductsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPost(requestParameters: ProductsApiProductsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.productsPost(requestParameters.productCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for productsGet operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsGetRequest
 */
export interface ProductsApiProductsGetRequest {
    /**
     * The region to filter by
     * @type {string}
     * @memberof ProductsApiProductsGet
     */
    readonly region?: string
}

/**
 * Request parameters for productsPatch operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsPatchRequest
 */
export interface ProductsApiProductsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsPatch
     */
    readonly id: string

    /**
     * 
     * @type {ProductUpdate}
     * @memberof ProductsApiProductsPatch
     */
    readonly productUpdate?: ProductUpdate
}

/**
 * Request parameters for productsPost operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsPostRequest
 */
export interface ProductsApiProductsPostRequest {
    /**
     * 
     * @type {ProductCreate}
     * @memberof ProductsApiProductsPost
     */
    readonly productCreate?: ProductCreate
}

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch All Available Products
     * @param {ProductsApiProductsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsGet(requestParameters: ProductsApiProductsGetRequest = {}, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsGet(requestParameters.region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a product\'s properties
     * @param {ProductsApiProductsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsPatch(requestParameters: ProductsApiProductsPatchRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsPatch(requestParameters.id, requestParameters.productUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new product
     * @param {ProductsApiProductsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsPost(requestParameters: ProductsApiProductsPostRequest = {}, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsPost(requestParameters.productCreate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReferralsApi - axios parameter creator
 * @export
 */
export const ReferralsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartner: async (referralCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'referralCode' is not null or undefined
            assertParamExists('getPartner', 'referralCode', referralCode)
            const localVarPath = `/partner-referral/get-partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (referralCode !== undefined) {
                localVarQueryParameter['referralCode'] = referralCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsDelete: async (referralCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'referralCode' is not null or undefined
            assertParamExists('partnerReferralsDelete', 'referralCode', referralCode)
            const localVarPath = `/partner-referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PARTNER_ADMIN_PANEL_ACCESS", "ADMIN_PANEL_ACCESS"], configuration)

            if (referralCode !== undefined) {
                localVarQueryParameter['referralCode'] = referralCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] The page for the cursor
         * @param {number} [count] The numbers of items to return
         * @param {Array<string>} [id] The array of referralCodes to be fetched
         * @param {string} [q] Search by id, productId, etc
         * @param {boolean} [returnTotal] Include the total number of referralCodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsGet: async (page?: number, count?: number, id?: Array<string>, q?: string, returnTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partner-referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PARTNER_ADMIN_PANEL_ACCESS", "ADMIN_PANEL_ACCESS"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PartnerReferralCreateOptions} [partnerReferralCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsPost: async (partnerReferralCreateOptions?: PartnerReferralCreateOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partner-referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PARTNER_ADMIN_PANEL_ACCESS", "ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerReferralCreateOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferralsApi - functional programming interface
 * @export
 */
export const ReferralsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferralsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartner(referralCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPartner200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartner(referralCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerReferralsDelete(referralCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerReferralsDelete(referralCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] The page for the cursor
         * @param {number} [count] The numbers of items to return
         * @param {Array<string>} [id] The array of referralCodes to be fetched
         * @param {string} [q] Search by id, productId, etc
         * @param {boolean} [returnTotal] Include the total number of referralCodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerReferralsGet(page?: number, count?: number, id?: Array<string>, q?: string, returnTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerReferralsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerReferralsGet(page, count, id, q, returnTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PartnerReferralCreateOptions} [partnerReferralCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerReferralsPost(partnerReferralCreateOptions?: PartnerReferralCreateOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerReferralsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerReferralsPost(partnerReferralCreateOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReferralsApi - factory interface
 * @export
 */
export const ReferralsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferralsApiFp(configuration)
    return {
        /**
         * 
         * @param {ReferralsApiGetPartnerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartner(requestParameters: ReferralsApiGetPartnerRequest, options?: AxiosRequestConfig): AxiosPromise<GetPartner200Response> {
            return localVarFp.getPartner(requestParameters.referralCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReferralsApiPartnerReferralsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsDelete(requestParameters: ReferralsApiPartnerReferralsDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.partnerReferralsDelete(requestParameters.referralCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReferralsApiPartnerReferralsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsGet(requestParameters: ReferralsApiPartnerReferralsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PartnerReferralsGet200Response> {
            return localVarFp.partnerReferralsGet(requestParameters.page, requestParameters.count, requestParameters.id, requestParameters.q, requestParameters.returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReferralsApiPartnerReferralsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsPost(requestParameters: ReferralsApiPartnerReferralsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PartnerReferralsPost200Response> {
            return localVarFp.partnerReferralsPost(requestParameters.partnerReferralCreateOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPartner operation in ReferralsApi.
 * @export
 * @interface ReferralsApiGetPartnerRequest
 */
export interface ReferralsApiGetPartnerRequest {
    /**
     * 
     * @type {string}
     * @memberof ReferralsApiGetPartner
     */
    readonly referralCode: string
}

/**
 * Request parameters for partnerReferralsDelete operation in ReferralsApi.
 * @export
 * @interface ReferralsApiPartnerReferralsDeleteRequest
 */
export interface ReferralsApiPartnerReferralsDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ReferralsApiPartnerReferralsDelete
     */
    readonly referralCode: string
}

/**
 * Request parameters for partnerReferralsGet operation in ReferralsApi.
 * @export
 * @interface ReferralsApiPartnerReferralsGetRequest
 */
export interface ReferralsApiPartnerReferralsGetRequest {
    /**
     * The page for the cursor
     * @type {number}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly page?: number

    /**
     * The numbers of items to return
     * @type {number}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly count?: number

    /**
     * The array of referralCodes to be fetched
     * @type {Array<string>}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly id?: Array<string>

    /**
     * Search by id, productId, etc
     * @type {string}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly q?: string

    /**
     * Include the total number of referralCodes
     * @type {boolean}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for partnerReferralsPost operation in ReferralsApi.
 * @export
 * @interface ReferralsApiPartnerReferralsPostRequest
 */
export interface ReferralsApiPartnerReferralsPostRequest {
    /**
     * 
     * @type {PartnerReferralCreateOptions}
     * @memberof ReferralsApiPartnerReferralsPost
     */
    readonly partnerReferralCreateOptions?: PartnerReferralCreateOptions
}

/**
 * ReferralsApi - object-oriented interface
 * @export
 * @class ReferralsApi
 * @extends {BaseAPI}
 */
export class ReferralsApi extends BaseAPI {
    /**
     * 
     * @param {ReferralsApiGetPartnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public getPartner(requestParameters: ReferralsApiGetPartnerRequest, options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).getPartner(requestParameters.referralCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReferralsApiPartnerReferralsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public partnerReferralsDelete(requestParameters: ReferralsApiPartnerReferralsDeleteRequest, options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).partnerReferralsDelete(requestParameters.referralCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReferralsApiPartnerReferralsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public partnerReferralsGet(requestParameters: ReferralsApiPartnerReferralsGetRequest = {}, options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).partnerReferralsGet(requestParameters.page, requestParameters.count, requestParameters.id, requestParameters.q, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReferralsApiPartnerReferralsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public partnerReferralsPost(requestParameters: ReferralsApiPartnerReferralsPostRequest = {}, options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).partnerReferralsPost(requestParameters.partnerReferralCreateOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StripeApi - axios parameter creator
 * @export
 */
export const StripeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {string} returnUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingSessionPost: async (returnUrl: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'returnUrl' is not null or undefined
            assertParamExists('billingSessionPost', 'returnUrl', returnUrl)
            const localVarPath = `/billing-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a checkout session
         * @param {CheckoutCreateOptions} [checkoutCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeCheckout: async (checkoutCreateOptions?: CheckoutCreateOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/checkout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutCreateOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Receive stripe hook
         * @param {string} secret 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeHook: async (secret: string, requestBody?: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secret' is not null or undefined
            assertParamExists('stripeHook', 'secret', secret)
            const localVarPath = `/stripe/webhook/{secret}`
                .replace(`{${"secret"}}`, encodeURIComponent(String(secret)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use results from here to attach prices to products.
         * @summary Get prices from Stripe
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {string} [q] Filter by stripe query. See https://stripe.com/docs/search#search-query-language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripePricesGet: async (count?: number, cursor?: string, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/prices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {string} returnUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingSessionPost(returnUrl: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingSessionPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingSessionPost(returnUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a checkout session
         * @param {CheckoutCreateOptions} [checkoutCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeCheckout(checkoutCreateOptions?: CheckoutCreateOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeCheckout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripeCheckout(checkoutCreateOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Receive stripe hook
         * @param {string} secret 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeHook(secret: string, requestBody?: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripeHook(secret, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use results from here to attach prices to products.
         * @summary Get prices from Stripe
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {string} [q] Filter by stripe query. See https://stripe.com/docs/search#search-query-language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripePricesGet(count?: number, cursor?: string, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripePricesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripePricesGet(count, cursor, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {StripeApiBillingSessionPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingSessionPost(requestParameters: StripeApiBillingSessionPostRequest, options?: AxiosRequestConfig): AxiosPromise<BillingSessionPost200Response> {
            return localVarFp.billingSessionPost(requestParameters.returnUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a checkout session
         * @param {StripeApiStripeCheckoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeCheckout(requestParameters: StripeApiStripeCheckoutRequest = {}, options?: AxiosRequestConfig): AxiosPromise<StripeCheckout200Response> {
            return localVarFp.stripeCheckout(requestParameters.checkoutCreateOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Receive stripe hook
         * @param {StripeApiStripeHookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeHook(requestParameters: StripeApiStripeHookRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stripeHook(requestParameters.secret, requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Use results from here to attach prices to products.
         * @summary Get prices from Stripe
         * @param {StripeApiStripePricesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripePricesGet(requestParameters: StripeApiStripePricesGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<StripePricesGet200Response> {
            return localVarFp.stripePricesGet(requestParameters.count, requestParameters.cursor, requestParameters.q, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for billingSessionPost operation in StripeApi.
 * @export
 * @interface StripeApiBillingSessionPostRequest
 */
export interface StripeApiBillingSessionPostRequest {
    /**
     * 
     * @type {string}
     * @memberof StripeApiBillingSessionPost
     */
    readonly returnUrl: string
}

/**
 * Request parameters for stripeCheckout operation in StripeApi.
 * @export
 * @interface StripeApiStripeCheckoutRequest
 */
export interface StripeApiStripeCheckoutRequest {
    /**
     * 
     * @type {CheckoutCreateOptions}
     * @memberof StripeApiStripeCheckout
     */
    readonly checkoutCreateOptions?: CheckoutCreateOptions
}

/**
 * Request parameters for stripeHook operation in StripeApi.
 * @export
 * @interface StripeApiStripeHookRequest
 */
export interface StripeApiStripeHookRequest {
    /**
     * 
     * @type {string}
     * @memberof StripeApiStripeHook
     */
    readonly secret: string

    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof StripeApiStripeHook
     */
    readonly requestBody?: { [key: string]: any; }
}

/**
 * Request parameters for stripePricesGet operation in StripeApi.
 * @export
 * @interface StripeApiStripePricesGetRequest
 */
export interface StripeApiStripePricesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof StripeApiStripePricesGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof StripeApiStripePricesGet
     */
    readonly cursor?: string

    /**
     * Filter by stripe query. See https://stripe.com/docs/search#search-query-language
     * @type {string}
     * @memberof StripeApiStripePricesGet
     */
    readonly q?: string
}

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
    /**
     * 
     * @summary Create a new billing portal session to manage payment details
     * @param {StripeApiBillingSessionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public billingSessionPost(requestParameters: StripeApiBillingSessionPostRequest, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).billingSessionPost(requestParameters.returnUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a checkout session
     * @param {StripeApiStripeCheckoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public stripeCheckout(requestParameters: StripeApiStripeCheckoutRequest = {}, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).stripeCheckout(requestParameters.checkoutCreateOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Receive stripe hook
     * @param {StripeApiStripeHookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public stripeHook(requestParameters: StripeApiStripeHookRequest, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).stripeHook(requestParameters.secret, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use results from here to attach prices to products.
     * @summary Get prices from Stripe
     * @param {StripeApiStripePricesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public stripePricesGet(requestParameters: StripeApiStripePricesGetRequest = {}, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).stripePricesGet(requestParameters.count, requestParameters.cursor, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the list of subscriptions
         * @param {string} [teamId] Filter by teamId
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {string} [q] Search by subscription ID, team ID or product name
         * @param {boolean} [includeFreeTier] Include free tier subscriptions
         * @param {'startDate' | 'endOrNextRenewalDate'} [sortBy] Sort by the given field
         * @param {'asc' | 'desc'} [sortDirection] Sort direction
         * @param {string} [endsOrRenewsAfter] Filter subscriptions that end or renew after the given date
         * @param {string} [endsOrRenewsBefore] Filter subscriptions that end or renew before the given date
         * @param {boolean} [stripeOnly] Filter subscriptions that are only in Stripe
         * @param {Array<string>} [product] Filter subscriptions by product
         * @param {boolean} [returnTotal] Return total number of subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsGet: async (teamId?: string, count?: number, page?: number, q?: string, includeFreeTier?: boolean, sortBy?: 'startDate' | 'endOrNextRenewalDate', sortDirection?: 'asc' | 'desc', endsOrRenewsAfter?: string, endsOrRenewsBefore?: string, stripeOnly?: boolean, product?: Array<string>, returnTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ"], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (includeFreeTier !== undefined) {
                localVarQueryParameter['includeFreeTier'] = includeFreeTier;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }

            if (endsOrRenewsAfter !== undefined) {
                localVarQueryParameter['endsOrRenewsAfter'] = (endsOrRenewsAfter as any instanceof Date) ?
                    (endsOrRenewsAfter as any).toISOString() :
                    endsOrRenewsAfter;
            }

            if (endsOrRenewsBefore !== undefined) {
                localVarQueryParameter['endsOrRenewsBefore'] = (endsOrRenewsBefore as any instanceof Date) ?
                    (endsOrRenewsBefore as any).toISOString() :
                    endsOrRenewsBefore;
            }

            if (stripeOnly !== undefined) {
                localVarQueryParameter['stripeOnly'] = stripeOnly;
            }

            if (product) {
                localVarQueryParameter['product'] = product;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a subscription\'s properties
         * @param {string} id 
         * @param {SubscriptionUpdate} [subscriptionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPatch: async (id: string, subscriptionUpdate?: SubscriptionUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subscriptionsPatch', 'id', id)
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subscription created here does not get counted in revenue. Not recommended, create a payment link instead.
         * @summary Manually create a subscription for the team
         * @param {SubscriptionCreate} [subscriptionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPost: async (subscriptionCreate?: SubscriptionCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the list of subscriptions
         * @param {string} [teamId] Filter by teamId
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {string} [q] Search by subscription ID, team ID or product name
         * @param {boolean} [includeFreeTier] Include free tier subscriptions
         * @param {'startDate' | 'endOrNextRenewalDate'} [sortBy] Sort by the given field
         * @param {'asc' | 'desc'} [sortDirection] Sort direction
         * @param {string} [endsOrRenewsAfter] Filter subscriptions that end or renew after the given date
         * @param {string} [endsOrRenewsBefore] Filter subscriptions that end or renew before the given date
         * @param {boolean} [stripeOnly] Filter subscriptions that are only in Stripe
         * @param {Array<string>} [product] Filter subscriptions by product
         * @param {boolean} [returnTotal] Return total number of subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsGet(teamId?: string, count?: number, page?: number, q?: string, includeFreeTier?: boolean, sortBy?: 'startDate' | 'endOrNextRenewalDate', sortDirection?: 'asc' | 'desc', endsOrRenewsAfter?: string, endsOrRenewsBefore?: string, stripeOnly?: boolean, product?: Array<string>, returnTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsGet(teamId, count, page, q, includeFreeTier, sortBy, sortDirection, endsOrRenewsAfter, endsOrRenewsBefore, stripeOnly, product, returnTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a subscription\'s properties
         * @param {string} id 
         * @param {SubscriptionUpdate} [subscriptionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsPatch(id: string, subscriptionUpdate?: SubscriptionUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsPatch(id, subscriptionUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Subscription created here does not get counted in revenue. Not recommended, create a payment link instead.
         * @summary Manually create a subscription for the team
         * @param {SubscriptionCreate} [subscriptionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsPost(subscriptionCreate?: SubscriptionCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsPost(subscriptionCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the list of subscriptions
         * @param {SubscriptionsApiSubscriptionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsGet(requestParameters: SubscriptionsApiSubscriptionsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<SubscriptionsGet200Response> {
            return localVarFp.subscriptionsGet(requestParameters.teamId, requestParameters.count, requestParameters.page, requestParameters.q, requestParameters.includeFreeTier, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.endsOrRenewsAfter, requestParameters.endsOrRenewsBefore, requestParameters.stripeOnly, requestParameters.product, requestParameters.returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a subscription\'s properties
         * @param {SubscriptionsApiSubscriptionsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPatch(requestParameters: SubscriptionsApiSubscriptionsPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.subscriptionsPatch(requestParameters.id, requestParameters.subscriptionUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Subscription created here does not get counted in revenue. Not recommended, create a payment link instead.
         * @summary Manually create a subscription for the team
         * @param {SubscriptionsApiSubscriptionsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPost(requestParameters: SubscriptionsApiSubscriptionsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Subscription> {
            return localVarFp.subscriptionsPost(requestParameters.subscriptionCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for subscriptionsGet operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiSubscriptionsGetRequest
 */
export interface SubscriptionsApiSubscriptionsGetRequest {
    /**
     * Filter by teamId
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly teamId?: string

    /**
     * 
     * @type {number}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly count?: number

    /**
     * 
     * @type {number}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly page?: number

    /**
     * Search by subscription ID, team ID or product name
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly q?: string

    /**
     * Include free tier subscriptions
     * @type {boolean}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly includeFreeTier?: boolean

    /**
     * Sort by the given field
     * @type {'startDate' | 'endOrNextRenewalDate'}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly sortBy?: 'startDate' | 'endOrNextRenewalDate'

    /**
     * Sort direction
     * @type {'asc' | 'desc'}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly sortDirection?: 'asc' | 'desc'

    /**
     * Filter subscriptions that end or renew after the given date
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly endsOrRenewsAfter?: string

    /**
     * Filter subscriptions that end or renew before the given date
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly endsOrRenewsBefore?: string

    /**
     * Filter subscriptions that are only in Stripe
     * @type {boolean}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly stripeOnly?: boolean

    /**
     * Filter subscriptions by product
     * @type {Array<string>}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly product?: Array<string>

    /**
     * Return total number of subscriptions
     * @type {boolean}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for subscriptionsPatch operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiSubscriptionsPatchRequest
 */
export interface SubscriptionsApiSubscriptionsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsPatch
     */
    readonly id: string

    /**
     * 
     * @type {SubscriptionUpdate}
     * @memberof SubscriptionsApiSubscriptionsPatch
     */
    readonly subscriptionUpdate?: SubscriptionUpdate
}

/**
 * Request parameters for subscriptionsPost operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiSubscriptionsPostRequest
 */
export interface SubscriptionsApiSubscriptionsPostRequest {
    /**
     * 
     * @type {SubscriptionCreate}
     * @memberof SubscriptionsApiSubscriptionsPost
     */
    readonly subscriptionCreate?: SubscriptionCreate
}

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * 
     * @summary Get the list of subscriptions
     * @param {SubscriptionsApiSubscriptionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsGet(requestParameters: SubscriptionsApiSubscriptionsGetRequest = {}, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscriptionsGet(requestParameters.teamId, requestParameters.count, requestParameters.page, requestParameters.q, requestParameters.includeFreeTier, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.endsOrRenewsAfter, requestParameters.endsOrRenewsBefore, requestParameters.stripeOnly, requestParameters.product, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a subscription\'s properties
     * @param {SubscriptionsApiSubscriptionsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsPatch(requestParameters: SubscriptionsApiSubscriptionsPatchRequest, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscriptionsPatch(requestParameters.id, requestParameters.subscriptionUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subscription created here does not get counted in revenue. Not recommended, create a payment link instead.
     * @summary Manually create a subscription for the team
     * @param {SubscriptionsApiSubscriptionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsPost(requestParameters: SubscriptionsApiSubscriptionsPostRequest = {}, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscriptionsPost(requestParameters.subscriptionCreate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamDetailApi - axios parameter creator
 * @export
 */
export const TeamDetailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If the account is an independent account, the access details for the account are returned. Otherwise, the team\'s access details are returned.
         * @summary Get the access details for the given account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailAccountAccessGet: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('teamDetailAccountAccessGet', 'accountId', accountId)
            const localVarPath = `/team-detail/account-access/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the team\'s subscription and payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/team-detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the team\'s subscription and payment details
         * @param {TeamDetailUpdate} [teamDetailUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailPatch: async (teamDetailUpdate?: TeamDetailUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/team-detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamDetailUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initialise a team with the free tier
         * @param {TeamDetailCreate} [teamDetailCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailPost: async (teamDetailCreate?: TeamDetailCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/team-detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamDetailCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the access given by subscriptions
         * @param {boolean} [refreshUsage] Refreshes usage statistics as well
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailRefreshAccess: async (refreshUsage?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/team-detail/refresh-access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)

            if (refreshUsage !== undefined) {
                localVarQueryParameter['refreshUsage'] = refreshUsage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamDetailApi - functional programming interface
 * @export
 */
export const TeamDetailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamDetailApiAxiosParamCreator(configuration)
    return {
        /**
         * If the account is an independent account, the access details for the account are returned. Otherwise, the team\'s access details are returned.
         * @summary Get the access details for the given account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailAccountAccessGet(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountAccessDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailAccountAccessGet(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the team\'s subscription and payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the team\'s subscription and payment details
         * @param {TeamDetailUpdate} [teamDetailUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailPatch(teamDetailUpdate?: TeamDetailUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailPatch(teamDetailUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Initialise a team with the free tier
         * @param {TeamDetailCreate} [teamDetailCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailPost(teamDetailCreate?: TeamDetailCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailPost(teamDetailCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the access given by subscriptions
         * @param {boolean} [refreshUsage] Refreshes usage statistics as well
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailRefreshAccess(refreshUsage?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailRefreshAccess(refreshUsage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamDetailApi - factory interface
 * @export
 */
export const TeamDetailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamDetailApiFp(configuration)
    return {
        /**
         * If the account is an independent account, the access details for the account are returned. Otherwise, the team\'s access details are returned.
         * @summary Get the access details for the given account
         * @param {TeamDetailApiTeamDetailAccountAccessGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailAccountAccessGet(requestParameters: TeamDetailApiTeamDetailAccountAccessGetRequest, options?: AxiosRequestConfig): AxiosPromise<AccountAccessDetail> {
            return localVarFp.teamDetailAccountAccessGet(requestParameters.accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the team\'s subscription and payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailGet(options?: AxiosRequestConfig): AxiosPromise<TeamDetail> {
            return localVarFp.teamDetailGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the team\'s subscription and payment details
         * @param {TeamDetailApiTeamDetailPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailPatch(requestParameters: TeamDetailApiTeamDetailPatchRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.teamDetailPatch(requestParameters.teamDetailUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initialise a team with the free tier
         * @param {TeamDetailApiTeamDetailPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailPost(requestParameters: TeamDetailApiTeamDetailPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<TeamDetail> {
            return localVarFp.teamDetailPost(requestParameters.teamDetailCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the access given by subscriptions
         * @param {TeamDetailApiTeamDetailRefreshAccessRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailRefreshAccess(requestParameters: TeamDetailApiTeamDetailRefreshAccessRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.teamDetailRefreshAccess(requestParameters.refreshUsage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for teamDetailAccountAccessGet operation in TeamDetailApi.
 * @export
 * @interface TeamDetailApiTeamDetailAccountAccessGetRequest
 */
export interface TeamDetailApiTeamDetailAccountAccessGetRequest {
    /**
     * 
     * @type {string}
     * @memberof TeamDetailApiTeamDetailAccountAccessGet
     */
    readonly accountId: string
}

/**
 * Request parameters for teamDetailPatch operation in TeamDetailApi.
 * @export
 * @interface TeamDetailApiTeamDetailPatchRequest
 */
export interface TeamDetailApiTeamDetailPatchRequest {
    /**
     * 
     * @type {TeamDetailUpdate}
     * @memberof TeamDetailApiTeamDetailPatch
     */
    readonly teamDetailUpdate?: TeamDetailUpdate
}

/**
 * Request parameters for teamDetailPost operation in TeamDetailApi.
 * @export
 * @interface TeamDetailApiTeamDetailPostRequest
 */
export interface TeamDetailApiTeamDetailPostRequest {
    /**
     * 
     * @type {TeamDetailCreate}
     * @memberof TeamDetailApiTeamDetailPost
     */
    readonly teamDetailCreate?: TeamDetailCreate
}

/**
 * Request parameters for teamDetailRefreshAccess operation in TeamDetailApi.
 * @export
 * @interface TeamDetailApiTeamDetailRefreshAccessRequest
 */
export interface TeamDetailApiTeamDetailRefreshAccessRequest {
    /**
     * Refreshes usage statistics as well
     * @type {boolean}
     * @memberof TeamDetailApiTeamDetailRefreshAccess
     */
    readonly refreshUsage?: boolean
}

/**
 * TeamDetailApi - object-oriented interface
 * @export
 * @class TeamDetailApi
 * @extends {BaseAPI}
 */
export class TeamDetailApi extends BaseAPI {
    /**
     * If the account is an independent account, the access details for the account are returned. Otherwise, the team\'s access details are returned.
     * @summary Get the access details for the given account
     * @param {TeamDetailApiTeamDetailAccountAccessGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailAccountAccessGet(requestParameters: TeamDetailApiTeamDetailAccountAccessGetRequest, options?: AxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailAccountAccessGet(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the team\'s subscription and payment details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailGet(options?: AxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the team\'s subscription and payment details
     * @param {TeamDetailApiTeamDetailPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailPatch(requestParameters: TeamDetailApiTeamDetailPatchRequest = {}, options?: AxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailPatch(requestParameters.teamDetailUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initialise a team with the free tier
     * @param {TeamDetailApiTeamDetailPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailPost(requestParameters: TeamDetailApiTeamDetailPostRequest = {}, options?: AxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailPost(requestParameters.teamDetailCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
     * @summary Refreshes the access given by subscriptions
     * @param {TeamDetailApiTeamDetailRefreshAccessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailRefreshAccess(requestParameters: TeamDetailApiTeamDetailRefreshAccessRequest = {}, options?: AxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailRefreshAccess(requestParameters.refreshUsage, options).then((request) => request(this.axios, this.basePath));
    }
}


