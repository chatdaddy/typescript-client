const BASE_PATH = "https://api.chatdaddy.tech/payments".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Payments Service
 * Manage all payment/subscription related operations
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: info@chatdaddy.tech
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError } from '../base';

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * 
     * @type {Array<Feature>}
     * @memberof Access
     */
    'features': Array<Feature>;
    /**
     * 
     * @type {LimitationMap}
     * @memberof Access
     */
    'limits': LimitationMap;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Access
     */
    'lastExpiryOrRenewalDate'?: string;
}
/**
 * 
 * @export
 * @interface AccountAccess
 */
export interface AccountAccess {
    /**
     * 
     * @type {Array<AccountFeature>}
     * @memberof AccountAccess
     */
    'features': Array<AccountFeature>;
    /**
     * 
     * @type {AccountLimitationMap}
     * @memberof AccountAccess
     */
    'limits': AccountLimitationMap;
}
/**
 * 
 * @export
 * @interface AccountAccessDetail
 */
export interface AccountAccessDetail {
    /**
     * 
     * @type {AccountAccess}
     * @memberof AccountAccessDetail
     */
    'access': AccountAccess;
    /**
     * 
     * @type {LimitationMap}
     * @memberof AccountAccessDetail
     */
    'usage': LimitationMap;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AccountFeature = {
    TeamInbox: 'team-inbox',
    CustomMarketingMessage: 'custom-marketing-message',
    ChatHistorySync: 'chat-history-sync'
} as const;

export type AccountFeature = typeof AccountFeature[keyof typeof AccountFeature];


/**
 * 
 * @export
 * @interface AccountLimitationMap
 */
export interface AccountLimitationMap {
    /**
     * The number of messages that can be sent per month.
     * @type {number}
     * @memberof AccountLimitationMap
     */
    'messages'?: number;
}
/**
 * 
 * @export
 * @interface AmountWithCurrency
 */
export interface AmountWithCurrency {
    /**
     * The amount in cents. So 100 is $1.00
     * @type {number}
     * @memberof AmountWithCurrency
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof AmountWithCurrency
     */
    'currency': string;
}
/**
 * @type AnyCreditConsumptionType
 * @export
 */
export type AnyCreditConsumptionType = CreditConsumptionType | RecurringCreditConsumptionType;

/**
 * 
 * @export
 * @interface AutoChargeProduct
 */
export interface AutoChargeProduct {
    /**
     * 
     * @type {LimitedItem}
     * @memberof AutoChargeProduct
     */
    'item': LimitedItem;
    /**
     * 
     * @type {string}
     * @memberof AutoChargeProduct
     */
    'stripePriceId': string;
}


/**
 * 
 * @export
 * @interface AutoChargeProductSet
 */
export interface AutoChargeProductSet {
    /**
     * 
     * @type {LimitedItem}
     * @memberof AutoChargeProductSet
     */
    'item': LimitedItem;
    /**
     * If null, auto charge for this item is disabled. Otherwise, this is the stripe price ID to charge for this item.
     * @type {string}
     * @memberof AutoChargeProductSet
     */
    'stripePriceId': string | null;
}


/**
 * 
 * @export
 * @interface AutoChargeProductsGet200Response
 */
export interface AutoChargeProductsGet200Response {
    /**
     * 
     * @type {Array<AutoChargeProduct>}
     * @memberof AutoChargeProductsGet200Response
     */
    'items': Array<AutoChargeProduct>;
}
/**
 * 
 * @export
 * @interface AutoChargeProductsPrepare200Response
 */
export interface AutoChargeProductsPrepare200Response {
    /**
     * 
     * @type {Access}
     * @memberof AutoChargeProductsPrepare200Response
     */
    'access': Access;
    /**
     * 
     * @type {LimitationMap}
     * @memberof AutoChargeProductsPrepare200Response
     */
    'usage': LimitationMap;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AutoRenewalPeriod = {
    Quarter: 'quarter',
    Year: 'year'
} as const;

export type AutoRenewalPeriod = typeof AutoRenewalPeriod[keyof typeof AutoRenewalPeriod];


/**
 * 
 * @export
 * @enum {string}
 */

export const BillingPeriod = {
    Month: 'month',
    Quarter: 'quarter',
    Year: 'year'
} as const;

export type BillingPeriod = typeof BillingPeriod[keyof typeof BillingPeriod];


/**
 * 
 * @export
 * @interface BillingSessionPost200Response
 */
export interface BillingSessionPost200Response {
    /**
     * 
     * @type {string}
     * @memberof BillingSessionPost200Response
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof BillingSessionPost200Response
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface CheckoutCreateOptions
 */
export interface CheckoutCreateOptions {
    /**
     * 
     * @type {CheckoutCreateOptionsCallbackUrls}
     * @memberof CheckoutCreateOptions
     */
    'callbackUrls': CheckoutCreateOptionsCallbackUrls;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateOptions
     */
    'coupon'?: string;
    /**
     * 
     * @type {Array<ProductsSelectionInner>}
     * @memberof CheckoutCreateOptions
     */
    'products': Array<ProductsSelectionInner>;
    /**
     * Add extra days to a subscription. Can only set using admin access
     * @type {number}
     * @memberof CheckoutCreateOptions
     */
    'extraDays'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CheckoutCreateOptions
     */
    'disableAutoRenew'?: boolean;
}
/**
 * 
 * @export
 * @interface CheckoutCreateOptionsCallbackUrls
 */
export interface CheckoutCreateOptionsCallbackUrls {
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateOptionsCallbackUrls
     */
    'success': string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateOptionsCallbackUrls
     */
    'failure': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CountryTier = {
    Tier1: 'tier1',
    Tier2: 'tier2',
    Tier3: 'tier3',
    Tier4: 'tier4'
} as const;

export type CountryTier = typeof CountryTier[keyof typeof CountryTier];


/**
 * 
 * @export
 * @interface Coupon
 */
export interface Coupon {
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof Coupon
     */
    'id': string;
    /**
     * The percentage off the coupon provides
     * @type {number}
     * @memberof Coupon
     */
    'percentageOff': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Coupon
     */
    'createdAt': string;
    /**
     * The ID of a user
     * @type {string}
     * @memberof Coupon
     */
    'createdBy': string;
    /**
     * If true, the coupon can be used for all subsequent billing cycles, else, only the first
     * @type {boolean}
     * @memberof Coupon
     */
    'isRecurring'?: boolean;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Coupon
     */
    'expiresAt'?: string | null;
    /**
     * limit coupon code to certain product types. If not provided, coupon code is applicable to all recurring product types
     * @type {Array<AnyCreditConsumptionType>}
     * @memberof Coupon
     */
    'creditConsumptionTypes': Array<AnyCreditConsumptionType>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Coupon
     */
    'archivedAt'?: string | null;
    /**
     * The partnership to use for this coupon. Only partnership teams can redeem this coupon.
     * @type {string}
     * @memberof Coupon
     */
    'partnership'?: string;
    /**
     * 
     * @type {CouponValidation}
     * @memberof Coupon
     */
    'couponValidation'?: CouponValidation;
}
/**
 * 
 * @export
 * @interface CouponCodeCreateOptions
 */
export interface CouponCodeCreateOptions {
    /**
     * 
     * @type {string}
     * @memberof CouponCodeCreateOptions
     */
    'category': string;
    /**
     * limit coupon code to products
     * @type {Array<string>}
     * @memberof CouponCodeCreateOptions
     */
    'products'?: Array<string>;
    /**
     * set free trial. Can only set using admin access
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'freeTrialDays'?: number;
    /**
     * Add extra days to a subscription. Can only set using admin access
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'extraDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof CouponCodeCreateOptions
     */
    'discountPercentageOff': number;
}
/**
 * 
 * @export
 * @interface CouponValidation
 */
export interface CouponValidation {
    /**
     * 
     * @type {Array<AutoRenewalPeriod>}
     * @memberof CouponValidation
     */
    'period'?: Array<AutoRenewalPeriod>;
}
/**
 * 
 * @export
 * @interface CouponsPost200Response
 */
export interface CouponsPost200Response {
    /**
     * 
     * @type {string}
     * @memberof CouponsPost200Response
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface CreditAmountObj
 */
export interface CreditAmountObj {
    /**
     * 
     * @type {number}
     * @memberof CreditAmountObj
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface CreditAutoRenewalUpdate
 */
export interface CreditAutoRenewalUpdate {
    /**
     * 
     * @type {AutoRenewalPeriod}
     * @memberof CreditAutoRenewalUpdate
     */
    'period': AutoRenewalPeriod;
    /**
     * 
     * @type {CreditUnitsPurchaseOpts}
     * @memberof CreditAutoRenewalUpdate
     */
    'units': CreditUnitsPurchaseOpts;
    /**
     * 
     * @type {MiscBillingOptions}
     * @memberof CreditAutoRenewalUpdate
     */
    'options'?: MiscBillingOptions;
}


/**
 * @type CreditBalanceEffectType
 * All the ways a team\'s credit balance can be affected.
 * @export
 */
export type CreditBalanceEffectType = CreditConsumptionType | CreditGainType | RecurringCreditConsumptionType;

/**
 * 
 * @export
 * @interface CreditCanConsumeResponse
 */
export interface CreditCanConsumeResponse {
    /**
     * 
     * @type {Array<CreditUnlockType>}
     * @memberof CreditCanConsumeResponse
     */
    'unlocks': Array<CreditUnlockType>;
}
/**
 * 
 * @export
 * @interface CreditConsumptionCreate
 */
export interface CreditConsumptionCreate {
    /**
     * 
     * @type {CreditConsumptionType}
     * @memberof CreditConsumptionCreate
     */
    'type': CreditConsumptionType;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CreditConsumptionCreate
     */
    'createdAt'?: string;
    /**
     * The ID of the object that was consumed. (createdAt, objectId) will be enforced to be unique.
     * @type {string}
     * @memberof CreditConsumptionCreate
     */
    'objectId': string;
    /**
     * The ID of a team
     * @type {string}
     * @memberof CreditConsumptionCreate
     */
    'teamId': string;
    /**
     * Multiplier for the number of units to consume of this consumption type. For eg. if multiplier is 2, and each consumption of this type consumes 5 units, then 10 units will be consumed.
     * @type {number}
     * @memberof CreditConsumptionCreate
     */
    'multiplier'?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CreditConsumptionCreate
     */
    'metadata'?: { [key: string]: any; };
}


/**
 * 
 * @export
 * @interface CreditConsumptionPostRequest
 */
export interface CreditConsumptionPostRequest {
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof CreditConsumptionPostRequest
     */
    'customerId': string;
    /**
     * 
     * @type {Array<CreditConsumptionCreate>}
     * @memberof CreditConsumptionPostRequest
     */
    'items': Array<CreditConsumptionCreate>;
}
/**
 * 
 * @export
 * @interface CreditConsumptionRecordData
 */
export interface CreditConsumptionRecordData {
    /**
     * 
     * @type {CreditConsumptionRecordDataType}
     * @memberof CreditConsumptionRecordData
     */
    'type': CreditConsumptionRecordDataType;
    /**
     * 
     * @type {string}
     * @memberof CreditConsumptionRecordData
     */
    'teamId'?: string;
    /**
     * ID of a recurring credit consumption
     * @type {string}
     * @memberof CreditConsumptionRecordData
     */
    'recurringConsumptionId'?: string;
}
/**
 * @type CreditConsumptionRecordDataType
 * @export
 */
export type CreditConsumptionRecordDataType = CreditConsumptionType | RecurringCreditConsumptionType;

/**
 * 
 * @export
 * @interface CreditConsumptionTier
 */
export interface CreditConsumptionTier {
    /**
     * Cost per unit of consumption
     * @type {number}
     * @memberof CreditConsumptionTier
     */
    'perUnitCost': number;
    /**
     * Maximum number of items that can be consumed before the next tier is used. This limit is inclusive as well. Undefined means no cap.
     * @type {number}
     * @memberof CreditConsumptionTier
     */
    'maxItems'?: number;
}
/**
 * Enum of all the types of single-use credit consumption. This is used to track the usage of credits. Category of consumptions are separated by a slash.
 * @export
 * @enum {string}
 */

export const CreditConsumptionType = {
    MessageSentWa: 'message_sent/wa',
    MessageSentMail: 'message_sent/mail',
    MessageSentSms: 'message_sent/sms',
    ConversationWaBusinessApi: 'conversation/wa-business-api',
    VoiceCall: 'voice_call',
    IntegrationNotification: 'integration/notification',
    IntegrationPayment: 'integration/payment',
    AiChatbot: 'ai_chatbot',
    Consultation1h: 'consultation/1h',
    AdminDiscretionary: 'admin/discretionary',
    AdminRefund: 'admin/refund',
    AdminExpiredCreditGain: 'admin/expired_credit_gain',
    ConsultationTraining: 'consultation/training',
    ActiveChat: 'active_chat',
    AiCreditUse: 'ai_credit_use'
} as const;

export type CreditConsumptionType = typeof CreditConsumptionType[keyof typeof CreditConsumptionType];


/**
 * 
 * @export
 * @interface CreditCouponCodeCreateOptions
 */
export interface CreditCouponCodeCreateOptions {
    /**
     * limit coupon code to certain product types. If not provided, coupon code is applicable to all recurring product types
     * @type {Array<AnyCreditConsumptionType>}
     * @memberof CreditCouponCodeCreateOptions
     */
    'creditConsumptionTypes'?: Array<AnyCreditConsumptionType>;
    /**
     * 
     * @type {number}
     * @memberof CreditCouponCodeCreateOptions
     */
    'discountPercentageOff': number;
    /**
     * 
     * @type {boolean}
     * @memberof CreditCouponCodeCreateOptions
     */
    'isRecurring'?: boolean;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CreditCouponCodeCreateOptions
     */
    'expiresAt'?: string | null;
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof CreditCouponCodeCreateOptions
     */
    'id'?: string;
    /**
     * 
     * @type {CouponValidation}
     * @memberof CreditCouponCodeCreateOptions
     */
    'couponValidation'?: CouponValidation;
}
/**
 * 
 * @export
 * @interface CreditCustomer
 */
export interface CreditCustomer {
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof CreditCustomer
     */
    'id': string;
    /**
     * Total number of units available for consumption
     * @type {number}
     * @memberof CreditCustomer
     */
    'unitsAvailable': number;
    /**
     * Number of units consumed per period.
     * @type {number}
     * @memberof CreditCustomer
     */
    'recurringConsumptionUnits': number;
    /**
     * List of features that have been unlocked.
     * @type {Array<CreditUnlockType>}
     * @memberof CreditCustomer
     */
    'unlockedFeatures': Array<CreditUnlockType>;
    /**
     * 
     * @type {CustomerAutoRenewalWRedeemedCoupon}
     * @memberof CreditCustomer
     */
    'autoRenewal'?: CustomerAutoRenewalWRedeemedCoupon;
    /**
     * 
     * @type {CountryTier}
     * @memberof CreditCustomer
     */
    'tier'?: CountryTier;
    /**
     * 
     * @type {CreditLevelStatus}
     * @memberof CreditCustomer
     */
    'creditLevelStatus'?: CreditLevelStatus | null;
    /**
     * 
     * @type {RecurringCreditConsumption}
     * @memberof CreditCustomer
     */
    'supportPlan'?: RecurringCreditConsumption;
    /**
     * 
     * @type {CreditCustomerRecurringPlans}
     * @memberof CreditCustomer
     */
    'recurringPlans'?: CreditCustomerRecurringPlans;
    /**
     * The partnership to use for this customer. This is only used if the customer is new.
     * @type {string}
     * @memberof CreditCustomer
     */
    'partnership'?: string;
    /**
     * Region from which the customer is from.
     * @type {string}
     * @memberof CreditCustomer
     */
    'region': string;
    /**
     * ID of the Stripe account that was created for this customer.
     * @type {string}
     * @memberof CreditCustomer
     */
    'stripeAccountId'?: string;
}


/**
 * 
 * @export
 * @interface CreditCustomerAllOf
 */
export interface CreditCustomerAllOf {
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof CreditCustomerAllOf
     */
    'id': string;
    /**
     * Total number of units available for consumption
     * @type {number}
     * @memberof CreditCustomerAllOf
     */
    'unitsAvailable': number;
    /**
     * Number of units consumed per period.
     * @type {number}
     * @memberof CreditCustomerAllOf
     */
    'recurringConsumptionUnits': number;
    /**
     * List of features that have been unlocked.
     * @type {Array<CreditUnlockType>}
     * @memberof CreditCustomerAllOf
     */
    'unlockedFeatures': Array<CreditUnlockType>;
    /**
     * 
     * @type {CustomerAutoRenewalWRedeemedCoupon}
     * @memberof CreditCustomerAllOf
     */
    'autoRenewal'?: CustomerAutoRenewalWRedeemedCoupon;
    /**
     * 
     * @type {CountryTier}
     * @memberof CreditCustomerAllOf
     */
    'tier'?: CountryTier;
    /**
     * 
     * @type {CreditLevelStatus}
     * @memberof CreditCustomerAllOf
     */
    'creditLevelStatus'?: CreditLevelStatus | null;
    /**
     * 
     * @type {RecurringCreditConsumption}
     * @memberof CreditCustomerAllOf
     */
    'supportPlan'?: RecurringCreditConsumption;
    /**
     * 
     * @type {CreditCustomerRecurringPlans}
     * @memberof CreditCustomerAllOf
     */
    'recurringPlans'?: CreditCustomerRecurringPlans;
}


/**
 * 
 * @export
 * @interface CreditCustomerMetadata
 */
export interface CreditCustomerMetadata {
    /**
     * The partnership to use for this customer. This is only used if the customer is new.
     * @type {string}
     * @memberof CreditCustomerMetadata
     */
    'partnership'?: string;
    /**
     * Region from which the customer is from.
     * @type {string}
     * @memberof CreditCustomerMetadata
     */
    'region': string;
    /**
     * ID of the Stripe account that was created for this customer.
     * @type {string}
     * @memberof CreditCustomerMetadata
     */
    'stripeAccountId'?: string;
}
/**
 * Used to migrate a customer to the credits system. Any recurring consumptions will be migrated to the new system. If the customerId is not provided, we\'ll retreive the customerId from Stripe using the teamId
 * @export
 * @interface CreditCustomerMigrate
 */
export interface CreditCustomerMigrate {
    /**
     * The ID of a team
     * @type {string}
     * @memberof CreditCustomerMigrate
     */
    'teamId': string;
    /**
     * Region from which the customer is from.
     * @type {string}
     * @memberof CreditCustomerMigrate
     */
    'region'?: string;
    /**
     * 
     * @type {StripeCustomerCreate}
     * @memberof CreditCustomerMigrate
     */
    'customer'?: StripeCustomerCreate;
    /**
     * 
     * @type {CreditAutoRenewalUpdate}
     * @memberof CreditCustomerMigrate
     */
    'autoRenewal'?: CreditAutoRenewalUpdate;
}
/**
 * 
 * @export
 * @interface CreditCustomerPost
 */
export interface CreditCustomerPost {
    /**
     * 
     * @type {StripeCustomerCreate}
     * @memberof CreditCustomerPost
     */
    'stripeCustomer': StripeCustomerCreate;
    /**
     * 
     * @type {CreditCustomerMetadata}
     * @memberof CreditCustomerPost
     */
    'metadata': CreditCustomerMetadata;
    /**
     * If true, the customer will receive the signup bonus.
     * @type {boolean}
     * @memberof CreditCustomerPost
     */
    'addSignupBonus'?: boolean;
    /**
     * The referral code to use for this customer. This is only used if the customer is new.
     * @type {string}
     * @memberof CreditCustomerPost
     */
    'referralCode'?: string;
}
/**
 * 
 * @export
 * @interface CreditCustomerRecurringPlans
 */
export interface CreditCustomerRecurringPlans {
    /**
     * 
     * @type {RecurringCreditConsumption}
     * @memberof CreditCustomerRecurringPlans
     */
    'supportPlan'?: RecurringCreditConsumption;
    /**
     * 
     * @type {RecurringCreditConsumption}
     * @memberof CreditCustomerRecurringPlans
     */
    'analyticsPlan'?: RecurringCreditConsumption;
}
/**
 * 
 * @export
 * @interface CreditGain
 */
export interface CreditGain {
    /**
     * ID of a credit gain
     * @type {string}
     * @memberof CreditGain
     */
    'id': string;
    /**
     * 
     * @type {CreditGainType}
     * @memberof CreditGain
     */
    'type': CreditGainType;
    /**
     * Number of units gained
     * @type {number}
     * @memberof CreditGain
     */
    'units': number;
    /**
     * Number of units left in this gain. Credits are consumed bottom up, i.e. credits from the oldest gain are consumed first.
     * @type {number}
     * @memberof CreditGain
     */
    'unitsLeft': number;
    /**
     * 
     * @type {CreditGainStatus}
     * @memberof CreditGain
     */
    'status': CreditGainStatus;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CreditGain
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CreditGain
     */
    'expiresAt'?: string;
    /**
     * The ID of a user
     * @type {string}
     * @memberof CreditGain
     */
    'doneBy': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CreditGain
     */
    'metadata'?: { [key: string]: any; };
    /**
     * 
     * @type {StripeMetadata}
     * @memberof CreditGain
     */
    'stripe'?: StripeMetadata;
    /**
     * 
     * @type {FloatAmountWithCurrency}
     * @memberof CreditGain
     */
    'amountPaid': FloatAmountWithCurrency;
}


/**
 * 
 * @export
 * @interface CreditGainCreate
 */
export interface CreditGainCreate {
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof CreditGainCreate
     */
    'customerId': string;
    /**
     * Number of units gained
     * @type {number}
     * @memberof CreditGainCreate
     */
    'units': number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CreditGainCreate
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface CreditGainRecordData
 */
export interface CreditGainRecordData {
    /**
     * 
     * @type {CreditGainType}
     * @memberof CreditGainRecordData
     */
    'type': CreditGainType;
    /**
     * 
     * @type {CreditGainRecordDataGain}
     * @memberof CreditGainRecordData
     */
    'gain'?: CreditGainRecordDataGain;
}


/**
 * 
 * @export
 * @interface CreditGainRecordDataGain
 */
export interface CreditGainRecordDataGain {
    /**
     * 
     * @type {StripeMetadata}
     * @memberof CreditGainRecordDataGain
     */
    'stripe'?: StripeMetadata;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CreditGainStatus = {
    Paid: 'paid',
    PendingPayment: 'pending_payment',
    Expired: 'expired'
} as const;

export type CreditGainStatus = typeof CreditGainStatus[keyof typeof CreditGainStatus];


/**
 * Different ways to categorise credits being added to the team\'s account.
 * @export
 * @enum {string}
 */

export const CreditGainType = {
    AutoRenewal: 'auto_renewal',
    TopUp: 'top_up',
    Bonus: 'bonus'
} as const;

export type CreditGainType = typeof CreditGainType[keyof typeof CreditGainType];


/**
 * 
 * @export
 * @interface CreditGainsGet200Response
 */
export interface CreditGainsGet200Response {
    /**
     * 
     * @type {Array<CreditGain>}
     * @memberof CreditGainsGet200Response
     */
    'items': Array<CreditGain>;
    /**
     * 
     * @type {string}
     * @memberof CreditGainsGet200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditGainsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CreditLevelStatus = {
    Danger: 'danger',
    Warning: 'warning'
} as const;

export type CreditLevelStatus = typeof CreditLevelStatus[keyof typeof CreditLevelStatus];


/**
 * @type CreditPreference
 * @export
 */
export type CreditPreference = MiscPreference | NotificationPreference | PurchaseTierPreference | RecurringConsumptionPreference | SingleConsumptionPreference | StripePreference | UnlockPreference;

/**
 * A tier of credits that can be purchased. Credits can only be purchased in multiples of the step size. The tier is to be used exactly as is for top-up purchases, and must be  multiplied by the number of months for recurring purchases.
 * @export
 * @interface CreditPurchaseTier
 */
export interface CreditPurchaseTier {
    /**
     * Step size for the tier. This is the minimum number of credits that can be purchased at once in this tier. This will increase with tier
     * @type {number}
     * @memberof CreditPurchaseTier
     */
    'step': number;
    /**
     * Maximum number of units to purchase. This limit is inclusive. Undefined means no cap. If cap is 100 & if the user purchases 101 credits, they\'ll move to the next tier.
     * @type {number}
     * @memberof CreditPurchaseTier
     */
    'maxUnits'?: number;
}
/**
 * 
 * @export
 * @interface CreditStripePrice
 */
export interface CreditStripePrice {
    /**
     * Cost per credit in terms of fiat currency.
     * @type {number}
     * @memberof CreditStripePrice
     */
    'costPerCredit': number;
    /**
     * ISO country code for currency
     * @type {string}
     * @memberof CreditStripePrice
     */
    'currency': string;
    /**
     * 
     * @type {CreditStripePricePriceIds}
     * @memberof CreditStripePrice
     */
    'priceIds': CreditStripePricePriceIds;
}
/**
 * 
 * @export
 * @interface CreditStripePricePriceIds
 */
export interface CreditStripePricePriceIds {
    /**
     * The ID of the price in Stripe. This is used to identify the price in Stripe. For credit billing, ensure that the price ID has the following prefixs for the respective billing types: - recurring: auto_renew_credit - top_up: top_up_credit - bonus: bonus_credit
     * @type {string}
     * @memberof CreditStripePricePriceIds
     */
    'quarter': string;
    /**
     * The ID of the price in Stripe. This is used to identify the price in Stripe. For credit billing, ensure that the price ID has the following prefixs for the respective billing types: - recurring: auto_renew_credit - top_up: top_up_credit - bonus: bonus_credit
     * @type {string}
     * @memberof CreditStripePricePriceIds
     */
    'year': string;
    /**
     * The ID of the price in Stripe. This is used to identify the price in Stripe. For credit billing, ensure that the price ID has the following prefixs for the respective billing types: - recurring: auto_renew_credit - top_up: top_up_credit - bonus: bonus_credit
     * @type {string}
     * @memberof CreditStripePricePriceIds
     */
    'oneTime': string;
}
/**
 * 
 * @export
 * @interface CreditTopUpOptions
 */
export interface CreditTopUpOptions {
    /**
     * 
     * @type {CreditUnitsPurchaseOpts}
     * @memberof CreditTopUpOptions
     */
    'units': CreditUnitsPurchaseOpts;
    /**
     * 
     * @type {MiscBillingOptions}
     * @memberof CreditTopUpOptions
     */
    'options'?: MiscBillingOptions;
}
/**
 * 
 * @export
 * @interface CreditTransactionBase
 */
export interface CreditTransactionBase {
    /**
     * ID of a credit consumption. IDs are chronological.
     * @type {string}
     * @memberof CreditTransactionBase
     */
    'id': string;
    /**
     * Number of units consumed/credited. Positive for credit, negative for consumption.
     * @type {number}
     * @memberof CreditTransactionBase
     */
    'units': number;
    /**
     * The ID of a user
     * @type {string}
     * @memberof CreditTransactionBase
     */
    'doneBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CreditTransactionBase
     */
    'createdAt': string;
    /**
     * The ID of the object that was consumed, or the ID of the gain that created this tx record. (createdAt, objectId) will be enforced to be unique.
     * @type {string}
     * @memberof CreditTransactionBase
     */
    'objectId': string;
    /**
     * 
     * @type {TxMetadata}
     * @memberof CreditTransactionBase
     */
    'metadata'?: TxMetadata | null;
}
/**
 * A record of a credit transaction. This could be a gain or a consumption record & is immutable.
 * @export
 * @interface CreditTransactionRecord
 */
export interface CreditTransactionRecord {
    /**
     * ID of a credit consumption. IDs are chronological.
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'id': string;
    /**
     * Number of units consumed/credited. Positive for credit, negative for consumption.
     * @type {number}
     * @memberof CreditTransactionRecord
     */
    'units': number;
    /**
     * The ID of a user
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'doneBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'createdAt': string;
    /**
     * The ID of the object that was consumed, or the ID of the gain that created this tx record. (createdAt, objectId) will be enforced to be unique.
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'objectId': string;
    /**
     * 
     * @type {TxMetadata}
     * @memberof CreditTransactionRecord
     */
    'metadata'?: TxMetadata | null;
    /**
     * 
     * @type {CreditConsumptionRecordDataType}
     * @memberof CreditTransactionRecord
     */
    'type': CreditConsumptionRecordDataType;
    /**
     * 
     * @type {CreditGainRecordDataGain}
     * @memberof CreditTransactionRecord
     */
    'gain'?: CreditGainRecordDataGain;
    /**
     * 
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'teamId'?: string;
    /**
     * ID of a recurring credit consumption
     * @type {string}
     * @memberof CreditTransactionRecord
     */
    'recurringConsumptionId'?: string;
}
/**
 * 
 * @export
 * @interface CreditTxsGet200Response
 */
export interface CreditTxsGet200Response {
    /**
     * 
     * @type {Array<CreditTransactionRecord>}
     * @memberof CreditTxsGet200Response
     */
    'items': Array<CreditTransactionRecord>;
    /**
     * 
     * @type {string}
     * @memberof CreditTxsGet200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreditTxsGet200Response
     */
    'total'?: number;
}
/**
 * @type CreditUnitsPurchaseOpts
 * @export
 */
export type CreditUnitsPurchaseOpts = CreditUnitsPurchaseOpts1 | CreditUnitsPurchaseOpts2;

/**
 * Options for purchasing credits. The total units are computed as the maxUnits of the previous tier from the specified tier, plus the step size of the specified tier multiplied by the number of steps specified. Essentially:   totalUnits = prev(maxUnits) + current(step) * steps
 * @export
 * @interface CreditUnitsPurchaseOpts1
 */
export interface CreditUnitsPurchaseOpts1 {
    /**
     * 
     * @type {string}
     * @memberof CreditUnitsPurchaseOpts1
     */
    'tier': string;
    /**
     * 
     * @type {number}
     * @memberof CreditUnitsPurchaseOpts1
     */
    'steps': number;
}
/**
 * Number of units to purchase. This is the total number of units to purchase.
 * @export
 * @interface CreditUnitsPurchaseOpts2
 */
export interface CreditUnitsPurchaseOpts2 {
    /**
     * Number of units to purchase
     * @type {number}
     * @memberof CreditUnitsPurchaseOpts2
     */
    'units': number;
}
/**
 * 
 * @export
 * @interface CreditUnlockMetadata
 */
export interface CreditUnlockMetadata {
    /**
     * Minimum number of auto renewing credits required to unlock this feature. Period of consumption is not considered.
     * @type {number}
     * @memberof CreditUnlockMetadata
     */
    'minRecurringCredits': number;
}
/**
 * Enum of all the types of credit unlocks. These are unlocked at a certain auto-renewal credit threshhold.
 * @export
 * @enum {string}
 */

export const CreditUnlockType = {
    ExportMsgFlow: 'export/msg_flow',
    ExportContacts: 'export/contacts',
    ExportTags: 'export/tags',
    ExportCustomFields: 'export/custom_fields',
    ExportProducts: 'export/products',
    RemoveMarketingMessage: 'remove_marketing_message'
} as const;

export type CreditUnlockType = typeof CreditUnlockType[keyof typeof CreditUnlockType];


/**
 * 
 * @export
 * @interface CreditsCouponsArchiveRequest
 */
export interface CreditsCouponsArchiveRequest {
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof CreditsCouponsArchiveRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface CreditsCouponsGet200Response
 */
export interface CreditsCouponsGet200Response {
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof CreditsCouponsGet200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {Array<Coupon>}
     * @memberof CreditsCouponsGet200Response
     */
    'items': Array<Coupon>;
    /**
     * 
     * @type {number}
     * @memberof CreditsCouponsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface CreditsCouponsRedemptionsGet200Response
 */
export interface CreditsCouponsRedemptionsGet200Response {
    /**
     * The redeemed coupon ID
     * @type {string}
     * @memberof CreditsCouponsRedemptionsGet200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {Array<RedeemedCoupon>}
     * @memberof CreditsCouponsRedemptionsGet200Response
     */
    'items': Array<RedeemedCoupon>;
    /**
     * 
     * @type {number}
     * @memberof CreditsCouponsRedemptionsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface CreditsCustomerPost200Response
 */
export interface CreditsCustomerPost200Response {
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof CreditsCustomerPost200Response
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface CreditsPreferences
 */
export interface CreditsPreferences {
    /**
     * 
     * @type {Array<CreditPreference>}
     * @memberof CreditsPreferences
     */
    'items': Array<CreditPreference>;
}
/**
 * 
 * @export
 * @interface CreditsPreferencesPostRequest
 */
export interface CreditsPreferencesPostRequest {
    /**
     * 
     * @type {Array<CreditPreference>}
     * @memberof CreditsPreferencesPostRequest
     */
    'items': Array<CreditPreference>;
}
/**
 * 
 * @export
 * @interface CustomerAutoRenewal
 */
export interface CustomerAutoRenewal {
    /**
     * The ID of the subscription that was created for this credit transaction.
     * @type {string}
     * @memberof CustomerAutoRenewal
     */
    'subscriptionId': string;
    /**
     * Number of units consumed per period
     * @type {number}
     * @memberof CustomerAutoRenewal
     */
    'units': number;
    /**
     * Number of bonus units
     * @type {number}
     * @memberof CustomerAutoRenewal
     */
    'bonusUnits': number;
    /**
     * 
     * @type {AutoRenewalPeriod}
     * @memberof CustomerAutoRenewal
     */
    'period': AutoRenewalPeriod;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CustomerAutoRenewal
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CustomerAutoRenewal
     */
    'nextChargeAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerAutoRenewal
     */
    'status': CustomerAutoRenewalStatusEnum;
    /**
     * The redeemed coupon ID
     * @type {string}
     * @memberof CustomerAutoRenewal
     */
    'currentRedeemedCouponId'?: string;
}

export const CustomerAutoRenewalStatusEnum = {
    Active: 'active',
    Cancelled: 'cancelled',
    Overdue: 'overdue'
} as const;

export type CustomerAutoRenewalStatusEnum = typeof CustomerAutoRenewalStatusEnum[keyof typeof CustomerAutoRenewalStatusEnum];

/**
 * 
 * @export
 * @interface CustomerAutoRenewalWRedeemedCoupon
 */
export interface CustomerAutoRenewalWRedeemedCoupon {
    /**
     * The ID of the subscription that was created for this credit transaction.
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'subscriptionId': string;
    /**
     * Number of units consumed per period
     * @type {number}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'units': number;
    /**
     * Number of bonus units
     * @type {number}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'bonusUnits': number;
    /**
     * 
     * @type {AutoRenewalPeriod}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'period': AutoRenewalPeriod;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'nextChargeAt': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'status': CustomerAutoRenewalWRedeemedCouponStatusEnum;
    /**
     * The redeemed coupon ID
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'currentRedeemedCouponId'?: string;
    /**
     * 
     * @type {CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon}
     * @memberof CustomerAutoRenewalWRedeemedCoupon
     */
    'currentRedeemedCoupon'?: CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon;
}

export const CustomerAutoRenewalWRedeemedCouponStatusEnum = {
    Active: 'active',
    Cancelled: 'cancelled',
    Overdue: 'overdue'
} as const;

export type CustomerAutoRenewalWRedeemedCouponStatusEnum = typeof CustomerAutoRenewalWRedeemedCouponStatusEnum[keyof typeof CustomerAutoRenewalWRedeemedCouponStatusEnum];

/**
 * 
 * @export
 * @interface CustomerAutoRenewalWRedeemedCouponAllOf
 */
export interface CustomerAutoRenewalWRedeemedCouponAllOf {
    /**
     * 
     * @type {CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon}
     * @memberof CustomerAutoRenewalWRedeemedCouponAllOf
     */
    'currentRedeemedCoupon'?: CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon;
}
/**
 * 
 * @export
 * @interface CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon
 */
export interface CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon {
    /**
     * The redeemed coupon ID
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon
     */
    'id': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon
     */
    'createdAt': string;
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon
     */
    'couponId': string;
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon
     */
    'customerId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon
     */
    'expiresAt'?: string | null;
    /**
     * Number of credits saved by using this coupon
     * @type {number}
     * @memberof CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon
     */
    'creditsSaved'?: number;
    /**
     * 
     * @type {Coupon}
     * @memberof CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCoupon
     */
    'coupon'?: Coupon;
}
/**
 * 
 * @export
 * @interface CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCouponAllOf
 */
export interface CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCouponAllOf {
    /**
     * 
     * @type {Coupon}
     * @memberof CustomerAutoRenewalWRedeemedCouponAllOfCurrentRedeemedCouponAllOf
     */
    'coupon'?: Coupon;
}
/**
 * 
 * @export
 * @interface DateRange
 */
interface DateRange {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DateRange
     */
    'from': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DateRange
     */
    'to': string;
}
/**
 * 
 * @export
 * @interface DefinedSingleConsumptionMetadata
 */
export interface DefinedSingleConsumptionMetadata {
    /**
     * Cost of the consumption
     * @type {number}
     * @memberof DefinedSingleConsumptionMetadata
     */
    'perUnitCost': number;
}
/**
 * List of features
 * @export
 * @enum {string}
 */

export const Feature = {
    TeamInbox: 'team-inbox',
    ChatHistorySync: 'chat-history-sync',
    CustomMarketingMessage: 'custom-marketing-message',
    Audience: 'audience',
    Notifications: 'notifications',
    KeywordReply: 'keyword-reply',
    Broadcast: 'broadcast',
    MessageFlows: 'message-flows',
    Shop: 'shop',
    Autocomplete: 'autocomplete'
} as const;

export type Feature = typeof Feature[keyof typeof Feature];


/**
 * @type FeatureConfig
 * @export
 */
export type FeatureConfig = Array<Feature> | string;

/**
 * 
 * @export
 * @interface FloatAmountWithCurrency
 */
export interface FloatAmountWithCurrency {
    /**
     * The amount in dollar value
     * @type {number}
     * @memberof FloatAmountWithCurrency
     */
    'amount': number;
    /**
     * ISO country code for currency in lowercase
     * @type {string}
     * @memberof FloatAmountWithCurrency
     */
    'currency': string;
}
/**
 * 
 * @export
 * @interface GetPartner200Response
 */
export interface GetPartner200Response {
    /**
     * 
     * @type {string}
     * @memberof GetPartner200Response
     */
    'partnerAdmin'?: string;
}
/**
 * 
 * @export
 * @interface LegacyCanConsumeOpts
 */
export interface LegacyCanConsumeOpts {
    /**
     * 
     * @type {LimitedItem}
     * @memberof LegacyCanConsumeOpts
     */
    'item': LimitedItem;
    /**
     * 
     * @type {string}
     * @memberof LegacyCanConsumeOpts
     */
    'accountId'?: string;
}


/**
 * 
 * @export
 * @interface LimitationMap
 */
export interface LimitationMap {
    /**
     * The number of messages that can be sent per month. This is reset every month.
     * @type {number}
     * @memberof LimitationMap
     */
    'messages'?: number;
    /**
     * The number of team members allowed in the team. This usage carries over to the next month.
     * @type {number}
     * @memberof LimitationMap
     */
    'seats'?: number;
    /**
     * The number of Inbox accounts allowed in the team. This usage carries over to the next month.
     * @type {number}
     * @memberof LimitationMap
     */
    'fullAccount'?: number;
    /**
     * The number of API accounts used on a per-day basis. This is reset every month.
     * @type {number}
     * @memberof LimitationMap
     */
    'limitedMsgNoHistoryAccountDay'?: number;
    /**
     * The number of API accounts used on a per-day basis. This is reset every month.
     * @type {number}
     * @memberof LimitationMap
     */
    'unlimitedMsgHistoryAccountDay'?: number;
}
/**
 * List of items that are limited in quantity
 * @export
 * @enum {string}
 */

export const LimitedItem = {
    Messages: 'messages',
    Seats: 'seats',
    FullAccount: 'fullAccount',
    LimitedMsgNoHistoryAccountDay: 'limitedMsgNoHistoryAccountDay',
    UnlimitedMsgHistoryAccountDay: 'unlimitedMsgHistoryAccountDay'
} as const;

export type LimitedItem = typeof LimitedItem[keyof typeof LimitedItem];


/**
 * 
 * @export
 * @interface MiscBillingOptions
 */
export interface MiscBillingOptions {
    /**
     * The promotion code to use for this purchase.
     * @type {string}
     * @memberof MiscBillingOptions
     */
    'promotionCode'?: string;
    /**
     * Doesn\'t attempt to automatically charge the customer and always returns a payment link.
     * @type {boolean}
     * @memberof MiscBillingOptions
     */
    'alwaysReturnLink'?: boolean;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof MiscBillingOptions
     */
    'startDate'?: string;
}
/**
 * 
 * @export
 * @interface MiscPreference
 */
export interface MiscPreference {
    /**
     * 
     * @type {string}
     * @memberof MiscPreference
     */
    'category': MiscPreferenceCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof MiscPreference
     */
    'key': MiscPreferenceKeyEnum;
    /**
     * 
     * @type {CreditAmountObj}
     * @memberof MiscPreference
     */
    'data': CreditAmountObj;
    /**
     * 
     * @type {CountryTier}
     * @memberof MiscPreference
     */
    'tier'?: CountryTier;
}

export const MiscPreferenceCategoryEnum = {
    Misc: 'misc'
} as const;

export type MiscPreferenceCategoryEnum = typeof MiscPreferenceCategoryEnum[keyof typeof MiscPreferenceCategoryEnum];
export const MiscPreferenceKeyEnum = {
    NewSignupCredits: 'newSignupCredits',
    ExpiryIntervalMonths: 'expiryIntervalMonths',
    YearlyBonusCreditsPercentage: 'yearlyBonusCreditsPercentage'
} as const;

export type MiscPreferenceKeyEnum = typeof MiscPreferenceKeyEnum[keyof typeof MiscPreferenceKeyEnum];

/**
 * 
 * @export
 * @interface ModifySupportPlan
 */
export interface ModifySupportPlan {
    /**
     * The type of support plan. This can be either consultation/support_plan or null to remove the support plan.
     * @type {string}
     * @memberof ModifySupportPlan
     */
    'type': ModifySupportPlanTypeEnum;
}

export const ModifySupportPlanTypeEnum = {
    ConsultationSupportPlanLvl1: 'consultation/support_plan_lvl1',
    ConsultationSupportPlanLvl2: 'consultation/support_plan_lvl2',
    Null: null as null
} as const;

export type ModifySupportPlanTypeEnum = typeof ModifySupportPlanTypeEnum[keyof typeof ModifySupportPlanTypeEnum];

/**
 * 
 * @export
 * @interface NotificationPreference
 */
export interface NotificationPreference {
    /**
     * 
     * @type {string}
     * @memberof NotificationPreference
     */
    'category': NotificationPreferenceCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof NotificationPreference
     */
    'key': NotificationPreferenceKeyEnum;
    /**
     * 
     * @type {NotificationPreferenceData}
     * @memberof NotificationPreference
     */
    'data': NotificationPreferenceData;
}

export const NotificationPreferenceCategoryEnum = {
    Notification: 'notification'
} as const;

export type NotificationPreferenceCategoryEnum = typeof NotificationPreferenceCategoryEnum[keyof typeof NotificationPreferenceCategoryEnum];
export const NotificationPreferenceKeyEnum = {
    Subscribed: 'subscribed',
    Unsubscribed: 'unsubscribed'
} as const;

export type NotificationPreferenceKeyEnum = typeof NotificationPreferenceKeyEnum[keyof typeof NotificationPreferenceKeyEnum];

/**
 * Map describing threshholds for notifications. The threshhold for subscribed users is in % of their recurring credits. The threshhold for unsubscribed users is in absolute credits.
 * @export
 * @interface NotificationPreferenceData
 */
export interface NotificationPreferenceData {
    /**
     * 
     * @type {number}
     * @memberof NotificationPreferenceData
     */
    'danger': number;
    /**
     * 
     * @type {number}
     * @memberof NotificationPreferenceData
     */
    'warning': number;
}
/**
 * Object which stores referral code details
 * @export
 * @interface PartnerReferral
 */
export interface PartnerReferral {
    /**
     * referralCode string; ID for the code
     * @type {string}
     * @memberof PartnerReferral
     */
    'referralCode': string;
    /**
     * ID of the stripe price, the usage of this referral code will give access to
     * @type {string}
     * @memberof PartnerReferral
     */
    'stripePriceId': string | null;
    /**
     * 
     * @type {StripePrice}
     * @memberof PartnerReferral
     */
    'stripePrice'?: StripePrice;
    /**
     * teamId of partnerAdmin associated with the referralCode
     * @type {string}
     * @memberof PartnerReferral
     */
    'partnerAdminTeam': string;
    /**
     * partnerAdmin of team associated with the referralCode
     * @type {string}
     * @memberof PartnerReferral
     */
    'partnerAdmin': string;
    /**
     * Time the product can be used for in days
     * @type {number}
     * @memberof PartnerReferral
     */
    'usagePeriodDays': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PartnerReferral
     */
    'referralCodeExpiry'?: string;
    /**
     * userId of creator of the code
     * @type {string}
     * @memberof PartnerReferral
     */
    'createdBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PartnerReferral
     */
    'createdAt': string;
    /**
     * number of credits to be given when the referral code is used
     * @type {number}
     * @memberof PartnerReferral
     */
    'credits'?: number;
}
/**
 * options to generate partnerReferral
 * @export
 * @interface PartnerReferralCreateOptions
 */
export interface PartnerReferralCreateOptions {
    /**
     * ID of the product that\'ll be given for free when the referral code is used
     * @type {string}
     * @memberof PartnerReferralCreateOptions
     */
    'stripePriceId': string | null;
    /**
     * time the product can be used for in days
     * @type {number}
     * @memberof PartnerReferralCreateOptions
     */
    'usagePeriodDays': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PartnerReferralCreateOptions
     */
    'referralCodeExpiry'?: string;
    /**
     * a string to be appended to the generated referral code
     * @type {string}
     * @memberof PartnerReferralCreateOptions
     */
    'includeInReferralCode'?: string;
    /**
     * number of credits to be given when the referral code is used
     * @type {number}
     * @memberof PartnerReferralCreateOptions
     */
    'credits'?: number;
}
/**
 * 
 * @export
 * @interface PartnerReferralsGet200Response
 */
export interface PartnerReferralsGet200Response {
    /**
     * 
     * @type {Array<PartnerReferral>}
     * @memberof PartnerReferralsGet200Response
     */
    'items': Array<PartnerReferral>;
    /**
     * 
     * @type {number}
     * @memberof PartnerReferralsGet200Response
     */
    'nextPageCursor'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartnerReferralsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface PartnerReferralsPost200Response
 */
export interface PartnerReferralsPost200Response {
    /**
     * 
     * @type {string}
     * @memberof PartnerReferralsPost200Response
     */
    'referralCode': string;
}
/**
 * 
 * @export
 * @interface PaymentData
 */
export interface PaymentData {
    /**
     * 
     * @type {string}
     * @memberof PaymentData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentData
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {AmountWithCurrency}
     * @memberof PaymentData
     */
    'amount': AmountWithCurrency;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PaymentData
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface PaymentRequest
 */
export interface PaymentRequest {
    /**
     * URL to pay for the credits. If empty, the payment has already been made.
     * @type {string}
     * @memberof PaymentRequest
     */
    'paymentUrl': string;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * The ID of a product
     * @type {string}
     * @memberof Product
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * 
     * @type {ProductAccess}
     * @memberof Product
     */
    'access': ProductAccess;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Product
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Product
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<StripePrice>}
     * @memberof Product
     */
    'stripePrices'?: Array<StripePrice>;
}
/**
 * 
 * @export
 * @interface ProductAccess
 */
export interface ProductAccess {
    /**
     * 
     * @type {FeatureConfig}
     * @memberof ProductAccess
     */
    'features': FeatureConfig;
    /**
     * 
     * @type {LimitationMap}
     * @memberof ProductAccess
     */
    'limits': LimitationMap;
}
/**
 * 
 * @export
 * @interface ProductCreate
 */
export interface ProductCreate {
    /**
     * 
     * @type {string}
     * @memberof ProductCreate
     */
    'name': string;
    /**
     * 
     * @type {ProductAccess}
     * @memberof ProductCreate
     */
    'access': ProductAccess;
}
/**
 * 
 * @export
 * @interface ProductUpdate
 */
export interface ProductUpdate {
    /**
     * 
     * @type {ProductAccess}
     * @memberof ProductUpdate
     */
    'access'?: ProductAccess;
    /**
     * Attach/detach some stripe price IDs
     * @type {Array<StripePriceAttachmentUpdate>}
     * @memberof ProductUpdate
     */
    'stripePriceIds'?: Array<StripePriceAttachmentUpdate>;
}
/**
 * 
 * @export
 * @interface ProductsGet200Response
 */
export interface ProductsGet200Response {
    /**
     * 
     * @type {Array<Product>}
     * @memberof ProductsGet200Response
     */
    'items': Array<Product>;
}
/**
 * 
 * @export
 * @interface ProductsSelectionInner
 */
export interface ProductsSelectionInner {
    /**
     * The ID of a product
     * @type {string}
     * @memberof ProductsSelectionInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductsSelectionInner
     */
    'stripePriceId': string;
    /**
     * 
     * @type {number}
     * @memberof ProductsSelectionInner
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface PurchaseTierPreference
 */
export interface PurchaseTierPreference {
    /**
     * 
     * @type {string}
     * @memberof PurchaseTierPreference
     */
    'category': PurchaseTierPreferenceCategoryEnum;
    /**
     * Unique string to identify the tier
     * @type {string}
     * @memberof PurchaseTierPreference
     */
    'key': string;
    /**
     * 
     * @type {CountryTier}
     * @memberof PurchaseTierPreference
     */
    'tier'?: CountryTier;
    /**
     * 
     * @type {CreditPurchaseTier}
     * @memberof PurchaseTierPreference
     */
    'data': CreditPurchaseTier;
}

export const PurchaseTierPreferenceCategoryEnum = {
    Tier: 'tier'
} as const;

export type PurchaseTierPreferenceCategoryEnum = typeof PurchaseTierPreferenceCategoryEnum[keyof typeof PurchaseTierPreferenceCategoryEnum];

/**
 * 
 * @export
 * @interface RecTxMetadata
 */
export interface RecTxMetadata {
    /**
     * The redeemed coupon ID
     * @type {string}
     * @memberof RecTxMetadata
     */
    'redeemedCouponId'?: string;
    /**
     * 
     * @type {number}
     * @memberof RecTxMetadata
     */
    'percentageOff'?: number;
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof RecTxMetadata
     */
    'couponId'?: string;
    /**
     * If this recurring charge was resynced after another recurring sub was cancelled, this will be the number of units that were charged previously. 
     * @type {number}
     * @memberof RecTxMetadata
     */
    'previousChargeUnits'?: number;
    /**
     * Number of times this recurring charge was resynced after another recurring sub was cancelled.
     * @type {number}
     * @memberof RecTxMetadata
     */
    'nextChargeResyncs'?: number;
}
/**
 * 
 * @export
 * @interface RecTxMetadataAllOf
 */
export interface RecTxMetadataAllOf {
    /**
     * If this recurring charge was resynced after another recurring sub was cancelled, this will be the number of units that were charged previously. 
     * @type {number}
     * @memberof RecTxMetadataAllOf
     */
    'previousChargeUnits'?: number;
    /**
     * Number of times this recurring charge was resynced after another recurring sub was cancelled.
     * @type {number}
     * @memberof RecTxMetadataAllOf
     */
    'nextChargeResyncs'?: number;
}
/**
 * 
 * @export
 * @interface RecurringConsumptionMetadata
 */
export interface RecurringConsumptionMetadata {
    /**
     * 
     * @type {Array<CreditConsumptionTier>}
     * @memberof RecurringConsumptionMetadata
     */
    'tiers': Array<CreditConsumptionTier>;
}
/**
 * 
 * @export
 * @interface RecurringConsumptionPreference
 */
export interface RecurringConsumptionPreference {
    /**
     * 
     * @type {string}
     * @memberof RecurringConsumptionPreference
     */
    'category': RecurringConsumptionPreferenceCategoryEnum;
    /**
     * 
     * @type {RecurringCreditConsumptionType}
     * @memberof RecurringConsumptionPreference
     */
    'key': RecurringCreditConsumptionType;
    /**
     * 
     * @type {CountryTier}
     * @memberof RecurringConsumptionPreference
     */
    'tier'?: CountryTier;
    /**
     * 
     * @type {RecurringConsumptionMetadata}
     * @memberof RecurringConsumptionPreference
     */
    'data': RecurringConsumptionMetadata;
}

export const RecurringConsumptionPreferenceCategoryEnum = {
    RecurringConsumption: 'recurring_consumption'
} as const;

export type RecurringConsumptionPreferenceCategoryEnum = typeof RecurringConsumptionPreferenceCategoryEnum[keyof typeof RecurringConsumptionPreferenceCategoryEnum];

/**
 * A recurring credit consumption is a credit consumption that is automatically renewed every month
 * @export
 * @interface RecurringCreditConsumption
 */
export interface RecurringCreditConsumption {
    /**
     * ID of a recurring credit consumption
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'id': string;
    /**
     * 
     * @type {RecurringCreditConsumptionType}
     * @memberof RecurringCreditConsumption
     */
    'type': RecurringCreditConsumptionType;
    /**
     * Number of units to consume at the next charge
     * @type {number}
     * @memberof RecurringCreditConsumption
     */
    'nextChargeUnits': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'cancelledAt'?: string | null;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'nextChargeAt': string;
    /**
     * The ID of a user
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'doneBy': string;
    /**
     * 
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'teamId'?: string;
    /**
     * The ID of the object that was consumed. (createdAt, objectId) will be enforced to be unique.
     * @type {string}
     * @memberof RecurringCreditConsumption
     */
    'objectId': string;
    /**
     * 
     * @type {RecTxMetadata}
     * @memberof RecurringCreditConsumption
     */
    'metadata'?: RecTxMetadata;
}


/**
 * 
 * @export
 * @interface RecurringCreditConsumptionCreate
 */
export interface RecurringCreditConsumptionCreate {
    /**
     * 
     * @type {RecurringCreditConsumptionType}
     * @memberof RecurringCreditConsumptionCreate
     */
    'type': RecurringCreditConsumptionType;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RecurringCreditConsumptionCreate
     */
    'createdAt'?: string;
    /**
     * The ID of a team
     * @type {string}
     * @memberof RecurringCreditConsumptionCreate
     */
    'teamId': string;
    /**
     * The ID of the object that was consumed. (createdAt, objectId) will be enforced to be unique.
     * @type {string}
     * @memberof RecurringCreditConsumptionCreate
     */
    'objectId': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RecurringCreditConsumptionCreate
     */
    'metadata'?: { [key: string]: any; };
}


/**
 * Enum of all the types of recurring credit consumption. Category of consumptions are separated by a slash.
 * @export
 * @enum {string}
 */

export const RecurringCreditConsumptionType = {
    ChannelWa: 'channel/wa',
    ChannelTiktok: 'channel/tiktok',
    ChannelMessenger: 'channel/messenger',
    ChannelWaBusinessApi: 'channel/wa-business-api',
    ChannelMail: 'channel/mail',
    ChannelSms: 'channel/sms',
    ConsultationSupportPlanLvl1: 'consultation/support_plan_lvl1',
    ConsultationSupportPlanLvl2: 'consultation/support_plan_lvl2',
    User: 'user',
    CallChannel: 'call_channel',
    AnalyticsDashboard: 'analytics_dashboard'
} as const;

export type RecurringCreditConsumptionType = typeof RecurringCreditConsumptionType[keyof typeof RecurringCreditConsumptionType];


/**
 * 
 * @export
 * @interface RecurringCreditsGet200Response
 */
export interface RecurringCreditsGet200Response {
    /**
     * 
     * @type {Array<RecurringCreditConsumption>}
     * @memberof RecurringCreditsGet200Response
     */
    'items': Array<RecurringCreditConsumption>;
    /**
     * 
     * @type {string}
     * @memberof RecurringCreditsGet200Response
     */
    'nextPageCursor'?: string;
    /**
     * 
     * @type {number}
     * @memberof RecurringCreditsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface RecurringCreditsGetDateRageParameter
 */
export interface RecurringCreditsGetDateRageParameter {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RecurringCreditsGetDateRageParameter
     */
    'from'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RecurringCreditsGetDateRageParameter
     */
    'to'?: string;
}
/**
 * 
 * @export
 * @interface RedeemedCoupon
 */
export interface RedeemedCoupon {
    /**
     * The redeemed coupon ID
     * @type {string}
     * @memberof RedeemedCoupon
     */
    'id': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RedeemedCoupon
     */
    'createdAt': string;
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof RedeemedCoupon
     */
    'couponId': string;
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof RedeemedCoupon
     */
    'customerId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof RedeemedCoupon
     */
    'expiresAt'?: string | null;
    /**
     * Number of credits saved by using this coupon
     * @type {number}
     * @memberof RedeemedCoupon
     */
    'creditsSaved'?: number;
}
/**
 * @type SingleConsumptionMetadata
 * @export
 */
export type SingleConsumptionMetadata = DefinedSingleConsumptionMetadata | VariableSingleConsumptionMetadata;

/**
 * 
 * @export
 * @interface SingleConsumptionPreference
 */
export interface SingleConsumptionPreference {
    /**
     * 
     * @type {string}
     * @memberof SingleConsumptionPreference
     */
    'category': SingleConsumptionPreferenceCategoryEnum;
    /**
     * 
     * @type {CreditConsumptionType}
     * @memberof SingleConsumptionPreference
     */
    'key': CreditConsumptionType;
    /**
     * 
     * @type {CountryTier}
     * @memberof SingleConsumptionPreference
     */
    'tier'?: CountryTier;
    /**
     * 
     * @type {SingleConsumptionMetadata}
     * @memberof SingleConsumptionPreference
     */
    'data': SingleConsumptionMetadata;
}

export const SingleConsumptionPreferenceCategoryEnum = {
    SingleConsumption: 'single_consumption'
} as const;

export type SingleConsumptionPreferenceCategoryEnum = typeof SingleConsumptionPreferenceCategoryEnum[keyof typeof SingleConsumptionPreferenceCategoryEnum];

/**
 * 
 * @export
 * @interface StripeCheckout200Response
 */
export interface StripeCheckout200Response {
    /**
     * 
     * @type {string}
     * @memberof StripeCheckout200Response
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof StripeCheckout200Response
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface StripeCouponData
 */
export interface StripeCouponData {
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof StripeCouponData
     */
    'id': string;
    /**
     * 
     * @type {FloatAmountWithCurrency}
     * @memberof StripeCouponData
     */
    'amountOff'?: FloatAmountWithCurrency;
    /**
     * The percentage off the coupon provides
     * @type {number}
     * @memberof StripeCouponData
     */
    'percentageOff'?: number;
    /**
     * 
     * @type {FloatAmountWithCurrency}
     * @memberof StripeCouponData
     */
    'minAmount'?: FloatAmountWithCurrency;
    /**
     * The duration the coupon is valid for. Can be one of forever, once, or repeating.
     * @type {string}
     * @memberof StripeCouponData
     */
    'duration': StripeCouponDataDurationEnum;
}

export const StripeCouponDataDurationEnum = {
    Forever: 'forever',
    Once: 'once'
} as const;

export type StripeCouponDataDurationEnum = typeof StripeCouponDataDurationEnum[keyof typeof StripeCouponDataDurationEnum];

/**
 * @type StripeCustomerCreate
 * @export
 */
export type StripeCustomerCreate = StripeCustomerCreateOneOf | StripeCustomerCreateOneOf1;

/**
 * Provide to link an existing stripe customer
 * @export
 * @interface StripeCustomerCreateOneOf
 */
export interface StripeCustomerCreateOneOf {
    /**
     * 
     * @type {string}
     * @memberof StripeCustomerCreateOneOf
     */
    'id': string;
}
/**
 * Provide to create a new stripe customer
 * @export
 * @interface StripeCustomerCreateOneOf1
 */
export interface StripeCustomerCreateOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof StripeCustomerCreateOneOf1
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof StripeCustomerCreateOneOf1
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof StripeCustomerCreateOneOf1
     */
    'phoneNumber'?: string;
}
/**
 * 
 * @export
 * @interface StripeMetadata
 */
export interface StripeMetadata {
    /**
     * The URL of the invoice that was created for this credit transaction.
     * @type {string}
     * @memberof StripeMetadata
     */
    'invoiceUrl': string;
    /**
     * The ID of the line item that was created for this credit transaction.
     * @type {string}
     * @memberof StripeMetadata
     */
    'lineItemId': string;
    /**
     * Fraction of the total amount that was paid for this credit transaction. Anything less than 1 means that some or all of the amount is refunded/due.
     * @type {number}
     * @memberof StripeMetadata
     */
    'paidFraction': number;
}
/**
 * 
 * @export
 * @interface StripePaymentIntent
 */
export interface StripePaymentIntent {
    /**
     * 
     * @type {string}
     * @memberof StripePaymentIntent
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StripePaymentIntent
     */
    'customer'?: string;
    /**
     * 
     * @type {number}
     * @memberof StripePaymentIntent
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof StripePaymentIntent
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof StripePaymentIntent
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof StripePaymentIntent
     */
    'created'?: number;
}
/**
 * 
 * @export
 * @interface StripePaymentIntentsGet200Response
 */
export interface StripePaymentIntentsGet200Response {
    /**
     * 
     * @type {Array<StripePaymentIntent>}
     * @memberof StripePaymentIntentsGet200Response
     */
    'paymentIntents': Array<StripePaymentIntent>;
}
/**
 * 
 * @export
 * @interface StripePreference
 */
export interface StripePreference {
    /**
     * 
     * @type {string}
     * @memberof StripePreference
     */
    'category': StripePreferenceCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof StripePreference
     */
    'key': StripePreferenceKeyEnum;
    /**
     * 
     * @type {CreditStripePrice}
     * @memberof StripePreference
     */
    'data': CreditStripePrice;
}

export const StripePreferenceCategoryEnum = {
    Stripe: 'stripe'
} as const;

export type StripePreferenceCategoryEnum = typeof StripePreferenceCategoryEnum[keyof typeof StripePreferenceCategoryEnum];
export const StripePreferenceKeyEnum = {
    AutoRenewal: 'autoRenewal',
    TopUp: 'topUp',
    Bonus: 'bonus'
} as const;

export type StripePreferenceKeyEnum = typeof StripePreferenceKeyEnum[keyof typeof StripePreferenceKeyEnum];

/**
 * 
 * @export
 * @interface StripePrice
 */
export interface StripePrice {
    /**
     * 
     * @type {string}
     * @memberof StripePrice
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StripePrice
     */
    'productName'?: string;
    /**
     * 
     * @type {BillingPeriod}
     * @memberof StripePrice
     */
    'period': BillingPeriod;
    /**
     * 
     * @type {AmountWithCurrency}
     * @memberof StripePrice
     */
    'amount': AmountWithCurrency;
    /**
     * ISO 3166-1 alpha-2 country code, or \"default\" to get the default prices
     * @type {string}
     * @memberof StripePrice
     */
    'region'?: string;
}


/**
 * Update a stripe price ID attachment. Supply ID to attach, or supply remove=true to detach. Supply region to mark price to a specific region.
 * @export
 * @interface StripePriceAttachmentUpdate
 */
export interface StripePriceAttachmentUpdate {
    /**
     * 
     * @type {string}
     * @memberof StripePriceAttachmentUpdate
     */
    'id': string;
    /**
     * ISO 3166-1 alpha-2 country code, or \"default\" to get the default prices
     * @type {string}
     * @memberof StripePriceAttachmentUpdate
     */
    'region'?: string;
    /**
     * Remove this stripe price ID from the product
     * @type {boolean}
     * @memberof StripePriceAttachmentUpdate
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface StripePricesGet200Response
 */
export interface StripePricesGet200Response {
    /**
     * 
     * @type {Array<StripePrice>}
     * @memberof StripePricesGet200Response
     */
    'items': Array<StripePrice>;
    /**
     * 
     * @type {string}
     * @memberof StripePricesGet200Response
     */
    'nextPageCursor'?: string;
}
/**
 * 
 * @export
 * @interface StripeSubscriptionItem
 */
export interface StripeSubscriptionItem {
    /**
     * 
     * @type {string}
     * @memberof StripeSubscriptionItem
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface SubscribedProduct
 */
export interface SubscribedProduct {
    /**
     * 
     * @type {Product}
     * @memberof SubscribedProduct
     */
    'product'?: Product;
    /**
     * 
     * @type {string}
     * @memberof SubscribedProduct
     */
    'productId': string;
    /**
     * The stripe price ID that was used to purchase this subscription product
     * @type {string}
     * @memberof SubscribedProduct
     */
    'stripePriceId': string;
    /**
     * 
     * @type {number}
     * @memberof SubscribedProduct
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * The ID of a subscription
     * @type {string}
     * @memberof Subscription
     */
    'id': string;
    /**
     * The ID of a team
     * @type {string}
     * @memberof Subscription
     */
    'teamId'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Subscription
     */
    'startDate': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Subscription
     */
    'endDate'?: string;
    /**
     * Reason for voiding the subscription
     * @type {string}
     * @memberof Subscription
     */
    'voidReason'?: string;
    /**
     * 
     * @type {SubscriptionStripeData}
     * @memberof Subscription
     */
    'stripe'?: SubscriptionStripeData;
    /**
     * 
     * @type {Array<SubscribedProduct>}
     * @memberof Subscription
     */
    'products'?: Array<SubscribedProduct>;
    /**
     * 
     * @type {AutoChargeProduct}
     * @memberof Subscription
     */
    'autoCharge'?: AutoChargeProduct;
}
/**
 * 
 * @export
 * @interface SubscriptionCreate
 */
export interface SubscriptionCreate {
    /**
     * The ID of a team
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'teamId': string;
    /**
     * 
     * @type {Array<ProductsSelectionInner>}
     * @memberof SubscriptionCreate
     */
    'products': Array<ProductsSelectionInner>;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'startDate'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'endDate'?: string;
    /**
     * Extra days to add to the subscription. Invalid request with endDate.
     * @type {number}
     * @memberof SubscriptionCreate
     */
    'extraDays'?: number;
    /**
     * Free trial days to add to the subscription. Invalid request with endDate, extraDays, or nextCycleAnchor, and createOnStripe=false.
     * @type {number}
     * @memberof SubscriptionCreate
     */
    'freeTrialDays'?: number;
    /**
     * Anchor the next cycle to a specific date. Invalid request with endDate. Only valid for stripe subscriptions.
     * @type {string}
     * @memberof SubscriptionCreate
     */
    'nextCycleAnchor'?: string;
    /**
     * Create the subscription on stripe. Will create the subscription on stripe if true. Only works if the customer has a payment method and it can be charged automatically.
     * @type {boolean}
     * @memberof SubscriptionCreate
     */
    'createOnStripe': boolean;
    /**
     * Refresh access after creating the subscription.
     * @type {boolean}
     * @memberof SubscriptionCreate
     */
    'refreshAccess'?: boolean;
}
/**
 * 
 * @export
 * @interface SubscriptionStripeData
 */
export interface SubscriptionStripeData {
    /**
     * The ID of a subscription
     * @type {string}
     * @memberof SubscriptionStripeData
     */
    'subscriptionId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof SubscriptionStripeData
     */
    'nextRenewalDate'?: string;
    /**
     * 
     * @type {Array<StripeSubscriptionItem>}
     * @memberof SubscriptionStripeData
     */
    'items': Array<StripeSubscriptionItem>;
    /**
     * 
     * @type {Array<PaymentData>}
     * @memberof SubscriptionStripeData
     */
    'payments': Array<PaymentData>;
}
/**
 * 
 * @export
 * @interface SubscriptionUpdate
 */
export interface SubscriptionUpdate {
    /**
     * Cancel the subscription. Will set the end date to the end of the current period. Features will continue to work until the end of the period.
     * @type {boolean}
     * @memberof SubscriptionUpdate
     */
    'cancel'?: boolean;
    /**
     * Reason for voiding the subscription. Will cancel the subscription if provided. Will set the end date to now.
     * @type {string}
     * @memberof SubscriptionUpdate
     */
    'voidReason'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionsGet200Response
 */
interface SubscriptionsGet200Response {
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof SubscriptionsGet200Response
     */
    'items': Array<Subscription>;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionsGet200Response
     */
    'nextPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface TeamDetail
 */
export interface TeamDetail {
    /**
     * The ID of a team
     * @type {string}
     * @memberof TeamDetail
     */
    'id': string;
    /**
     * 
     * @type {Access}
     * @memberof TeamDetail
     */
    'access': Access;
    /**
     * 
     * @type {LimitationMap}
     * @memberof TeamDetail
     */
    'usage': LimitationMap;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TeamDetail
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TeamDetail
     */
    'updatedAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TeamDetail
     */
    'lastAccessComputedAt': string;
    /**
     * 
     * @type {Array<LimitedItem>}
     * @memberof TeamDetail
     */
    'autoChargeItems': Array<LimitedItem>;
    /**
     * 
     * @type {string}
     * @memberof TeamDetail
     */
    'stripeCustomerId'?: string;
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof TeamDetail
     */
    'subscriptions'?: Array<Subscription>;
    /**
     * 
     * @type {string}
     * @memberof TeamDetail
     */
    'partnership'?: string;
}
/**
 * 
 * @export
 * @interface TeamDetailCreate
 */
export interface TeamDetailCreate {
    /**
     * The ID of a team
     * @type {string}
     * @memberof TeamDetailCreate
     */
    'id': string;
    /**
     * 
     * @type {Set<LimitedItem>}
     * @memberof TeamDetailCreate
     */
    'autoChargeItems'?: Set<LimitedItem>;
    /**
     * 
     * @type {StripeCustomerCreate}
     * @memberof TeamDetailCreate
     */
    'stripeCustomer': StripeCustomerCreate;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailCreate
     */
    'partnership'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailCreate
     */
    'referralCode'?: string;
}
/**
 * 
 * @export
 * @interface TeamDetailUpdate
 */
export interface TeamDetailUpdate {
    /**
     * 
     * @type {Set<LimitedItem>}
     * @memberof TeamDetailUpdate
     */
    'autoChargeItems'?: Set<LimitedItem>;
    /**
     * 
     * @type {string}
     * @memberof TeamDetailUpdate
     */
    'stripeCustomerId'?: string;
    /**
     * 
     * @type {LimitationMap}
     * @memberof TeamDetailUpdate
     */
    'usage'?: LimitationMap;
}
/**
 * 
 * @export
 * @interface TxMetadata
 */
export interface TxMetadata {
    [key: string]: any;

    /**
     * The redeemed coupon ID
     * @type {string}
     * @memberof TxMetadata
     */
    'redeemedCouponId'?: string;
    /**
     * 
     * @type {number}
     * @memberof TxMetadata
     */
    'percentageOff'?: number;
    /**
     * The ID of the coupon
     * @type {string}
     * @memberof TxMetadata
     */
    'couponId'?: string;
}
/**
 * 
 * @export
 * @interface UnlockPreference
 */
export interface UnlockPreference {
    /**
     * 
     * @type {string}
     * @memberof UnlockPreference
     */
    'category': UnlockPreferenceCategoryEnum;
    /**
     * 
     * @type {CreditUnlockType}
     * @memberof UnlockPreference
     */
    'key': CreditUnlockType;
    /**
     * 
     * @type {CountryTier}
     * @memberof UnlockPreference
     */
    'tier'?: CountryTier;
    /**
     * 
     * @type {CreditUnlockMetadata}
     * @memberof UnlockPreference
     */
    'data': CreditUnlockMetadata;
}

export const UnlockPreferenceCategoryEnum = {
    Unlock: 'unlock'
} as const;

export type UnlockPreferenceCategoryEnum = typeof UnlockPreferenceCategoryEnum[keyof typeof UnlockPreferenceCategoryEnum];

/**
 * 
 * @export
 * @interface VariableSingleConsumptionMetadata
 */
export interface VariableSingleConsumptionMetadata {
    /**
     * 
     * @type {string}
     * @memberof VariableSingleConsumptionMetadata
     */
    'type': VariableSingleConsumptionMetadataTypeEnum;
    /**
     * Some data used to configure the correct price of the consumption
     * @type {{ [key: string]: any; }}
     * @memberof VariableSingleConsumptionMetadata
     */
    'data': { [key: string]: any; };
}

export const VariableSingleConsumptionMetadataTypeEnum = {
    Custom: 'custom'
} as const;

export type VariableSingleConsumptionMetadataTypeEnum = typeof VariableSingleConsumptionMetadataTypeEnum[keyof typeof VariableSingleConsumptionMetadataTypeEnum];

/**
 * Pricing of each item in credits
 * @export
 * @interface WabaPricingData
 */
export interface WabaPricingData {
    /**
     * 
     * @type {number}
     * @memberof WabaPricingData
     */
    'authentication'?: number;
    /**
     * 
     * @type {number}
     * @memberof WabaPricingData
     */
    'service'?: number;
    /**
     * 
     * @type {number}
     * @memberof WabaPricingData
     */
    'marketing'?: number;
    /**
     * 
     * @type {number}
     * @memberof WabaPricingData
     */
    'utility'?: number;
}

/**
 * AutoChargeProductsApi - axios parameter creator
 * @export
 */
export const AutoChargeProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch All Auto Charge Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auto-charge-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - If usage < limit, then no action is taken - If usage >= limit, then:   - a metered subscription is created, if it doesn\'t exist   - fails if cannot be auto-charged
         * @summary Prepares the team for auto charge
         * @param {LimitedItem} item 
         * @param {string} [accountId] The account ID to prepare usage for. Relevant for messages only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsPrepare: async (item: LimitedItem, accountId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'item' is not null or undefined
            assertParamExists('autoChargeProductsPrepare', 'item', item)
            const localVarPath = `/auto-charge-products/prepare/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets config for auto charge product
         * @param {AutoChargeProductSet} [autoChargeProductSet] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsSet: async (autoChargeProductSet?: AutoChargeProductSet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auto-charge-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoChargeProductSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutoChargeProductsApi - functional programming interface
 * @export
 */
export const AutoChargeProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutoChargeProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch All Auto Charge Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoChargeProductsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoChargeProductsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoChargeProductsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * - If usage < limit, then no action is taken - If usage >= limit, then:   - a metered subscription is created, if it doesn\'t exist   - fails if cannot be auto-charged
         * @summary Prepares the team for auto charge
         * @param {LimitedItem} item 
         * @param {string} [accountId] The account ID to prepare usage for. Relevant for messages only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoChargeProductsPrepare(item: LimitedItem, accountId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoChargeProductsPrepare200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoChargeProductsPrepare(item, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sets config for auto charge product
         * @param {AutoChargeProductSet} [autoChargeProductSet] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoChargeProductsSet(autoChargeProductSet?: AutoChargeProductSet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoChargeProductsSet(autoChargeProductSet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AutoChargeProductsApi - factory interface
 * @export
 */
export const AutoChargeProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutoChargeProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch All Auto Charge Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsGet(options?: AxiosRequestConfig): AxiosPromise<AutoChargeProductsGet200Response> {
            return localVarFp.autoChargeProductsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * - If usage < limit, then no action is taken - If usage >= limit, then:   - a metered subscription is created, if it doesn\'t exist   - fails if cannot be auto-charged
         * @summary Prepares the team for auto charge
         * @param {AutoChargeProductsApiAutoChargeProductsPrepareRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsPrepare(requestParameters: AutoChargeProductsApiAutoChargeProductsPrepareRequest, options?: AxiosRequestConfig): AxiosPromise<AutoChargeProductsPrepare200Response> {
            return localVarFp.autoChargeProductsPrepare(requestParameters.item, requestParameters.accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets config for auto charge product
         * @param {AutoChargeProductsApiAutoChargeProductsSetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoChargeProductsSet(requestParameters: AutoChargeProductsApiAutoChargeProductsSetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.autoChargeProductsSet(requestParameters.autoChargeProductSet, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for autoChargeProductsPrepare operation in AutoChargeProductsApi.
 * @export
 * @interface AutoChargeProductsApiAutoChargeProductsPrepareRequest
 */
export interface AutoChargeProductsApiAutoChargeProductsPrepareRequest {
    /**
     * 
     * @type {LimitedItem}
     * @memberof AutoChargeProductsApiAutoChargeProductsPrepare
     */
    readonly item: LimitedItem

    /**
     * The account ID to prepare usage for. Relevant for messages only.
     * @type {string}
     * @memberof AutoChargeProductsApiAutoChargeProductsPrepare
     */
    readonly accountId?: string
}

/**
 * Request parameters for autoChargeProductsSet operation in AutoChargeProductsApi.
 * @export
 * @interface AutoChargeProductsApiAutoChargeProductsSetRequest
 */
export interface AutoChargeProductsApiAutoChargeProductsSetRequest {
    /**
     * 
     * @type {AutoChargeProductSet}
     * @memberof AutoChargeProductsApiAutoChargeProductsSet
     */
    readonly autoChargeProductSet?: AutoChargeProductSet
}

/**
 * AutoChargeProductsApi - object-oriented interface
 * @export
 * @class AutoChargeProductsApi
 * @extends {BaseAPI}
 */
export class AutoChargeProductsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch All Auto Charge Products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoChargeProductsApi
     */
    public autoChargeProductsGet(options?: AxiosRequestConfig) {
        return AutoChargeProductsApiFp(this.configuration).autoChargeProductsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - If usage < limit, then no action is taken - If usage >= limit, then:   - a metered subscription is created, if it doesn\'t exist   - fails if cannot be auto-charged
     * @summary Prepares the team for auto charge
     * @param {AutoChargeProductsApiAutoChargeProductsPrepareRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoChargeProductsApi
     */
    public autoChargeProductsPrepare(requestParameters: AutoChargeProductsApiAutoChargeProductsPrepareRequest, options?: AxiosRequestConfig) {
        return AutoChargeProductsApiFp(this.configuration).autoChargeProductsPrepare(requestParameters.item, requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets config for auto charge product
     * @param {AutoChargeProductsApiAutoChargeProductsSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoChargeProductsApi
     */
    public autoChargeProductsSet(requestParameters: AutoChargeProductsApiAutoChargeProductsSetRequest = {}, options?: AxiosRequestConfig) {
        return AutoChargeProductsApiFp(this.configuration).autoChargeProductsSet(requestParameters.autoChargeProductSet, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CouponCodesApi - axios parameter creator
 * @export
 */
export const CouponCodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get and verify coupon data from Stripe
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsGet: async (code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('couponsGet', 'code', code)
            const localVarPath = `/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a coupon code
         * @param {CouponCodeCreateOptions} [couponCodeCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsPost: async (couponCodeCreateOptions?: CouponCodeCreateOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(couponCodeCreateOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive a coupon code
         * @param {CreditsCouponsArchiveRequest} [creditsCouponsArchiveRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCouponsArchive: async (creditsCouponsArchiveRequest?: CreditsCouponsArchiveRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/coupons/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditsCouponsArchiveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Chatdaddy coupon data
         * @param {number} [count] 
         * @param {boolean} [returnTotal] Return total number of coupons
         * @param {string} [cursor] 
         * @param {string} [q] Search by partial coupon id
         * @param {string} [id] Filter by coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCouponsGet: async (count?: number, returnTotal?: boolean, cursor?: string, q?: string, id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a coupon by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCouponsGetId: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('creditsCouponsGetId', 'id', id)
            const localVarPath = `/v2/credits/coupons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a coupon code
         * @param {CreditCouponCodeCreateOptions} [creditCouponCodeCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCouponsPost: async (creditCouponCodeCreateOptions?: CreditCouponCodeCreateOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditCouponCodeCreateOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get coupon redemptions
         * @param {number} [count] 
         * @param {boolean} [returnTotal] Return total number of redemptions
         * @param {string} [cursor] 
         * @param {string} [q] Search by partial redeemed coupon id
         * @param {string} [couponId] Filter by coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCouponsRedemptionsGet: async (count?: number, returnTotal?: boolean, cursor?: string, q?: string, couponId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/coupons/redemptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (couponId !== undefined) {
                localVarQueryParameter['couponId'] = couponId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CouponCodesApi - functional programming interface
 * @export
 */
export const CouponCodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CouponCodesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get and verify coupon data from Stripe
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsGet(code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeCouponData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsGet(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate a coupon code
         * @param {CouponCodeCreateOptions} [couponCodeCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsPost(couponCodeCreateOptions?: CouponCodeCreateOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsPost(couponCodeCreateOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Archive a coupon code
         * @param {CreditsCouponsArchiveRequest} [creditsCouponsArchiveRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsCouponsArchive(creditsCouponsArchiveRequest?: CreditsCouponsArchiveRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsCouponsArchive(creditsCouponsArchiveRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Chatdaddy coupon data
         * @param {number} [count] 
         * @param {boolean} [returnTotal] Return total number of coupons
         * @param {string} [cursor] 
         * @param {string} [q] Search by partial coupon id
         * @param {string} [id] Filter by coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsCouponsGet(count?: number, returnTotal?: boolean, cursor?: string, q?: string, id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditsCouponsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsCouponsGet(count, returnTotal, cursor, q, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a coupon by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsCouponsGetId(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Coupon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsCouponsGetId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate a coupon code
         * @param {CreditCouponCodeCreateOptions} [creditCouponCodeCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsCouponsPost(creditCouponCodeCreateOptions?: CreditCouponCodeCreateOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Coupon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsCouponsPost(creditCouponCodeCreateOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get coupon redemptions
         * @param {number} [count] 
         * @param {boolean} [returnTotal] Return total number of redemptions
         * @param {string} [cursor] 
         * @param {string} [q] Search by partial redeemed coupon id
         * @param {string} [couponId] Filter by coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsCouponsRedemptionsGet(count?: number, returnTotal?: boolean, cursor?: string, q?: string, couponId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditsCouponsRedemptionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsCouponsRedemptionsGet(count, returnTotal, cursor, q, couponId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CouponCodesApi - factory interface
 * @export
 */
export const CouponCodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CouponCodesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get and verify coupon data from Stripe
         * @param {CouponCodesApiCouponsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsGet(requestParameters: CouponCodesApiCouponsGetRequest, options?: AxiosRequestConfig): AxiosPromise<StripeCouponData> {
            return localVarFp.couponsGet(requestParameters.code, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a coupon code
         * @param {CouponCodesApiCouponsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsPost(requestParameters: CouponCodesApiCouponsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CouponsPost200Response> {
            return localVarFp.couponsPost(requestParameters.couponCodeCreateOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Archive a coupon code
         * @param {CouponCodesApiCreditsCouponsArchiveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCouponsArchive(requestParameters: CouponCodesApiCreditsCouponsArchiveRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.creditsCouponsArchive(requestParameters.creditsCouponsArchiveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Chatdaddy coupon data
         * @param {CouponCodesApiCreditsCouponsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCouponsGet(requestParameters: CouponCodesApiCreditsCouponsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CreditsCouponsGet200Response> {
            return localVarFp.creditsCouponsGet(requestParameters.count, requestParameters.returnTotal, requestParameters.cursor, requestParameters.q, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a coupon by ID
         * @param {CouponCodesApiCreditsCouponsGetIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCouponsGetId(requestParameters: CouponCodesApiCreditsCouponsGetIdRequest, options?: AxiosRequestConfig): AxiosPromise<Coupon> {
            return localVarFp.creditsCouponsGetId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a coupon code
         * @param {CouponCodesApiCreditsCouponsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCouponsPost(requestParameters: CouponCodesApiCreditsCouponsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Coupon> {
            return localVarFp.creditsCouponsPost(requestParameters.creditCouponCodeCreateOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get coupon redemptions
         * @param {CouponCodesApiCreditsCouponsRedemptionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCouponsRedemptionsGet(requestParameters: CouponCodesApiCreditsCouponsRedemptionsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CreditsCouponsRedemptionsGet200Response> {
            return localVarFp.creditsCouponsRedemptionsGet(requestParameters.count, requestParameters.returnTotal, requestParameters.cursor, requestParameters.q, requestParameters.couponId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for couponsGet operation in CouponCodesApi.
 * @export
 * @interface CouponCodesApiCouponsGetRequest
 */
export interface CouponCodesApiCouponsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof CouponCodesApiCouponsGet
     */
    readonly code: string
}

/**
 * Request parameters for couponsPost operation in CouponCodesApi.
 * @export
 * @interface CouponCodesApiCouponsPostRequest
 */
export interface CouponCodesApiCouponsPostRequest {
    /**
     * 
     * @type {CouponCodeCreateOptions}
     * @memberof CouponCodesApiCouponsPost
     */
    readonly couponCodeCreateOptions?: CouponCodeCreateOptions
}

/**
 * Request parameters for creditsCouponsArchive operation in CouponCodesApi.
 * @export
 * @interface CouponCodesApiCreditsCouponsArchiveRequest
 */
export interface CouponCodesApiCreditsCouponsArchiveRequest {
    /**
     * 
     * @type {CreditsCouponsArchiveRequest}
     * @memberof CouponCodesApiCreditsCouponsArchive
     */
    readonly creditsCouponsArchiveRequest?: CreditsCouponsArchiveRequest
}

/**
 * Request parameters for creditsCouponsGet operation in CouponCodesApi.
 * @export
 * @interface CouponCodesApiCreditsCouponsGetRequest
 */
export interface CouponCodesApiCreditsCouponsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof CouponCodesApiCreditsCouponsGet
     */
    readonly count?: number

    /**
     * Return total number of coupons
     * @type {boolean}
     * @memberof CouponCodesApiCreditsCouponsGet
     */
    readonly returnTotal?: boolean

    /**
     * 
     * @type {string}
     * @memberof CouponCodesApiCreditsCouponsGet
     */
    readonly cursor?: string

    /**
     * Search by partial coupon id
     * @type {string}
     * @memberof CouponCodesApiCreditsCouponsGet
     */
    readonly q?: string

    /**
     * Filter by coupon ID
     * @type {string}
     * @memberof CouponCodesApiCreditsCouponsGet
     */
    readonly id?: string
}

/**
 * Request parameters for creditsCouponsGetId operation in CouponCodesApi.
 * @export
 * @interface CouponCodesApiCreditsCouponsGetIdRequest
 */
export interface CouponCodesApiCreditsCouponsGetIdRequest {
    /**
     * 
     * @type {string}
     * @memberof CouponCodesApiCreditsCouponsGetId
     */
    readonly id: string
}

/**
 * Request parameters for creditsCouponsPost operation in CouponCodesApi.
 * @export
 * @interface CouponCodesApiCreditsCouponsPostRequest
 */
export interface CouponCodesApiCreditsCouponsPostRequest {
    /**
     * 
     * @type {CreditCouponCodeCreateOptions}
     * @memberof CouponCodesApiCreditsCouponsPost
     */
    readonly creditCouponCodeCreateOptions?: CreditCouponCodeCreateOptions
}

/**
 * Request parameters for creditsCouponsRedemptionsGet operation in CouponCodesApi.
 * @export
 * @interface CouponCodesApiCreditsCouponsRedemptionsGetRequest
 */
export interface CouponCodesApiCreditsCouponsRedemptionsGetRequest {
    /**
     * 
     * @type {number}
     * @memberof CouponCodesApiCreditsCouponsRedemptionsGet
     */
    readonly count?: number

    /**
     * Return total number of redemptions
     * @type {boolean}
     * @memberof CouponCodesApiCreditsCouponsRedemptionsGet
     */
    readonly returnTotal?: boolean

    /**
     * 
     * @type {string}
     * @memberof CouponCodesApiCreditsCouponsRedemptionsGet
     */
    readonly cursor?: string

    /**
     * Search by partial redeemed coupon id
     * @type {string}
     * @memberof CouponCodesApiCreditsCouponsRedemptionsGet
     */
    readonly q?: string

    /**
     * Filter by coupon ID
     * @type {string}
     * @memberof CouponCodesApiCreditsCouponsRedemptionsGet
     */
    readonly couponId?: string
}

/**
 * CouponCodesApi - object-oriented interface
 * @export
 * @class CouponCodesApi
 * @extends {BaseAPI}
 */
export class CouponCodesApi extends BaseAPI {
    /**
     * 
     * @summary Get and verify coupon data from Stripe
     * @param {CouponCodesApiCouponsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponCodesApi
     */
    public couponsGet(requestParameters: CouponCodesApiCouponsGetRequest, options?: AxiosRequestConfig) {
        return CouponCodesApiFp(this.configuration).couponsGet(requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a coupon code
     * @param {CouponCodesApiCouponsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponCodesApi
     */
    public couponsPost(requestParameters: CouponCodesApiCouponsPostRequest = {}, options?: AxiosRequestConfig) {
        return CouponCodesApiFp(this.configuration).couponsPost(requestParameters.couponCodeCreateOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Archive a coupon code
     * @param {CouponCodesApiCreditsCouponsArchiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponCodesApi
     */
    public creditsCouponsArchive(requestParameters: CouponCodesApiCreditsCouponsArchiveRequest = {}, options?: AxiosRequestConfig) {
        return CouponCodesApiFp(this.configuration).creditsCouponsArchive(requestParameters.creditsCouponsArchiveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Chatdaddy coupon data
     * @param {CouponCodesApiCreditsCouponsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponCodesApi
     */
    public creditsCouponsGet(requestParameters: CouponCodesApiCreditsCouponsGetRequest = {}, options?: AxiosRequestConfig) {
        return CouponCodesApiFp(this.configuration).creditsCouponsGet(requestParameters.count, requestParameters.returnTotal, requestParameters.cursor, requestParameters.q, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a coupon by ID
     * @param {CouponCodesApiCreditsCouponsGetIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponCodesApi
     */
    public creditsCouponsGetId(requestParameters: CouponCodesApiCreditsCouponsGetIdRequest, options?: AxiosRequestConfig) {
        return CouponCodesApiFp(this.configuration).creditsCouponsGetId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a coupon code
     * @param {CouponCodesApiCreditsCouponsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponCodesApi
     */
    public creditsCouponsPost(requestParameters: CouponCodesApiCreditsCouponsPostRequest = {}, options?: AxiosRequestConfig) {
        return CouponCodesApiFp(this.configuration).creditsCouponsPost(requestParameters.creditCouponCodeCreateOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get coupon redemptions
     * @param {CouponCodesApiCreditsCouponsRedemptionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponCodesApi
     */
    public creditsCouponsRedemptionsGet(requestParameters: CouponCodesApiCreditsCouponsRedemptionsGetRequest = {}, options?: AxiosRequestConfig) {
        return CouponCodesApiFp(this.configuration).creditsCouponsRedemptionsGet(requestParameters.count, requestParameters.returnTotal, requestParameters.cursor, requestParameters.q, requestParameters.couponId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreditsApi - axios parameter creator
 * @export
 */
export const CreditsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel the current auto-renewal credit sub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoRenewalCancel: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/auto-renewal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create/update the auto-renewal credit sub
         * @param {CreditAutoRenewalUpdate} [creditAutoRenewalUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoRenewalPost: async (creditAutoRenewalUpdate?: CreditAutoRenewalUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/auto-renewal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditAutoRenewalUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {CreditConsumptionType} type The type of consumption
         * @param {number} quantity The number of times to consume the given type
         * @param {LegacyCanConsumeOpts} [legacyOpts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canConsumeCredits: async (type: CreditConsumptionType, quantity: number, legacyOpts?: LegacyCanConsumeOpts, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('canConsumeCredits', 'type', type)
            // verify required parameter 'quantity' is not null or undefined
            assertParamExists('canConsumeCredits', 'quantity', quantity)
            const localVarPath = `/v2/credits/can-consume`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (quantity !== undefined) {
                localVarQueryParameter['quantity'] = quantity;
            }

            if (legacyOpts !== undefined) {
                localVarQueryParameter['legacyOpts'] = legacyOpts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {RecurringCreditConsumptionType} type The type of consumption
         * @param {LegacyCanConsumeOpts} [legacyOpts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canConsumeRecurringCredits: async (type: RecurringCreditConsumptionType, legacyOpts?: LegacyCanConsumeOpts, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('canConsumeRecurringCredits', 'type', type)
            const localVarPath = `/v2/credits/can-consume-recurring`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (legacyOpts !== undefined) {
                localVarQueryParameter['legacyOpts'] = legacyOpts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new single use credit consumption record
         * @param {CreditConsumptionPostRequest} [creditConsumptionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditConsumptionPost: async (creditConsumptionPostRequest?: CreditConsumptionPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/consumption`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditConsumptionPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of gains your team has received
         * @param {string} [customerId] Filter by customerId.
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {Array<CreditGainType>} [type] 
         * @param {DateRange} [createdAt] 
         * @param {CreditGainStatus} [status] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditGainsGet: async (customerId?: string, count?: number, cursor?: string, type?: Array<CreditGainType>, createdAt?: DateRange, status?: CreditGainStatus, returnTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/gains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ"], configuration)

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new credit gain
         * @param {CreditGainCreate} [creditGainCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditGainsPost: async (creditGainCreate?: CreditGainCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/gains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditGainCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transaction history
         * @param {string} [teamId] Filter by teamId
         * @param {string} [customerId] Filter by customerId
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {Array<CreditBalanceEffectType>} [type] 
         * @param {'gain' | 'consume'} [effectType] 
         * @param {Array<string>} [id] 
         * @param {DateRange} [createdAt] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditTxsGet: async (teamId?: string, customerId?: string, count?: number, cursor?: string, type?: Array<CreditBalanceEffectType>, effectType?: 'gain' | 'consume', id?: Array<string>, createdAt?: DateRange, returnTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/consumption`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ"], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customerId'] = customerId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (effectType !== undefined) {
                localVarQueryParameter['effectType'] = effectType;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the customer\'s credit details
         * @param {boolean} [returnAutoRenewal] Return the auto-renewal subscription details. PAYMENTS_READ scope is required.
         * @param {boolean} [returnSupportPlan] Return the support plan details.
         * @param {boolean} [returnRecurringPlans] Return the support plan details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerGet: async (returnAutoRenewal?: boolean, returnSupportPlan?: boolean, returnRecurringPlans?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (returnAutoRenewal !== undefined) {
                localVarQueryParameter['returnAutoRenewal'] = returnAutoRenewal;
            }

            if (returnSupportPlan !== undefined) {
                localVarQueryParameter['returnSupportPlan'] = returnSupportPlan;
            }

            if (returnRecurringPlans !== undefined) {
                localVarQueryParameter['returnRecurringPlans'] = returnRecurringPlans;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Migrate the customer\'s subscription & any other purchased items to the credit system
         * @param {CreditCustomerMigrate} [creditCustomerMigrate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerMigrate: async (creditCustomerMigrate?: CreditCustomerMigrate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/customer/migrate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditCustomerMigrate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new customer, or link the team to an existing customer
         * @param {CreditCustomerPost} [creditCustomerPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerPost: async (creditCustomerPost?: CreditCustomerPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditCustomerPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refreshes the customer\'s subscription & any other purchased items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerRefresh: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/customer/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get metadata for credit consumptions and unlocks
         * @param {string} [region] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsPreferencesGet: async (region?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the system credit preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsPreferencesGetAdmin: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/preferences/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the given credit preferences
         * @param {CreditsPreferencesPostRequest} [creditsPreferencesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsPreferencesPost: async (creditsPreferencesPostRequest?: CreditsPreferencesPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/preferences/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditsPreferencesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create/update/cancel the support plan
         * @param {ModifySupportPlan} [modifySupportPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySupportPlan: async (modifySupportPlan?: ModifySupportPlan, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/support-plan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifySupportPlan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recurring credit consumptions
         * @param {string} [teamId] Filter by teamId
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {RecurringCreditConsumptionType} [type] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {string} [doneBy] Filter by the user who created the consumption
         * @param {RecurringCreditsGetDateRageParameter} [dateRage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recurringCreditsGet: async (teamId?: string, count?: number, cursor?: string, type?: RecurringCreditConsumptionType, returnTotal?: boolean, doneBy?: string, dateRage?: RecurringCreditsGetDateRageParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/recurring`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ"], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }

            if (doneBy !== undefined) {
                localVarQueryParameter['doneBy'] = doneBy;
            }

            if (dateRage !== undefined) {
                localVarQueryParameter['dateRage'] = dateRage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new recurring credit consumption record
         * @param {RecurringCreditConsumptionCreate} [recurringCreditConsumptionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRecurringConsumption: async (recurringCreditConsumptionCreate?: RecurringCreditConsumptionCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/recurring`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recurringCreditConsumptionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop a recurring credit consumption
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRecurringConsumption: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stopRecurringConsumption', 'id', id)
            const localVarPath = `/v2/credits/recurring/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Top up credits
         * @param {CreditTopUpOptions} [creditTopUpOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topUpCreditsPost: async (creditTopUpOptions?: CreditTopUpOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/credits/topup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(creditTopUpOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditsApi - functional programming interface
 * @export
 */
export const CreditsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel the current auto-renewal credit sub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoRenewalCancel(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoRenewalCancel(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create/update the auto-renewal credit sub
         * @param {CreditAutoRenewalUpdate} [creditAutoRenewalUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoRenewalPost(creditAutoRenewalUpdate?: CreditAutoRenewalUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoRenewalPost(creditAutoRenewalUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {CreditConsumptionType} type The type of consumption
         * @param {number} quantity The number of times to consume the given type
         * @param {LegacyCanConsumeOpts} [legacyOpts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async canConsumeCredits(type: CreditConsumptionType, quantity: number, legacyOpts?: LegacyCanConsumeOpts, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCanConsumeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.canConsumeCredits(type, quantity, legacyOpts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {RecurringCreditConsumptionType} type The type of consumption
         * @param {LegacyCanConsumeOpts} [legacyOpts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async canConsumeRecurringCredits(type: RecurringCreditConsumptionType, legacyOpts?: LegacyCanConsumeOpts, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCanConsumeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.canConsumeRecurringCredits(type, legacyOpts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new single use credit consumption record
         * @param {CreditConsumptionPostRequest} [creditConsumptionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditConsumptionPost(creditConsumptionPostRequest?: CreditConsumptionPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreditTransactionRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditConsumptionPost(creditConsumptionPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of gains your team has received
         * @param {string} [customerId] Filter by customerId.
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {Array<CreditGainType>} [type] 
         * @param {DateRange} [createdAt] 
         * @param {CreditGainStatus} [status] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditGainsGet(customerId?: string, count?: number, cursor?: string, type?: Array<CreditGainType>, createdAt?: DateRange, status?: CreditGainStatus, returnTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditGainsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditGainsGet(customerId, count, cursor, type, createdAt, status, returnTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new credit gain
         * @param {CreditGainCreate} [creditGainCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditGainsPost(creditGainCreate?: CreditGainCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditGain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditGainsPost(creditGainCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get transaction history
         * @param {string} [teamId] Filter by teamId
         * @param {string} [customerId] Filter by customerId
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {Array<CreditBalanceEffectType>} [type] 
         * @param {'gain' | 'consume'} [effectType] 
         * @param {Array<string>} [id] 
         * @param {DateRange} [createdAt] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditTxsGet(teamId?: string, customerId?: string, count?: number, cursor?: string, type?: Array<CreditBalanceEffectType>, effectType?: 'gain' | 'consume', id?: Array<string>, createdAt?: DateRange, returnTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditTxsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditTxsGet(teamId, customerId, count, cursor, type, effectType, id, createdAt, returnTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the customer\'s credit details
         * @param {boolean} [returnAutoRenewal] Return the auto-renewal subscription details. PAYMENTS_READ scope is required.
         * @param {boolean} [returnSupportPlan] Return the support plan details.
         * @param {boolean} [returnRecurringPlans] Return the support plan details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsCustomerGet(returnAutoRenewal?: boolean, returnSupportPlan?: boolean, returnRecurringPlans?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCustomer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsCustomerGet(returnAutoRenewal, returnSupportPlan, returnRecurringPlans, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Migrate the customer\'s subscription & any other purchased items to the credit system
         * @param {CreditCustomerMigrate} [creditCustomerMigrate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsCustomerMigrate(creditCustomerMigrate?: CreditCustomerMigrate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsCustomerMigrate(creditCustomerMigrate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new customer, or link the team to an existing customer
         * @param {CreditCustomerPost} [creditCustomerPost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsCustomerPost(creditCustomerPost?: CreditCustomerPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditsCustomerPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsCustomerPost(creditCustomerPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Refreshes the customer\'s subscription & any other purchased items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsCustomerRefresh(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsCustomerRefresh(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get metadata for credit consumptions and unlocks
         * @param {string} [region] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsPreferencesGet(region?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditsPreferences>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsPreferencesGet(region, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the system credit preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsPreferencesGetAdmin(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditsPreferences>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsPreferencesGetAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the given credit preferences
         * @param {CreditsPreferencesPostRequest} [creditsPreferencesPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async creditsPreferencesPost(creditsPreferencesPostRequest?: CreditsPreferencesPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.creditsPreferencesPost(creditsPreferencesPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create/update/cancel the support plan
         * @param {ModifySupportPlan} [modifySupportPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifySupportPlan(modifySupportPlan?: ModifySupportPlan, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurringCreditConsumption>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifySupportPlan(modifySupportPlan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get recurring credit consumptions
         * @param {string} [teamId] Filter by teamId
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {RecurringCreditConsumptionType} [type] 
         * @param {boolean} [returnTotal] Return total number of consumptions
         * @param {string} [doneBy] Filter by the user who created the consumption
         * @param {RecurringCreditsGetDateRageParameter} [dateRage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recurringCreditsGet(teamId?: string, count?: number, cursor?: string, type?: RecurringCreditConsumptionType, returnTotal?: boolean, doneBy?: string, dateRage?: RecurringCreditsGetDateRageParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurringCreditsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recurringCreditsGet(teamId, count, cursor, type, returnTotal, doneBy, dateRage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new recurring credit consumption record
         * @param {RecurringCreditConsumptionCreate} [recurringCreditConsumptionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRecurringConsumption(recurringCreditConsumptionCreate?: RecurringCreditConsumptionCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurringCreditConsumption>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRecurringConsumption(recurringCreditConsumptionCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop a recurring credit consumption
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopRecurringConsumption(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopRecurringConsumption(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Top up credits
         * @param {CreditTopUpOptions} [creditTopUpOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topUpCreditsPost(creditTopUpOptions?: CreditTopUpOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topUpCreditsPost(creditTopUpOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreditsApi - factory interface
 * @export
 */
export const CreditsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditsApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel the current auto-renewal credit sub
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoRenewalCancel(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.autoRenewalCancel(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create/update the auto-renewal credit sub
         * @param {CreditsApiAutoRenewalPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoRenewalPost(requestParameters: CreditsApiAutoRenewalPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PaymentRequest> {
            return localVarFp.autoRenewalPost(requestParameters.creditAutoRenewalUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {CreditsApiCanConsumeCreditsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canConsumeCredits(requestParameters: CreditsApiCanConsumeCreditsRequest, options?: AxiosRequestConfig): AxiosPromise<CreditCanConsumeResponse> {
            return localVarFp.canConsumeCredits(requestParameters.type, requestParameters.quantity, requestParameters.legacyOpts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if the team can consume the given quantity of credits
         * @param {CreditsApiCanConsumeRecurringCreditsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canConsumeRecurringCredits(requestParameters: CreditsApiCanConsumeRecurringCreditsRequest, options?: AxiosRequestConfig): AxiosPromise<CreditCanConsumeResponse> {
            return localVarFp.canConsumeRecurringCredits(requestParameters.type, requestParameters.legacyOpts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new single use credit consumption record
         * @param {CreditsApiCreditConsumptionPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditConsumptionPost(requestParameters: CreditsApiCreditConsumptionPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<CreditTransactionRecord>> {
            return localVarFp.creditConsumptionPost(requestParameters.creditConsumptionPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of gains your team has received
         * @param {CreditsApiCreditGainsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditGainsGet(requestParameters: CreditsApiCreditGainsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CreditGainsGet200Response> {
            return localVarFp.creditGainsGet(requestParameters.customerId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.createdAt, requestParameters.status, requestParameters.returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new credit gain
         * @param {CreditsApiCreditGainsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditGainsPost(requestParameters: CreditsApiCreditGainsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CreditGain> {
            return localVarFp.creditGainsPost(requestParameters.creditGainCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transaction history
         * @param {CreditsApiCreditTxsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditTxsGet(requestParameters: CreditsApiCreditTxsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CreditTxsGet200Response> {
            return localVarFp.creditTxsGet(requestParameters.teamId, requestParameters.customerId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.effectType, requestParameters.id, requestParameters.createdAt, requestParameters.returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the customer\'s credit details
         * @param {CreditsApiCreditsCustomerGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerGet(requestParameters: CreditsApiCreditsCustomerGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CreditCustomer> {
            return localVarFp.creditsCustomerGet(requestParameters.returnAutoRenewal, requestParameters.returnSupportPlan, requestParameters.returnRecurringPlans, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Migrate the customer\'s subscription & any other purchased items to the credit system
         * @param {CreditsApiCreditsCustomerMigrateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerMigrate(requestParameters: CreditsApiCreditsCustomerMigrateRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.creditsCustomerMigrate(requestParameters.creditCustomerMigrate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new customer, or link the team to an existing customer
         * @param {CreditsApiCreditsCustomerPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerPost(requestParameters: CreditsApiCreditsCustomerPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CreditsCustomerPost200Response> {
            return localVarFp.creditsCustomerPost(requestParameters.creditCustomerPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refreshes the customer\'s subscription & any other purchased items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsCustomerRefresh(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.creditsCustomerRefresh(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get metadata for credit consumptions and unlocks
         * @param {CreditsApiCreditsPreferencesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsPreferencesGet(requestParameters: CreditsApiCreditsPreferencesGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<CreditsPreferences> {
            return localVarFp.creditsPreferencesGet(requestParameters.region, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the system credit preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsPreferencesGetAdmin(options?: AxiosRequestConfig): AxiosPromise<CreditsPreferences> {
            return localVarFp.creditsPreferencesGetAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the given credit preferences
         * @param {CreditsApiCreditsPreferencesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        creditsPreferencesPost(requestParameters: CreditsApiCreditsPreferencesPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.creditsPreferencesPost(requestParameters.creditsPreferencesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create/update/cancel the support plan
         * @param {CreditsApiModifySupportPlanRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySupportPlan(requestParameters: CreditsApiModifySupportPlanRequest = {}, options?: AxiosRequestConfig): AxiosPromise<RecurringCreditConsumption> {
            return localVarFp.modifySupportPlan(requestParameters.modifySupportPlan, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recurring credit consumptions
         * @param {CreditsApiRecurringCreditsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recurringCreditsGet(requestParameters: CreditsApiRecurringCreditsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<RecurringCreditsGet200Response> {
            return localVarFp.recurringCreditsGet(requestParameters.teamId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.returnTotal, requestParameters.doneBy, requestParameters.dateRage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new recurring credit consumption record
         * @param {CreditsApiStartRecurringConsumptionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRecurringConsumption(requestParameters: CreditsApiStartRecurringConsumptionRequest = {}, options?: AxiosRequestConfig): AxiosPromise<RecurringCreditConsumption> {
            return localVarFp.startRecurringConsumption(requestParameters.recurringCreditConsumptionCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop a recurring credit consumption
         * @param {CreditsApiStopRecurringConsumptionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRecurringConsumption(requestParameters: CreditsApiStopRecurringConsumptionRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stopRecurringConsumption(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Top up credits
         * @param {CreditsApiTopUpCreditsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topUpCreditsPost(requestParameters: CreditsApiTopUpCreditsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PaymentRequest> {
            return localVarFp.topUpCreditsPost(requestParameters.creditTopUpOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for autoRenewalPost operation in CreditsApi.
 * @export
 * @interface CreditsApiAutoRenewalPostRequest
 */
export interface CreditsApiAutoRenewalPostRequest {
    /**
     * 
     * @type {CreditAutoRenewalUpdate}
     * @memberof CreditsApiAutoRenewalPost
     */
    readonly creditAutoRenewalUpdate?: CreditAutoRenewalUpdate
}

/**
 * Request parameters for canConsumeCredits operation in CreditsApi.
 * @export
 * @interface CreditsApiCanConsumeCreditsRequest
 */
export interface CreditsApiCanConsumeCreditsRequest {
    /**
     * The type of consumption
     * @type {CreditConsumptionType}
     * @memberof CreditsApiCanConsumeCredits
     */
    readonly type: CreditConsumptionType

    /**
     * The number of times to consume the given type
     * @type {number}
     * @memberof CreditsApiCanConsumeCredits
     */
    readonly quantity: number

    /**
     * 
     * @type {LegacyCanConsumeOpts}
     * @memberof CreditsApiCanConsumeCredits
     */
    readonly legacyOpts?: LegacyCanConsumeOpts
}

/**
 * Request parameters for canConsumeRecurringCredits operation in CreditsApi.
 * @export
 * @interface CreditsApiCanConsumeRecurringCreditsRequest
 */
export interface CreditsApiCanConsumeRecurringCreditsRequest {
    /**
     * The type of consumption
     * @type {RecurringCreditConsumptionType}
     * @memberof CreditsApiCanConsumeRecurringCredits
     */
    readonly type: RecurringCreditConsumptionType

    /**
     * 
     * @type {LegacyCanConsumeOpts}
     * @memberof CreditsApiCanConsumeRecurringCredits
     */
    readonly legacyOpts?: LegacyCanConsumeOpts
}

/**
 * Request parameters for creditConsumptionPost operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditConsumptionPostRequest
 */
export interface CreditsApiCreditConsumptionPostRequest {
    /**
     * 
     * @type {CreditConsumptionPostRequest}
     * @memberof CreditsApiCreditConsumptionPost
     */
    readonly creditConsumptionPostRequest?: CreditConsumptionPostRequest
}

/**
 * Request parameters for creditGainsGet operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditGainsGetRequest
 */
export interface CreditsApiCreditGainsGetRequest {
    /**
     * Filter by customerId.
     * @type {string}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly customerId?: string

    /**
     * 
     * @type {number}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly cursor?: string

    /**
     * 
     * @type {Array<CreditGainType>}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly type?: Array<CreditGainType>

    /**
     * 
     * @type {DateRange}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly createdAt?: DateRange

    /**
     * 
     * @type {CreditGainStatus}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly status?: CreditGainStatus

    /**
     * Return total number of consumptions
     * @type {boolean}
     * @memberof CreditsApiCreditGainsGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for creditGainsPost operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditGainsPostRequest
 */
export interface CreditsApiCreditGainsPostRequest {
    /**
     * 
     * @type {CreditGainCreate}
     * @memberof CreditsApiCreditGainsPost
     */
    readonly creditGainCreate?: CreditGainCreate
}

/**
 * Request parameters for creditTxsGet operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditTxsGetRequest
 */
export interface CreditsApiCreditTxsGetRequest {
    /**
     * Filter by teamId
     * @type {string}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly teamId?: string

    /**
     * Filter by customerId
     * @type {string}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly customerId?: string

    /**
     * 
     * @type {number}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly cursor?: string

    /**
     * 
     * @type {Array<CreditBalanceEffectType>}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly type?: Array<CreditBalanceEffectType>

    /**
     * 
     * @type {'gain' | 'consume'}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly effectType?: 'gain' | 'consume'

    /**
     * 
     * @type {Array<string>}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly id?: Array<string>

    /**
     * 
     * @type {DateRange}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly createdAt?: DateRange

    /**
     * Return total number of consumptions
     * @type {boolean}
     * @memberof CreditsApiCreditTxsGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for creditsCustomerGet operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditsCustomerGetRequest
 */
export interface CreditsApiCreditsCustomerGetRequest {
    /**
     * Return the auto-renewal subscription details. PAYMENTS_READ scope is required.
     * @type {boolean}
     * @memberof CreditsApiCreditsCustomerGet
     */
    readonly returnAutoRenewal?: boolean

    /**
     * Return the support plan details.
     * @type {boolean}
     * @memberof CreditsApiCreditsCustomerGet
     */
    readonly returnSupportPlan?: boolean

    /**
     * Return the support plan details.
     * @type {boolean}
     * @memberof CreditsApiCreditsCustomerGet
     */
    readonly returnRecurringPlans?: boolean
}

/**
 * Request parameters for creditsCustomerMigrate operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditsCustomerMigrateRequest
 */
export interface CreditsApiCreditsCustomerMigrateRequest {
    /**
     * 
     * @type {CreditCustomerMigrate}
     * @memberof CreditsApiCreditsCustomerMigrate
     */
    readonly creditCustomerMigrate?: CreditCustomerMigrate
}

/**
 * Request parameters for creditsCustomerPost operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditsCustomerPostRequest
 */
export interface CreditsApiCreditsCustomerPostRequest {
    /**
     * 
     * @type {CreditCustomerPost}
     * @memberof CreditsApiCreditsCustomerPost
     */
    readonly creditCustomerPost?: CreditCustomerPost
}

/**
 * Request parameters for creditsPreferencesGet operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditsPreferencesGetRequest
 */
export interface CreditsApiCreditsPreferencesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditsApiCreditsPreferencesGet
     */
    readonly region?: string
}

/**
 * Request parameters for creditsPreferencesPost operation in CreditsApi.
 * @export
 * @interface CreditsApiCreditsPreferencesPostRequest
 */
export interface CreditsApiCreditsPreferencesPostRequest {
    /**
     * 
     * @type {CreditsPreferencesPostRequest}
     * @memberof CreditsApiCreditsPreferencesPost
     */
    readonly creditsPreferencesPostRequest?: CreditsPreferencesPostRequest
}

/**
 * Request parameters for modifySupportPlan operation in CreditsApi.
 * @export
 * @interface CreditsApiModifySupportPlanRequest
 */
export interface CreditsApiModifySupportPlanRequest {
    /**
     * 
     * @type {ModifySupportPlan}
     * @memberof CreditsApiModifySupportPlan
     */
    readonly modifySupportPlan?: ModifySupportPlan
}

/**
 * Request parameters for recurringCreditsGet operation in CreditsApi.
 * @export
 * @interface CreditsApiRecurringCreditsGetRequest
 */
export interface CreditsApiRecurringCreditsGetRequest {
    /**
     * Filter by teamId
     * @type {string}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly teamId?: string

    /**
     * 
     * @type {number}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly cursor?: string

    /**
     * 
     * @type {RecurringCreditConsumptionType}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly type?: RecurringCreditConsumptionType

    /**
     * Return total number of consumptions
     * @type {boolean}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly returnTotal?: boolean

    /**
     * Filter by the user who created the consumption
     * @type {string}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly doneBy?: string

    /**
     * 
     * @type {RecurringCreditsGetDateRageParameter}
     * @memberof CreditsApiRecurringCreditsGet
     */
    readonly dateRage?: RecurringCreditsGetDateRageParameter
}

/**
 * Request parameters for startRecurringConsumption operation in CreditsApi.
 * @export
 * @interface CreditsApiStartRecurringConsumptionRequest
 */
export interface CreditsApiStartRecurringConsumptionRequest {
    /**
     * 
     * @type {RecurringCreditConsumptionCreate}
     * @memberof CreditsApiStartRecurringConsumption
     */
    readonly recurringCreditConsumptionCreate?: RecurringCreditConsumptionCreate
}

/**
 * Request parameters for stopRecurringConsumption operation in CreditsApi.
 * @export
 * @interface CreditsApiStopRecurringConsumptionRequest
 */
export interface CreditsApiStopRecurringConsumptionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreditsApiStopRecurringConsumption
     */
    readonly id: string
}

/**
 * Request parameters for topUpCreditsPost operation in CreditsApi.
 * @export
 * @interface CreditsApiTopUpCreditsPostRequest
 */
export interface CreditsApiTopUpCreditsPostRequest {
    /**
     * 
     * @type {CreditTopUpOptions}
     * @memberof CreditsApiTopUpCreditsPost
     */
    readonly creditTopUpOptions?: CreditTopUpOptions
}

/**
 * CreditsApi - object-oriented interface
 * @export
 * @class CreditsApi
 * @extends {BaseAPI}
 */
export class CreditsApi extends BaseAPI {
    /**
     * 
     * @summary Cancel the current auto-renewal credit sub
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public autoRenewalCancel(options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).autoRenewalCancel(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create/update the auto-renewal credit sub
     * @param {CreditsApiAutoRenewalPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public autoRenewalPost(requestParameters: CreditsApiAutoRenewalPostRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).autoRenewalPost(requestParameters.creditAutoRenewalUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if the team can consume the given quantity of credits
     * @param {CreditsApiCanConsumeCreditsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public canConsumeCredits(requestParameters: CreditsApiCanConsumeCreditsRequest, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).canConsumeCredits(requestParameters.type, requestParameters.quantity, requestParameters.legacyOpts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if the team can consume the given quantity of credits
     * @param {CreditsApiCanConsumeRecurringCreditsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public canConsumeRecurringCredits(requestParameters: CreditsApiCanConsumeRecurringCreditsRequest, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).canConsumeRecurringCredits(requestParameters.type, requestParameters.legacyOpts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new single use credit consumption record
     * @param {CreditsApiCreditConsumptionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditConsumptionPost(requestParameters: CreditsApiCreditConsumptionPostRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditConsumptionPost(requestParameters.creditConsumptionPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of gains your team has received
     * @param {CreditsApiCreditGainsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditGainsGet(requestParameters: CreditsApiCreditGainsGetRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditGainsGet(requestParameters.customerId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.createdAt, requestParameters.status, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new credit gain
     * @param {CreditsApiCreditGainsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditGainsPost(requestParameters: CreditsApiCreditGainsPostRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditGainsPost(requestParameters.creditGainCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transaction history
     * @param {CreditsApiCreditTxsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditTxsGet(requestParameters: CreditsApiCreditTxsGetRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditTxsGet(requestParameters.teamId, requestParameters.customerId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.effectType, requestParameters.id, requestParameters.createdAt, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the customer\'s credit details
     * @param {CreditsApiCreditsCustomerGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditsCustomerGet(requestParameters: CreditsApiCreditsCustomerGetRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditsCustomerGet(requestParameters.returnAutoRenewal, requestParameters.returnSupportPlan, requestParameters.returnRecurringPlans, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Migrate the customer\'s subscription & any other purchased items to the credit system
     * @param {CreditsApiCreditsCustomerMigrateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditsCustomerMigrate(requestParameters: CreditsApiCreditsCustomerMigrateRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditsCustomerMigrate(requestParameters.creditCustomerMigrate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new customer, or link the team to an existing customer
     * @param {CreditsApiCreditsCustomerPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditsCustomerPost(requestParameters: CreditsApiCreditsCustomerPostRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditsCustomerPost(requestParameters.creditCustomerPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refreshes the customer\'s subscription & any other purchased items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditsCustomerRefresh(options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditsCustomerRefresh(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get metadata for credit consumptions and unlocks
     * @param {CreditsApiCreditsPreferencesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditsPreferencesGet(requestParameters: CreditsApiCreditsPreferencesGetRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditsPreferencesGet(requestParameters.region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the system credit preferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditsPreferencesGetAdmin(options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditsPreferencesGetAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the given credit preferences
     * @param {CreditsApiCreditsPreferencesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public creditsPreferencesPost(requestParameters: CreditsApiCreditsPreferencesPostRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).creditsPreferencesPost(requestParameters.creditsPreferencesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create/update/cancel the support plan
     * @param {CreditsApiModifySupportPlanRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public modifySupportPlan(requestParameters: CreditsApiModifySupportPlanRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).modifySupportPlan(requestParameters.modifySupportPlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recurring credit consumptions
     * @param {CreditsApiRecurringCreditsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public recurringCreditsGet(requestParameters: CreditsApiRecurringCreditsGetRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).recurringCreditsGet(requestParameters.teamId, requestParameters.count, requestParameters.cursor, requestParameters.type, requestParameters.returnTotal, requestParameters.doneBy, requestParameters.dateRage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new recurring credit consumption record
     * @param {CreditsApiStartRecurringConsumptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public startRecurringConsumption(requestParameters: CreditsApiStartRecurringConsumptionRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).startRecurringConsumption(requestParameters.recurringCreditConsumptionCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop a recurring credit consumption
     * @param {CreditsApiStopRecurringConsumptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public stopRecurringConsumption(requestParameters: CreditsApiStopRecurringConsumptionRequest, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).stopRecurringConsumption(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Top up credits
     * @param {CreditsApiTopUpCreditsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditsApi
     */
    public topUpCreditsPost(requestParameters: CreditsApiTopUpCreditsPostRequest = {}, options?: AxiosRequestConfig) {
        return CreditsApiFp(this.configuration).topUpCreditsPost(requestParameters.creditTopUpOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch All Available Products
         * @param {string} [region] The region to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet: async (region?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a product\'s properties
         * @param {string} id 
         * @param {ProductUpdate} [productUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPatch: async (id: string, productUpdate?: ProductUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsPatch', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new product
         * @param {ProductCreate} [productCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPost: async (productCreate?: ProductCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch All Available Products
         * @param {string} [region] The region to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGet(region?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGet(region, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a product\'s properties
         * @param {string} id 
         * @param {ProductUpdate} [productUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsPatch(id: string, productUpdate?: ProductUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsPatch(id, productUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new product
         * @param {ProductCreate} [productCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsPost(productCreate?: ProductCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsPost(productCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch All Available Products
         * @param {ProductsApiProductsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet(requestParameters: ProductsApiProductsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ProductsGet200Response> {
            return localVarFp.productsGet(requestParameters.region, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a product\'s properties
         * @param {ProductsApiProductsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPatch(requestParameters: ProductsApiProductsPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.productsPatch(requestParameters.id, requestParameters.productUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new product
         * @param {ProductsApiProductsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsPost(requestParameters: ProductsApiProductsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Product> {
            return localVarFp.productsPost(requestParameters.productCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for productsGet operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsGetRequest
 */
export interface ProductsApiProductsGetRequest {
    /**
     * The region to filter by
     * @type {string}
     * @memberof ProductsApiProductsGet
     */
    readonly region?: string
}

/**
 * Request parameters for productsPatch operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsPatchRequest
 */
export interface ProductsApiProductsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductsApiProductsPatch
     */
    readonly id: string

    /**
     * 
     * @type {ProductUpdate}
     * @memberof ProductsApiProductsPatch
     */
    readonly productUpdate?: ProductUpdate
}

/**
 * Request parameters for productsPost operation in ProductsApi.
 * @export
 * @interface ProductsApiProductsPostRequest
 */
export interface ProductsApiProductsPostRequest {
    /**
     * 
     * @type {ProductCreate}
     * @memberof ProductsApiProductsPost
     */
    readonly productCreate?: ProductCreate
}

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch All Available Products
     * @param {ProductsApiProductsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsGet(requestParameters: ProductsApiProductsGetRequest = {}, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsGet(requestParameters.region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a product\'s properties
     * @param {ProductsApiProductsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsPatch(requestParameters: ProductsApiProductsPatchRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsPatch(requestParameters.id, requestParameters.productUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new product
     * @param {ProductsApiProductsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public productsPost(requestParameters: ProductsApiProductsPostRequest = {}, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).productsPost(requestParameters.productCreate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReferralsApi - axios parameter creator
 * @export
 */
export const ReferralsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartner: async (referralCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'referralCode' is not null or undefined
            assertParamExists('getPartner', 'referralCode', referralCode)
            const localVarPath = `/partner-referral/get-partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (referralCode !== undefined) {
                localVarQueryParameter['referralCode'] = referralCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsDelete: async (referralCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'referralCode' is not null or undefined
            assertParamExists('partnerReferralsDelete', 'referralCode', referralCode)
            const localVarPath = `/partner-referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PARTNER_ADMIN_PANEL_ACCESS", "ADMIN_PANEL_ACCESS"], configuration)

            if (referralCode !== undefined) {
                localVarQueryParameter['referralCode'] = referralCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] The page for the cursor
         * @param {number} [count] The numbers of items to return
         * @param {Array<string>} [id] The array of referralCodes to be fetched
         * @param {string} [q] Search by id, productId, etc
         * @param {boolean} [returnTotal] Include the total number of referralCodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsGet: async (page?: number, count?: number, id?: Array<string>, q?: string, returnTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partner-referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PARTNER_ADMIN_PANEL_ACCESS", "ADMIN_PANEL_ACCESS"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PartnerReferralCreateOptions} [partnerReferralCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsPost: async (partnerReferralCreateOptions?: PartnerReferralCreateOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partner-referral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PARTNER_ADMIN_PANEL_ACCESS", "ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerReferralCreateOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferralsApi - functional programming interface
 * @export
 */
export const ReferralsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferralsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartner(referralCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPartner200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartner(referralCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} referralCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerReferralsDelete(referralCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerReferralsDelete(referralCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] The page for the cursor
         * @param {number} [count] The numbers of items to return
         * @param {Array<string>} [id] The array of referralCodes to be fetched
         * @param {string} [q] Search by id, productId, etc
         * @param {boolean} [returnTotal] Include the total number of referralCodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerReferralsGet(page?: number, count?: number, id?: Array<string>, q?: string, returnTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerReferralsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerReferralsGet(page, count, id, q, returnTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PartnerReferralCreateOptions} [partnerReferralCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerReferralsPost(partnerReferralCreateOptions?: PartnerReferralCreateOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerReferralsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerReferralsPost(partnerReferralCreateOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReferralsApi - factory interface
 * @export
 */
export const ReferralsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferralsApiFp(configuration)
    return {
        /**
         * 
         * @param {ReferralsApiGetPartnerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartner(requestParameters: ReferralsApiGetPartnerRequest, options?: AxiosRequestConfig): AxiosPromise<GetPartner200Response> {
            return localVarFp.getPartner(requestParameters.referralCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReferralsApiPartnerReferralsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsDelete(requestParameters: ReferralsApiPartnerReferralsDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.partnerReferralsDelete(requestParameters.referralCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReferralsApiPartnerReferralsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsGet(requestParameters: ReferralsApiPartnerReferralsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PartnerReferralsGet200Response> {
            return localVarFp.partnerReferralsGet(requestParameters.page, requestParameters.count, requestParameters.id, requestParameters.q, requestParameters.returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReferralsApiPartnerReferralsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerReferralsPost(requestParameters: ReferralsApiPartnerReferralsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<PartnerReferralsPost200Response> {
            return localVarFp.partnerReferralsPost(requestParameters.partnerReferralCreateOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPartner operation in ReferralsApi.
 * @export
 * @interface ReferralsApiGetPartnerRequest
 */
export interface ReferralsApiGetPartnerRequest {
    /**
     * 
     * @type {string}
     * @memberof ReferralsApiGetPartner
     */
    readonly referralCode: string
}

/**
 * Request parameters for partnerReferralsDelete operation in ReferralsApi.
 * @export
 * @interface ReferralsApiPartnerReferralsDeleteRequest
 */
export interface ReferralsApiPartnerReferralsDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ReferralsApiPartnerReferralsDelete
     */
    readonly referralCode: string
}

/**
 * Request parameters for partnerReferralsGet operation in ReferralsApi.
 * @export
 * @interface ReferralsApiPartnerReferralsGetRequest
 */
export interface ReferralsApiPartnerReferralsGetRequest {
    /**
     * The page for the cursor
     * @type {number}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly page?: number

    /**
     * The numbers of items to return
     * @type {number}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly count?: number

    /**
     * The array of referralCodes to be fetched
     * @type {Array<string>}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly id?: Array<string>

    /**
     * Search by id, productId, etc
     * @type {string}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly q?: string

    /**
     * Include the total number of referralCodes
     * @type {boolean}
     * @memberof ReferralsApiPartnerReferralsGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for partnerReferralsPost operation in ReferralsApi.
 * @export
 * @interface ReferralsApiPartnerReferralsPostRequest
 */
export interface ReferralsApiPartnerReferralsPostRequest {
    /**
     * 
     * @type {PartnerReferralCreateOptions}
     * @memberof ReferralsApiPartnerReferralsPost
     */
    readonly partnerReferralCreateOptions?: PartnerReferralCreateOptions
}

/**
 * ReferralsApi - object-oriented interface
 * @export
 * @class ReferralsApi
 * @extends {BaseAPI}
 */
export class ReferralsApi extends BaseAPI {
    /**
     * 
     * @param {ReferralsApiGetPartnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public getPartner(requestParameters: ReferralsApiGetPartnerRequest, options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).getPartner(requestParameters.referralCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReferralsApiPartnerReferralsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public partnerReferralsDelete(requestParameters: ReferralsApiPartnerReferralsDeleteRequest, options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).partnerReferralsDelete(requestParameters.referralCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReferralsApiPartnerReferralsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public partnerReferralsGet(requestParameters: ReferralsApiPartnerReferralsGetRequest = {}, options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).partnerReferralsGet(requestParameters.page, requestParameters.count, requestParameters.id, requestParameters.q, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReferralsApiPartnerReferralsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferralsApi
     */
    public partnerReferralsPost(requestParameters: ReferralsApiPartnerReferralsPostRequest = {}, options?: AxiosRequestConfig) {
        return ReferralsApiFp(this.configuration).partnerReferralsPost(requestParameters.partnerReferralCreateOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StripeApi - axios parameter creator
 * @export
 */
export const StripeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {string} returnUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingSessionPost: async (returnUrl: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'returnUrl' is not null or undefined
            assertParamExists('billingSessionPost', 'returnUrl', returnUrl)
            const localVarPath = `/billing-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)

            if (returnUrl !== undefined) {
                localVarQueryParameter['returnUrl'] = returnUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a checkout session
         * @param {CheckoutCreateOptions} [checkoutCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeCheckout: async (checkoutCreateOptions?: CheckoutCreateOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/checkout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutCreateOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Receive stripe hook
         * @param {string} secret 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeHook: async (secret: string, requestBody?: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'secret' is not null or undefined
            assertParamExists('stripeHook', 'secret', secret)
            const localVarPath = `/stripe/webhook/{secret}`
                .replace(`{${"secret"}}`, encodeURIComponent(String(secret)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a payment intent
         * @param {string} [stripeCustomerId] The stripe customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripePaymentIntentsGet: async (stripeCustomerId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/payment-intents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)

            if (stripeCustomerId !== undefined) {
                localVarQueryParameter['stripeCustomerId'] = stripeCustomerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use results from here to attach prices to products.
         * @summary Get prices from Stripe
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {string} [q] Filter by stripe query. See https://stripe.com/docs/search#search-query-language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripePricesGet: async (count?: number, cursor?: string, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/prices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {string} returnUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingSessionPost(returnUrl: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingSessionPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingSessionPost(returnUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a checkout session
         * @param {CheckoutCreateOptions} [checkoutCreateOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeCheckout(checkoutCreateOptions?: CheckoutCreateOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeCheckout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripeCheckout(checkoutCreateOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Receive stripe hook
         * @param {string} secret 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeHook(secret: string, requestBody?: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripeHook(secret, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a payment intent
         * @param {string} [stripeCustomerId] The stripe customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripePaymentIntentsGet(stripeCustomerId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripePaymentIntentsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripePaymentIntentsGet(stripeCustomerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use results from here to attach prices to products.
         * @summary Get prices from Stripe
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {string} [q] Filter by stripe query. See https://stripe.com/docs/search#search-query-language
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripePricesGet(count?: number, cursor?: string, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripePricesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripePricesGet(count, cursor, q, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new billing portal session to manage payment details
         * @param {StripeApiBillingSessionPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingSessionPost(requestParameters: StripeApiBillingSessionPostRequest, options?: AxiosRequestConfig): AxiosPromise<BillingSessionPost200Response> {
            return localVarFp.billingSessionPost(requestParameters.returnUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a checkout session
         * @param {StripeApiStripeCheckoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeCheckout(requestParameters: StripeApiStripeCheckoutRequest = {}, options?: AxiosRequestConfig): AxiosPromise<StripeCheckout200Response> {
            return localVarFp.stripeCheckout(requestParameters.checkoutCreateOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Receive stripe hook
         * @param {StripeApiStripeHookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeHook(requestParameters: StripeApiStripeHookRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stripeHook(requestParameters.secret, requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a payment intent
         * @param {StripeApiStripePaymentIntentsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripePaymentIntentsGet(requestParameters: StripeApiStripePaymentIntentsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<StripePaymentIntentsGet200Response> {
            return localVarFp.stripePaymentIntentsGet(requestParameters.stripeCustomerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use results from here to attach prices to products.
         * @summary Get prices from Stripe
         * @param {StripeApiStripePricesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripePricesGet(requestParameters: StripeApiStripePricesGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<StripePricesGet200Response> {
            return localVarFp.stripePricesGet(requestParameters.count, requestParameters.cursor, requestParameters.q, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for billingSessionPost operation in StripeApi.
 * @export
 * @interface StripeApiBillingSessionPostRequest
 */
export interface StripeApiBillingSessionPostRequest {
    /**
     * 
     * @type {string}
     * @memberof StripeApiBillingSessionPost
     */
    readonly returnUrl: string
}

/**
 * Request parameters for stripeCheckout operation in StripeApi.
 * @export
 * @interface StripeApiStripeCheckoutRequest
 */
export interface StripeApiStripeCheckoutRequest {
    /**
     * 
     * @type {CheckoutCreateOptions}
     * @memberof StripeApiStripeCheckout
     */
    readonly checkoutCreateOptions?: CheckoutCreateOptions
}

/**
 * Request parameters for stripeHook operation in StripeApi.
 * @export
 * @interface StripeApiStripeHookRequest
 */
export interface StripeApiStripeHookRequest {
    /**
     * 
     * @type {string}
     * @memberof StripeApiStripeHook
     */
    readonly secret: string

    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof StripeApiStripeHook
     */
    readonly requestBody?: { [key: string]: any; }
}

/**
 * Request parameters for stripePaymentIntentsGet operation in StripeApi.
 * @export
 * @interface StripeApiStripePaymentIntentsGetRequest
 */
export interface StripeApiStripePaymentIntentsGetRequest {
    /**
     * The stripe customer ID
     * @type {string}
     * @memberof StripeApiStripePaymentIntentsGet
     */
    readonly stripeCustomerId?: string
}

/**
 * Request parameters for stripePricesGet operation in StripeApi.
 * @export
 * @interface StripeApiStripePricesGetRequest
 */
export interface StripeApiStripePricesGetRequest {
    /**
     * 
     * @type {number}
     * @memberof StripeApiStripePricesGet
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof StripeApiStripePricesGet
     */
    readonly cursor?: string

    /**
     * Filter by stripe query. See https://stripe.com/docs/search#search-query-language
     * @type {string}
     * @memberof StripeApiStripePricesGet
     */
    readonly q?: string
}

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
    /**
     * 
     * @summary Create a new billing portal session to manage payment details
     * @param {StripeApiBillingSessionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public billingSessionPost(requestParameters: StripeApiBillingSessionPostRequest, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).billingSessionPost(requestParameters.returnUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a checkout session
     * @param {StripeApiStripeCheckoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public stripeCheckout(requestParameters: StripeApiStripeCheckoutRequest = {}, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).stripeCheckout(requestParameters.checkoutCreateOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Receive stripe hook
     * @param {StripeApiStripeHookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public stripeHook(requestParameters: StripeApiStripeHookRequest, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).stripeHook(requestParameters.secret, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a payment intent
     * @param {StripeApiStripePaymentIntentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public stripePaymentIntentsGet(requestParameters: StripeApiStripePaymentIntentsGetRequest = {}, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).stripePaymentIntentsGet(requestParameters.stripeCustomerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use results from here to attach prices to products.
     * @summary Get prices from Stripe
     * @param {StripeApiStripePricesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public stripePricesGet(requestParameters: StripeApiStripePricesGetRequest = {}, options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).stripePricesGet(requestParameters.count, requestParameters.cursor, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the list of subscriptions
         * @param {string} [teamId] Filter by teamId
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {string} [q] Search by subscription ID, team ID or product name
         * @param {boolean} [includeFreeTier] Include free tier subscriptions
         * @param {'startDate' | 'endOrNextRenewalDate'} [sortBy] Sort by the given field
         * @param {'asc' | 'desc'} [sortDirection] Sort direction
         * @param {string} [endsOrRenewsAfter] Filter subscriptions that end or renew after the given date
         * @param {string} [endsOrRenewsBefore] Filter subscriptions that end or renew before the given date
         * @param {boolean} [stripeOnly] Filter subscriptions that are only in Stripe
         * @param {Array<string>} [product] Filter subscriptions by product
         * @param {boolean} [returnTotal] Return total number of subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsGet: async (teamId?: string, count?: number, page?: number, q?: string, includeFreeTier?: boolean, sortBy?: 'startDate' | 'endOrNextRenewalDate', sortDirection?: 'asc' | 'desc', endsOrRenewsAfter?: string, endsOrRenewsBefore?: string, stripeOnly?: boolean, product?: Array<string>, returnTotal?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_READ"], configuration)

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (includeFreeTier !== undefined) {
                localVarQueryParameter['includeFreeTier'] = includeFreeTier;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }

            if (endsOrRenewsAfter !== undefined) {
                localVarQueryParameter['endsOrRenewsAfter'] = (endsOrRenewsAfter as any instanceof Date) ?
                    (endsOrRenewsAfter as any).toISOString() :
                    endsOrRenewsAfter;
            }

            if (endsOrRenewsBefore !== undefined) {
                localVarQueryParameter['endsOrRenewsBefore'] = (endsOrRenewsBefore as any instanceof Date) ?
                    (endsOrRenewsBefore as any).toISOString() :
                    endsOrRenewsBefore;
            }

            if (stripeOnly !== undefined) {
                localVarQueryParameter['stripeOnly'] = stripeOnly;
            }

            if (product) {
                localVarQueryParameter['product'] = product;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a subscription\'s properties
         * @param {string} id 
         * @param {SubscriptionUpdate} [subscriptionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPatch: async (id: string, subscriptionUpdate?: SubscriptionUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subscriptionsPatch', 'id', id)
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subscription created here does not get counted in revenue. Not recommended, create a payment link instead.
         * @summary Manually create a subscription for the team
         * @param {SubscriptionCreate} [subscriptionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPost: async (subscriptionCreate?: SubscriptionCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the list of subscriptions
         * @param {string} [teamId] Filter by teamId
         * @param {number} [count] 
         * @param {number} [page] 
         * @param {string} [q] Search by subscription ID, team ID or product name
         * @param {boolean} [includeFreeTier] Include free tier subscriptions
         * @param {'startDate' | 'endOrNextRenewalDate'} [sortBy] Sort by the given field
         * @param {'asc' | 'desc'} [sortDirection] Sort direction
         * @param {string} [endsOrRenewsAfter] Filter subscriptions that end or renew after the given date
         * @param {string} [endsOrRenewsBefore] Filter subscriptions that end or renew before the given date
         * @param {boolean} [stripeOnly] Filter subscriptions that are only in Stripe
         * @param {Array<string>} [product] Filter subscriptions by product
         * @param {boolean} [returnTotal] Return total number of subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsGet(teamId?: string, count?: number, page?: number, q?: string, includeFreeTier?: boolean, sortBy?: 'startDate' | 'endOrNextRenewalDate', sortDirection?: 'asc' | 'desc', endsOrRenewsAfter?: string, endsOrRenewsBefore?: string, stripeOnly?: boolean, product?: Array<string>, returnTotal?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsGet(teamId, count, page, q, includeFreeTier, sortBy, sortDirection, endsOrRenewsAfter, endsOrRenewsBefore, stripeOnly, product, returnTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a subscription\'s properties
         * @param {string} id 
         * @param {SubscriptionUpdate} [subscriptionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsPatch(id: string, subscriptionUpdate?: SubscriptionUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsPatch(id, subscriptionUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Subscription created here does not get counted in revenue. Not recommended, create a payment link instead.
         * @summary Manually create a subscription for the team
         * @param {SubscriptionCreate} [subscriptionCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionsPost(subscriptionCreate?: SubscriptionCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionsPost(subscriptionCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the list of subscriptions
         * @param {SubscriptionsApiSubscriptionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsGet(requestParameters: SubscriptionsApiSubscriptionsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<SubscriptionsGet200Response> {
            return localVarFp.subscriptionsGet(requestParameters.teamId, requestParameters.count, requestParameters.page, requestParameters.q, requestParameters.includeFreeTier, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.endsOrRenewsAfter, requestParameters.endsOrRenewsBefore, requestParameters.stripeOnly, requestParameters.product, requestParameters.returnTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a subscription\'s properties
         * @param {SubscriptionsApiSubscriptionsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPatch(requestParameters: SubscriptionsApiSubscriptionsPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.subscriptionsPatch(requestParameters.id, requestParameters.subscriptionUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Subscription created here does not get counted in revenue. Not recommended, create a payment link instead.
         * @summary Manually create a subscription for the team
         * @param {SubscriptionsApiSubscriptionsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionsPost(requestParameters: SubscriptionsApiSubscriptionsPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Subscription> {
            return localVarFp.subscriptionsPost(requestParameters.subscriptionCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for subscriptionsGet operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiSubscriptionsGetRequest
 */
export interface SubscriptionsApiSubscriptionsGetRequest {
    /**
     * Filter by teamId
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly teamId?: string

    /**
     * 
     * @type {number}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly count?: number

    /**
     * 
     * @type {number}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly page?: number

    /**
     * Search by subscription ID, team ID or product name
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly q?: string

    /**
     * Include free tier subscriptions
     * @type {boolean}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly includeFreeTier?: boolean

    /**
     * Sort by the given field
     * @type {'startDate' | 'endOrNextRenewalDate'}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly sortBy?: 'startDate' | 'endOrNextRenewalDate'

    /**
     * Sort direction
     * @type {'asc' | 'desc'}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly sortDirection?: 'asc' | 'desc'

    /**
     * Filter subscriptions that end or renew after the given date
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly endsOrRenewsAfter?: string

    /**
     * Filter subscriptions that end or renew before the given date
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly endsOrRenewsBefore?: string

    /**
     * Filter subscriptions that are only in Stripe
     * @type {boolean}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly stripeOnly?: boolean

    /**
     * Filter subscriptions by product
     * @type {Array<string>}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly product?: Array<string>

    /**
     * Return total number of subscriptions
     * @type {boolean}
     * @memberof SubscriptionsApiSubscriptionsGet
     */
    readonly returnTotal?: boolean
}

/**
 * Request parameters for subscriptionsPatch operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiSubscriptionsPatchRequest
 */
export interface SubscriptionsApiSubscriptionsPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionsApiSubscriptionsPatch
     */
    readonly id: string

    /**
     * 
     * @type {SubscriptionUpdate}
     * @memberof SubscriptionsApiSubscriptionsPatch
     */
    readonly subscriptionUpdate?: SubscriptionUpdate
}

/**
 * Request parameters for subscriptionsPost operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiSubscriptionsPostRequest
 */
export interface SubscriptionsApiSubscriptionsPostRequest {
    /**
     * 
     * @type {SubscriptionCreate}
     * @memberof SubscriptionsApiSubscriptionsPost
     */
    readonly subscriptionCreate?: SubscriptionCreate
}

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * 
     * @summary Get the list of subscriptions
     * @param {SubscriptionsApiSubscriptionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsGet(requestParameters: SubscriptionsApiSubscriptionsGetRequest = {}, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscriptionsGet(requestParameters.teamId, requestParameters.count, requestParameters.page, requestParameters.q, requestParameters.includeFreeTier, requestParameters.sortBy, requestParameters.sortDirection, requestParameters.endsOrRenewsAfter, requestParameters.endsOrRenewsBefore, requestParameters.stripeOnly, requestParameters.product, requestParameters.returnTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a subscription\'s properties
     * @param {SubscriptionsApiSubscriptionsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsPatch(requestParameters: SubscriptionsApiSubscriptionsPatchRequest, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscriptionsPatch(requestParameters.id, requestParameters.subscriptionUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subscription created here does not get counted in revenue. Not recommended, create a payment link instead.
     * @summary Manually create a subscription for the team
     * @param {SubscriptionsApiSubscriptionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public subscriptionsPost(requestParameters: SubscriptionsApiSubscriptionsPostRequest = {}, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).subscriptionsPost(requestParameters.subscriptionCreate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamDetailApi - axios parameter creator
 * @export
 */
export const TeamDetailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If the account is an independent account, the access details for the account are returned. Otherwise, the team\'s access details are returned.
         * @summary Get the access details for the given account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailAccountAccessGet: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('teamDetailAccountAccessGet', 'accountId', accountId)
            const localVarPath = `/team-detail/account-access/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the team\'s subscription and payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/team-detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the team\'s subscription and payment details
         * @param {TeamDetailUpdate} [teamDetailUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailPatch: async (teamDetailUpdate?: TeamDetailUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/team-detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamDetailUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initialise a team with the free tier
         * @param {TeamDetailCreate} [teamDetailCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailPost: async (teamDetailCreate?: TeamDetailCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/team-detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamDetailCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the access given by subscriptions
         * @param {boolean} [refreshUsage] Refreshes usage statistics as well
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailRefreshAccess: async (refreshUsage?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/team-detail/refresh-access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["PAYMENTS_UPDATE"], configuration)

            if (refreshUsage !== undefined) {
                localVarQueryParameter['refreshUsage'] = refreshUsage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamDetailApi - functional programming interface
 * @export
 */
export const TeamDetailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamDetailApiAxiosParamCreator(configuration)
    return {
        /**
         * If the account is an independent account, the access details for the account are returned. Otherwise, the team\'s access details are returned.
         * @summary Get the access details for the given account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailAccountAccessGet(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountAccessDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailAccountAccessGet(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the team\'s subscription and payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the team\'s subscription and payment details
         * @param {TeamDetailUpdate} [teamDetailUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailPatch(teamDetailUpdate?: TeamDetailUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailPatch(teamDetailUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Initialise a team with the free tier
         * @param {TeamDetailCreate} [teamDetailCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailPost(teamDetailCreate?: TeamDetailCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailPost(teamDetailCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the access given by subscriptions
         * @param {boolean} [refreshUsage] Refreshes usage statistics as well
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDetailRefreshAccess(refreshUsage?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDetailRefreshAccess(refreshUsage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamDetailApi - factory interface
 * @export
 */
export const TeamDetailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamDetailApiFp(configuration)
    return {
        /**
         * If the account is an independent account, the access details for the account are returned. Otherwise, the team\'s access details are returned.
         * @summary Get the access details for the given account
         * @param {TeamDetailApiTeamDetailAccountAccessGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailAccountAccessGet(requestParameters: TeamDetailApiTeamDetailAccountAccessGetRequest, options?: AxiosRequestConfig): AxiosPromise<AccountAccessDetail> {
            return localVarFp.teamDetailAccountAccessGet(requestParameters.accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the team\'s subscription and payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailGet(options?: AxiosRequestConfig): AxiosPromise<TeamDetail> {
            return localVarFp.teamDetailGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the team\'s subscription and payment details
         * @param {TeamDetailApiTeamDetailPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailPatch(requestParameters: TeamDetailApiTeamDetailPatchRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.teamDetailPatch(requestParameters.teamDetailUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initialise a team with the free tier
         * @param {TeamDetailApiTeamDetailPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailPost(requestParameters: TeamDetailApiTeamDetailPostRequest = {}, options?: AxiosRequestConfig): AxiosPromise<TeamDetail> {
            return localVarFp.teamDetailPost(requestParameters.teamDetailCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
         * @summary Refreshes the access given by subscriptions
         * @param {TeamDetailApiTeamDetailRefreshAccessRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDetailRefreshAccess(requestParameters: TeamDetailApiTeamDetailRefreshAccessRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.teamDetailRefreshAccess(requestParameters.refreshUsage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for teamDetailAccountAccessGet operation in TeamDetailApi.
 * @export
 * @interface TeamDetailApiTeamDetailAccountAccessGetRequest
 */
export interface TeamDetailApiTeamDetailAccountAccessGetRequest {
    /**
     * 
     * @type {string}
     * @memberof TeamDetailApiTeamDetailAccountAccessGet
     */
    readonly accountId: string
}

/**
 * Request parameters for teamDetailPatch operation in TeamDetailApi.
 * @export
 * @interface TeamDetailApiTeamDetailPatchRequest
 */
export interface TeamDetailApiTeamDetailPatchRequest {
    /**
     * 
     * @type {TeamDetailUpdate}
     * @memberof TeamDetailApiTeamDetailPatch
     */
    readonly teamDetailUpdate?: TeamDetailUpdate
}

/**
 * Request parameters for teamDetailPost operation in TeamDetailApi.
 * @export
 * @interface TeamDetailApiTeamDetailPostRequest
 */
export interface TeamDetailApiTeamDetailPostRequest {
    /**
     * 
     * @type {TeamDetailCreate}
     * @memberof TeamDetailApiTeamDetailPost
     */
    readonly teamDetailCreate?: TeamDetailCreate
}

/**
 * Request parameters for teamDetailRefreshAccess operation in TeamDetailApi.
 * @export
 * @interface TeamDetailApiTeamDetailRefreshAccessRequest
 */
export interface TeamDetailApiTeamDetailRefreshAccessRequest {
    /**
     * Refreshes usage statistics as well
     * @type {boolean}
     * @memberof TeamDetailApiTeamDetailRefreshAccess
     */
    readonly refreshUsage?: boolean
}

/**
 * TeamDetailApi - object-oriented interface
 * @export
 * @class TeamDetailApi
 * @extends {BaseAPI}
 */
export class TeamDetailApi extends BaseAPI {
    /**
     * If the account is an independent account, the access details for the account are returned. Otherwise, the team\'s access details are returned.
     * @summary Get the access details for the given account
     * @param {TeamDetailApiTeamDetailAccountAccessGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailAccountAccessGet(requestParameters: TeamDetailApiTeamDetailAccountAccessGetRequest, options?: AxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailAccountAccessGet(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the team\'s subscription and payment details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailGet(options?: AxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the team\'s subscription and payment details
     * @param {TeamDetailApiTeamDetailPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailPatch(requestParameters: TeamDetailApiTeamDetailPatchRequest = {}, options?: AxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailPatch(requestParameters.teamDetailUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initialise a team with the free tier
     * @param {TeamDetailApiTeamDetailPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailPost(requestParameters: TeamDetailApiTeamDetailPostRequest = {}, options?: AxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailPost(requestParameters.teamDetailCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches the list of active subscriptions/purchases from stripe and calculates what the current subscriptions should be. This route can be called to refresh the subscription after checkout to ensure the subscription is retreived. 
     * @summary Refreshes the access given by subscriptions
     * @param {TeamDetailApiTeamDetailRefreshAccessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamDetailApi
     */
    public teamDetailRefreshAccess(requestParameters: TeamDetailApiTeamDetailRefreshAccessRequest = {}, options?: AxiosRequestConfig) {
        return TeamDetailApiFp(this.configuration).teamDetailRefreshAccess(requestParameters.refreshUsage, options).then((request) => request(this.axios, this.basePath));
    }
}


