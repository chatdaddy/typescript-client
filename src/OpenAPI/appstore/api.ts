const BASE_PATH = "https://api.chatdaddy.tech/appstore".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * AppStore Service
 * AppStore Service 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from '../base';

/**
 * 
 * @export
 * @enum {string}
 */

export const AppLocation = {
    Profile: 'profile',
    Crm: 'crm',
    Navbar: 'navbar'
} as const;

export type AppLocation = typeof AppLocation[keyof typeof AppLocation];


/**
 * 
 * @export
 * @enum {string}
 */

export const AppType = {
    Extension: 'extension',
    PaymentIntegration: 'paymentIntegration',
    MessageFlow: 'messageFlow'
} as const;

export type AppType = typeof AppType[keyof typeof AppType];


/**
 * 
 * @export
 * @interface Author
 */
export interface Author {
    /**
     * 
     * @type {string}
     * @memberof Author
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Author
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface DataType
 */
export interface DataType {
    /**
     * 
     * @type {string}
     * @memberof DataType
     */
    'qrCodeUrl'?: string;
}
/**
 * 
 * @export
 * @interface DoesUserLikeListing200Response
 */
export interface DoesUserLikeListing200Response {
    /**
     * 
     * @type {boolean}
     * @memberof DoesUserLikeListing200Response
     */
    'liked': boolean;
}
/**
 * 
 * @export
 * @interface Extension
 */
export interface Extension {
    /**
     * 
     * @type {number}
     * @memberof Extension
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'imageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'iframeUrl': string;
    /**
     * 
     * @type {Array<AppLocation>}
     * @memberof Extension
     */
    'location': Array<AppLocation>;
    /**
     * 
     * @type {ExtensionType}
     * @memberof Extension
     */
    'type': ExtensionType;
    /**
     * 
     * @type {HTTPRequestOptions}
     * @memberof Extension
     */
    'httpRequestOptions'?: HTTPRequestOptions;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Extension
     */
    'variables'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'publishedState': ExtensionPublishedStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Extension
     */
    'permissions'?: Array<string>;
}

export const ExtensionPublishedStateEnum = {
    Private: 'private',
    UnderReview: 'underReview',
    Published: 'published'
} as const;

export type ExtensionPublishedStateEnum = typeof ExtensionPublishedStateEnum[keyof typeof ExtensionPublishedStateEnum];

/**
 * 
 * @export
 * @interface ExtensionCreate
 */
export interface ExtensionCreate {
    /**
     * 
     * @type {string}
     * @memberof ExtensionCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ExtensionCreate
     */
    'iframeUrl': string;
    /**
     * 
     * @type {string}
     * @memberof ExtensionCreate
     */
    'imageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof ExtensionCreate
     */
    'description': string;
    /**
     * 
     * @type {Array<AppLocation>}
     * @memberof ExtensionCreate
     */
    'location': Array<AppLocation>;
    /**
     * 
     * @type {HTTPRequestOptions}
     * @memberof ExtensionCreate
     */
    'httpRequestOptions'?: HTTPRequestOptions;
    /**
     * 
     * @type {ExtensionType}
     * @memberof ExtensionCreate
     */
    'type': ExtensionType;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ExtensionCreate
     */
    'variables'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ExtensionCreate
     */
    'publishedState': ExtensionCreatePublishedStateEnum;
}

export const ExtensionCreatePublishedStateEnum = {
    Private: 'private',
    UnderReview: 'underReview',
    Published: 'published'
} as const;

export type ExtensionCreatePublishedStateEnum = typeof ExtensionCreatePublishedStateEnum[keyof typeof ExtensionCreatePublishedStateEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const ExtensionType = {
    Section: 'section',
    AppButtonModal: 'appButtonModal',
    AppButton: 'appButton',
    AppPage: 'appPage',
    ApiButton: 'apiButton'
} as const;

export type ExtensionType = typeof ExtensionType[keyof typeof ExtensionType];


/**
 * 
 * @export
 * @interface ExtensionUpdate
 */
export interface ExtensionUpdate {
    /**
     * 
     * @type {number}
     * @memberof ExtensionUpdate
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExtensionUpdate
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExtensionUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExtensionUpdate
     */
    'teamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExtensionUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExtensionUpdate
     */
    'iframeUrl'?: string;
    /**
     * 
     * @type {Array<AppLocation>}
     * @memberof ExtensionUpdate
     */
    'location'?: Array<AppLocation>;
    /**
     * 
     * @type {ExtensionType}
     * @memberof ExtensionUpdate
     */
    'type'?: ExtensionType;
    /**
     * 
     * @type {HTTPRequestOptions}
     * @memberof ExtensionUpdate
     */
    'httpRequestOptions'?: HTTPRequestOptions;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ExtensionUpdate
     */
    'variables'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ExtensionUpdate
     */
    'publishedState'?: ExtensionUpdatePublishedStateEnum;
    /**
     * 
     * @type {string}
     * @memberof ExtensionUpdate
     */
    'publishedAt'?: string;
}

export const ExtensionUpdatePublishedStateEnum = {
    Private: 'private',
    UnderReview: 'underReview',
    Published: 'published'
} as const;

export type ExtensionUpdatePublishedStateEnum = typeof ExtensionUpdatePublishedStateEnum[keyof typeof ExtensionUpdatePublishedStateEnum];

/**
 * 
 * @export
 * @interface GetExtensions200Response
 */
export interface GetExtensions200Response {
    /**
     * 
     * @type {Array<Extension>}
     * @memberof GetExtensions200Response
     */
    'items': Array<Extension>;
    /**
     * 
     * @type {number}
     * @memberof GetExtensions200Response
     */
    'cursor'?: number;
}
/**
 * 
 * @export
 * @interface GetInstalledExtensions200Response
 */
export interface GetInstalledExtensions200Response {
    /**
     * 
     * @type {Array<InstalledExtension>}
     * @memberof GetInstalledExtensions200Response
     */
    'items': Array<InstalledExtension>;
    /**
     * 
     * @type {string}
     * @memberof GetInstalledExtensions200Response
     */
    'cursor'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetInstalledExtensions200Response
     */
    'totalDataCount'?: number;
}
/**
 * 
 * @export
 * @interface GetListings200Response
 */
export interface GetListings200Response {
    /**
     * 
     * @type {Array<Listing>}
     * @memberof GetListings200Response
     */
    'items': Array<Listing>;
    /**
     * 
     * @type {string}
     * @memberof GetListings200Response
     */
    'cursor'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetListings200Response
     */
    'totalDataCount'?: number;
}
/**
 * 
 * @export
 * @interface HTTPRequestOptions
 */
export interface HTTPRequestOptions {
    /**
     * 
     * @type {string}
     * @memberof HTTPRequestOptions
     */
    'method': HTTPRequestOptionsMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof HTTPRequestOptions
     */
    'url': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof HTTPRequestOptions
     */
    'headers': { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof HTTPRequestOptions
     */
    'body': string;
}

export const HTTPRequestOptionsMethodEnum = {
    Get: 'GET',
    Post: 'POST',
    Put: 'PUT',
    Delete: 'DELETE',
    Patch: 'PATCH'
} as const;

export type HTTPRequestOptionsMethodEnum = typeof HTTPRequestOptionsMethodEnum[keyof typeof HTTPRequestOptionsMethodEnum];

/**
 * 
 * @export
 * @interface InstallListingRequest
 */
export interface InstallListingRequest {
    /**
     * 
     * @type {string}
     * @memberof InstallListingRequest
     */
    'listingId': string;
}
/**
 * 
 * @export
 * @interface InstalledExtension
 */
export interface InstalledExtension {
    /**
     * 
     * @type {number}
     * @memberof InstalledExtension
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof InstalledExtension
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof InstalledExtension
     */
    'nickname'?: string;
    /**
     * 
     * @type {number}
     * @memberof InstalledExtension
     */
    'extensionId': number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof InstalledExtension
     */
    'variables'?: { [key: string]: any; };
    /**
     * 
     * @type {Extension}
     * @memberof InstalledExtension
     */
    'extension'?: Extension;
}
/**
 * 
 * @export
 * @interface InstalledExtensionCreate
 */
export interface InstalledExtensionCreate {
    /**
     * 
     * @type {string}
     * @memberof InstalledExtensionCreate
     */
    'nickname'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof InstalledExtensionCreate
     */
    'variables'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof InstalledExtensionCreate
     */
    'extensionId': number;
}
/**
 * 
 * @export
 * @interface InstalledExtensionUpdate
 */
export interface InstalledExtensionUpdate {
    /**
     * 
     * @type {number}
     * @memberof InstalledExtensionUpdate
     */
    'installedId'?: number;
    /**
     * 
     * @type {string}
     * @memberof InstalledExtensionUpdate
     */
    'nickname'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof InstalledExtensionUpdate
     */
    'variables'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface Like
 */
export interface Like {
    /**
     * 
     * @type {number}
     * @memberof Like
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Like
     */
    'listingId': string;
    /**
     * 
     * @type {string}
     * @memberof Like
     */
    'likedBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Like
     */
    'likedAt': string;
}
/**
 * 
 * @export
 * @interface Listing
 */
export interface Listing {
    /**
     * 
     * @type {string}
     * @memberof Listing
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Listing
     */
    'teamId': string;
    /**
     * 
     * @type {boolean}
     * @memberof Listing
     */
    'isRecommended'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Listing
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Listing
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Listing
     */
    'partnership'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Listing
     */
    'icons'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Listing
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof Listing
     */
    'totalInstalls'?: number;
    /**
     * 
     * @type {string}
     * @memberof Listing
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof Listing
     */
    'industry'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Listing
     */
    'industries'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Listing
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Listing
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {AppType}
     * @memberof Listing
     */
    'type': AppType;
    /**
     * 
     * @type {Array<Like>}
     * @memberof Listing
     */
    'likes'?: Array<Like>;
    /**
     * 
     * @type {number}
     * @memberof Listing
     */
    'likeCount'?: number;
    /**
     * 
     * @type {Author}
     * @memberof Listing
     */
    'author'?: Author;
    /**
     * 
     * @type {string}
     * @memberof Listing
     */
    'publishedState'?: ListingPublishedStateEnum;
    /**
     * 
     * @type {ListingData}
     * @memberof Listing
     */
    'data': ListingData;
}

export const ListingPublishedStateEnum = {
    Delisted: 'delisted',
    Published: 'published'
} as const;

export type ListingPublishedStateEnum = typeof ListingPublishedStateEnum[keyof typeof ListingPublishedStateEnum];

/**
 * 
 * @export
 * @interface ListingCreate
 */
export interface ListingCreate {
    /**
     * 
     * @type {string}
     * @memberof ListingCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListingCreate
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListingCreate
     */
    'isRecommended'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingCreate
     */
    'icons'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ListingCreate
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListingCreate
     */
    'partnership'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListingCreate
     */
    'totalInstalls'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListingCreate
     */
    'language'?: string;
    /**
     * 
     * @type {Author}
     * @memberof ListingCreate
     */
    'author'?: Author;
    /**
     * 
     * @type {string}
     * @memberof ListingCreate
     */
    'industry'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingCreate
     */
    'industries'?: Array<string>;
    /**
     * 
     * @type {AppType}
     * @memberof ListingCreate
     */
    'type': AppType;
    /**
     * 
     * @type {string}
     * @memberof ListingCreate
     */
    'publishedState'?: ListingCreatePublishedStateEnum;
    /**
     * 
     * @type {ListingData}
     * @memberof ListingCreate
     */
    'data': ListingData;
}

export const ListingCreatePublishedStateEnum = {
    Delisted: 'delisted',
    Published: 'published'
} as const;

export type ListingCreatePublishedStateEnum = typeof ListingCreatePublishedStateEnum[keyof typeof ListingCreatePublishedStateEnum];

/**
 * @type ListingData
 * @export
 */
export type ListingData = Extension | PaymentIntegration | PublishedMessageFlow;

/**
 * 
 * @export
 * @interface ListingUpdate
 */
export interface ListingUpdate {
    /**
     * 
     * @type {string}
     * @memberof ListingUpdate
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListingUpdate
     */
    'teamId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListingUpdate
     */
    'isRecommended'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ListingUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListingUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListingUpdate
     */
    'partnership'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingUpdate
     */
    'icons'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ListingUpdate
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListingUpdate
     */
    'totalInstalls'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListingUpdate
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListingUpdate
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListingUpdate
     */
    'industry'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingUpdate
     */
    'industries'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ListingUpdate
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {Author}
     * @memberof ListingUpdate
     */
    'author'?: Author;
    /**
     * 
     * @type {AppType}
     * @memberof ListingUpdate
     */
    'type'?: AppType;
    /**
     * 
     * @type {string}
     * @memberof ListingUpdate
     */
    'publishedState'?: ListingUpdatePublishedStateEnum;
    /**
     * 
     * @type {ListingData}
     * @memberof ListingUpdate
     */
    'data'?: ListingData;
}

export const ListingUpdatePublishedStateEnum = {
    Delisted: 'delisted',
    Published: 'published'
} as const;

export type ListingUpdatePublishedStateEnum = typeof ListingUpdatePublishedStateEnum[keyof typeof ListingUpdatePublishedStateEnum];

/**
 * 
 * @export
 * @interface PaymentIntegration
 */
export interface PaymentIntegration {
    /**
     * 
     * @type {string}
     * @memberof PaymentIntegration
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentIntegration
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentIntegration
     */
    'teamId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PaymentIntegration
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PaymentIntegration
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentIntegration
     */
    'paymentSystemId': string;
    /**
     * URL of the QR code image
     * @type {string}
     * @memberof PaymentIntegration
     */
    'qrCodeUrl'?: string;
    /**
     * Secret key for the payment system
     * @type {string}
     * @memberof PaymentIntegration
     */
    'secret'?: string;
}
/**
 * 
 * @export
 * @interface PaymentSystem
 */
export interface PaymentSystem {
    /**
     * 
     * @type {string}
     * @memberof PaymentSystem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentSystem
     */
    'name': string;
    /**
     * - qr - QR code payment system - url - payment link generation system
     * @type {string}
     * @memberof PaymentSystem
     */
    'type': PaymentSystemTypeEnum;
    /**
     * 
     * @type {DataType}
     * @memberof PaymentSystem
     */
    'dataType': DataType;
    /**
     * 
     * @type {PaymentSystemAuth}
     * @memberof PaymentSystem
     */
    'auth'?: PaymentSystemAuth;
    /**
     * User\'s integrations of this payment system
     * @type {Array<PaymentIntegration>}
     * @memberof PaymentSystem
     */
    'currentIntegrations'?: Array<PaymentIntegration> | null;
    /**
     * ISO 3166-1 alpha-2 country code.
     * @type {string}
     * @memberof PaymentSystem
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentSystem
     */
    'logoImageUrl'?: string;
}

export const PaymentSystemTypeEnum = {
    Qr: 'qr',
    Url: 'url'
} as const;

export type PaymentSystemTypeEnum = typeof PaymentSystemTypeEnum[keyof typeof PaymentSystemTypeEnum];

/**
 * 
 * @export
 * @interface PaymentSystemAuth
 */
export interface PaymentSystemAuth {
    /**
     * URL to redirect user to in order to authorize the payment system integration
     * @type {string}
     * @memberof PaymentSystemAuth
     */
    'oauthUrl'?: string;
}
/**
 * 
 * @export
 * @interface PublishedMessageFlow
 */
export interface PublishedMessageFlow {
    /**
     * 
     * @type {string}
     * @memberof PublishedMessageFlow
     */
    'botId': string;
    /**
     * 
     * @type {string}
     * @memberof PublishedMessageFlow
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof PublishedMessageFlow
     */
    'url'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof PublishedMessageFlow
     */
    'publishedAt'?: string;
}

/**
 * ExtensionsApi - axios parameter creator
 * @export
 */
export const ExtensionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an extension
         * @param {ExtensionCreate} extensionCreate The extension to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExtension: async (extensionCreate: ExtensionCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'extensionCreate' is not null or undefined
            assertParamExists('createExtension', 'extensionCreate', extensionCreate)
            const localVarPath = `/extensions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(extensionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an extension
         * @param {number} id The id of the extension to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExtension: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteExtension', 'id', id)
            const localVarPath = `/extensions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get extensions
         * @param {number} [count] The number of extensions to get
         * @param {string} [q] The query to get extensions from
         * @param {number} [cursor] The cursor to get extensions from
         * @param {string} [teamId] The teamId to get extensions from
         * @param {AppLocation} [location] The location to get extensions from
         * @param {ExtensionType} [type] The type to get extensions from
         * @param {Array<GetExtensionsPublishedStateEnum>} [publishedState] The publishedState of the extension
         * @param {Array<number>} [ids] The ids to get extensions from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtensions: async (count?: number, q?: string, cursor?: number, teamId?: string, location?: AppLocation, type?: ExtensionType, publishedState?: Array<GetExtensionsPublishedStateEnum>, ids?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/extensions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (publishedState) {
                localVarQueryParameter['publishedState'] = publishedState;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an extension
         * @param {number} id The id of the extension to update
         * @param {ExtensionUpdate} extensionUpdate The extension to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExtension: async (id: number, extensionUpdate: ExtensionUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateExtension', 'id', id)
            // verify required parameter 'extensionUpdate' is not null or undefined
            assertParamExists('updateExtension', 'extensionUpdate', extensionUpdate)
            const localVarPath = `/extensions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(extensionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExtensionsApi - functional programming interface
 * @export
 */
export const ExtensionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExtensionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an extension
         * @param {ExtensionCreate} extensionCreate The extension to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExtension(extensionCreate: ExtensionCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Extension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExtension(extensionCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExtensionsApi.createExtension']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an extension
         * @param {number} id The id of the extension to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExtension(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExtension(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExtensionsApi.deleteExtension']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get extensions
         * @param {number} [count] The number of extensions to get
         * @param {string} [q] The query to get extensions from
         * @param {number} [cursor] The cursor to get extensions from
         * @param {string} [teamId] The teamId to get extensions from
         * @param {AppLocation} [location] The location to get extensions from
         * @param {ExtensionType} [type] The type to get extensions from
         * @param {Array<GetExtensionsPublishedStateEnum>} [publishedState] The publishedState of the extension
         * @param {Array<number>} [ids] The ids to get extensions from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExtensions(count?: number, q?: string, cursor?: number, teamId?: string, location?: AppLocation, type?: ExtensionType, publishedState?: Array<GetExtensionsPublishedStateEnum>, ids?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetExtensions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExtensions(count, q, cursor, teamId, location, type, publishedState, ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExtensionsApi.getExtensions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an extension
         * @param {number} id The id of the extension to update
         * @param {ExtensionUpdate} extensionUpdate The extension to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExtension(id: number, extensionUpdate: ExtensionUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Extension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExtension(id, extensionUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExtensionsApi.updateExtension']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExtensionsApi - factory interface
 * @export
 */
export const ExtensionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExtensionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an extension
         * @param {ExtensionsApiCreateExtensionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExtension(requestParameters: ExtensionsApiCreateExtensionRequest, options?: RawAxiosRequestConfig): AxiosPromise<Extension> {
            return localVarFp.createExtension(requestParameters.extensionCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an extension
         * @param {ExtensionsApiDeleteExtensionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExtension(requestParameters: ExtensionsApiDeleteExtensionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteExtension(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get extensions
         * @param {ExtensionsApiGetExtensionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtensions(requestParameters: ExtensionsApiGetExtensionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetExtensions200Response> {
            return localVarFp.getExtensions(requestParameters.count, requestParameters.q, requestParameters.cursor, requestParameters.teamId, requestParameters.location, requestParameters.type, requestParameters.publishedState, requestParameters.ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an extension
         * @param {ExtensionsApiUpdateExtensionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExtension(requestParameters: ExtensionsApiUpdateExtensionRequest, options?: RawAxiosRequestConfig): AxiosPromise<Extension> {
            return localVarFp.updateExtension(requestParameters.id, requestParameters.extensionUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createExtension operation in ExtensionsApi.
 * @export
 * @interface ExtensionsApiCreateExtensionRequest
 */
export interface ExtensionsApiCreateExtensionRequest {
    /**
     * The extension to create
     * @type {ExtensionCreate}
     * @memberof ExtensionsApiCreateExtension
     */
    readonly extensionCreate: ExtensionCreate
}

/**
 * Request parameters for deleteExtension operation in ExtensionsApi.
 * @export
 * @interface ExtensionsApiDeleteExtensionRequest
 */
export interface ExtensionsApiDeleteExtensionRequest {
    /**
     * The id of the extension to delete
     * @type {number}
     * @memberof ExtensionsApiDeleteExtension
     */
    readonly id: number
}

/**
 * Request parameters for getExtensions operation in ExtensionsApi.
 * @export
 * @interface ExtensionsApiGetExtensionsRequest
 */
export interface ExtensionsApiGetExtensionsRequest {
    /**
     * The number of extensions to get
     * @type {number}
     * @memberof ExtensionsApiGetExtensions
     */
    readonly count?: number

    /**
     * The query to get extensions from
     * @type {string}
     * @memberof ExtensionsApiGetExtensions
     */
    readonly q?: string

    /**
     * The cursor to get extensions from
     * @type {number}
     * @memberof ExtensionsApiGetExtensions
     */
    readonly cursor?: number

    /**
     * The teamId to get extensions from
     * @type {string}
     * @memberof ExtensionsApiGetExtensions
     */
    readonly teamId?: string

    /**
     * The location to get extensions from
     * @type {AppLocation}
     * @memberof ExtensionsApiGetExtensions
     */
    readonly location?: AppLocation

    /**
     * The type to get extensions from
     * @type {ExtensionType}
     * @memberof ExtensionsApiGetExtensions
     */
    readonly type?: ExtensionType

    /**
     * The publishedState of the extension
     * @type {Array<'private' | 'underReview' | 'published'>}
     * @memberof ExtensionsApiGetExtensions
     */
    readonly publishedState?: Array<GetExtensionsPublishedStateEnum>

    /**
     * The ids to get extensions from
     * @type {Array<number>}
     * @memberof ExtensionsApiGetExtensions
     */
    readonly ids?: Array<number>
}

/**
 * Request parameters for updateExtension operation in ExtensionsApi.
 * @export
 * @interface ExtensionsApiUpdateExtensionRequest
 */
export interface ExtensionsApiUpdateExtensionRequest {
    /**
     * The id of the extension to update
     * @type {number}
     * @memberof ExtensionsApiUpdateExtension
     */
    readonly id: number

    /**
     * The extension to update
     * @type {ExtensionUpdate}
     * @memberof ExtensionsApiUpdateExtension
     */
    readonly extensionUpdate: ExtensionUpdate
}

/**
 * ExtensionsApi - object-oriented interface
 * @export
 * @class ExtensionsApi
 * @extends {BaseAPI}
 */
export class ExtensionsApi extends BaseAPI {
    /**
     * 
     * @summary Create an extension
     * @param {ExtensionsApiCreateExtensionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public createExtension(requestParameters: ExtensionsApiCreateExtensionRequest, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).createExtension(requestParameters.extensionCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an extension
     * @param {ExtensionsApiDeleteExtensionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public deleteExtension(requestParameters: ExtensionsApiDeleteExtensionRequest, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).deleteExtension(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get extensions
     * @param {ExtensionsApiGetExtensionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public getExtensions(requestParameters: ExtensionsApiGetExtensionsRequest = {}, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).getExtensions(requestParameters.count, requestParameters.q, requestParameters.cursor, requestParameters.teamId, requestParameters.location, requestParameters.type, requestParameters.publishedState, requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an extension
     * @param {ExtensionsApiUpdateExtensionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public updateExtension(requestParameters: ExtensionsApiUpdateExtensionRequest, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).updateExtension(requestParameters.id, requestParameters.extensionUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetExtensionsPublishedStateEnum = {
    Private: 'private',
    UnderReview: 'underReview',
    Published: 'published'
} as const;
export type GetExtensionsPublishedStateEnum = typeof GetExtensionsPublishedStateEnum[keyof typeof GetExtensionsPublishedStateEnum];


/**
 * InstalledExtensionsApi - axios parameter creator
 * @export
 */
export const InstalledExtensionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get installed extensions
         * @param {number} [count] The number of installed extensions to get
         * @param {number} [cursor] The cursor to get installed extensions from
         * @param {number} [extensionId] The extensionId to get installed extensions from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstalledExtensions: async (count?: number, cursor?: number, extensionId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/installed-extensions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (extensionId !== undefined) {
                localVarQueryParameter['extensionId'] = extensionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Install an extension
         * @param {InstalledExtensionCreate} installedExtensionCreate The extension to install
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installExtension: async (installedExtensionCreate: InstalledExtensionCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'installedExtensionCreate' is not null or undefined
            assertParamExists('installExtension', 'installedExtensionCreate', installedExtensionCreate)
            const localVarPath = `/installed-extensions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(installedExtensionCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uninstall an extension
         * @param {number} extensionId The extensionId to uninstall
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallExtension: async (extensionId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'extensionId' is not null or undefined
            assertParamExists('uninstallExtension', 'extensionId', extensionId)
            const localVarPath = `/installed-extensions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (extensionId !== undefined) {
                localVarQueryParameter['extensionId'] = extensionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an installed extension
         * @param {InstalledExtensionUpdate} installedExtensionUpdate The installed extension to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInstalledExtension: async (installedExtensionUpdate: InstalledExtensionUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'installedExtensionUpdate' is not null or undefined
            assertParamExists('updateInstalledExtension', 'installedExtensionUpdate', installedExtensionUpdate)
            const localVarPath = `/installed-extensions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(installedExtensionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InstalledExtensionsApi - functional programming interface
 * @export
 */
export const InstalledExtensionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InstalledExtensionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get installed extensions
         * @param {number} [count] The number of installed extensions to get
         * @param {number} [cursor] The cursor to get installed extensions from
         * @param {number} [extensionId] The extensionId to get installed extensions from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstalledExtensions(count?: number, cursor?: number, extensionId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInstalledExtensions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstalledExtensions(count, cursor, extensionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstalledExtensionsApi.getInstalledExtensions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Install an extension
         * @param {InstalledExtensionCreate} installedExtensionCreate The extension to install
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installExtension(installedExtensionCreate: InstalledExtensionCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstalledExtension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.installExtension(installedExtensionCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstalledExtensionsApi.installExtension']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Uninstall an extension
         * @param {number} extensionId The extensionId to uninstall
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallExtension(extensionId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallExtension(extensionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstalledExtensionsApi.uninstallExtension']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an installed extension
         * @param {InstalledExtensionUpdate} installedExtensionUpdate The installed extension to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInstalledExtension(installedExtensionUpdate: InstalledExtensionUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstalledExtension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInstalledExtension(installedExtensionUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstalledExtensionsApi.updateInstalledExtension']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InstalledExtensionsApi - factory interface
 * @export
 */
export const InstalledExtensionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InstalledExtensionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get installed extensions
         * @param {InstalledExtensionsApiGetInstalledExtensionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstalledExtensions(requestParameters: InstalledExtensionsApiGetInstalledExtensionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetInstalledExtensions200Response> {
            return localVarFp.getInstalledExtensions(requestParameters.count, requestParameters.cursor, requestParameters.extensionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Install an extension
         * @param {InstalledExtensionsApiInstallExtensionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installExtension(requestParameters: InstalledExtensionsApiInstallExtensionRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstalledExtension> {
            return localVarFp.installExtension(requestParameters.installedExtensionCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uninstall an extension
         * @param {InstalledExtensionsApiUninstallExtensionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallExtension(requestParameters: InstalledExtensionsApiUninstallExtensionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uninstallExtension(requestParameters.extensionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an installed extension
         * @param {InstalledExtensionsApiUpdateInstalledExtensionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInstalledExtension(requestParameters: InstalledExtensionsApiUpdateInstalledExtensionRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstalledExtension> {
            return localVarFp.updateInstalledExtension(requestParameters.installedExtensionUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getInstalledExtensions operation in InstalledExtensionsApi.
 * @export
 * @interface InstalledExtensionsApiGetInstalledExtensionsRequest
 */
export interface InstalledExtensionsApiGetInstalledExtensionsRequest {
    /**
     * The number of installed extensions to get
     * @type {number}
     * @memberof InstalledExtensionsApiGetInstalledExtensions
     */
    readonly count?: number

    /**
     * The cursor to get installed extensions from
     * @type {number}
     * @memberof InstalledExtensionsApiGetInstalledExtensions
     */
    readonly cursor?: number

    /**
     * The extensionId to get installed extensions from
     * @type {number}
     * @memberof InstalledExtensionsApiGetInstalledExtensions
     */
    readonly extensionId?: number
}

/**
 * Request parameters for installExtension operation in InstalledExtensionsApi.
 * @export
 * @interface InstalledExtensionsApiInstallExtensionRequest
 */
export interface InstalledExtensionsApiInstallExtensionRequest {
    /**
     * The extension to install
     * @type {InstalledExtensionCreate}
     * @memberof InstalledExtensionsApiInstallExtension
     */
    readonly installedExtensionCreate: InstalledExtensionCreate
}

/**
 * Request parameters for uninstallExtension operation in InstalledExtensionsApi.
 * @export
 * @interface InstalledExtensionsApiUninstallExtensionRequest
 */
export interface InstalledExtensionsApiUninstallExtensionRequest {
    /**
     * The extensionId to uninstall
     * @type {number}
     * @memberof InstalledExtensionsApiUninstallExtension
     */
    readonly extensionId: number
}

/**
 * Request parameters for updateInstalledExtension operation in InstalledExtensionsApi.
 * @export
 * @interface InstalledExtensionsApiUpdateInstalledExtensionRequest
 */
export interface InstalledExtensionsApiUpdateInstalledExtensionRequest {
    /**
     * The installed extension to update
     * @type {InstalledExtensionUpdate}
     * @memberof InstalledExtensionsApiUpdateInstalledExtension
     */
    readonly installedExtensionUpdate: InstalledExtensionUpdate
}

/**
 * InstalledExtensionsApi - object-oriented interface
 * @export
 * @class InstalledExtensionsApi
 * @extends {BaseAPI}
 */
export class InstalledExtensionsApi extends BaseAPI {
    /**
     * 
     * @summary Get installed extensions
     * @param {InstalledExtensionsApiGetInstalledExtensionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstalledExtensionsApi
     */
    public getInstalledExtensions(requestParameters: InstalledExtensionsApiGetInstalledExtensionsRequest = {}, options?: RawAxiosRequestConfig) {
        return InstalledExtensionsApiFp(this.configuration).getInstalledExtensions(requestParameters.count, requestParameters.cursor, requestParameters.extensionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Install an extension
     * @param {InstalledExtensionsApiInstallExtensionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstalledExtensionsApi
     */
    public installExtension(requestParameters: InstalledExtensionsApiInstallExtensionRequest, options?: RawAxiosRequestConfig) {
        return InstalledExtensionsApiFp(this.configuration).installExtension(requestParameters.installedExtensionCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uninstall an extension
     * @param {InstalledExtensionsApiUninstallExtensionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstalledExtensionsApi
     */
    public uninstallExtension(requestParameters: InstalledExtensionsApiUninstallExtensionRequest, options?: RawAxiosRequestConfig) {
        return InstalledExtensionsApiFp(this.configuration).uninstallExtension(requestParameters.extensionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an installed extension
     * @param {InstalledExtensionsApiUpdateInstalledExtensionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstalledExtensionsApi
     */
    public updateInstalledExtension(requestParameters: InstalledExtensionsApiUpdateInstalledExtensionRequest, options?: RawAxiosRequestConfig) {
        return InstalledExtensionsApiFp(this.configuration).updateInstalledExtension(requestParameters.installedExtensionUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ListingsApi - axios parameter creator
 * @export
 */
export const ListingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a listing
         * @param {ListingCreate} listingCreate The listing to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListing: async (listingCreate: ListingCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listingCreate' is not null or undefined
            assertParamExists('createListing', 'listingCreate', listingCreate)
            const localVarPath = `/listings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listingCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a listing
         * @param {string} id The id of the listing to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListing: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteListing', 'id', id)
            const localVarPath = `/listing/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a user likes a listing
         * @param {string} id The id of the listing to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doesUserLikeListing: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('doesUserLikeListing', 'id', id)
            const localVarPath = `/listing/{id}/like`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get listings
         * @param {number} [count] The number of extensions to get
         * @param {string} [cursor] The cursor to get extensions from
         * @param {string} [teamId] The teamId to get extensions from
         * @param {AppType} [type] The type to get extensions from
         * @param {Array<string>} [ids] The ids to get extensions from
         * @param {string} [language] The language to get extensions from
         * @param {string} [industry] The industry to get extensions from
         * @param {string} [q] The query to get extensions from
         * @param {GetListingsPublishedStateEnum} [publishedState] The publishedState of the listing
         * @param {GetListingsSortByEnum} [sortBy] The field to sort by
         * @param {boolean} [returnTotalDataCount] Return the total data count
         * @param {string} [partnership] The partnership to get extensions from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListings: async (count?: number, cursor?: string, teamId?: string, type?: AppType, ids?: Array<string>, language?: string, industry?: string, q?: string, publishedState?: GetListingsPublishedStateEnum, sortBy?: GetListingsSortByEnum, returnTotalDataCount?: boolean, partnership?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/listings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (industry !== undefined) {
                localVarQueryParameter['industry'] = industry;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (publishedState !== undefined) {
                localVarQueryParameter['publishedState'] = publishedState;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (returnTotalDataCount !== undefined) {
                localVarQueryParameter['returnTotalDataCount'] = returnTotalDataCount;
            }

            if (partnership !== undefined) {
                localVarQueryParameter['partnership'] = partnership;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Install a listing
         * @param {InstallListingRequest} installListingRequest The listing to install
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installListing: async (installListingRequest: InstallListingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'installListingRequest' is not null or undefined
            assertParamExists('installListing', 'installListingRequest', installListingRequest)
            const localVarPath = `/install-listing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(installListingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggle like on a listing
         * @param {string} id The id of the listing to like
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleLikeListing: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('toggleLikeListing', 'id', id)
            const localVarPath = `/listing/{id}/like`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a listing
         * @param {string} id The id of the listing to update
         * @param {ListingUpdate} listingUpdate The listing to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateListing: async (id: string, listingUpdate: ListingUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateListing', 'id', id)
            // verify required parameter 'listingUpdate' is not null or undefined
            assertParamExists('updateListing', 'listingUpdate', listingUpdate)
            const localVarPath = `/listing/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listingUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListingsApi - functional programming interface
 * @export
 */
export const ListingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ListingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a listing
         * @param {ListingCreate} listingCreate The listing to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createListing(listingCreate: ListingCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Listing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createListing(listingCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListingsApi.createListing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a listing
         * @param {string} id The id of the listing to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteListing(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteListing(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListingsApi.deleteListing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check if a user likes a listing
         * @param {string} id The id of the listing to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doesUserLikeListing(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DoesUserLikeListing200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doesUserLikeListing(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListingsApi.doesUserLikeListing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get listings
         * @param {number} [count] The number of extensions to get
         * @param {string} [cursor] The cursor to get extensions from
         * @param {string} [teamId] The teamId to get extensions from
         * @param {AppType} [type] The type to get extensions from
         * @param {Array<string>} [ids] The ids to get extensions from
         * @param {string} [language] The language to get extensions from
         * @param {string} [industry] The industry to get extensions from
         * @param {string} [q] The query to get extensions from
         * @param {GetListingsPublishedStateEnum} [publishedState] The publishedState of the listing
         * @param {GetListingsSortByEnum} [sortBy] The field to sort by
         * @param {boolean} [returnTotalDataCount] Return the total data count
         * @param {string} [partnership] The partnership to get extensions from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListings(count?: number, cursor?: string, teamId?: string, type?: AppType, ids?: Array<string>, language?: string, industry?: string, q?: string, publishedState?: GetListingsPublishedStateEnum, sortBy?: GetListingsSortByEnum, returnTotalDataCount?: boolean, partnership?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListings(count, cursor, teamId, type, ids, language, industry, q, publishedState, sortBy, returnTotalDataCount, partnership, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListingsApi.getListings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Install a listing
         * @param {InstallListingRequest} installListingRequest The listing to install
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installListing(installListingRequest: InstallListingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.installListing(installListingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListingsApi.installListing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Toggle like on a listing
         * @param {string} id The id of the listing to like
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toggleLikeListing(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toggleLikeListing(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListingsApi.toggleLikeListing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a listing
         * @param {string} id The id of the listing to update
         * @param {ListingUpdate} listingUpdate The listing to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateListing(id: string, listingUpdate: ListingUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Listing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateListing(id, listingUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListingsApi.updateListing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ListingsApi - factory interface
 * @export
 */
export const ListingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ListingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a listing
         * @param {ListingsApiCreateListingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createListing(requestParameters: ListingsApiCreateListingRequest, options?: RawAxiosRequestConfig): AxiosPromise<Listing> {
            return localVarFp.createListing(requestParameters.listingCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a listing
         * @param {ListingsApiDeleteListingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListing(requestParameters: ListingsApiDeleteListingRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteListing(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if a user likes a listing
         * @param {ListingsApiDoesUserLikeListingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doesUserLikeListing(requestParameters: ListingsApiDoesUserLikeListingRequest, options?: RawAxiosRequestConfig): AxiosPromise<DoesUserLikeListing200Response> {
            return localVarFp.doesUserLikeListing(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get listings
         * @param {ListingsApiGetListingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListings(requestParameters: ListingsApiGetListingsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetListings200Response> {
            return localVarFp.getListings(requestParameters.count, requestParameters.cursor, requestParameters.teamId, requestParameters.type, requestParameters.ids, requestParameters.language, requestParameters.industry, requestParameters.q, requestParameters.publishedState, requestParameters.sortBy, requestParameters.returnTotalDataCount, requestParameters.partnership, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Install a listing
         * @param {ListingsApiInstallListingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installListing(requestParameters: ListingsApiInstallListingRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.installListing(requestParameters.installListingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Toggle like on a listing
         * @param {ListingsApiToggleLikeListingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleLikeListing(requestParameters: ListingsApiToggleLikeListingRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.toggleLikeListing(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a listing
         * @param {ListingsApiUpdateListingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateListing(requestParameters: ListingsApiUpdateListingRequest, options?: RawAxiosRequestConfig): AxiosPromise<Listing> {
            return localVarFp.updateListing(requestParameters.id, requestParameters.listingUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createListing operation in ListingsApi.
 * @export
 * @interface ListingsApiCreateListingRequest
 */
export interface ListingsApiCreateListingRequest {
    /**
     * The listing to create
     * @type {ListingCreate}
     * @memberof ListingsApiCreateListing
     */
    readonly listingCreate: ListingCreate
}

/**
 * Request parameters for deleteListing operation in ListingsApi.
 * @export
 * @interface ListingsApiDeleteListingRequest
 */
export interface ListingsApiDeleteListingRequest {
    /**
     * The id of the listing to delete
     * @type {string}
     * @memberof ListingsApiDeleteListing
     */
    readonly id: string
}

/**
 * Request parameters for doesUserLikeListing operation in ListingsApi.
 * @export
 * @interface ListingsApiDoesUserLikeListingRequest
 */
export interface ListingsApiDoesUserLikeListingRequest {
    /**
     * The id of the listing to check
     * @type {string}
     * @memberof ListingsApiDoesUserLikeListing
     */
    readonly id: string
}

/**
 * Request parameters for getListings operation in ListingsApi.
 * @export
 * @interface ListingsApiGetListingsRequest
 */
export interface ListingsApiGetListingsRequest {
    /**
     * The number of extensions to get
     * @type {number}
     * @memberof ListingsApiGetListings
     */
    readonly count?: number

    /**
     * The cursor to get extensions from
     * @type {string}
     * @memberof ListingsApiGetListings
     */
    readonly cursor?: string

    /**
     * The teamId to get extensions from
     * @type {string}
     * @memberof ListingsApiGetListings
     */
    readonly teamId?: string

    /**
     * The type to get extensions from
     * @type {AppType}
     * @memberof ListingsApiGetListings
     */
    readonly type?: AppType

    /**
     * The ids to get extensions from
     * @type {Array<string>}
     * @memberof ListingsApiGetListings
     */
    readonly ids?: Array<string>

    /**
     * The language to get extensions from
     * @type {string}
     * @memberof ListingsApiGetListings
     */
    readonly language?: string

    /**
     * The industry to get extensions from
     * @type {string}
     * @memberof ListingsApiGetListings
     */
    readonly industry?: string

    /**
     * The query to get extensions from
     * @type {string}
     * @memberof ListingsApiGetListings
     */
    readonly q?: string

    /**
     * The publishedState of the listing
     * @type {'delisted' | 'published' | 'underReview'}
     * @memberof ListingsApiGetListings
     */
    readonly publishedState?: GetListingsPublishedStateEnum

    /**
     * The field to sort by
     * @type {'installs' | 'likes' | 'recommended' | 'createdAt'}
     * @memberof ListingsApiGetListings
     */
    readonly sortBy?: GetListingsSortByEnum

    /**
     * Return the total data count
     * @type {boolean}
     * @memberof ListingsApiGetListings
     */
    readonly returnTotalDataCount?: boolean

    /**
     * The partnership to get extensions from
     * @type {string}
     * @memberof ListingsApiGetListings
     */
    readonly partnership?: string
}

/**
 * Request parameters for installListing operation in ListingsApi.
 * @export
 * @interface ListingsApiInstallListingRequest
 */
export interface ListingsApiInstallListingRequest {
    /**
     * The listing to install
     * @type {InstallListingRequest}
     * @memberof ListingsApiInstallListing
     */
    readonly installListingRequest: InstallListingRequest
}

/**
 * Request parameters for toggleLikeListing operation in ListingsApi.
 * @export
 * @interface ListingsApiToggleLikeListingRequest
 */
export interface ListingsApiToggleLikeListingRequest {
    /**
     * The id of the listing to like
     * @type {string}
     * @memberof ListingsApiToggleLikeListing
     */
    readonly id: string
}

/**
 * Request parameters for updateListing operation in ListingsApi.
 * @export
 * @interface ListingsApiUpdateListingRequest
 */
export interface ListingsApiUpdateListingRequest {
    /**
     * The id of the listing to update
     * @type {string}
     * @memberof ListingsApiUpdateListing
     */
    readonly id: string

    /**
     * The listing to update
     * @type {ListingUpdate}
     * @memberof ListingsApiUpdateListing
     */
    readonly listingUpdate: ListingUpdate
}

/**
 * ListingsApi - object-oriented interface
 * @export
 * @class ListingsApi
 * @extends {BaseAPI}
 */
export class ListingsApi extends BaseAPI {
    /**
     * 
     * @summary Create a listing
     * @param {ListingsApiCreateListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListingsApi
     */
    public createListing(requestParameters: ListingsApiCreateListingRequest, options?: RawAxiosRequestConfig) {
        return ListingsApiFp(this.configuration).createListing(requestParameters.listingCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a listing
     * @param {ListingsApiDeleteListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListingsApi
     */
    public deleteListing(requestParameters: ListingsApiDeleteListingRequest, options?: RawAxiosRequestConfig) {
        return ListingsApiFp(this.configuration).deleteListing(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if a user likes a listing
     * @param {ListingsApiDoesUserLikeListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListingsApi
     */
    public doesUserLikeListing(requestParameters: ListingsApiDoesUserLikeListingRequest, options?: RawAxiosRequestConfig) {
        return ListingsApiFp(this.configuration).doesUserLikeListing(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get listings
     * @param {ListingsApiGetListingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListingsApi
     */
    public getListings(requestParameters: ListingsApiGetListingsRequest = {}, options?: RawAxiosRequestConfig) {
        return ListingsApiFp(this.configuration).getListings(requestParameters.count, requestParameters.cursor, requestParameters.teamId, requestParameters.type, requestParameters.ids, requestParameters.language, requestParameters.industry, requestParameters.q, requestParameters.publishedState, requestParameters.sortBy, requestParameters.returnTotalDataCount, requestParameters.partnership, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Install a listing
     * @param {ListingsApiInstallListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListingsApi
     */
    public installListing(requestParameters: ListingsApiInstallListingRequest, options?: RawAxiosRequestConfig) {
        return ListingsApiFp(this.configuration).installListing(requestParameters.installListingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Toggle like on a listing
     * @param {ListingsApiToggleLikeListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListingsApi
     */
    public toggleLikeListing(requestParameters: ListingsApiToggleLikeListingRequest, options?: RawAxiosRequestConfig) {
        return ListingsApiFp(this.configuration).toggleLikeListing(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a listing
     * @param {ListingsApiUpdateListingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListingsApi
     */
    public updateListing(requestParameters: ListingsApiUpdateListingRequest, options?: RawAxiosRequestConfig) {
        return ListingsApiFp(this.configuration).updateListing(requestParameters.id, requestParameters.listingUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetListingsPublishedStateEnum = {
    Delisted: 'delisted',
    Published: 'published',
    UnderReview: 'underReview'
} as const;
export type GetListingsPublishedStateEnum = typeof GetListingsPublishedStateEnum[keyof typeof GetListingsPublishedStateEnum];
/**
 * @export
 */
export const GetListingsSortByEnum = {
    Installs: 'installs',
    Likes: 'likes',
    Recommended: 'recommended',
    CreatedAt: 'createdAt'
} as const;
export type GetListingsSortByEnum = typeof GetListingsSortByEnum[keyof typeof GetListingsSortByEnum];


