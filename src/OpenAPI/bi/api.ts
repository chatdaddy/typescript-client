const BASE_PATH = "https://api.chatdaddy.tech/bi".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy BI Service
 * Business Intelligence and Analytics API for product usage insights
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from '../base';

/**
 * 
 * @export
 * @interface ChannelSegment
 */
export interface ChannelSegment {
    /**
     * 
     * @type {number}
     * @memberof ChannelSegment
     */
    'count': number;
    /**
     * 
     * @type {Array<ChannelSegmentChannelsInner>}
     * @memberof ChannelSegment
     */
    'channels'?: Array<ChannelSegmentChannelsInner>;
}
/**
 * 
 * @export
 * @interface ChannelSegmentChannelsInner
 */
export interface ChannelSegmentChannelsInner {
    /**
     * 
     * @type {string}
     * @memberof ChannelSegmentChannelsInner
     */
    'account_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelSegmentChannelsInner
     */
    'platform'?: string;
    /**
     * 
     * @type {number}
     * @memberof ChannelSegmentChannelsInner
     */
    'days_disconnected'?: number;
}
/**
 * 
 * @export
 * @interface CountPostResponse
 */
export interface CountPostResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CountPostResponse
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof CountPostResponse
     */
    'bucket'?: string;
    /**
     * 
     * @type {string}
     * @memberof CountPostResponse
     */
    'docId'?: string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
interface ErrorResponse {
    /**
     * 
     * @type {number}
     * @memberof ErrorResponse
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * Additional error context
     * @type {object}
     * @memberof ErrorResponse
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EventCategory = {
    Communication: 'communication',
    Crm: 'crm',
    Automation: 'automation',
    Support: 'support',
    Revenue: 'revenue',
    Team: 'team',
    System: 'system',
    Channels: 'channels'
} as const;

export type EventCategory = typeof EventCategory[keyof typeof EventCategory];


/**
 * 
 * @export
 * @enum {string}
 */

export const EventName = {
    GroupUpdate: 'group-update',
    PresenceUpdate: 'presence-update',
    OrderInsert: 'order-insert',
    ActionExecute: 'action-execute',
    ActionSchedule: 'action-schedule',
    FewMessagesLeft: 'few-messages-left',
    StaleAccountNotification: 'stale-account-notification',
    CustomerCreditsLevelUpdate: 'customer-credits-level-update',
    PushNotification: 'push-notification',
    CampaignInsert: 'campaign-insert',
    CredittransactionrecordInsert: 'credittransactionrecord-insert',
    KeywordbasedactionInsert: 'keywordbasedaction-insert',
    ChatbotInsert: 'chatbot-insert',
    PaymentintegrationInsert: 'paymentintegration-insert',
    ShopproductInsert: 'shopproduct-insert',
    TeammemberLogout: 'teammember-logout',
    AiCreditUse: 'ai-credit-use',
    DashboardInsert: 'dashboard-insert',
    DashboardUpdate: 'dashboard-update',
    DashboardDelete: 'dashboard-delete',
    ContactInsert: 'contact-insert',
    ContactUpdate: 'contact-update',
    ContactDelete: 'contact-delete',
    ChatInsert: 'chat-insert',
    ChatUpdate: 'chat-update',
    ChatDelete: 'chat-delete',
    TagInsert: 'tag-insert',
    TagUpdate: 'tag-update',
    TagDelete: 'tag-delete',
    AccountInsert: 'account-insert',
    AccountUpdate: 'account-update',
    AccountDelete: 'account-delete',
    MessageInsert: 'message-insert',
    MessageUpdate: 'message-update',
    MessageDelete: 'message-delete',
    UserInsert: 'user-insert',
    UserUpdate: 'user-update',
    UserDelete: 'user-delete',
    TeamInsert: 'team-insert',
    TeamUpdate: 'team-update',
    TeamDelete: 'team-delete',
    TeammemberInsert: 'teammember-insert',
    TeammemberUpdate: 'teammember-update',
    TeammemberDelete: 'teammember-delete',
    PlatformproductInsert: 'platformproduct-insert',
    PlatformproductUpdate: 'platformproduct-update',
    PlatformproductDelete: 'platformproduct-delete',
    TrackingInsert: 'tracking-insert',
    TrackingUpdate: 'tracking-update',
    TrackingDelete: 'tracking-delete',
    BotInsert: 'bot-insert',
    BotUpdate: 'bot-update',
    BotDelete: 'bot-delete',
    CrmTicketInsert: 'crm-ticket-insert',
    CrmTicketUpdate: 'crm-ticket-update',
    CrmTicketDelete: 'crm-ticket-delete',
    CallInsert: 'call-insert',
    CallUpdate: 'call-update',
    CallDelete: 'call-delete',
    CallchannelInsert: 'callchannel-insert',
    CallchannelUpdate: 'callchannel-update',
    CallchannelDelete: 'callchannel-delete'
} as const;

export type EventName = typeof EventName[keyof typeof EventName];


/**
 * 
 * @export
 * @interface GetActiveUsers200Response
 */
export interface GetActiveUsers200Response {
    /**
     * 
     * @type {GetActiveUsers200ResponseData}
     * @memberof GetActiveUsers200Response
     */
    'data': GetActiveUsers200ResponseData;
    /**
     * 
     * @type {GetActiveUsers200ResponseSummary}
     * @memberof GetActiveUsers200Response
     */
    'summary': GetActiveUsers200ResponseSummary;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GetActiveUsers200Response
     */
    'metadata': ResponseMetadata;
}
/**
 * 
 * @export
 * @interface GetActiveUsers200ResponseData
 */
export interface GetActiveUsers200ResponseData {
    /**
     * Daily Active Users
     * @type {number}
     * @memberof GetActiveUsers200ResponseData
     */
    'dau'?: number;
    /**
     * Weekly Active Users
     * @type {number}
     * @memberof GetActiveUsers200ResponseData
     */
    'wau'?: number;
    /**
     * Monthly Active Users
     * @type {number}
     * @memberof GetActiveUsers200ResponseData
     */
    'mau'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetActiveUsers200ResponseData
     */
    'active_with_min_1_message'?: number;
}
/**
 * 
 * @export
 * @interface GetActiveUsers200ResponseSummary
 */
export interface GetActiveUsers200ResponseSummary {
    /**
     * 
     * @type {number}
     * @memberof GetActiveUsers200ResponseSummary
     */
    'dau_change_percentage'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetActiveUsers200ResponseSummary
     */
    'wau_change_percentage'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetActiveUsers200ResponseSummary
     */
    'mau_change_percentage'?: number;
}
/**
 * 
 * @export
 * @interface GetAutomationPerformance200Response
 */
export interface GetAutomationPerformance200Response {
    /**
     * 
     * @type {Array<GetAutomationPerformance200ResponseDataInner>}
     * @memberof GetAutomationPerformance200Response
     */
    'data': Array<GetAutomationPerformance200ResponseDataInner>;
    /**
     * 
     * @type {GetAutomationPerformance200ResponseSummary}
     * @memberof GetAutomationPerformance200Response
     */
    'summary': GetAutomationPerformance200ResponseSummary;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GetAutomationPerformance200Response
     */
    'metadata': ResponseMetadata;
}
/**
 * 
 * @export
 * @interface GetAutomationPerformance200ResponseDataInner
 */
export interface GetAutomationPerformance200ResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetAutomationPerformance200ResponseDataInner
     */
    'timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetAutomationPerformance200ResponseDataInner
     */
    'flows_created'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAutomationPerformance200ResponseDataInner
     */
    'actions_executed'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAutomationPerformance200ResponseDataInner
     */
    'actions_scheduled'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAutomationPerformance200ResponseDataInner
     */
    'chatbots_deployed'?: number;
}
/**
 * 
 * @export
 * @interface GetAutomationPerformance200ResponseSummary
 */
export interface GetAutomationPerformance200ResponseSummary {
    /**
     * 
     * @type {number}
     * @memberof GetAutomationPerformance200ResponseSummary
     */
    'total_flows'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAutomationPerformance200ResponseSummary
     */
    'total_actions_executed'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAutomationPerformance200ResponseSummary
     */
    'average_complexity_index'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAutomationPerformance200ResponseSummary
     */
    'success_rate_percentage'?: number;
}
/**
 * 
 * @export
 * @interface GetChannelsDistribution200Response
 */
export interface GetChannelsDistribution200Response {
    /**
     * 
     * @type {Array<GetChannelsDistribution200ResponseDataInner>}
     * @memberof GetChannelsDistribution200Response
     */
    'data': Array<GetChannelsDistribution200ResponseDataInner>;
    /**
     * 
     * @type {GetChannelsDistribution200ResponseSummary}
     * @memberof GetChannelsDistribution200Response
     */
    'summary': GetChannelsDistribution200ResponseSummary;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GetChannelsDistribution200Response
     */
    'metadata': ResponseMetadata;
}
/**
 * 
 * @export
 * @interface GetChannelsDistribution200ResponseDataInner
 */
export interface GetChannelsDistribution200ResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetChannelsDistribution200ResponseDataInner
     */
    'platform'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetChannelsDistribution200ResponseDataInner
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetChannelsDistribution200ResponseDataInner
     */
    'percentage'?: number;
}
/**
 * 
 * @export
 * @interface GetChannelsDistribution200ResponseSummary
 */
export interface GetChannelsDistribution200ResponseSummary {
    /**
     * 
     * @type {number}
     * @memberof GetChannelsDistribution200ResponseSummary
     */
    'total_channels'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetChannelsDistribution200ResponseSummary
     */
    'platforms_count'?: number;
}
/**
 * 
 * @export
 * @interface GetChannelsStatus200Response
 */
export interface GetChannelsStatus200Response {
    /**
     * 
     * @type {GetChannelsStatus200ResponseData}
     * @memberof GetChannelsStatus200Response
     */
    'data': GetChannelsStatus200ResponseData;
    /**
     * 
     * @type {GetChannelsStatus200ResponseSummary}
     * @memberof GetChannelsStatus200Response
     */
    'summary': GetChannelsStatus200ResponseSummary;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GetChannelsStatus200Response
     */
    'metadata': ResponseMetadata;
}
/**
 * 
 * @export
 * @interface GetChannelsStatus200ResponseData
 */
export interface GetChannelsStatus200ResponseData {
    /**
     * 
     * @type {ChannelSegment}
     * @memberof GetChannelsStatus200ResponseData
     */
    'connected'?: ChannelSegment;
    /**
     * 
     * @type {ChannelSegment}
     * @memberof GetChannelsStatus200ResponseData
     */
    'disconnected_0_3_days'?: ChannelSegment;
    /**
     * 
     * @type {ChannelSegment}
     * @memberof GetChannelsStatus200ResponseData
     */
    'disconnected_3_10_days'?: ChannelSegment;
    /**
     * 
     * @type {ChannelSegment}
     * @memberof GetChannelsStatus200ResponseData
     */
    'disconnected_over_10_days'?: ChannelSegment;
}
/**
 * 
 * @export
 * @interface GetChannelsStatus200ResponseSummary
 */
export interface GetChannelsStatus200ResponseSummary {
    /**
     * 
     * @type {number}
     * @memberof GetChannelsStatus200ResponseSummary
     */
    'total_channels'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetChannelsStatus200ResponseSummary
     */
    'healthy_channels'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetChannelsStatus200ResponseSummary
     */
    'at_risk_channels'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetChannelsStatus200ResponseSummary
     */
    'critical_channels'?: number;
}
/**
 * 
 * @export
 * @interface GetContactsGrowth200Response
 */
export interface GetContactsGrowth200Response {
    /**
     * 
     * @type {Array<GetContactsGrowth200ResponseDataInner>}
     * @memberof GetContactsGrowth200Response
     */
    'data': Array<GetContactsGrowth200ResponseDataInner>;
    /**
     * 
     * @type {GetContactsGrowth200ResponseSummary}
     * @memberof GetContactsGrowth200Response
     */
    'summary': GetContactsGrowth200ResponseSummary;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GetContactsGrowth200Response
     */
    'metadata': ResponseMetadata;
}
/**
 * 
 * @export
 * @interface GetContactsGrowth200ResponseDataInner
 */
export interface GetContactsGrowth200ResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetContactsGrowth200ResponseDataInner
     */
    'timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetContactsGrowth200ResponseDataInner
     */
    'contacts_created'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetContactsGrowth200ResponseDataInner
     */
    'contacts_updated'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetContactsGrowth200ResponseDataInner
     */
    'contacts_deleted'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetContactsGrowth200ResponseDataInner
     */
    'net_growth'?: number;
}
/**
 * 
 * @export
 * @interface GetContactsGrowth200ResponseSummary
 */
export interface GetContactsGrowth200ResponseSummary {
    /**
     * 
     * @type {number}
     * @memberof GetContactsGrowth200ResponseSummary
     */
    'total_created'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetContactsGrowth200ResponseSummary
     */
    'total_updated'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetContactsGrowth200ResponseSummary
     */
    'total_deleted'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetContactsGrowth200ResponseSummary
     */
    'net_growth'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetContactsGrowth200ResponseSummary
     */
    'growth_rate_percentage'?: number;
}
/**
 * 
 * @export
 * @interface GetContactsTags200Response
 */
export interface GetContactsTags200Response {
    /**
     * 
     * @type {Array<GetContactsTags200ResponseDataInner>}
     * @memberof GetContactsTags200Response
     */
    'data': Array<GetContactsTags200ResponseDataInner>;
    /**
     * 
     * @type {GetContactsTags200ResponseSummary}
     * @memberof GetContactsTags200Response
     */
    'summary': GetContactsTags200ResponseSummary;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GetContactsTags200Response
     */
    'metadata': ResponseMetadata;
}
/**
 * 
 * @export
 * @interface GetContactsTags200ResponseDataInner
 */
export interface GetContactsTags200ResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetContactsTags200ResponseDataInner
     */
    'timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetContactsTags200ResponseDataInner
     */
    'tags_created'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetContactsTags200ResponseDataInner
     */
    'tags_applied'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetContactsTags200ResponseDataInner
     */
    'tags_removed'?: number;
}
/**
 * 
 * @export
 * @interface GetContactsTags200ResponseSummary
 */
export interface GetContactsTags200ResponseSummary {
    /**
     * 
     * @type {number}
     * @memberof GetContactsTags200ResponseSummary
     */
    'total_tags_created'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetContactsTags200ResponseSummary
     */
    'total_tagging_events'?: number;
    /**
     * 
     * @type {Array<GetContactsTags200ResponseSummaryMostUsedTagsInner>}
     * @memberof GetContactsTags200ResponseSummary
     */
    'most_used_tags'?: Array<GetContactsTags200ResponseSummaryMostUsedTagsInner>;
}
/**
 * 
 * @export
 * @interface GetContactsTags200ResponseSummaryMostUsedTagsInner
 */
export interface GetContactsTags200ResponseSummaryMostUsedTagsInner {
    /**
     * 
     * @type {string}
     * @memberof GetContactsTags200ResponseSummaryMostUsedTagsInner
     */
    'tag_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetContactsTags200ResponseSummaryMostUsedTagsInner
     */
    'usage_count'?: number;
}
/**
 * 
 * @export
 * @interface GetEventVolume200Response
 */
export interface GetEventVolume200Response {
    /**
     * 
     * @type {Array<GetEventVolume200ResponseDataInner>}
     * @memberof GetEventVolume200Response
     */
    'data': Array<GetEventVolume200ResponseDataInner>;
    /**
     * 
     * @type {GetEventVolume200ResponseSummary}
     * @memberof GetEventVolume200Response
     */
    'summary': GetEventVolume200ResponseSummary;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GetEventVolume200Response
     */
    'metadata': ResponseMetadata;
}
/**
 * 
 * @export
 * @interface GetEventVolume200ResponseDataInner
 */
export interface GetEventVolume200ResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetEventVolume200ResponseDataInner
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof GetEventVolume200ResponseDataInner
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface GetEventVolume200ResponseSummary
 */
export interface GetEventVolume200ResponseSummary {
    /**
     * 
     * @type {number}
     * @memberof GetEventVolume200ResponseSummary
     */
    'total_events'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetEventVolume200ResponseSummary
     */
    'average_per_day'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetEventVolume200ResponseSummary
     */
    'period_days'?: number;
}
/**
 * 
 * @export
 * @interface GetEventsByType200Response
 */
export interface GetEventsByType200Response {
    /**
     * 
     * @type {Array<GetEventsByType200ResponseDataInner>}
     * @memberof GetEventsByType200Response
     */
    'data': Array<GetEventsByType200ResponseDataInner>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GetEventsByType200Response
     */
    'metadata': ResponseMetadata;
}
/**
 * 
 * @export
 * @interface GetEventsByType200ResponseDataInner
 */
export interface GetEventsByType200ResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetEventsByType200ResponseDataInner
     */
    'event_type'?: string;
    /**
     * 
     * @type {EventCategory}
     * @memberof GetEventsByType200ResponseDataInner
     */
    'category'?: EventCategory;
    /**
     * 
     * @type {number}
     * @memberof GetEventsByType200ResponseDataInner
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetEventsByType200ResponseDataInner
     */
    'percentage'?: number;
}


/**
 * 
 * @export
 * @interface GetFeaturesUsage200Response
 */
export interface GetFeaturesUsage200Response {
    /**
     * 
     * @type {Array<GetFeaturesUsage200ResponseDataInner>}
     * @memberof GetFeaturesUsage200Response
     */
    'data': Array<GetFeaturesUsage200ResponseDataInner>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GetFeaturesUsage200Response
     */
    'metadata': ResponseMetadata;
}
/**
 * 
 * @export
 * @interface GetFeaturesUsage200ResponseDataInner
 */
export interface GetFeaturesUsage200ResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetFeaturesUsage200ResponseDataInner
     */
    'timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetFeaturesUsage200ResponseDataInner
     */
    'messages'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetFeaturesUsage200ResponseDataInner
     */
    'chatbot'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetFeaturesUsage200ResponseDataInner
     */
    'calls'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetFeaturesUsage200ResponseDataInner
     */
    'automation'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetFeaturesUsage200ResponseDataInner
     */
    'broadcasts'?: number;
}
/**
 * 
 * @export
 * @interface GetMessageCount200Response
 */
export interface GetMessageCount200Response {
    /**
     * 
     * @type {number}
     * @memberof GetMessageCount200Response
     */
    'messagesSent': number;
    /**
     * 
     * @type {number}
     * @memberof GetMessageCount200Response
     */
    'messagesReceived': number;
    /**
     * 
     * @type {number}
     * @memberof GetMessageCount200Response
     */
    'total': number;
    /**
     * 
     * @type {string}
     * @memberof GetMessageCount200Response
     */
    'teamId'?: string;
    /**
     * 
     * @type {GetMessageCount200ResponseDateRange}
     * @memberof GetMessageCount200Response
     */
    'dateRange'?: GetMessageCount200ResponseDateRange;
}
/**
 * 
 * @export
 * @interface GetMessageCount200ResponseDateRange
 */
export interface GetMessageCount200ResponseDateRange {
    /**
     * 
     * @type {string}
     * @memberof GetMessageCount200ResponseDateRange
     */
    'start'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetMessageCount200ResponseDateRange
     */
    'end'?: string;
}
/**
 * 
 * @export
 * @interface GetMessagesBySource200Response
 */
export interface GetMessagesBySource200Response {
    /**
     * 
     * @type {Array<GetMessagesBySource200ResponseDataInner>}
     * @memberof GetMessagesBySource200Response
     */
    'data': Array<GetMessagesBySource200ResponseDataInner>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GetMessagesBySource200Response
     */
    'metadata': ResponseMetadata;
}
/**
 * 
 * @export
 * @interface GetMessagesBySource200ResponseDataInner
 */
export interface GetMessagesBySource200ResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetMessagesBySource200ResponseDataInner
     */
    'timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetMessagesBySource200ResponseDataInner
     */
    'automation'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetMessagesBySource200ResponseDataInner
     */
    'broadcast'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetMessagesBySource200ResponseDataInner
     */
    'manual'?: number;
}
/**
 * 
 * @export
 * @interface GetMessagesSummary200Response
 */
export interface GetMessagesSummary200Response {
    /**
     * 
     * @type {Array<GetMessagesSummary200ResponseDataInner>}
     * @memberof GetMessagesSummary200Response
     */
    'data': Array<GetMessagesSummary200ResponseDataInner>;
    /**
     * 
     * @type {GetMessagesSummary200ResponseSummary}
     * @memberof GetMessagesSummary200Response
     */
    'summary': GetMessagesSummary200ResponseSummary;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GetMessagesSummary200Response
     */
    'metadata': ResponseMetadata;
}
/**
 * 
 * @export
 * @interface GetMessagesSummary200ResponseDataInner
 */
export interface GetMessagesSummary200ResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetMessagesSummary200ResponseDataInner
     */
    'timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetMessagesSummary200ResponseDataInner
     */
    'messages_sent'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetMessagesSummary200ResponseDataInner
     */
    'messages_received'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetMessagesSummary200ResponseDataInner
     */
    'messages_by_automation'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetMessagesSummary200ResponseDataInner
     */
    'messages_by_broadcast'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetMessagesSummary200ResponseDataInner
     */
    'messages_manual'?: number;
}
/**
 * 
 * @export
 * @interface GetMessagesSummary200ResponseSummary
 */
export interface GetMessagesSummary200ResponseSummary {
    /**
     * 
     * @type {number}
     * @memberof GetMessagesSummary200ResponseSummary
     */
    'total_sent'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetMessagesSummary200ResponseSummary
     */
    'total_received'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetMessagesSummary200ResponseSummary
     */
    'total_by_automation'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetMessagesSummary200ResponseSummary
     */
    'total_by_broadcast'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetMessagesSummary200ResponseSummary
     */
    'automation_percentage'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetMessagesSummary200ResponseSummary
     */
    'broadcast_percentage'?: number;
}
/**
 * 
 * @export
 * @interface GetOverviewKPIs200Response
 */
export interface GetOverviewKPIs200Response {
    /**
     * 
     * @type {GetOverviewKPIs200ResponseData}
     * @memberof GetOverviewKPIs200Response
     */
    'data': GetOverviewKPIs200ResponseData;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GetOverviewKPIs200Response
     */
    'metadata': ResponseMetadata;
}
/**
 * 
 * @export
 * @interface GetOverviewKPIs200ResponseData
 */
export interface GetOverviewKPIs200ResponseData {
    /**
     * 
     * @type {KPIMetric}
     * @memberof GetOverviewKPIs200ResponseData
     */
    'active_accounts_7d'?: KPIMetric;
    /**
     * 
     * @type {KPIMetric}
     * @memberof GetOverviewKPIs200ResponseData
     */
    'dau'?: KPIMetric;
    /**
     * 
     * @type {KPIMetric}
     * @memberof GetOverviewKPIs200ResponseData
     */
    'wau'?: KPIMetric;
    /**
     * 
     * @type {KPIMetric}
     * @memberof GetOverviewKPIs200ResponseData
     */
    'mau'?: KPIMetric;
    /**
     * 
     * @type {KPIMetric}
     * @memberof GetOverviewKPIs200ResponseData
     */
    'credits_used_this_month'?: KPIMetric;
    /**
     * 
     * @type {GetOverviewKPIs200ResponseDataTopFeature}
     * @memberof GetOverviewKPIs200ResponseData
     */
    'top_feature'?: GetOverviewKPIs200ResponseDataTopFeature;
    /**
     * 
     * @type {KPIMetric}
     * @memberof GetOverviewKPIs200ResponseData
     */
    'at_risk_accounts'?: KPIMetric;
}
/**
 * 
 * @export
 * @interface GetOverviewKPIs200ResponseDataTopFeature
 */
export interface GetOverviewKPIs200ResponseDataTopFeature {
    /**
     * 
     * @type {string}
     * @memberof GetOverviewKPIs200ResponseDataTopFeature
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetOverviewKPIs200ResponseDataTopFeature
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface GetRevenueOrders200Response
 */
export interface GetRevenueOrders200Response {
    /**
     * 
     * @type {Array<GetRevenueOrders200ResponseDataInner>}
     * @memberof GetRevenueOrders200Response
     */
    'data': Array<GetRevenueOrders200ResponseDataInner>;
    /**
     * 
     * @type {GetRevenueOrders200ResponseSummary}
     * @memberof GetRevenueOrders200Response
     */
    'summary': GetRevenueOrders200ResponseSummary;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GetRevenueOrders200Response
     */
    'metadata': ResponseMetadata;
}
/**
 * 
 * @export
 * @interface GetRevenueOrders200ResponseDataInner
 */
export interface GetRevenueOrders200ResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetRevenueOrders200ResponseDataInner
     */
    'timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetRevenueOrders200ResponseDataInner
     */
    'orders_received'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetRevenueOrders200ResponseDataInner
     */
    'campaigns_sent'?: number;
}
/**
 * 
 * @export
 * @interface GetRevenueOrders200ResponseSummary
 */
export interface GetRevenueOrders200ResponseSummary {
    /**
     * 
     * @type {number}
     * @memberof GetRevenueOrders200ResponseSummary
     */
    'total_orders'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetRevenueOrders200ResponseSummary
     */
    'total_campaigns'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetRevenueOrders200ResponseSummary
     */
    'conversion_rate_percentage'?: number;
}
/**
 * 
 * @export
 * @interface GetSupportTickets200Response
 */
export interface GetSupportTickets200Response {
    /**
     * 
     * @type {Array<GetSupportTickets200ResponseDataInner>}
     * @memberof GetSupportTickets200Response
     */
    'data': Array<GetSupportTickets200ResponseDataInner>;
    /**
     * 
     * @type {GetSupportTickets200ResponseSummary}
     * @memberof GetSupportTickets200Response
     */
    'summary': GetSupportTickets200ResponseSummary;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GetSupportTickets200Response
     */
    'metadata': ResponseMetadata;
}
/**
 * 
 * @export
 * @interface GetSupportTickets200ResponseDataInner
 */
export interface GetSupportTickets200ResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetSupportTickets200ResponseDataInner
     */
    'timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetSupportTickets200ResponseDataInner
     */
    'tickets_created'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetSupportTickets200ResponseDataInner
     */
    'tickets_updated'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetSupportTickets200ResponseDataInner
     */
    'tickets_resolved'?: number;
}
/**
 * 
 * @export
 * @interface GetSupportTickets200ResponseSummary
 */
export interface GetSupportTickets200ResponseSummary {
    /**
     * 
     * @type {number}
     * @memberof GetSupportTickets200ResponseSummary
     */
    'total_created'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetSupportTickets200ResponseSummary
     */
    'total_resolved'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetSupportTickets200ResponseSummary
     */
    'resolution_rate_percentage'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetSupportTickets200ResponseSummary
     */
    'average_resolution_time_hours'?: number;
}
/**
 * 
 * @export
 * @interface GetSystemHealth200Response
 */
export interface GetSystemHealth200Response {
    /**
     * 
     * @type {GetSystemHealth200ResponseData}
     * @memberof GetSystemHealth200Response
     */
    'data': GetSystemHealth200ResponseData;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GetSystemHealth200Response
     */
    'metadata': ResponseMetadata;
}
/**
 * 
 * @export
 * @interface GetSystemHealth200ResponseData
 */
export interface GetSystemHealth200ResponseData {
    /**
     * 
     * @type {number}
     * @memberof GetSystemHealth200ResponseData
     */
    'credits_remaining'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetSystemHealth200ResponseData
     */
    'credits_used_this_month'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetSystemHealth200ResponseData
     */
    'ai_credits_used'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetSystemHealth200ResponseData
     */
    'accounts_with_low_messages'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetSystemHealth200ResponseData
     */
    'stale_accounts'?: number;
}
/**
 * 
 * @export
 * @interface GetTeamActivity200Response
 */
export interface GetTeamActivity200Response {
    /**
     * 
     * @type {Array<GetTeamActivity200ResponseDataInner>}
     * @memberof GetTeamActivity200Response
     */
    'data': Array<GetTeamActivity200ResponseDataInner>;
    /**
     * 
     * @type {GetTeamActivity200ResponseSummary}
     * @memberof GetTeamActivity200Response
     */
    'summary': GetTeamActivity200ResponseSummary;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GetTeamActivity200Response
     */
    'metadata': ResponseMetadata;
}
/**
 * 
 * @export
 * @interface GetTeamActivity200ResponseDataInner
 */
export interface GetTeamActivity200ResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof GetTeamActivity200ResponseDataInner
     */
    'timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetTeamActivity200ResponseDataInner
     */
    'users_created'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetTeamActivity200ResponseDataInner
     */
    'team_members_added'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetTeamActivity200ResponseDataInner
     */
    'team_members_active'?: number;
}
/**
 * 
 * @export
 * @interface GetTeamActivity200ResponseSummary
 */
export interface GetTeamActivity200ResponseSummary {
    /**
     * 
     * @type {number}
     * @memberof GetTeamActivity200ResponseSummary
     */
    'total_team_members'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetTeamActivity200ResponseSummary
     */
    'active_team_members'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetTeamActivity200ResponseSummary
     */
    'new_members_this_period'?: number;
}
/**
 * 
 * @export
 * @interface GetUserSegments200Response
 */
export interface GetUserSegments200Response {
    /**
     * 
     * @type {GetUserSegments200ResponseData}
     * @memberof GetUserSegments200Response
     */
    'data': GetUserSegments200ResponseData;
    /**
     * 
     * @type {GetUserSegments200ResponseSummary}
     * @memberof GetUserSegments200Response
     */
    'summary': GetUserSegments200ResponseSummary;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GetUserSegments200Response
     */
    'metadata': ResponseMetadata;
}
/**
 * 
 * @export
 * @interface GetUserSegments200ResponseData
 */
export interface GetUserSegments200ResponseData {
    /**
     * 
     * @type {UserSegment}
     * @memberof GetUserSegments200ResponseData
     */
    'active_today'?: UserSegment;
    /**
     * 
     * @type {UserSegment}
     * @memberof GetUserSegments200ResponseData
     */
    'inactive_1_3_days'?: UserSegment;
    /**
     * 
     * @type {UserSegment}
     * @memberof GetUserSegments200ResponseData
     */
    'inactive_4_7_days'?: UserSegment;
    /**
     * 
     * @type {UserSegment}
     * @memberof GetUserSegments200ResponseData
     */
    'inactive_8_15_days'?: UserSegment;
    /**
     * 
     * @type {UserSegment}
     * @memberof GetUserSegments200ResponseData
     */
    'inactive_over_15_days'?: UserSegment;
}
/**
 * 
 * @export
 * @interface GetUserSegments200ResponseSummary
 */
export interface GetUserSegments200ResponseSummary {
    /**
     * 
     * @type {number}
     * @memberof GetUserSegments200ResponseSummary
     */
    'total_users'?: number;
    /**
     * Users inactive 7-15 days
     * @type {number}
     * @memberof GetUserSegments200ResponseSummary
     */
    'at_risk_users'?: number;
    /**
     * Users inactive over 15 days
     * @type {number}
     * @memberof GetUserSegments200ResponseSummary
     */
    'churned_users'?: number;
}
/**
 * 
 * @export
 * @interface KPIMetric
 */
export interface KPIMetric {
    /**
     * 
     * @type {number}
     * @memberof KPIMetric
     */
    'value': number;
    /**
     * Percentage change vs previous period
     * @type {number}
     * @memberof KPIMetric
     */
    'change_percentage'?: number;
    /**
     * 
     * @type {string}
     * @memberof KPIMetric
     */
    'trend'?: KPIMetricTrendEnum;
}

export const KPIMetricTrendEnum = {
    Up: 'up',
    Down: 'down',
    Flat: 'flat'
} as const;

export type KPIMetricTrendEnum = typeof KPIMetricTrendEnum[keyof typeof KPIMetricTrendEnum];

/**
 * 
 * @export
 * @interface MessageCountPost
 */
export interface MessageCountPost {
    /**
     * 
     * @type {number}
     * @memberof MessageCountPost
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof MessageCountPost
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageCountPost
     */
    'teamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageCountPost
     */
    'messageType'?: MessageCountPostMessageTypeEnum;
}

export const MessageCountPostMessageTypeEnum = {
    Sent: 'sent',
    Received: 'received'
} as const;

export type MessageCountPostMessageTypeEnum = typeof MessageCountPostMessageTypeEnum[keyof typeof MessageCountPostMessageTypeEnum];

/**
 * 
 * @export
 * @interface ResponseMetadata
 */
export interface ResponseMetadata {
    /**
     * When this data was generated
     * @type {string}
     * @memberof ResponseMetadata
     */
    'timestamp': string;
    /**
     * Start of query range
     * @type {string}
     * @memberof ResponseMetadata
     */
    'start_date'?: string;
    /**
     * End of query range
     * @type {string}
     * @memberof ResponseMetadata
     */
    'end_date'?: string;
    /**
     * Team ID filter applied
     * @type {string}
     * @memberof ResponseMetadata
     */
    'team_id'?: string;
    /**
     * Time grouping applied
     * @type {string}
     * @memberof ResponseMetadata
     */
    'group_by'?: ResponseMetadataGroupByEnum;
    /**
     * Total number of data points returned
     * @type {number}
     * @memberof ResponseMetadata
     */
    'total_records'?: number;
}

export const ResponseMetadataGroupByEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;

export type ResponseMetadataGroupByEnum = typeof ResponseMetadataGroupByEnum[keyof typeof ResponseMetadataGroupByEnum];

/**
 * 
 * @export
 * @interface UserCountPost
 */
export interface UserCountPost {
    /**
     * 
     * @type {number}
     * @memberof UserCountPost
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof UserCountPost
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCountPost
     */
    'teamId'?: string;
}
/**
 * 
 * @export
 * @interface UserSegment
 */
export interface UserSegment {
    /**
     * 
     * @type {number}
     * @memberof UserSegment
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof UserSegment
     */
    'percentage': number;
}

/**
 * AutomationPerformanceDataApi - axios parameter creator
 * @export
 */
export const AutomationPerformanceDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns comprehensive automation metrics including flows created,  actions executed, and workflow complexity. 
         * @summary Get automation performance metrics
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetAutomationPerformanceTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetAutomationPerformanceGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutomationPerformance: async (startDate?: string, endDate?: string, timeRange?: GetAutomationPerformanceTimeRangeEnum, groupBy?: GetAutomationPerformanceGroupByEnum, teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/automation/performance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (timeRange !== undefined) {
                localVarQueryParameter['timeRange'] = timeRange;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutomationPerformanceDataApi - functional programming interface
 * @export
 */
export const AutomationPerformanceDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutomationPerformanceDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns comprehensive automation metrics including flows created,  actions executed, and workflow complexity. 
         * @summary Get automation performance metrics
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetAutomationPerformanceTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetAutomationPerformanceGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAutomationPerformance(startDate?: string, endDate?: string, timeRange?: GetAutomationPerformanceTimeRangeEnum, groupBy?: GetAutomationPerformanceGroupByEnum, teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAutomationPerformance200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAutomationPerformance(startDate, endDate, timeRange, groupBy, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutomationPerformanceDataApi.getAutomationPerformance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AutomationPerformanceDataApi - factory interface
 * @export
 */
export const AutomationPerformanceDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutomationPerformanceDataApiFp(configuration)
    return {
        /**
         * Returns comprehensive automation metrics including flows created,  actions executed, and workflow complexity. 
         * @summary Get automation performance metrics
         * @param {AutomationPerformanceDataApiGetAutomationPerformanceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutomationPerformance(requestParameters: AutomationPerformanceDataApiGetAutomationPerformanceRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetAutomationPerformance200Response> {
            return localVarFp.getAutomationPerformance(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAutomationPerformance operation in AutomationPerformanceDataApi.
 * @export
 * @interface AutomationPerformanceDataApiGetAutomationPerformanceRequest
 */
export interface AutomationPerformanceDataApiGetAutomationPerformanceRequest {
    /**
     * Start date for the query range (inclusive)
     * @type {string}
     * @memberof AutomationPerformanceDataApiGetAutomationPerformance
     */
    readonly startDate?: string

    /**
     * End date for the query range (inclusive)
     * @type {string}
     * @memberof AutomationPerformanceDataApiGetAutomationPerformance
     */
    readonly endDate?: string

    /**
     * Preset time range (alternative to startDate/endDate)
     * @type {'7d' | '30d' | '90d'}
     * @memberof AutomationPerformanceDataApiGetAutomationPerformance
     */
    readonly timeRange?: GetAutomationPerformanceTimeRangeEnum

    /**
     * Time aggregation period
     * @type {'day' | 'week' | 'month'}
     * @memberof AutomationPerformanceDataApiGetAutomationPerformance
     */
    readonly groupBy?: GetAutomationPerformanceGroupByEnum

    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof AutomationPerformanceDataApiGetAutomationPerformance
     */
    readonly teamId?: string
}

/**
 * AutomationPerformanceDataApi - object-oriented interface
 * @export
 * @class AutomationPerformanceDataApi
 * @extends {BaseAPI}
 */
export class AutomationPerformanceDataApi extends BaseAPI {
    /**
     * Returns comprehensive automation metrics including flows created,  actions executed, and workflow complexity. 
     * @summary Get automation performance metrics
     * @param {AutomationPerformanceDataApiGetAutomationPerformanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationPerformanceDataApi
     */
    public getAutomationPerformance(requestParameters: AutomationPerformanceDataApiGetAutomationPerformanceRequest = {}, options?: RawAxiosRequestConfig) {
        return AutomationPerformanceDataApiFp(this.configuration).getAutomationPerformance(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAutomationPerformanceTimeRangeEnum = {
    7d: '7d',
    30d: '30d',
    90d: '90d'
} as const;
export type GetAutomationPerformanceTimeRangeEnum = typeof GetAutomationPerformanceTimeRangeEnum[keyof typeof GetAutomationPerformanceTimeRangeEnum];
/**
 * @export
 */
export const GetAutomationPerformanceGroupByEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;
export type GetAutomationPerformanceGroupByEnum = typeof GetAutomationPerformanceGroupByEnum[keyof typeof GetAutomationPerformanceGroupByEnum];


/**
 * ChannelsDistributionDataApi - axios parameter creator
 * @export
 */
export const ChannelsDistributionDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns distribution of channels across different platforms  (WhatsApp, Instagram, Messenger, etc.). 
         * @summary Get channels by platform type
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelsDistribution: async (teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/channels/distribution`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelsDistributionDataApi - functional programming interface
 * @export
 */
export const ChannelsDistributionDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChannelsDistributionDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns distribution of channels across different platforms  (WhatsApp, Instagram, Messenger, etc.). 
         * @summary Get channels by platform type
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelsDistribution(teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChannelsDistribution200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChannelsDistribution(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelsDistributionDataApi.getChannelsDistribution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChannelsDistributionDataApi - factory interface
 * @export
 */
export const ChannelsDistributionDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChannelsDistributionDataApiFp(configuration)
    return {
        /**
         * Returns distribution of channels across different platforms  (WhatsApp, Instagram, Messenger, etc.). 
         * @summary Get channels by platform type
         * @param {ChannelsDistributionDataApiGetChannelsDistributionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelsDistribution(requestParameters: ChannelsDistributionDataApiGetChannelsDistributionRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetChannelsDistribution200Response> {
            return localVarFp.getChannelsDistribution(requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getChannelsDistribution operation in ChannelsDistributionDataApi.
 * @export
 * @interface ChannelsDistributionDataApiGetChannelsDistributionRequest
 */
export interface ChannelsDistributionDataApiGetChannelsDistributionRequest {
    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof ChannelsDistributionDataApiGetChannelsDistribution
     */
    readonly teamId?: string
}

/**
 * ChannelsDistributionDataApi - object-oriented interface
 * @export
 * @class ChannelsDistributionDataApi
 * @extends {BaseAPI}
 */
export class ChannelsDistributionDataApi extends BaseAPI {
    /**
     * Returns distribution of channels across different platforms  (WhatsApp, Instagram, Messenger, etc.). 
     * @summary Get channels by platform type
     * @param {ChannelsDistributionDataApiGetChannelsDistributionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsDistributionDataApi
     */
    public getChannelsDistribution(requestParameters: ChannelsDistributionDataApiGetChannelsDistributionRequest = {}, options?: RawAxiosRequestConfig) {
        return ChannelsDistributionDataApiFp(this.configuration).getChannelsDistribution(requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChannelsStatusDataApi - axios parameter creator
 * @export
 */
export const ChannelsStatusDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns channel connection health including timeline segmentation  (connected, disconnected 0-3d, 3-10d, 10d+). 
         * @summary Get channels connection status
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelsStatus: async (teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/channels/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelsStatusDataApi - functional programming interface
 * @export
 */
export const ChannelsStatusDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChannelsStatusDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns channel connection health including timeline segmentation  (connected, disconnected 0-3d, 3-10d, 10d+). 
         * @summary Get channels connection status
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelsStatus(teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChannelsStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChannelsStatus(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelsStatusDataApi.getChannelsStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChannelsStatusDataApi - factory interface
 * @export
 */
export const ChannelsStatusDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChannelsStatusDataApiFp(configuration)
    return {
        /**
         * Returns channel connection health including timeline segmentation  (connected, disconnected 0-3d, 3-10d, 10d+). 
         * @summary Get channels connection status
         * @param {ChannelsStatusDataApiGetChannelsStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelsStatus(requestParameters: ChannelsStatusDataApiGetChannelsStatusRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetChannelsStatus200Response> {
            return localVarFp.getChannelsStatus(requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getChannelsStatus operation in ChannelsStatusDataApi.
 * @export
 * @interface ChannelsStatusDataApiGetChannelsStatusRequest
 */
export interface ChannelsStatusDataApiGetChannelsStatusRequest {
    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof ChannelsStatusDataApiGetChannelsStatus
     */
    readonly teamId?: string
}

/**
 * ChannelsStatusDataApi - object-oriented interface
 * @export
 * @class ChannelsStatusDataApi
 * @extends {BaseAPI}
 */
export class ChannelsStatusDataApi extends BaseAPI {
    /**
     * Returns channel connection health including timeline segmentation  (connected, disconnected 0-3d, 3-10d, 10d+). 
     * @summary Get channels connection status
     * @param {ChannelsStatusDataApiGetChannelsStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsStatusDataApi
     */
    public getChannelsStatus(requestParameters: ChannelsStatusDataApiGetChannelsStatusRequest = {}, options?: RawAxiosRequestConfig) {
        return ChannelsStatusDataApiFp(this.configuration).getChannelsStatus(requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContactsGrowthDataApi - axios parameter creator
 * @export
 */
export const ContactsGrowthDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns contact database growth over time including new contacts,  updates, and deletions. 
         * @summary Get contacts growth metrics
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetContactsGrowthTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetContactsGrowthGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactsGrowth: async (startDate?: string, endDate?: string, timeRange?: GetContactsGrowthTimeRangeEnum, groupBy?: GetContactsGrowthGroupByEnum, teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts/growth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (timeRange !== undefined) {
                localVarQueryParameter['timeRange'] = timeRange;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsGrowthDataApi - functional programming interface
 * @export
 */
export const ContactsGrowthDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactsGrowthDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns contact database growth over time including new contacts,  updates, and deletions. 
         * @summary Get contacts growth metrics
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetContactsGrowthTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetContactsGrowthGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContactsGrowth(startDate?: string, endDate?: string, timeRange?: GetContactsGrowthTimeRangeEnum, groupBy?: GetContactsGrowthGroupByEnum, teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContactsGrowth200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContactsGrowth(startDate, endDate, timeRange, groupBy, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsGrowthDataApi.getContactsGrowth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactsGrowthDataApi - factory interface
 * @export
 */
export const ContactsGrowthDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactsGrowthDataApiFp(configuration)
    return {
        /**
         * Returns contact database growth over time including new contacts,  updates, and deletions. 
         * @summary Get contacts growth metrics
         * @param {ContactsGrowthDataApiGetContactsGrowthRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactsGrowth(requestParameters: ContactsGrowthDataApiGetContactsGrowthRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetContactsGrowth200Response> {
            return localVarFp.getContactsGrowth(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getContactsGrowth operation in ContactsGrowthDataApi.
 * @export
 * @interface ContactsGrowthDataApiGetContactsGrowthRequest
 */
export interface ContactsGrowthDataApiGetContactsGrowthRequest {
    /**
     * Start date for the query range (inclusive)
     * @type {string}
     * @memberof ContactsGrowthDataApiGetContactsGrowth
     */
    readonly startDate?: string

    /**
     * End date for the query range (inclusive)
     * @type {string}
     * @memberof ContactsGrowthDataApiGetContactsGrowth
     */
    readonly endDate?: string

    /**
     * Preset time range (alternative to startDate/endDate)
     * @type {'7d' | '30d' | '90d'}
     * @memberof ContactsGrowthDataApiGetContactsGrowth
     */
    readonly timeRange?: GetContactsGrowthTimeRangeEnum

    /**
     * Time aggregation period
     * @type {'day' | 'week' | 'month'}
     * @memberof ContactsGrowthDataApiGetContactsGrowth
     */
    readonly groupBy?: GetContactsGrowthGroupByEnum

    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof ContactsGrowthDataApiGetContactsGrowth
     */
    readonly teamId?: string
}

/**
 * ContactsGrowthDataApi - object-oriented interface
 * @export
 * @class ContactsGrowthDataApi
 * @extends {BaseAPI}
 */
export class ContactsGrowthDataApi extends BaseAPI {
    /**
     * Returns contact database growth over time including new contacts,  updates, and deletions. 
     * @summary Get contacts growth metrics
     * @param {ContactsGrowthDataApiGetContactsGrowthRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsGrowthDataApi
     */
    public getContactsGrowth(requestParameters: ContactsGrowthDataApiGetContactsGrowthRequest = {}, options?: RawAxiosRequestConfig) {
        return ContactsGrowthDataApiFp(this.configuration).getContactsGrowth(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetContactsGrowthTimeRangeEnum = {
    7d: '7d',
    30d: '30d',
    90d: '90d'
} as const;
export type GetContactsGrowthTimeRangeEnum = typeof GetContactsGrowthTimeRangeEnum[keyof typeof GetContactsGrowthTimeRangeEnum];
/**
 * @export
 */
export const GetContactsGrowthGroupByEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;
export type GetContactsGrowthGroupByEnum = typeof GetContactsGrowthGroupByEnum[keyof typeof GetContactsGrowthGroupByEnum];


/**
 * ContactsTaggingDataApi - axios parameter creator
 * @export
 */
export const ContactsTaggingDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns metrics on contact tagging and assignment events. 
         * @summary Get contact tagging activity
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetContactsTagsTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetContactsTagsGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactsTags: async (startDate?: string, endDate?: string, timeRange?: GetContactsTagsTimeRangeEnum, groupBy?: GetContactsTagsGroupByEnum, teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (timeRange !== undefined) {
                localVarQueryParameter['timeRange'] = timeRange;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsTaggingDataApi - functional programming interface
 * @export
 */
export const ContactsTaggingDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactsTaggingDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns metrics on contact tagging and assignment events. 
         * @summary Get contact tagging activity
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetContactsTagsTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetContactsTagsGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContactsTags(startDate?: string, endDate?: string, timeRange?: GetContactsTagsTimeRangeEnum, groupBy?: GetContactsTagsGroupByEnum, teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContactsTags200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContactsTags(startDate, endDate, timeRange, groupBy, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContactsTaggingDataApi.getContactsTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContactsTaggingDataApi - factory interface
 * @export
 */
export const ContactsTaggingDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactsTaggingDataApiFp(configuration)
    return {
        /**
         * Returns metrics on contact tagging and assignment events. 
         * @summary Get contact tagging activity
         * @param {ContactsTaggingDataApiGetContactsTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactsTags(requestParameters: ContactsTaggingDataApiGetContactsTagsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetContactsTags200Response> {
            return localVarFp.getContactsTags(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getContactsTags operation in ContactsTaggingDataApi.
 * @export
 * @interface ContactsTaggingDataApiGetContactsTagsRequest
 */
export interface ContactsTaggingDataApiGetContactsTagsRequest {
    /**
     * Start date for the query range (inclusive)
     * @type {string}
     * @memberof ContactsTaggingDataApiGetContactsTags
     */
    readonly startDate?: string

    /**
     * End date for the query range (inclusive)
     * @type {string}
     * @memberof ContactsTaggingDataApiGetContactsTags
     */
    readonly endDate?: string

    /**
     * Preset time range (alternative to startDate/endDate)
     * @type {'7d' | '30d' | '90d'}
     * @memberof ContactsTaggingDataApiGetContactsTags
     */
    readonly timeRange?: GetContactsTagsTimeRangeEnum

    /**
     * Time aggregation period
     * @type {'day' | 'week' | 'month'}
     * @memberof ContactsTaggingDataApiGetContactsTags
     */
    readonly groupBy?: GetContactsTagsGroupByEnum

    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof ContactsTaggingDataApiGetContactsTags
     */
    readonly teamId?: string
}

/**
 * ContactsTaggingDataApi - object-oriented interface
 * @export
 * @class ContactsTaggingDataApi
 * @extends {BaseAPI}
 */
export class ContactsTaggingDataApi extends BaseAPI {
    /**
     * Returns metrics on contact tagging and assignment events. 
     * @summary Get contact tagging activity
     * @param {ContactsTaggingDataApiGetContactsTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsTaggingDataApi
     */
    public getContactsTags(requestParameters: ContactsTaggingDataApiGetContactsTagsRequest = {}, options?: RawAxiosRequestConfig) {
        return ContactsTaggingDataApiFp(this.configuration).getContactsTags(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetContactsTagsTimeRangeEnum = {
    7d: '7d',
    30d: '30d',
    90d: '90d'
} as const;
export type GetContactsTagsTimeRangeEnum = typeof GetContactsTagsTimeRangeEnum[keyof typeof GetContactsTagsTimeRangeEnum];
/**
 * @export
 */
export const GetContactsTagsGroupByEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;
export type GetContactsTagsGroupByEnum = typeof GetContactsTagsGroupByEnum[keyof typeof GetContactsTagsGroupByEnum];


/**
 * EventsAnalyticsApi - axios parameter creator
 * @export
 */
export const EventsAnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns event counts broken down by event type (messages, contacts, automation, etc.) 
         * @summary Get events grouped by type
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetEventsByTypeTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {string} [teamId] Filter by specific team ID
         * @param {EventCategory} [category] Filter by event category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByType: async (startDate?: string, endDate?: string, timeRange?: GetEventsByTypeTimeRangeEnum, teamId?: string, category?: EventCategory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/by-type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (timeRange !== undefined) {
                localVarQueryParameter['timeRange'] = timeRange;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsAnalyticsApi - functional programming interface
 * @export
 */
export const EventsAnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsAnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns event counts broken down by event type (messages, contacts, automation, etc.) 
         * @summary Get events grouped by type
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetEventsByTypeTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {string} [teamId] Filter by specific team ID
         * @param {EventCategory} [category] Filter by event category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventsByType(startDate?: string, endDate?: string, timeRange?: GetEventsByTypeTimeRangeEnum, teamId?: string, category?: EventCategory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventsByType200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsByType(startDate, endDate, timeRange, teamId, category, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsAnalyticsApi.getEventsByType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventsAnalyticsApi - factory interface
 * @export
 */
export const EventsAnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsAnalyticsApiFp(configuration)
    return {
        /**
         * Returns event counts broken down by event type (messages, contacts, automation, etc.) 
         * @summary Get events grouped by type
         * @param {EventsAnalyticsApiGetEventsByTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsByType(requestParameters: EventsAnalyticsApiGetEventsByTypeRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetEventsByType200Response> {
            return localVarFp.getEventsByType(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.teamId, requestParameters.category, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getEventsByType operation in EventsAnalyticsApi.
 * @export
 * @interface EventsAnalyticsApiGetEventsByTypeRequest
 */
export interface EventsAnalyticsApiGetEventsByTypeRequest {
    /**
     * Start date for the query range (inclusive)
     * @type {string}
     * @memberof EventsAnalyticsApiGetEventsByType
     */
    readonly startDate?: string

    /**
     * End date for the query range (inclusive)
     * @type {string}
     * @memberof EventsAnalyticsApiGetEventsByType
     */
    readonly endDate?: string

    /**
     * Preset time range (alternative to startDate/endDate)
     * @type {'7d' | '30d' | '90d'}
     * @memberof EventsAnalyticsApiGetEventsByType
     */
    readonly timeRange?: GetEventsByTypeTimeRangeEnum

    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof EventsAnalyticsApiGetEventsByType
     */
    readonly teamId?: string

    /**
     * Filter by event category
     * @type {EventCategory}
     * @memberof EventsAnalyticsApiGetEventsByType
     */
    readonly category?: EventCategory
}

/**
 * EventsAnalyticsApi - object-oriented interface
 * @export
 * @class EventsAnalyticsApi
 * @extends {BaseAPI}
 */
export class EventsAnalyticsApi extends BaseAPI {
    /**
     * Returns event counts broken down by event type (messages, contacts, automation, etc.) 
     * @summary Get events grouped by type
     * @param {EventsAnalyticsApiGetEventsByTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsAnalyticsApi
     */
    public getEventsByType(requestParameters: EventsAnalyticsApiGetEventsByTypeRequest = {}, options?: RawAxiosRequestConfig) {
        return EventsAnalyticsApiFp(this.configuration).getEventsByType(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.teamId, requestParameters.category, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetEventsByTypeTimeRangeEnum = {
    7d: '7d',
    30d: '30d',
    90d: '90d'
} as const;
export type GetEventsByTypeTimeRangeEnum = typeof GetEventsByTypeTimeRangeEnum[keyof typeof GetEventsByTypeTimeRangeEnum];


/**
 * EventsVolumeDataApi - axios parameter creator
 * @export
 */
export const EventsVolumeDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns total event count aggregated by time period (day/week/month). Supports all 62 event types tracked by ChatDaddy. 
         * @summary Get event volume over time
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetEventVolumeTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetEventVolumeGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {Array<EventName>} [eventTypes] Filter by specific event types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventVolume: async (startDate?: string, endDate?: string, timeRange?: GetEventVolumeTimeRangeEnum, groupBy?: GetEventVolumeGroupByEnum, teamId?: string, eventTypes?: Array<EventName>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/volume`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (timeRange !== undefined) {
                localVarQueryParameter['timeRange'] = timeRange;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (eventTypes) {
                localVarQueryParameter['eventTypes'] = eventTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsVolumeDataApi - functional programming interface
 * @export
 */
export const EventsVolumeDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsVolumeDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns total event count aggregated by time period (day/week/month). Supports all 62 event types tracked by ChatDaddy. 
         * @summary Get event volume over time
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetEventVolumeTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetEventVolumeGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {Array<EventName>} [eventTypes] Filter by specific event types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventVolume(startDate?: string, endDate?: string, timeRange?: GetEventVolumeTimeRangeEnum, groupBy?: GetEventVolumeGroupByEnum, teamId?: string, eventTypes?: Array<EventName>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEventVolume200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventVolume(startDate, endDate, timeRange, groupBy, teamId, eventTypes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsVolumeDataApi.getEventVolume']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventsVolumeDataApi - factory interface
 * @export
 */
export const EventsVolumeDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsVolumeDataApiFp(configuration)
    return {
        /**
         * Returns total event count aggregated by time period (day/week/month). Supports all 62 event types tracked by ChatDaddy. 
         * @summary Get event volume over time
         * @param {EventsVolumeDataApiGetEventVolumeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventVolume(requestParameters: EventsVolumeDataApiGetEventVolumeRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetEventVolume200Response> {
            return localVarFp.getEventVolume(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, requestParameters.eventTypes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getEventVolume operation in EventsVolumeDataApi.
 * @export
 * @interface EventsVolumeDataApiGetEventVolumeRequest
 */
export interface EventsVolumeDataApiGetEventVolumeRequest {
    /**
     * Start date for the query range (inclusive)
     * @type {string}
     * @memberof EventsVolumeDataApiGetEventVolume
     */
    readonly startDate?: string

    /**
     * End date for the query range (inclusive)
     * @type {string}
     * @memberof EventsVolumeDataApiGetEventVolume
     */
    readonly endDate?: string

    /**
     * Preset time range (alternative to startDate/endDate)
     * @type {'7d' | '30d' | '90d'}
     * @memberof EventsVolumeDataApiGetEventVolume
     */
    readonly timeRange?: GetEventVolumeTimeRangeEnum

    /**
     * Time aggregation period
     * @type {'day' | 'week' | 'month'}
     * @memberof EventsVolumeDataApiGetEventVolume
     */
    readonly groupBy?: GetEventVolumeGroupByEnum

    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof EventsVolumeDataApiGetEventVolume
     */
    readonly teamId?: string

    /**
     * Filter by specific event types
     * @type {Array<EventName>}
     * @memberof EventsVolumeDataApiGetEventVolume
     */
    readonly eventTypes?: Array<EventName>
}

/**
 * EventsVolumeDataApi - object-oriented interface
 * @export
 * @class EventsVolumeDataApi
 * @extends {BaseAPI}
 */
export class EventsVolumeDataApi extends BaseAPI {
    /**
     * Returns total event count aggregated by time period (day/week/month). Supports all 62 event types tracked by ChatDaddy. 
     * @summary Get event volume over time
     * @param {EventsVolumeDataApiGetEventVolumeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsVolumeDataApi
     */
    public getEventVolume(requestParameters: EventsVolumeDataApiGetEventVolumeRequest = {}, options?: RawAxiosRequestConfig) {
        return EventsVolumeDataApiFp(this.configuration).getEventVolume(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, requestParameters.eventTypes, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetEventVolumeTimeRangeEnum = {
    7d: '7d',
    30d: '30d',
    90d: '90d'
} as const;
export type GetEventVolumeTimeRangeEnum = typeof GetEventVolumeTimeRangeEnum[keyof typeof GetEventVolumeTimeRangeEnum];
/**
 * @export
 */
export const GetEventVolumeGroupByEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;
export type GetEventVolumeGroupByEnum = typeof GetEventVolumeGroupByEnum[keyof typeof GetEventVolumeGroupByEnum];


/**
 * FeaturesUsageDataApi - axios parameter creator
 * @export
 */
export const FeaturesUsageDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns usage trends for key features like messages, chatbot, and calls. 
         * @summary Get feature usage trends
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetFeaturesUsageTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetFeaturesUsageGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturesUsage: async (startDate?: string, endDate?: string, timeRange?: GetFeaturesUsageTimeRangeEnum, groupBy?: GetFeaturesUsageGroupByEnum, teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/features/usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (timeRange !== undefined) {
                localVarQueryParameter['timeRange'] = timeRange;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeaturesUsageDataApi - functional programming interface
 * @export
 */
export const FeaturesUsageDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeaturesUsageDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns usage trends for key features like messages, chatbot, and calls. 
         * @summary Get feature usage trends
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetFeaturesUsageTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetFeaturesUsageGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeaturesUsage(startDate?: string, endDate?: string, timeRange?: GetFeaturesUsageTimeRangeEnum, groupBy?: GetFeaturesUsageGroupByEnum, teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFeaturesUsage200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeaturesUsage(startDate, endDate, timeRange, groupBy, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeaturesUsageDataApi.getFeaturesUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeaturesUsageDataApi - factory interface
 * @export
 */
export const FeaturesUsageDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeaturesUsageDataApiFp(configuration)
    return {
        /**
         * Returns usage trends for key features like messages, chatbot, and calls. 
         * @summary Get feature usage trends
         * @param {FeaturesUsageDataApiGetFeaturesUsageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturesUsage(requestParameters: FeaturesUsageDataApiGetFeaturesUsageRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetFeaturesUsage200Response> {
            return localVarFp.getFeaturesUsage(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFeaturesUsage operation in FeaturesUsageDataApi.
 * @export
 * @interface FeaturesUsageDataApiGetFeaturesUsageRequest
 */
export interface FeaturesUsageDataApiGetFeaturesUsageRequest {
    /**
     * Start date for the query range (inclusive)
     * @type {string}
     * @memberof FeaturesUsageDataApiGetFeaturesUsage
     */
    readonly startDate?: string

    /**
     * End date for the query range (inclusive)
     * @type {string}
     * @memberof FeaturesUsageDataApiGetFeaturesUsage
     */
    readonly endDate?: string

    /**
     * Preset time range (alternative to startDate/endDate)
     * @type {'7d' | '30d' | '90d'}
     * @memberof FeaturesUsageDataApiGetFeaturesUsage
     */
    readonly timeRange?: GetFeaturesUsageTimeRangeEnum

    /**
     * Time aggregation period
     * @type {'day' | 'week' | 'month'}
     * @memberof FeaturesUsageDataApiGetFeaturesUsage
     */
    readonly groupBy?: GetFeaturesUsageGroupByEnum

    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof FeaturesUsageDataApiGetFeaturesUsage
     */
    readonly teamId?: string
}

/**
 * FeaturesUsageDataApi - object-oriented interface
 * @export
 * @class FeaturesUsageDataApi
 * @extends {BaseAPI}
 */
export class FeaturesUsageDataApi extends BaseAPI {
    /**
     * Returns usage trends for key features like messages, chatbot, and calls. 
     * @summary Get feature usage trends
     * @param {FeaturesUsageDataApiGetFeaturesUsageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeaturesUsageDataApi
     */
    public getFeaturesUsage(requestParameters: FeaturesUsageDataApiGetFeaturesUsageRequest = {}, options?: RawAxiosRequestConfig) {
        return FeaturesUsageDataApiFp(this.configuration).getFeaturesUsage(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetFeaturesUsageTimeRangeEnum = {
    7d: '7d',
    30d: '30d',
    90d: '90d'
} as const;
export type GetFeaturesUsageTimeRangeEnum = typeof GetFeaturesUsageTimeRangeEnum[keyof typeof GetFeaturesUsageTimeRangeEnum];
/**
 * @export
 */
export const GetFeaturesUsageGroupByEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;
export type GetFeaturesUsageGroupByEnum = typeof GetFeaturesUsageGroupByEnum[keyof typeof GetFeaturesUsageGroupByEnum];


/**
 * MessagesCountDataApi - axios parameter creator
 * @export
 */
export const MessagesCountDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get aggregated message counts (sent and received) within a date range. Data is aggregated from hourly buckets stored in ElasticSearch. 
         * @summary Get message count statistics
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageCount: async (startDate?: string, endDate?: string, teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messages/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint for external systems to POST message count data.  Data is aggregated into hourly buckets. 
         * @summary Receive message count from external systems
         * @param {MessageCountPost} messageCountPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessageCount: async (messageCountPost: MessageCountPost, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageCountPost' is not null or undefined
            assertParamExists('postMessageCount', 'messageCountPost', messageCountPost)
            const localVarPath = `/messages/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageCountPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesCountDataApi - functional programming interface
 * @export
 */
export const MessagesCountDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesCountDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Get aggregated message counts (sent and received) within a date range. Data is aggregated from hourly buckets stored in ElasticSearch. 
         * @summary Get message count statistics
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageCount(startDate?: string, endDate?: string, teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessageCount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageCount(startDate, endDate, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesCountDataApi.getMessageCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint for external systems to POST message count data.  Data is aggregated into hourly buckets. 
         * @summary Receive message count from external systems
         * @param {MessageCountPost} messageCountPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMessageCount(messageCountPost: MessageCountPost, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMessageCount(messageCountPost, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesCountDataApi.postMessageCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessagesCountDataApi - factory interface
 * @export
 */
export const MessagesCountDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesCountDataApiFp(configuration)
    return {
        /**
         * Get aggregated message counts (sent and received) within a date range. Data is aggregated from hourly buckets stored in ElasticSearch. 
         * @summary Get message count statistics
         * @param {MessagesCountDataApiGetMessageCountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageCount(requestParameters: MessagesCountDataApiGetMessageCountRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetMessageCount200Response> {
            return localVarFp.getMessageCount(requestParameters.startDate, requestParameters.endDate, requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for external systems to POST message count data.  Data is aggregated into hourly buckets. 
         * @summary Receive message count from external systems
         * @param {MessagesCountDataApiPostMessageCountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessageCount(requestParameters: MessagesCountDataApiPostMessageCountRequest, options?: RawAxiosRequestConfig): AxiosPromise<CountPostResponse> {
            return localVarFp.postMessageCount(requestParameters.messageCountPost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMessageCount operation in MessagesCountDataApi.
 * @export
 * @interface MessagesCountDataApiGetMessageCountRequest
 */
export interface MessagesCountDataApiGetMessageCountRequest {
    /**
     * Start date for the query range (inclusive)
     * @type {string}
     * @memberof MessagesCountDataApiGetMessageCount
     */
    readonly startDate?: string

    /**
     * End date for the query range (inclusive)
     * @type {string}
     * @memberof MessagesCountDataApiGetMessageCount
     */
    readonly endDate?: string

    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof MessagesCountDataApiGetMessageCount
     */
    readonly teamId?: string
}

/**
 * Request parameters for postMessageCount operation in MessagesCountDataApi.
 * @export
 * @interface MessagesCountDataApiPostMessageCountRequest
 */
export interface MessagesCountDataApiPostMessageCountRequest {
    /**
     * 
     * @type {MessageCountPost}
     * @memberof MessagesCountDataApiPostMessageCount
     */
    readonly messageCountPost: MessageCountPost
}

/**
 * MessagesCountDataApi - object-oriented interface
 * @export
 * @class MessagesCountDataApi
 * @extends {BaseAPI}
 */
export class MessagesCountDataApi extends BaseAPI {
    /**
     * Get aggregated message counts (sent and received) within a date range. Data is aggregated from hourly buckets stored in ElasticSearch. 
     * @summary Get message count statistics
     * @param {MessagesCountDataApiGetMessageCountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesCountDataApi
     */
    public getMessageCount(requestParameters: MessagesCountDataApiGetMessageCountRequest = {}, options?: RawAxiosRequestConfig) {
        return MessagesCountDataApiFp(this.configuration).getMessageCount(requestParameters.startDate, requestParameters.endDate, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint for external systems to POST message count data.  Data is aggregated into hourly buckets. 
     * @summary Receive message count from external systems
     * @param {MessagesCountDataApiPostMessageCountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesCountDataApi
     */
    public postMessageCount(requestParameters: MessagesCountDataApiPostMessageCountRequest, options?: RawAxiosRequestConfig) {
        return MessagesCountDataApiFp(this.configuration).postMessageCount(requestParameters.messageCountPost, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessagesVolumeBySourceApi - axios parameter creator
 * @export
 */
export const MessagesVolumeBySourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns message counts segmented by source type: automation, broadcast, or manual. 
         * @summary Get messages breakdown by source
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetMessagesBySourceTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetMessagesBySourceGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesBySource: async (startDate?: string, endDate?: string, timeRange?: GetMessagesBySourceTimeRangeEnum, groupBy?: GetMessagesBySourceGroupByEnum, teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messages/by-source`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (timeRange !== undefined) {
                localVarQueryParameter['timeRange'] = timeRange;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesVolumeBySourceApi - functional programming interface
 * @export
 */
export const MessagesVolumeBySourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesVolumeBySourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns message counts segmented by source type: automation, broadcast, or manual. 
         * @summary Get messages breakdown by source
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetMessagesBySourceTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetMessagesBySourceGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessagesBySource(startDate?: string, endDate?: string, timeRange?: GetMessagesBySourceTimeRangeEnum, groupBy?: GetMessagesBySourceGroupByEnum, teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesBySource200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesBySource(startDate, endDate, timeRange, groupBy, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesVolumeBySourceApi.getMessagesBySource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessagesVolumeBySourceApi - factory interface
 * @export
 */
export const MessagesVolumeBySourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesVolumeBySourceApiFp(configuration)
    return {
        /**
         * Returns message counts segmented by source type: automation, broadcast, or manual. 
         * @summary Get messages breakdown by source
         * @param {MessagesVolumeBySourceApiGetMessagesBySourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesBySource(requestParameters: MessagesVolumeBySourceApiGetMessagesBySourceRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetMessagesBySource200Response> {
            return localVarFp.getMessagesBySource(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMessagesBySource operation in MessagesVolumeBySourceApi.
 * @export
 * @interface MessagesVolumeBySourceApiGetMessagesBySourceRequest
 */
export interface MessagesVolumeBySourceApiGetMessagesBySourceRequest {
    /**
     * Start date for the query range (inclusive)
     * @type {string}
     * @memberof MessagesVolumeBySourceApiGetMessagesBySource
     */
    readonly startDate?: string

    /**
     * End date for the query range (inclusive)
     * @type {string}
     * @memberof MessagesVolumeBySourceApiGetMessagesBySource
     */
    readonly endDate?: string

    /**
     * Preset time range (alternative to startDate/endDate)
     * @type {'7d' | '30d' | '90d'}
     * @memberof MessagesVolumeBySourceApiGetMessagesBySource
     */
    readonly timeRange?: GetMessagesBySourceTimeRangeEnum

    /**
     * Time aggregation period
     * @type {'day' | 'week' | 'month'}
     * @memberof MessagesVolumeBySourceApiGetMessagesBySource
     */
    readonly groupBy?: GetMessagesBySourceGroupByEnum

    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof MessagesVolumeBySourceApiGetMessagesBySource
     */
    readonly teamId?: string
}

/**
 * MessagesVolumeBySourceApi - object-oriented interface
 * @export
 * @class MessagesVolumeBySourceApi
 * @extends {BaseAPI}
 */
export class MessagesVolumeBySourceApi extends BaseAPI {
    /**
     * Returns message counts segmented by source type: automation, broadcast, or manual. 
     * @summary Get messages breakdown by source
     * @param {MessagesVolumeBySourceApiGetMessagesBySourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesVolumeBySourceApi
     */
    public getMessagesBySource(requestParameters: MessagesVolumeBySourceApiGetMessagesBySourceRequest = {}, options?: RawAxiosRequestConfig) {
        return MessagesVolumeBySourceApiFp(this.configuration).getMessagesBySource(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetMessagesBySourceTimeRangeEnum = {
    7d: '7d',
    30d: '30d',
    90d: '90d'
} as const;
export type GetMessagesBySourceTimeRangeEnum = typeof GetMessagesBySourceTimeRangeEnum[keyof typeof GetMessagesBySourceTimeRangeEnum];
/**
 * @export
 */
export const GetMessagesBySourceGroupByEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;
export type GetMessagesBySourceGroupByEnum = typeof GetMessagesBySourceGroupByEnum[keyof typeof GetMessagesBySourceGroupByEnum];


/**
 * MessagesVolumeDataApi - axios parameter creator
 * @export
 */
export const MessagesVolumeDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns comprehensive message statistics including sent, received,  and messages by source (automation, broadcast, manual). 
         * @summary Get messages summary metrics
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetMessagesSummaryTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetMessagesSummaryGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesSummary: async (startDate?: string, endDate?: string, timeRange?: GetMessagesSummaryTimeRangeEnum, groupBy?: GetMessagesSummaryGroupByEnum, teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/messages/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (timeRange !== undefined) {
                localVarQueryParameter['timeRange'] = timeRange;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesVolumeDataApi - functional programming interface
 * @export
 */
export const MessagesVolumeDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesVolumeDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns comprehensive message statistics including sent, received,  and messages by source (automation, broadcast, manual). 
         * @summary Get messages summary metrics
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetMessagesSummaryTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetMessagesSummaryGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessagesSummary(startDate?: string, endDate?: string, timeRange?: GetMessagesSummaryTimeRangeEnum, groupBy?: GetMessagesSummaryGroupByEnum, teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesSummary200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesSummary(startDate, endDate, timeRange, groupBy, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesVolumeDataApi.getMessagesSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessagesVolumeDataApi - factory interface
 * @export
 */
export const MessagesVolumeDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesVolumeDataApiFp(configuration)
    return {
        /**
         * Returns comprehensive message statistics including sent, received,  and messages by source (automation, broadcast, manual). 
         * @summary Get messages summary metrics
         * @param {MessagesVolumeDataApiGetMessagesSummaryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesSummary(requestParameters: MessagesVolumeDataApiGetMessagesSummaryRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetMessagesSummary200Response> {
            return localVarFp.getMessagesSummary(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMessagesSummary operation in MessagesVolumeDataApi.
 * @export
 * @interface MessagesVolumeDataApiGetMessagesSummaryRequest
 */
export interface MessagesVolumeDataApiGetMessagesSummaryRequest {
    /**
     * Start date for the query range (inclusive)
     * @type {string}
     * @memberof MessagesVolumeDataApiGetMessagesSummary
     */
    readonly startDate?: string

    /**
     * End date for the query range (inclusive)
     * @type {string}
     * @memberof MessagesVolumeDataApiGetMessagesSummary
     */
    readonly endDate?: string

    /**
     * Preset time range (alternative to startDate/endDate)
     * @type {'7d' | '30d' | '90d'}
     * @memberof MessagesVolumeDataApiGetMessagesSummary
     */
    readonly timeRange?: GetMessagesSummaryTimeRangeEnum

    /**
     * Time aggregation period
     * @type {'day' | 'week' | 'month'}
     * @memberof MessagesVolumeDataApiGetMessagesSummary
     */
    readonly groupBy?: GetMessagesSummaryGroupByEnum

    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof MessagesVolumeDataApiGetMessagesSummary
     */
    readonly teamId?: string
}

/**
 * MessagesVolumeDataApi - object-oriented interface
 * @export
 * @class MessagesVolumeDataApi
 * @extends {BaseAPI}
 */
export class MessagesVolumeDataApi extends BaseAPI {
    /**
     * Returns comprehensive message statistics including sent, received,  and messages by source (automation, broadcast, manual). 
     * @summary Get messages summary metrics
     * @param {MessagesVolumeDataApiGetMessagesSummaryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesVolumeDataApi
     */
    public getMessagesSummary(requestParameters: MessagesVolumeDataApiGetMessagesSummaryRequest = {}, options?: RawAxiosRequestConfig) {
        return MessagesVolumeDataApiFp(this.configuration).getMessagesSummary(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetMessagesSummaryTimeRangeEnum = {
    7d: '7d',
    30d: '30d',
    90d: '90d'
} as const;
export type GetMessagesSummaryTimeRangeEnum = typeof GetMessagesSummaryTimeRangeEnum[keyof typeof GetMessagesSummaryTimeRangeEnum];
/**
 * @export
 */
export const GetMessagesSummaryGroupByEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;
export type GetMessagesSummaryGroupByEnum = typeof GetMessagesSummaryGroupByEnum[keyof typeof GetMessagesSummaryGroupByEnum];


/**
 * OverviewAnalyticsApi - axios parameter creator
 * @export
 */
export const OverviewAnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns key performance indicators including active users, DAU, WAU, MAU,  credits usage, top features, and at-risk accounts. 
         * @summary Get executive overview KPIs
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetOverviewKPIsTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverviewKPIs: async (startDate?: string, endDate?: string, timeRange?: GetOverviewKPIsTimeRangeEnum, teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/overview/kpis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (timeRange !== undefined) {
                localVarQueryParameter['timeRange'] = timeRange;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OverviewAnalyticsApi - functional programming interface
 * @export
 */
export const OverviewAnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OverviewAnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns key performance indicators including active users, DAU, WAU, MAU,  credits usage, top features, and at-risk accounts. 
         * @summary Get executive overview KPIs
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetOverviewKPIsTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOverviewKPIs(startDate?: string, endDate?: string, timeRange?: GetOverviewKPIsTimeRangeEnum, teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOverviewKPIs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOverviewKPIs(startDate, endDate, timeRange, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OverviewAnalyticsApi.getOverviewKPIs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OverviewAnalyticsApi - factory interface
 * @export
 */
export const OverviewAnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OverviewAnalyticsApiFp(configuration)
    return {
        /**
         * Returns key performance indicators including active users, DAU, WAU, MAU,  credits usage, top features, and at-risk accounts. 
         * @summary Get executive overview KPIs
         * @param {OverviewAnalyticsApiGetOverviewKPIsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverviewKPIs(requestParameters: OverviewAnalyticsApiGetOverviewKPIsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetOverviewKPIs200Response> {
            return localVarFp.getOverviewKPIs(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getOverviewKPIs operation in OverviewAnalyticsApi.
 * @export
 * @interface OverviewAnalyticsApiGetOverviewKPIsRequest
 */
export interface OverviewAnalyticsApiGetOverviewKPIsRequest {
    /**
     * Start date for the query range (inclusive)
     * @type {string}
     * @memberof OverviewAnalyticsApiGetOverviewKPIs
     */
    readonly startDate?: string

    /**
     * End date for the query range (inclusive)
     * @type {string}
     * @memberof OverviewAnalyticsApiGetOverviewKPIs
     */
    readonly endDate?: string

    /**
     * Preset time range (alternative to startDate/endDate)
     * @type {'7d' | '30d' | '90d'}
     * @memberof OverviewAnalyticsApiGetOverviewKPIs
     */
    readonly timeRange?: GetOverviewKPIsTimeRangeEnum

    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof OverviewAnalyticsApiGetOverviewKPIs
     */
    readonly teamId?: string
}

/**
 * OverviewAnalyticsApi - object-oriented interface
 * @export
 * @class OverviewAnalyticsApi
 * @extends {BaseAPI}
 */
export class OverviewAnalyticsApi extends BaseAPI {
    /**
     * Returns key performance indicators including active users, DAU, WAU, MAU,  credits usage, top features, and at-risk accounts. 
     * @summary Get executive overview KPIs
     * @param {OverviewAnalyticsApiGetOverviewKPIsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverviewAnalyticsApi
     */
    public getOverviewKPIs(requestParameters: OverviewAnalyticsApiGetOverviewKPIsRequest = {}, options?: RawAxiosRequestConfig) {
        return OverviewAnalyticsApiFp(this.configuration).getOverviewKPIs(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetOverviewKPIsTimeRangeEnum = {
    7d: '7d',
    30d: '30d',
    90d: '90d'
} as const;
export type GetOverviewKPIsTimeRangeEnum = typeof GetOverviewKPIsTimeRangeEnum[keyof typeof GetOverviewKPIsTimeRangeEnum];


/**
 * RevenueDataApi - axios parameter creator
 * @export
 */
export const RevenueDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns order volume and revenue-related metrics. 
         * @summary Get orders and revenue metrics
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetRevenueOrdersTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetRevenueOrdersGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevenueOrders: async (startDate?: string, endDate?: string, timeRange?: GetRevenueOrdersTimeRangeEnum, groupBy?: GetRevenueOrdersGroupByEnum, teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/revenue/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (timeRange !== undefined) {
                localVarQueryParameter['timeRange'] = timeRange;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RevenueDataApi - functional programming interface
 * @export
 */
export const RevenueDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RevenueDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns order volume and revenue-related metrics. 
         * @summary Get orders and revenue metrics
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetRevenueOrdersTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetRevenueOrdersGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRevenueOrders(startDate?: string, endDate?: string, timeRange?: GetRevenueOrdersTimeRangeEnum, groupBy?: GetRevenueOrdersGroupByEnum, teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRevenueOrders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRevenueOrders(startDate, endDate, timeRange, groupBy, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RevenueDataApi.getRevenueOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RevenueDataApi - factory interface
 * @export
 */
export const RevenueDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RevenueDataApiFp(configuration)
    return {
        /**
         * Returns order volume and revenue-related metrics. 
         * @summary Get orders and revenue metrics
         * @param {RevenueDataApiGetRevenueOrdersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevenueOrders(requestParameters: RevenueDataApiGetRevenueOrdersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetRevenueOrders200Response> {
            return localVarFp.getRevenueOrders(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getRevenueOrders operation in RevenueDataApi.
 * @export
 * @interface RevenueDataApiGetRevenueOrdersRequest
 */
export interface RevenueDataApiGetRevenueOrdersRequest {
    /**
     * Start date for the query range (inclusive)
     * @type {string}
     * @memberof RevenueDataApiGetRevenueOrders
     */
    readonly startDate?: string

    /**
     * End date for the query range (inclusive)
     * @type {string}
     * @memberof RevenueDataApiGetRevenueOrders
     */
    readonly endDate?: string

    /**
     * Preset time range (alternative to startDate/endDate)
     * @type {'7d' | '30d' | '90d'}
     * @memberof RevenueDataApiGetRevenueOrders
     */
    readonly timeRange?: GetRevenueOrdersTimeRangeEnum

    /**
     * Time aggregation period
     * @type {'day' | 'week' | 'month'}
     * @memberof RevenueDataApiGetRevenueOrders
     */
    readonly groupBy?: GetRevenueOrdersGroupByEnum

    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof RevenueDataApiGetRevenueOrders
     */
    readonly teamId?: string
}

/**
 * RevenueDataApi - object-oriented interface
 * @export
 * @class RevenueDataApi
 * @extends {BaseAPI}
 */
export class RevenueDataApi extends BaseAPI {
    /**
     * Returns order volume and revenue-related metrics. 
     * @summary Get orders and revenue metrics
     * @param {RevenueDataApiGetRevenueOrdersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RevenueDataApi
     */
    public getRevenueOrders(requestParameters: RevenueDataApiGetRevenueOrdersRequest = {}, options?: RawAxiosRequestConfig) {
        return RevenueDataApiFp(this.configuration).getRevenueOrders(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetRevenueOrdersTimeRangeEnum = {
    7d: '7d',
    30d: '30d',
    90d: '90d'
} as const;
export type GetRevenueOrdersTimeRangeEnum = typeof GetRevenueOrdersTimeRangeEnum[keyof typeof GetRevenueOrdersTimeRangeEnum];
/**
 * @export
 */
export const GetRevenueOrdersGroupByEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;
export type GetRevenueOrdersGroupByEnum = typeof GetRevenueOrdersGroupByEnum[keyof typeof GetRevenueOrdersGroupByEnum];


/**
 * SupportTicketsDataApi - axios parameter creator
 * @export
 */
export const SupportTicketsDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns comprehensive ticket metrics including volume,  resolution rate, and response times. 
         * @summary Get support tickets metrics
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetSupportTicketsTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetSupportTicketsGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportTickets: async (startDate?: string, endDate?: string, timeRange?: GetSupportTicketsTimeRangeEnum, groupBy?: GetSupportTicketsGroupByEnum, teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/support/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (timeRange !== undefined) {
                localVarQueryParameter['timeRange'] = timeRange;
            }

            if (groupBy !== undefined) {
                localVarQueryParameter['groupBy'] = groupBy;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SupportTicketsDataApi - functional programming interface
 * @export
 */
export const SupportTicketsDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SupportTicketsDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns comprehensive ticket metrics including volume,  resolution rate, and response times. 
         * @summary Get support tickets metrics
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetSupportTicketsTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {GetSupportTicketsGroupByEnum} [groupBy] Time aggregation period
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupportTickets(startDate?: string, endDate?: string, timeRange?: GetSupportTicketsTimeRangeEnum, groupBy?: GetSupportTicketsGroupByEnum, teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSupportTickets200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupportTickets(startDate, endDate, timeRange, groupBy, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupportTicketsDataApi.getSupportTickets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SupportTicketsDataApi - factory interface
 * @export
 */
export const SupportTicketsDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SupportTicketsDataApiFp(configuration)
    return {
        /**
         * Returns comprehensive ticket metrics including volume,  resolution rate, and response times. 
         * @summary Get support tickets metrics
         * @param {SupportTicketsDataApiGetSupportTicketsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportTickets(requestParameters: SupportTicketsDataApiGetSupportTicketsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetSupportTickets200Response> {
            return localVarFp.getSupportTickets(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSupportTickets operation in SupportTicketsDataApi.
 * @export
 * @interface SupportTicketsDataApiGetSupportTicketsRequest
 */
export interface SupportTicketsDataApiGetSupportTicketsRequest {
    /**
     * Start date for the query range (inclusive)
     * @type {string}
     * @memberof SupportTicketsDataApiGetSupportTickets
     */
    readonly startDate?: string

    /**
     * End date for the query range (inclusive)
     * @type {string}
     * @memberof SupportTicketsDataApiGetSupportTickets
     */
    readonly endDate?: string

    /**
     * Preset time range (alternative to startDate/endDate)
     * @type {'7d' | '30d' | '90d'}
     * @memberof SupportTicketsDataApiGetSupportTickets
     */
    readonly timeRange?: GetSupportTicketsTimeRangeEnum

    /**
     * Time aggregation period
     * @type {'day' | 'week' | 'month'}
     * @memberof SupportTicketsDataApiGetSupportTickets
     */
    readonly groupBy?: GetSupportTicketsGroupByEnum

    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof SupportTicketsDataApiGetSupportTickets
     */
    readonly teamId?: string
}

/**
 * SupportTicketsDataApi - object-oriented interface
 * @export
 * @class SupportTicketsDataApi
 * @extends {BaseAPI}
 */
export class SupportTicketsDataApi extends BaseAPI {
    /**
     * Returns comprehensive ticket metrics including volume,  resolution rate, and response times. 
     * @summary Get support tickets metrics
     * @param {SupportTicketsDataApiGetSupportTicketsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportTicketsDataApi
     */
    public getSupportTickets(requestParameters: SupportTicketsDataApiGetSupportTicketsRequest = {}, options?: RawAxiosRequestConfig) {
        return SupportTicketsDataApiFp(this.configuration).getSupportTickets(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.groupBy, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetSupportTicketsTimeRangeEnum = {
    7d: '7d',
    30d: '30d',
    90d: '90d'
} as const;
export type GetSupportTicketsTimeRangeEnum = typeof GetSupportTicketsTimeRangeEnum[keyof typeof GetSupportTicketsTimeRangeEnum];
/**
 * @export
 */
export const GetSupportTicketsGroupByEnum = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;
export type GetSupportTicketsGroupByEnum = typeof GetSupportTicketsGroupByEnum[keyof typeof GetSupportTicketsGroupByEnum];


/**
 * SystemHealthDataApi - axios parameter creator
 * @export
 */
export const SystemHealthDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns system health indicators including credit usage,  account status, and platform stability. 
         * @summary Get system health metrics
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemHealth: async (teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemHealthDataApi - functional programming interface
 * @export
 */
export const SystemHealthDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemHealthDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns system health indicators including credit usage,  account status, and platform stability. 
         * @summary Get system health metrics
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemHealth(teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSystemHealth200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemHealth(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemHealthDataApi.getSystemHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemHealthDataApi - factory interface
 * @export
 */
export const SystemHealthDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemHealthDataApiFp(configuration)
    return {
        /**
         * Returns system health indicators including credit usage,  account status, and platform stability. 
         * @summary Get system health metrics
         * @param {SystemHealthDataApiGetSystemHealthRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemHealth(requestParameters: SystemHealthDataApiGetSystemHealthRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetSystemHealth200Response> {
            return localVarFp.getSystemHealth(requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSystemHealth operation in SystemHealthDataApi.
 * @export
 * @interface SystemHealthDataApiGetSystemHealthRequest
 */
export interface SystemHealthDataApiGetSystemHealthRequest {
    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof SystemHealthDataApiGetSystemHealth
     */
    readonly teamId?: string
}

/**
 * SystemHealthDataApi - object-oriented interface
 * @export
 * @class SystemHealthDataApi
 * @extends {BaseAPI}
 */
export class SystemHealthDataApi extends BaseAPI {
    /**
     * Returns system health indicators including credit usage,  account status, and platform stability. 
     * @summary Get system health metrics
     * @param {SystemHealthDataApiGetSystemHealthRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemHealthDataApi
     */
    public getSystemHealth(requestParameters: SystemHealthDataApiGetSystemHealthRequest = {}, options?: RawAxiosRequestConfig) {
        return SystemHealthDataApiFp(this.configuration).getSystemHealth(requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamActivityDataApi - axios parameter creator
 * @export
 */
export const TeamActivityDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns team member activity including logins, assignments, and productivity. 
         * @summary Get team member activity metrics
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetTeamActivityTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamActivity: async (startDate?: string, endDate?: string, timeRange?: GetTeamActivityTimeRangeEnum, teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/team/activity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (timeRange !== undefined) {
                localVarQueryParameter['timeRange'] = timeRange;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamActivityDataApi - functional programming interface
 * @export
 */
export const TeamActivityDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamActivityDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns team member activity including logins, assignments, and productivity. 
         * @summary Get team member activity metrics
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetTeamActivityTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamActivity(startDate?: string, endDate?: string, timeRange?: GetTeamActivityTimeRangeEnum, teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTeamActivity200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamActivity(startDate, endDate, timeRange, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamActivityDataApi.getTeamActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamActivityDataApi - factory interface
 * @export
 */
export const TeamActivityDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamActivityDataApiFp(configuration)
    return {
        /**
         * Returns team member activity including logins, assignments, and productivity. 
         * @summary Get team member activity metrics
         * @param {TeamActivityDataApiGetTeamActivityRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamActivity(requestParameters: TeamActivityDataApiGetTeamActivityRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetTeamActivity200Response> {
            return localVarFp.getTeamActivity(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getTeamActivity operation in TeamActivityDataApi.
 * @export
 * @interface TeamActivityDataApiGetTeamActivityRequest
 */
export interface TeamActivityDataApiGetTeamActivityRequest {
    /**
     * Start date for the query range (inclusive)
     * @type {string}
     * @memberof TeamActivityDataApiGetTeamActivity
     */
    readonly startDate?: string

    /**
     * End date for the query range (inclusive)
     * @type {string}
     * @memberof TeamActivityDataApiGetTeamActivity
     */
    readonly endDate?: string

    /**
     * Preset time range (alternative to startDate/endDate)
     * @type {'7d' | '30d' | '90d'}
     * @memberof TeamActivityDataApiGetTeamActivity
     */
    readonly timeRange?: GetTeamActivityTimeRangeEnum

    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof TeamActivityDataApiGetTeamActivity
     */
    readonly teamId?: string
}

/**
 * TeamActivityDataApi - object-oriented interface
 * @export
 * @class TeamActivityDataApi
 * @extends {BaseAPI}
 */
export class TeamActivityDataApi extends BaseAPI {
    /**
     * Returns team member activity including logins, assignments, and productivity. 
     * @summary Get team member activity metrics
     * @param {TeamActivityDataApiGetTeamActivityRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamActivityDataApi
     */
    public getTeamActivity(requestParameters: TeamActivityDataApiGetTeamActivityRequest = {}, options?: RawAxiosRequestConfig) {
        return TeamActivityDataApiFp(this.configuration).getTeamActivity(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetTeamActivityTimeRangeEnum = {
    7d: '7d',
    30d: '30d',
    90d: '90d'
} as const;
export type GetTeamActivityTimeRangeEnum = typeof GetTeamActivityTimeRangeEnum[keyof typeof GetTeamActivityTimeRangeEnum];


/**
 * UsersActiveDataApi - axios parameter creator
 * @export
 */
export const UsersActiveDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns active users count for various time periods (DAU, WAU, MAU). Users are considered active if they sent at least one message. 
         * @summary Get active users metrics
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetActiveUsersTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveUsers: async (startDate?: string, endDate?: string, timeRange?: GetActiveUsersTimeRangeEnum, teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (timeRange !== undefined) {
                localVarQueryParameter['timeRange'] = timeRange;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersActiveDataApi - functional programming interface
 * @export
 */
export const UsersActiveDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersActiveDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns active users count for various time periods (DAU, WAU, MAU). Users are considered active if they sent at least one message. 
         * @summary Get active users metrics
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {GetActiveUsersTimeRangeEnum} [timeRange] Preset time range (alternative to startDate/endDate)
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveUsers(startDate?: string, endDate?: string, timeRange?: GetActiveUsersTimeRangeEnum, teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetActiveUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveUsers(startDate, endDate, timeRange, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersActiveDataApi.getActiveUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersActiveDataApi - factory interface
 * @export
 */
export const UsersActiveDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersActiveDataApiFp(configuration)
    return {
        /**
         * Returns active users count for various time periods (DAU, WAU, MAU). Users are considered active if they sent at least one message. 
         * @summary Get active users metrics
         * @param {UsersActiveDataApiGetActiveUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveUsers(requestParameters: UsersActiveDataApiGetActiveUsersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetActiveUsers200Response> {
            return localVarFp.getActiveUsers(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getActiveUsers operation in UsersActiveDataApi.
 * @export
 * @interface UsersActiveDataApiGetActiveUsersRequest
 */
export interface UsersActiveDataApiGetActiveUsersRequest {
    /**
     * Start date for the query range (inclusive)
     * @type {string}
     * @memberof UsersActiveDataApiGetActiveUsers
     */
    readonly startDate?: string

    /**
     * End date for the query range (inclusive)
     * @type {string}
     * @memberof UsersActiveDataApiGetActiveUsers
     */
    readonly endDate?: string

    /**
     * Preset time range (alternative to startDate/endDate)
     * @type {'7d' | '30d' | '90d'}
     * @memberof UsersActiveDataApiGetActiveUsers
     */
    readonly timeRange?: GetActiveUsersTimeRangeEnum

    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof UsersActiveDataApiGetActiveUsers
     */
    readonly teamId?: string
}

/**
 * UsersActiveDataApi - object-oriented interface
 * @export
 * @class UsersActiveDataApi
 * @extends {BaseAPI}
 */
export class UsersActiveDataApi extends BaseAPI {
    /**
     * Returns active users count for various time periods (DAU, WAU, MAU). Users are considered active if they sent at least one message. 
     * @summary Get active users metrics
     * @param {UsersActiveDataApiGetActiveUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersActiveDataApi
     */
    public getActiveUsers(requestParameters: UsersActiveDataApiGetActiveUsersRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersActiveDataApiFp(this.configuration).getActiveUsers(requestParameters.startDate, requestParameters.endDate, requestParameters.timeRange, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetActiveUsersTimeRangeEnum = {
    7d: '7d',
    30d: '30d',
    90d: '90d'
} as const;
export type GetActiveUsersTimeRangeEnum = typeof GetActiveUsersTimeRangeEnum[keyof typeof GetActiveUsersTimeRangeEnum];


/**
 * UsersActivitySegmentsApi - axios parameter creator
 * @export
 */
export const UsersActivitySegmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns users segmented by activity timeline: active today,  inactive 1-3 days, 3-7 days, 7-15 days, and over 15 days. 
         * @summary Get user activity segments
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSegments: async (startDate?: string, endDate?: string, teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/segments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersActivitySegmentsApi - functional programming interface
 * @export
 */
export const UsersActivitySegmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersActivitySegmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns users segmented by activity timeline: active today,  inactive 1-3 days, 3-7 days, 7-15 days, and over 15 days. 
         * @summary Get user activity segments
         * @param {string} [startDate] Start date for the query range (inclusive)
         * @param {string} [endDate] End date for the query range (inclusive)
         * @param {string} [teamId] Filter by specific team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSegments(startDate?: string, endDate?: string, teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserSegments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSegments(startDate, endDate, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersActivitySegmentsApi.getUserSegments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersActivitySegmentsApi - factory interface
 * @export
 */
export const UsersActivitySegmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersActivitySegmentsApiFp(configuration)
    return {
        /**
         * Returns users segmented by activity timeline: active today,  inactive 1-3 days, 3-7 days, 7-15 days, and over 15 days. 
         * @summary Get user activity segments
         * @param {UsersActivitySegmentsApiGetUserSegmentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSegments(requestParameters: UsersActivitySegmentsApiGetUserSegmentsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetUserSegments200Response> {
            return localVarFp.getUserSegments(requestParameters.startDate, requestParameters.endDate, requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getUserSegments operation in UsersActivitySegmentsApi.
 * @export
 * @interface UsersActivitySegmentsApiGetUserSegmentsRequest
 */
export interface UsersActivitySegmentsApiGetUserSegmentsRequest {
    /**
     * Start date for the query range (inclusive)
     * @type {string}
     * @memberof UsersActivitySegmentsApiGetUserSegments
     */
    readonly startDate?: string

    /**
     * End date for the query range (inclusive)
     * @type {string}
     * @memberof UsersActivitySegmentsApiGetUserSegments
     */
    readonly endDate?: string

    /**
     * Filter by specific team ID
     * @type {string}
     * @memberof UsersActivitySegmentsApiGetUserSegments
     */
    readonly teamId?: string
}

/**
 * UsersActivitySegmentsApi - object-oriented interface
 * @export
 * @class UsersActivitySegmentsApi
 * @extends {BaseAPI}
 */
export class UsersActivitySegmentsApi extends BaseAPI {
    /**
     * Returns users segmented by activity timeline: active today,  inactive 1-3 days, 3-7 days, 7-15 days, and over 15 days. 
     * @summary Get user activity segments
     * @param {UsersActivitySegmentsApiGetUserSegmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersActivitySegmentsApi
     */
    public getUserSegments(requestParameters: UsersActivitySegmentsApiGetUserSegmentsRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersActivitySegmentsApiFp(this.configuration).getUserSegments(requestParameters.startDate, requestParameters.endDate, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersCountDataApi - axios parameter creator
 * @export
 */
export const UsersCountDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint for service-auth to POST user count data.  Data is aggregated into hourly buckets. 
         * @summary Receive user count from service-auth
         * @param {UserCountPost} userCountPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserCount: async (userCountPost: UserCountPost, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCountPost' is not null or undefined
            assertParamExists('postUserCount', 'userCountPost', userCountPost)
            const localVarPath = `/users/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCountPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersCountDataApi - functional programming interface
 * @export
 */
export const UsersCountDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersCountDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint for service-auth to POST user count data.  Data is aggregated into hourly buckets. 
         * @summary Receive user count from service-auth
         * @param {UserCountPost} userCountPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserCount(userCountPost: UserCountPost, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserCount(userCountPost, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersCountDataApi.postUserCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersCountDataApi - factory interface
 * @export
 */
export const UsersCountDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersCountDataApiFp(configuration)
    return {
        /**
         * Endpoint for service-auth to POST user count data.  Data is aggregated into hourly buckets. 
         * @summary Receive user count from service-auth
         * @param {UsersCountDataApiPostUserCountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserCount(requestParameters: UsersCountDataApiPostUserCountRequest, options?: RawAxiosRequestConfig): AxiosPromise<CountPostResponse> {
            return localVarFp.postUserCount(requestParameters.userCountPost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for postUserCount operation in UsersCountDataApi.
 * @export
 * @interface UsersCountDataApiPostUserCountRequest
 */
export interface UsersCountDataApiPostUserCountRequest {
    /**
     * 
     * @type {UserCountPost}
     * @memberof UsersCountDataApiPostUserCount
     */
    readonly userCountPost: UserCountPost
}

/**
 * UsersCountDataApi - object-oriented interface
 * @export
 * @class UsersCountDataApi
 * @extends {BaseAPI}
 */
export class UsersCountDataApi extends BaseAPI {
    /**
     * Endpoint for service-auth to POST user count data.  Data is aggregated into hourly buckets. 
     * @summary Receive user count from service-auth
     * @param {UsersCountDataApiPostUserCountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersCountDataApi
     */
    public postUserCount(requestParameters: UsersCountDataApiPostUserCountRequest, options?: RawAxiosRequestConfig) {
        return UsersCountDataApiFp(this.configuration).postUserCount(requestParameters.userCountPost, options).then((request) => request(this.axios, this.basePath));
    }
}



