const BASE_PATH = "https://api.chatdaddy.tech/auth".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Auth & Teams Service
 * Manage Users & Teams
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@chatdaddy.tech
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from '../base';

/**
 * 
 * @export
 * @interface AccountNotificationPreference
 */
export interface AccountNotificationPreference {
    /**
     * 
     * @type {Array<NotificationDestination>}
     * @memberof AccountNotificationPreference
     */
    'destinations': Array<NotificationDestination>;
    /**
     * List of accounts to receive notifications for. If empty, all accounts will be notified.
     * @type {Array<AccountNotificationPreferenceAccountsInner>}
     * @memberof AccountNotificationPreference
     */
    'accounts'?: Array<AccountNotificationPreferenceAccountsInner>;
}
/**
 * 
 * @export
 * @interface AccountNotificationPreferenceAccountsInner
 */
export interface AccountNotificationPreferenceAccountsInner {
    /**
     * 
     * @type {string}
     * @memberof AccountNotificationPreferenceAccountsInner
     */
    'id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ActorAutomationType = {
    KeywordReply: 'keyword-reply',
    DefaultReply: 'default-reply',
    Campaigns: 'campaigns',
    Notifications: 'notifications',
    Bot: 'bot',
    AiChatbot: 'ai-chatbot',
    Trigger: 'trigger'
} as const;

export type ActorAutomationType = typeof ActorAutomationType[keyof typeof ActorAutomationType];


/**
 * Context about the actor of a particular action
 * @export
 * @interface ActorMetadata
 */
export interface ActorMetadata {
    /**
     * 
     * @type {ActorAutomationType}
     * @memberof ActorMetadata
     */
    'type': ActorAutomationType;
    /**
     * ID of the object that sent the message. For example, the campaign ID or keyword reply ID. Separate sub-objects with a `/`. For example, to specify the action of a bot -- use `bot_id/action_id`
     * @type {string}
     * @memberof ActorMetadata
     */
    'objectId': string;
    /**
     * Name of the object that sent the message. For example, the campaign name or keyword reply name
     * @type {string}
     * @memberof ActorMetadata
     */
    'objectName'?: string;
}


/**
 * 
 * @export
 * @interface AnnouncementButtonAction
 */
export interface AnnouncementButtonAction {
    /**
     * Text displayed on the button
     * @type {string}
     * @memberof AnnouncementButtonAction
     */
    'text': string;
    /**
     * URL to navigate to when the button is clicked
     * @type {string}
     * @memberof AnnouncementButtonAction
     */
    'url'?: string;
    /**
     * Indicates if the URL should be opened in a new tab/window
     * @type {boolean}
     * @memberof AnnouncementButtonAction
     */
    'openInNewTab'?: boolean;
}
/**
 * 
 * @export
 * @interface AnnouncementMetadata
 */
export interface AnnouncementMetadata {
    /**
     * ID of the Announcement
     * @type {string}
     * @memberof AnnouncementMetadata
     */
    'id'?: string;
    /**
     * The partnership the announcement belongs to
     * @type {string}
     * @memberof AnnouncementMetadata
     */
    'partnership'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnouncementMetadata
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnouncementMetadata
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {AnnouncementUser}
     * @memberof AnnouncementMetadata
     */
    'createdBy'?: AnnouncementUser;
    /**
     * 
     * @type {AnnouncementUser}
     * @memberof AnnouncementMetadata
     */
    'updatedBy'?: AnnouncementUser;
    /**
     * Category of the Announcement
     * @type {string}
     * @memberof AnnouncementMetadata
     */
    'category': string;
    /**
     * Title of the Announcement
     * @type {string}
     * @memberof AnnouncementMetadata
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof AnnouncementMetadata
     */
    'publishedAt': string;
    /**
     * 
     * @type {string}
     * @memberof AnnouncementMetadata
     */
    'expiresAt'?: string | null;
    /**
     * 
     * @type {Array<AnnouncementButtonAction>}
     * @memberof AnnouncementMetadata
     */
    'actionButtons'?: Array<AnnouncementButtonAction>;
    /**
     * URL of the cover image for the announcement
     * @type {string}
     * @memberof AnnouncementMetadata
     */
    'coverImage'?: string | null;
    /**
     * Announcement body as markdown
     * @type {string}
     * @memberof AnnouncementMetadata
     */
    'markdownText': string;
    /**
     * Specifies how often the announcement should be repeated
     * @type {string}
     * @memberof AnnouncementMetadata
     */
    'repeatOption'?: AnnouncementMetadataRepeatOptionEnum | null;
    /**
     * array of string URLs for URL filtering.
     * @type {Array<string>}
     * @memberof AnnouncementMetadata
     */
    'filteredUrls'?: Array<string> | null;
}

export const AnnouncementMetadataRepeatOptionEnum = {
    EveryVisit: 'every-visit',
    OncePerDay: 'once-per-day',
    OncePerWeek: 'once-per-week'
} as const;

export type AnnouncementMetadataRepeatOptionEnum = typeof AnnouncementMetadataRepeatOptionEnum[keyof typeof AnnouncementMetadataRepeatOptionEnum];

/**
 * 
 * @export
 * @interface AnnouncementPatch
 */
export interface AnnouncementPatch {
    /**
     * 
     * @type {string}
     * @memberof AnnouncementPatch
     */
    'partnership'?: string | null;
    /**
     * Category of the Announcement
     * @type {string}
     * @memberof AnnouncementPatch
     */
    'category'?: string;
    /**
     * Title of the Announcement
     * @type {string}
     * @memberof AnnouncementPatch
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnouncementPatch
     */
    'publishedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnouncementPatch
     */
    'expiresAt'?: string | null;
    /**
     * 
     * @type {Array<AnnouncementButtonAction>}
     * @memberof AnnouncementPatch
     */
    'actionButtons'?: Array<AnnouncementButtonAction>;
    /**
     * URL of the cover image for the announcement
     * @type {string}
     * @memberof AnnouncementPatch
     */
    'coverImage'?: string | null;
    /**
     * Announcement body as markdown
     * @type {string}
     * @memberof AnnouncementPatch
     */
    'markdownText'?: string;
    /**
     * Specifies how often the announcement should be repeated
     * @type {string}
     * @memberof AnnouncementPatch
     */
    'repeatOption'?: AnnouncementPatchRepeatOptionEnum | null;
    /**
     * array of string URLs for URL filtering.
     * @type {Array<string>}
     * @memberof AnnouncementPatch
     */
    'filteredUrls'?: Array<string> | null;
}

export const AnnouncementPatchRepeatOptionEnum = {
    EveryVisit: 'every-visit',
    OncePerDay: 'once-per-day',
    OncePerWeek: 'once-per-week'
} as const;

export type AnnouncementPatchRepeatOptionEnum = typeof AnnouncementPatchRepeatOptionEnum[keyof typeof AnnouncementPatchRepeatOptionEnum];

/**
 * 
 * @export
 * @interface AnnouncementRetrievalResponse
 */
export interface AnnouncementRetrievalResponse {
    /**
     * 
     * @type {Array<AnnouncementMetadata>}
     * @memberof AnnouncementRetrievalResponse
     */
    'announcements': Array<AnnouncementMetadata>;
    /**
     * Cursor to fetch next page of announcements
     * @type {string}
     * @memberof AnnouncementRetrievalResponse
     */
    'cursor'?: string;
    /**
     * total announcements present with these filters. Only returned if returnTotalCount is true
     * @type {number}
     * @memberof AnnouncementRetrievalResponse
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface AnnouncementUser
 */
export interface AnnouncementUser {
    /**
     * 
     * @type {string}
     * @memberof AnnouncementUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AnnouncementUser
     */
    'fullName': string;
}
/**
 * 
 * @export
 * @interface ApiToken
 */
export interface ApiToken {
    /**
     * The reason for the token
     * @type {string}
     * @memberof ApiToken
     */
    'reason': string;
    /**
     * 
     * @type {string}
     * @memberof ApiToken
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ApiToken
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApiToken
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiToken
     */
    'teamId': string;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof ApiToken
     */
    'scopes': Array<Scope>;
}
/**
 * 
 * @export
 * @interface ApiTokenGet200Response
 */
export interface ApiTokenGet200Response {
    /**
     * 
     * @type {Array<ApiToken>}
     * @memberof ApiTokenGet200Response
     */
    'tokens': Array<ApiToken>;
}
/**
 * 
 * @export
 * @interface ApiTokenPostRequest
 */
export interface ApiTokenPostRequest {
    /**
     * The reason for generating the token
     * @type {string}
     * @memberof ApiTokenPostRequest
     */
    'reason': string;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof ApiTokenPostRequest
     */
    'scopes': Array<Scope>;
}
/**
 * 
 * @export
 * @interface ApiTokenValidatePostRequest
 */
export interface ApiTokenValidatePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiTokenValidatePostRequest
     */
    'token': string;
}
/**
 * @type AuthRequest
 * @export
 */
export type AuthRequest = PasswordAuthRequest | RefreshTokenLoginRequest;

/**
 * Login with Boutir
 * @export
 * @interface BoutirTokenRequest
 */
export interface BoutirTokenRequest {
    /**
     * Id of the invite link to use
     * @type {string}
     * @memberof BoutirTokenRequest
     */
    'inviteLinkId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BoutirTokenRequest
     */
    'type': BoutirTokenRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BoutirTokenRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof BoutirTokenRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof BoutirTokenRequest
     */
    'referralCode'?: string;
    /**
     * The variant of the Firebase token to use. If not specified, will default to chatdaddy. 
     * @type {string}
     * @memberof BoutirTokenRequest
     */
    'variant'?: BoutirTokenRequestVariantEnum;
}

export const BoutirTokenRequestTypeEnum = {
    Boutir: 'boutir'
} as const;

export type BoutirTokenRequestTypeEnum = typeof BoutirTokenRequestTypeEnum[keyof typeof BoutirTokenRequestTypeEnum];
export const BoutirTokenRequestVariantEnum = {
    Chatdaddy: 'chatdaddy',
    Lite: 'lite'
} as const;

export type BoutirTokenRequestVariantEnum = typeof BoutirTokenRequestVariantEnum[keyof typeof BoutirTokenRequestVariantEnum];

/**
 * @type EitherRoleOrScopes
 * @export
 */
export type EitherRoleOrScopes = EitherRoleOrScopesOneOf | EitherRoleOrScopesOneOf1;

/**
 * 
 * @export
 * @interface EitherRoleOrScopesOneOf
 */
export interface EitherRoleOrScopesOneOf {
    /**
     * 
     * @type {Array<Scope>}
     * @memberof EitherRoleOrScopesOneOf
     */
    'scopes': Array<Scope>;
}
/**
 * 
 * @export
 * @interface EitherRoleOrScopesOneOf1
 */
export interface EitherRoleOrScopesOneOf1 {
    /**
     * 
     * @type {TeamMemberRole}
     * @memberof EitherRoleOrScopesOneOf1
     */
    'role': TeamMemberRole;
}


/**
 * 
 * @export
 * @interface EmailOtpRequest
 */
export interface EmailOtpRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailOtpRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof EmailOtpRequest
     */
    'captchaToken'?: string;
}
/**
 * 
 * @export
 * @interface ExternalTokenPostResponse
 */
export interface ExternalTokenPostResponse {
    /**
     * 
     * @type {string}
     * @memberof ExternalTokenPostResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTokenPostResponse
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalTokenPostResponse
     */
    'refresh_token_expiry'?: string;
    /**
     * Was the user just created
     * @type {boolean}
     * @memberof ExternalTokenPostResponse
     */
    'created'?: boolean;
}
/**
 * @type ExternalTokenRequest
 * @export
 */
export type ExternalTokenRequest = BoutirTokenRequest | FirebaseTokenRequest;

/**
 * Login with Firebase
 * @export
 * @interface FirebaseTokenRequest
 */
export interface FirebaseTokenRequest {
    /**
     * Id of the invite link to use
     * @type {string}
     * @memberof FirebaseTokenRequest
     */
    'inviteLinkId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FirebaseTokenRequest
     */
    'type': FirebaseTokenRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FirebaseTokenRequest
     */
    'idToken': string;
    /**
     * 
     * @type {string}
     * @memberof FirebaseTokenRequest
     */
    'referralCode'?: string;
    /**
     * The variant of the Firebase token to use. If not specified, will default to chatdaddy. 
     * @type {string}
     * @memberof FirebaseTokenRequest
     */
    'variant'?: FirebaseTokenRequestVariantEnum;
}

export const FirebaseTokenRequestTypeEnum = {
    Firebase: 'firebase'
} as const;

export type FirebaseTokenRequestTypeEnum = typeof FirebaseTokenRequestTypeEnum[keyof typeof FirebaseTokenRequestTypeEnum];
export const FirebaseTokenRequestVariantEnum = {
    Chatdaddy: 'chatdaddy',
    Lite: 'lite'
} as const;

export type FirebaseTokenRequestVariantEnum = typeof FirebaseTokenRequestVariantEnum[keyof typeof FirebaseTokenRequestVariantEnum];

/**
 * 
 * @export
 * @interface GetUsersCount200Response
 */
export interface GetUsersCount200Response {
    /**
     * Total number of users
     * @type {number}
     * @memberof GetUsersCount200Response
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface InboxFilterData
 */
export interface InboxFilterData {
    /**
     * 
     * @type {string}
     * @memberof InboxFilterData
     */
    'name': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof InboxFilterData
     */
    'filters': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface InboxFilterName
 */
export interface InboxFilterName {
    /**
     * 
     * @type {string}
     * @memberof InboxFilterName
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface InviteLink
 */
export interface InviteLink {
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    'id': string;
    /**
     * Unique identifier for a team
     * @type {string}
     * @memberof InviteLink
     */
    'teamId': string;
    /**
     * User ID of the person who created the link
     * @type {string}
     * @memberof InviteLink
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    'expiresAt': string;
    /**
     * The scopes allowed for the invite link
     * @type {Array<Scope>}
     * @memberof InviteLink
     */
    'scopes': Array<Scope>;
    /**
     * 
     * @type {TeamMemberRole}
     * @memberof InviteLink
     */
    'role'?: TeamMemberRole;
    /**
     * 
     * @type {Team}
     * @memberof InviteLink
     */
    'team'?: Team;
}


/**
 * 
 * @export
 * @interface JWT
 */
export interface JWT {
    /**
     * Binary representation of the scope array
     * @type {string}
     * @memberof JWT
     */
    'scope': string;
    /**
     * 
     * @type {number}
     * @memberof JWT
     */
    'exp': number;
    /**
     * 
     * @type {number}
     * @memberof JWT
     */
    'iat': number;
    /**
     * 
     * @type {JWTUser}
     * @memberof JWT
     */
    'user': JWTUser;
}
/**
 * 
 * @export
 * @interface JWTUser
 */
export interface JWTUser {
    /**
     * Unique identifier for a user
     * @type {string}
     * @memberof JWTUser
     */
    'id': string;
    /**
     * Unique identifier for a team
     * @type {string}
     * @memberof JWTUser
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof JWTUser
     */
    'fullName'?: string;
    /**
     * 
     * @type {number}
     * @memberof JWTUser
     */
    'phoneNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof JWTUser
     */
    'emailAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof JWTUser
     */
    'partnership'?: string;
    /**
     * Partner admin string if the user is a partner admin
     * @type {string}
     * @memberof JWTUser
     */
    'partnerAdmin'?: string;
    /**
     * 
     * @type {ActorMetadata}
     * @memberof JWTUser
     */
    'metadata'?: ActorMetadata;
}
/**
 * 
 * @export
 * @interface NewMessageNotificationPreference
 */
export interface NewMessageNotificationPreference {
    /**
     * 
     * @type {Array<string>}
     * @memberof NewMessageNotificationPreference
     */
    'destinations': Array<NewMessageNotificationPreferenceDestinationsEnum>;
    /**
     * 
     * @type {NewMessageNotificationType}
     * @memberof NewMessageNotificationPreference
     */
    'defaultType'?: NewMessageNotificationType;
    /**
     * List of accounts to receive notifications for. If empty, all accounts will be notified based on the preference set in \"\"
     * @type {Array<NewMessageNotificationPreferenceAccountsInner>}
     * @memberof NewMessageNotificationPreference
     */
    'accounts'?: Array<NewMessageNotificationPreferenceAccountsInner>;
}

export const NewMessageNotificationPreferenceDestinationsEnum = {
    Push: 'push'
} as const;

export type NewMessageNotificationPreferenceDestinationsEnum = typeof NewMessageNotificationPreferenceDestinationsEnum[keyof typeof NewMessageNotificationPreferenceDestinationsEnum];

/**
 * 
 * @export
 * @interface NewMessageNotificationPreferenceAccountsInner
 */
export interface NewMessageNotificationPreferenceAccountsInner {
    /**
     * 
     * @type {string}
     * @memberof NewMessageNotificationPreferenceAccountsInner
     */
    'id': string;
    /**
     * 
     * @type {NewMessageNotificationType}
     * @memberof NewMessageNotificationPreferenceAccountsInner
     */
    'type': NewMessageNotificationType;
}
/**
 * @type NewMessageNotificationType
 * @export
 */
export type NewMessageNotificationType = Array<string> | string;

/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationDestination = {
    Push: 'push',
    Email: 'email',
    Whatsapp: 'whatsapp'
} as const;

export type NotificationDestination = typeof NotificationDestination[keyof typeof NotificationDestination];


/**
 * 
 * @export
 * @interface NotificationMiscData
 */
export interface NotificationMiscData {
    /**
     * The path to open when the notification is clicked
     * @type {string}
     * @memberof NotificationMiscData
     */
    'path'?: string;
    /**
     * The image to show in the notification
     * @type {string}
     * @memberof NotificationMiscData
     */
    'imgUrl'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NotificationMiscData
     */
    'context'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface NotificationPreferences
 */
export interface NotificationPreferences {
    /**
     * 
     * @type {AccountNotificationPreference}
     * @memberof NotificationPreferences
     */
    'accountDisconnected'?: AccountNotificationPreference;
    /**
     * 
     * @type {SimpleNotificationPreference}
     * @memberof NotificationPreferences
     */
    'contactAssignedToMe'?: SimpleNotificationPreference;
    /**
     * 
     * @type {NewMessageNotificationPreference}
     * @memberof NotificationPreferences
     */
    'newMessage'?: NewMessageNotificationPreference;
    /**
     * 
     * @type {SimpleNotificationPreference}
     * @memberof NotificationPreferences
     */
    'teamMemberAdded'?: SimpleNotificationPreference;
    /**
     * 
     * @type {SimpleNotificationPreference}
     * @memberof NotificationPreferences
     */
    'trackingAdded'?: SimpleNotificationPreference;
    /**
     * 
     * @type {SimpleNotificationPreference}
     * @memberof NotificationPreferences
     */
    'trackingErrored'?: SimpleNotificationPreference;
    /**
     * 
     * @type {AccountNotificationPreference}
     * @memberof NotificationPreferences
     */
    'botExternalTemplateStatusUpdated'?: AccountNotificationPreference;
    /**
     * 
     * @type {SimpleNotificationPreference}
     * @memberof NotificationPreferences
     */
    'actionExecute'?: SimpleNotificationPreference;
    /**
     * 
     * @type {SimpleNotificationPreference}
     * @memberof NotificationPreferences
     */
    'noteMentionsMe'?: SimpleNotificationPreference;
    /**
     * 
     * @type {SimpleNotificationPreference}
     * @memberof NotificationPreferences
     */
    'payments'?: SimpleNotificationPreference;
    /**
     * 
     * @type {SimpleNotificationPreference}
     * @memberof NotificationPreferences
     */
    'creditsLevelNotification'?: SimpleNotificationPreference;
}
/**
 * @type NotificationResult
 * @export
 */
export type NotificationResult = boolean | string;

/**
 * Deprecated. Use notificationPreferences instead
 * @export
 * @interface NotifyModel
 */
export interface NotifyModel {
    /**
     * 
     * @type {boolean}
     * @memberof NotifyModel
     */
    'whatsapp'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotifyModel
     */
    'email'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NotifyModel
     */
    'desktop'?: boolean;
}
/**
 * 
 * @export
 * @interface NotifyRequestWithContent
 */
export interface NotifyRequestWithContent {
    /**
     * 
     * @type {string}
     * @memberof NotifyRequestWithContent
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof NotifyRequestWithContent
     */
    'content': string;
    /**
     * 
     * @type {NotifyRequestWithContentOverrides}
     * @memberof NotifyRequestWithContent
     */
    'overrides'?: NotifyRequestWithContentOverrides;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NotifyRequestWithContent
     */
    'parameters'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface NotifyRequestWithContentOverrides
 */
export interface NotifyRequestWithContentOverrides {
    /**
     * 
     * @type {NotifyRequestWithContentOverridesWhatsapp}
     * @memberof NotifyRequestWithContentOverrides
     */
    'whatsapp'?: NotifyRequestWithContentOverridesWhatsapp;
}
/**
 * 
 * @export
 * @interface NotifyRequestWithContentOverridesWhatsapp
 */
export interface NotifyRequestWithContentOverridesWhatsapp {
    /**
     * 
     * @type {string}
     * @memberof NotifyRequestWithContentOverridesWhatsapp
     */
    'botId': string;
}
/**
 * 
 * @export
 * @interface OTP
 */
export interface OTP {
    /**
     * 
     * @type {number}
     * @memberof OTP
     */
    'phoneNumber': number;
    /**
     * 
     * @type {number}
     * @memberof OTP
     */
    'otp'?: number;
    /**
     * 
     * @type {string}
     * @memberof OTP
     */
    'expiresAt': string;
    /**
     * 
     * @type {number}
     * @memberof OTP
     */
    'resendsLeft': number;
}
/**
 * 
 * @export
 * @interface OnboardingStep
 */
export interface OnboardingStep {
    /**
     * 
     * @type {OnboardingStepID}
     * @memberof OnboardingStep
     */
    'id': OnboardingStepID;
    /**
     * 
     * @type {string}
     * @memberof OnboardingStep
     */
    'doneAt': string;
    /**
     * ID of the user that completed the step
     * @type {string}
     * @memberof OnboardingStep
     */
    'doneBy': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const OnboardingStepID = {
    ConnectedWa: 'connectedWa',
    SentMessage: 'sentMessage',
    UsedMobileVersion: 'usedMobileVersion',
    InvitedTeamMember: 'invitedTeamMember',
    CreatedNote: 'createdNote',
    CreatedTag: 'createdTag',
    CreatedMessageFlow: 'createdMessageFlow',
    SentMessageFlowByShortcut: 'sentMessageFlowByShortcut',
    AssignedChatToTeamMember: 'assignedChatToTeamMember',
    ScheduledAMessage: 'scheduledAMessage',
    CreatedMessageFlowWithButtons: 'createdMessageFlowWithButtons',
    SentMessageFlowWithButtons: 'sentMessageFlowWithButtons',
    AutoTagOrAssignWithMessageFlow: 'autoTagOrAssignWithMessageFlow',
    CreatedFirstBroadcast: 'createdFirstBroadcast',
    ScheduledFirstBroadcast: 'scheduledFirstBroadcast',
    ToggleOfflineBotOn: 'toggleOfflineBotOn',
    CreatedFirstKeywordBot: 'createdFirstKeywordBot',
    ConnectFirstIntegration: 'connectFirstIntegration',
    ImportedContacts: 'importedContacts',
    AdddedACustomFieldToContact: 'adddedACustomFieldToContact'
} as const;

export type OnboardingStepID = typeof OnboardingStepID[keyof typeof OnboardingStepID];


/**
 * 
 * @export
 * @interface OptionalWidgetButtonParams
 */
export interface OptionalWidgetButtonParams {
    /**
     * 
     * @type {string}
     * @memberof OptionalWidgetButtonParams
     */
    'buttonIcon'?: OptionalWidgetButtonParamsButtonIconEnum;
    /**
     * 
     * @type {string}
     * @memberof OptionalWidgetButtonParams
     */
    'buttonText'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionalWidgetButtonParams
     */
    'buttonBackgroundColor'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionalWidgetButtonParams
     */
    'buttonTextAndIconColor'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionalWidgetButtonParams
     */
    'buttonPosition'?: OptionalWidgetButtonParamsButtonPositionEnum;
}

export const OptionalWidgetButtonParamsButtonIconEnum = {
    Wa: 'wa',
    Headset: 'headset',
    Message: 'message',
    ChatBubble: 'chatBubble'
} as const;

export type OptionalWidgetButtonParamsButtonIconEnum = typeof OptionalWidgetButtonParamsButtonIconEnum[keyof typeof OptionalWidgetButtonParamsButtonIconEnum];
export const OptionalWidgetButtonParamsButtonPositionEnum = {
    Left: 'left',
    Right: 'right'
} as const;

export type OptionalWidgetButtonParamsButtonPositionEnum = typeof OptionalWidgetButtonParamsButtonPositionEnum[keyof typeof OptionalWidgetButtonParamsButtonPositionEnum];

/**
 * 
 * @export
 * @interface OptionalWidgetCTAParams
 */
export interface OptionalWidgetCTAParams {
    /**
     * 
     * @type {string}
     * @memberof OptionalWidgetCTAParams
     */
    'widgetCTAButtonText'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionalWidgetCTAParams
     */
    'widgetCTAContentColor'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionalWidgetCTAParams
     */
    'widgetCTABackgroundColor'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionalWidgetCTAParams
     */
    'CTALink'?: string;
}
/**
 * 
 * @export
 * @interface OptionalWidgetConfigParams
 */
export interface OptionalWidgetConfigParams {
    /**
     * 
     * @type {OptionalWidgetButtonParams}
     * @memberof OptionalWidgetConfigParams
     */
    'widgetButtonParams'?: OptionalWidgetButtonParams;
    /**
     * 
     * @type {OptionalWidgetDialogParams}
     * @memberof OptionalWidgetConfigParams
     */
    'widgetDialogParams'?: OptionalWidgetDialogParams;
    /**
     * 
     * @type {OptionalWidgetCTAParams}
     * @memberof OptionalWidgetConfigParams
     */
    'widgetCTAParams'?: OptionalWidgetCTAParams;
}
/**
 * 
 * @export
 * @interface OptionalWidgetDialogParams
 */
export interface OptionalWidgetDialogParams {
    /**
     * 
     * @type {string}
     * @memberof OptionalWidgetDialogParams
     */
    'widgetBrandName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionalWidgetDialogParams
     */
    'widgetHeaderCaption'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionalWidgetDialogParams
     */
    'widgetBrandIconUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionalWidgetDialogParams
     */
    'widgetWelcomeMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionalWidgetDialogParams
     */
    'widgetPrefilledTextMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionalWidgetDialogParams
     */
    'widgetHeaderContentColor'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionalWidgetDialogParams
     */
    'widgetHeaderBackgroundColor'?: string;
}
/**
 * 
 * @export
 * @interface OtpPostRequest
 */
export interface OtpPostRequest {
    /**
     * 
     * @type {string}
     * @memberof OtpPostRequest
     */
    'phoneNumber': string;
    /**
     * Specify the Recaptcha token
     * @type {string}
     * @memberof OtpPostRequest
     */
    'captchaToken'?: string;
}
/**
 * 
 * @export
 * @interface PartnerAdminGet200Response
 */
export interface PartnerAdminGet200Response {
    /**
     * 
     * @type {Array<PartnerAdminGet200ResponseTeamsInner>}
     * @memberof PartnerAdminGet200Response
     */
    'teams': Array<PartnerAdminGet200ResponseTeamsInner>;
}
/**
 * 
 * @export
 * @interface PartnerAdminGet200ResponseTeamsInner
 */
export interface PartnerAdminGet200ResponseTeamsInner {
    /**
     * 
     * @type {string}
     * @memberof PartnerAdminGet200ResponseTeamsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PartnerAdminGet200ResponseTeamsInner
     */
    'partnerAdmin': string;
}
/**
 * 
 * @export
 * @interface PartnerTeamPatchRequest
 */
export interface PartnerTeamPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof PartnerTeamPatchRequest
     */
    'partnerAdmin': string | null;
}
/**
 * 
 * @export
 * @interface PasswordAuthRequest
 */
export interface PasswordAuthRequest {
    /**
     * 
     * @type {number}
     * @memberof PasswordAuthRequest
     */
    'phoneNumber': number;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordAuthRequest
     */
    'returnRefreshToken'?: boolean;
    /**
     * plaintext/base64Sha256 of the password, depending on the passwordEncoding
     * @type {string}
     * @memberof PasswordAuthRequest
     */
    'password': string;
    /**
     * 
     * @type {PasswordEncoding}
     * @memberof PasswordAuthRequest
     */
    'passwordEncoding'?: PasswordEncoding;
    /**
     * The team ID to generate the token for, lastUsedTeam will be used otherwise
     * @type {string}
     * @memberof PasswordAuthRequest
     */
    'teamId'?: string;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof PasswordAuthRequest
     */
    'scopes'?: Array<Scope>;
    /**
     * Should logging in with this team ID update the lastUsedTeam for login
     * @type {boolean}
     * @memberof PasswordAuthRequest
     */
    'updateLastUsedTeam'?: boolean;
    /**
     * Force the generation of an access token
     * @type {boolean}
     * @memberof PasswordAuthRequest
     */
    'force'?: boolean;
    /**
     * 
     * @type {ActorMetadata}
     * @memberof PasswordAuthRequest
     */
    'metadata'?: ActorMetadata;
}


/**
 * describe how the password is encoded
 * @export
 * @enum {string}
 */

export const PasswordEncoding = {
    ShaBase64: 'shaBase64',
    Plaintext: 'plaintext'
} as const;

export type PasswordEncoding = typeof PasswordEncoding[keyof typeof PasswordEncoding];


/**
 * A refresh token allows you to generate access tokens to access & update things on ChatDaddy services. A refresh token will expire and become invalidated after 14 days of no activity. 
 * @export
 * @interface RefreshToken
 */
export interface RefreshToken {
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RefreshToken
     */
    'expiresAt': string;
}
/**
 * 
 * @export
 * @interface RefreshTokenLoginRequest
 */
export interface RefreshTokenLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenLoginRequest
     */
    'refreshToken': string;
    /**
     * The team ID to generate the token for, lastUsedTeam will be used otherwise
     * @type {string}
     * @memberof RefreshTokenLoginRequest
     */
    'teamId': string;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof RefreshTokenLoginRequest
     */
    'scopes'?: Array<Scope>;
    /**
     * Should fetching the token of a new team update the lastUsedTeam for login
     * @type {boolean}
     * @memberof RefreshTokenLoginRequest
     */
    'updateLastUsedTeam'?: boolean;
    /**
     * Force the generation of an access token
     * @type {boolean}
     * @memberof RefreshTokenLoginRequest
     */
    'force'?: boolean;
    /**
     * 
     * @type {ActorMetadata}
     * @memberof RefreshTokenLoginRequest
     */
    'metadata'?: ActorMetadata;
}
/**
 * 
 * @export
 * @interface ResetPassword
 */
export interface ResetPassword {
    /**
     * plaintext/base64Sha256 of the password, depending on the passwordEncoding
     * @type {string}
     * @memberof ResetPassword
     */
    'password': string;
    /**
     * 
     * @type {PasswordEncoding}
     * @memberof ResetPassword
     */
    'passwordEncoding'?: PasswordEncoding;
    /**
     * Logs out the user from all devices. If the user is logged in on the device, the user will be logged out.
     * @type {boolean}
     * @memberof ResetPassword
     */
    'logout'?: boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const Scope = {
    ContactsReadAssigned: 'CONTACTS_READ_ASSIGNED',
    ContactsReadAll: 'CONTACTS_READ_ALL',
    ContactsCreate: 'CONTACTS_CREATE',
    ContactsDelete: 'CONTACTS_DELETE',
    ContactsUpdate: 'CONTACTS_UPDATE',
    CampaignsRead: 'CAMPAIGNS_READ',
    CampaignsCreate: 'CAMPAIGNS_CREATE',
    CampaignsDelete: 'CAMPAIGNS_DELETE',
    CampaignsUpdate: 'CAMPAIGNS_UPDATE',
    KeywordRead: 'KEYWORD_READ',
    KeywordCreate: 'KEYWORD_CREATE',
    KeywordDelete: 'KEYWORD_DELETE',
    KeywordUpdate: 'KEYWORD_UPDATE',
    TemplatesRead: 'TEMPLATES_READ',
    TemplatesCreate: 'TEMPLATES_CREATE',
    TemplatesDelete: 'TEMPLATES_DELETE',
    TemplatesUpdate: 'TEMPLATES_UPDATE',
    TagsRead: 'TAGS_READ',
    TagsCreate: 'TAGS_CREATE',
    TagsDelete: 'TAGS_DELETE',
    TokensRead: 'TOKENS_READ',
    TokensDelete: 'TOKENS_DELETE',
    UsersPatch: 'USERS_PATCH',
    ContactsExportButton: 'CONTACTS_EXPORT_BUTTON',
    TeamUpdate: 'TEAM_UPDATE',
    AccountCreate: 'ACCOUNT_CREATE',
    AccountPatch: 'ACCOUNT_PATCH',
    AccountDelete: 'ACCOUNT_DELETE',
    AccountRead: 'ACCOUNT_READ',
    CreateSubUser: 'CREATE_SUB_USER',
    TeamlinkCreate: 'TEAMLINK_CREATE',
    TeammembersUpdate: 'TEAMMEMBERS_UPDATE',
    TeammembersRead: 'TEAMMEMBERS_READ',
    LogoutSubUser: 'LOGOUT_SUB_USER',
    ChatsAccessAll: 'CHATS_ACCESS_ALL',
    ChatsAccessAssigned: 'CHATS_ACCESS_ASSIGNED',
    ChatsDelete: 'CHATS_DELETE',
    MessagesSendToAssigned: 'MESSAGES_SEND_TO_ASSIGNED',
    MessagesSendToAll: 'MESSAGES_SEND_TO_ALL',
    EditNotes: 'EDIT_NOTES',
    MessagesDelete: 'MESSAGES_DELETE',
    GroupsCreate: 'GROUPS_CREATE',
    GroupsUpdate: 'GROUPS_UPDATE',
    CreateNotes: 'CREATE_NOTES',
    ChatdaddyHook: 'CHATDADDY_HOOK',
    NotificationRead: 'NOTIFICATION_READ',
    NotificationCreate: 'NOTIFICATION_CREATE',
    NotificationUpdate: 'NOTIFICATION_UPDATE',
    NotificationDelete: 'NOTIFICATION_DELETE',
    DeleteNotes: 'DELETE_NOTES',
    IntegrationsUpdate: 'INTEGRATIONS_UPDATE',
    AdminPanelAccess: 'ADMIN_PANEL_ACCESS',
    DashboardCreate: 'DASHBOARD_CREATE',
    DashboardDelete: 'DASHBOARD_DELETE',
    PaymentsRead: 'PAYMENTS_READ',
    PaymentsUpdate: 'PAYMENTS_UPDATE',
    WaLiveEvents: 'WA_LIVE_EVENTS',
    PartnerAdminPanelAccess: 'PARTNER_ADMIN_PANEL_ACCESS',
    ProductsGet: 'PRODUCTS_GET',
    ProductsCreate: 'PRODUCTS_CREATE',
    ProductsUpdate: 'PRODUCTS_UPDATE',
    ProductsDelete: 'PRODUCTS_DELETE',
    PaymentIntegrationRead: 'PAYMENT_INTEGRATION_READ',
    PaymentIntegrationWrite: 'PAYMENT_INTEGRATION_WRITE',
    PaymentRecordsRead: 'PAYMENT_RECORDS_READ',
    PaymentRecordsWrite: 'PAYMENT_RECORDS_WRITE',
    MetricsGet: 'METRICS_GET',
    AccountsReadAssigned: 'ACCOUNTS_READ_ASSIGNED',
    AutocompleteGet: 'AUTOCOMPLETE_GET',
    MessagesSearch: 'MESSAGES_SEARCH',
    WidgetEdit: 'WIDGET_EDIT',
    CouponRead: 'COUPON_READ',
    CouponCreate: 'COUPON_CREATE',
    CouponDelete: 'COUPON_DELETE',
    CouponUpdate: 'COUPON_UPDATE',
    TeammembersReadContactDetails: 'TEAMMEMBERS_READ_CONTACT_DETAILS',
    TeammembersReadMessageDetails: 'TEAMMEMBERS_READ_MESSAGE_DETAILS',
    CallPhoneCreate: 'CALL_PHONE_CREATE',
    CallPhoneDelete: 'CALL_PHONE_DELETE',
    MakeCalls: 'MAKE_CALLS',
    CallLogsRead: 'CALL_LOGS_READ'
} as const;

export type Scope = typeof Scope[keyof typeof Scope];


/**
 * 
 * @export
 * @interface SimpleNotificationPreference
 */
export interface SimpleNotificationPreference {
    /**
     * 
     * @type {Array<NotificationDestination>}
     * @memberof SimpleNotificationPreference
     */
    'destinations': Array<NotificationDestination>;
}
/**
 * 
 * @export
 * @interface SubUserCreate
 */
export interface SubUserCreate {
    /**
     * 
     * @type {string}
     * @memberof SubUserCreate
     */
    'fullName': string;
    /**
     * Will only contain numbers, no + sign, brackets etc.
     * @type {number}
     * @memberof SubUserCreate
     */
    'phoneNumber': number;
    /**
     * plaintext/base64Sha256 of the password, depending on the passwordEncoding
     * @type {string}
     * @memberof SubUserCreate
     */
    'password': string;
    /**
     * 
     * @type {PasswordEncoding}
     * @memberof SubUserCreate
     */
    'passwordEncoding'?: PasswordEncoding;
    /**
     * 
     * @type {TeamMemberRole}
     * @memberof SubUserCreate
     */
    'role': TeamMemberRole;
}


/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'updatedAt': string;
    /**
     * Who created the team
     * @type {string}
     * @memberof Team
     */
    'createdBy'?: string;
    /**
     * 
     * @type {User}
     * @memberof Team
     */
    'creator'?: User;
    /**
     * The ISO country code of the team
     * @type {string}
     * @memberof Team
     */
    'region': string;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    'name': string;
    /**
     * Is an admin team
     * @type {boolean}
     * @memberof Team
     */
    'isAdmin'?: boolean;
    /**
     * The max scopes allowed
     * @type {Array<Scope>}
     * @memberof Team
     */
    'scopes': Array<Scope>;
    /**
     * 
     * @type {TeamMetadata}
     * @memberof Team
     */
    'metadata': TeamMetadata;
    /**
     * 
     * @type {Array<TeamMember>}
     * @memberof Team
     */
    'members'?: Array<TeamMember>;
    /**
     * 
     * @type {Array<InviteLink>}
     * @memberof Team
     */
    'inviteLinks'?: Array<InviteLink>;
    /**
     * The team will be the admin team of a Chatdaddy partner if this property is not null.
     * @type {string}
     * @memberof Team
     */
    'partnerAdmin'?: string | null;
    /**
     * 
     * @type {TeamZapierToken}
     * @memberof Team
     */
    'zapierToken'?: TeamZapierToken | null;
    /**
     * 
     * @type {Array<OnboardingStep>}
     * @memberof Team
     */
    'onboardingStepsDone'?: Array<OnboardingStep>;
    /**
     * The onboarding score of the team.
     * @type {number}
     * @memberof Team
     */
    'onboardingScore'?: number;
    /**
     * The total connected channels in the team.
     * @type {number}
     * @memberof Team
     */
    'connectedChannelCount'?: number;
    /**
     * ID of a customer. All credits are linked to a customer. Multiple teams can be linked to the same customer & thus share credits.
     * @type {string}
     * @memberof Team
     */
    'creditCustomerId'?: string | null;
    /**
     * The variant of the team, chatdaddy or lite
     * @type {string}
     * @memberof Team
     */
    'variant'?: TeamVariantEnum;
}

export const TeamVariantEnum = {
    Chatdaddy: 'chatdaddy',
    Lite: 'lite'
} as const;

export type TeamVariantEnum = typeof TeamVariantEnum[keyof typeof TeamVariantEnum];

/**
 * 
 * @export
 * @interface TeamMember
 */
export interface TeamMember {
    /**
     * 
     * @type {Team}
     * @memberof TeamMember
     */
    'team'?: Team;
    /**
     * 
     * @type {User}
     * @memberof TeamMember
     */
    'user'?: User;
    /**
     * Unique identifier for a user
     * @type {string}
     * @memberof TeamMember
     */
    'userId': string;
    /**
     * Unique identifier for a team
     * @type {string}
     * @memberof TeamMember
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMember
     */
    'addedAt': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMember
     */
    'addedBy'?: string | null;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof TeamMember
     */
    'scopes': Array<Scope>;
    /**
     * 
     * @type {TeamMemberRole}
     * @memberof TeamMember
     */
    'role'?: TeamMemberRole;
}


/**
 * 
 * @export
 * @interface TeamMemberLogout
 */
export interface TeamMemberLogout {
    /**
     * 
     * @type {string}
     * @memberof TeamMemberLogout
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMemberLogout
     */
    'userId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TeamMemberRole = {
    Viewer: 'viewer',
    Editor: 'editor',
    Admin: 'admin',
    Agent: 'agent'
} as const;

export type TeamMemberRole = typeof TeamMemberRole[keyof typeof TeamMemberRole];


/**
 * 
 * @export
 * @interface TeamMetadata
 */
export interface TeamMetadata {
    /**
     * 
     * @type {string}
     * @memberof TeamMetadata
     */
    'companyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMetadata
     */
    'companyEmailAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMetadata
     */
    'companyWebsite'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMetadata
     */
    'industry'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMetadata
     */
    'subIndustry'?: string;
}
/**
 * 
 * @export
 * @interface TeamPatchRequest
 */
export interface TeamPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof TeamPatchRequest
     */
    'name'?: string;
    /**
     * 
     * @type {TeamMetadata}
     * @memberof TeamPatchRequest
     */
    'metadata'?: TeamMetadata;
    /**
     * The ISO country code of the team
     * @type {string}
     * @memberof TeamPatchRequest
     */
    'region'?: string;
    /**
     * 
     * @type {Array<TeamPatchRequestMembersInner>}
     * @memberof TeamPatchRequest
     */
    'members'?: Array<TeamPatchRequestMembersInner>;
    /**
     * 
     * @type {Array<TeamPatchRequestInviteLinksInner>}
     * @memberof TeamPatchRequest
     */
    'inviteLinks'?: Array<TeamPatchRequestInviteLinksInner>;
    /**
     * 
     * @type {TeamZapierToken}
     * @memberof TeamPatchRequest
     */
    'zapierToken'?: TeamZapierToken | null;
}
/**
 * 
 * @export
 * @interface TeamPatchRequestInviteLinksInner
 */
export interface TeamPatchRequestInviteLinksInner {
    /**
     * 
     * @type {string}
     * @memberof TeamPatchRequestInviteLinksInner
     */
    'id': string;
    /**
     * If set to true, will delete the invite link
     * @type {boolean}
     * @memberof TeamPatchRequestInviteLinksInner
     */
    'delete'?: boolean;
}
/**
 * 
 * @export
 * @interface TeamPatchRequestMembersInner
 */
export interface TeamPatchRequestMembersInner {
    /**
     * 
     * @type {string}
     * @memberof TeamPatchRequestMembersInner
     */
    'id': string;
    /**
     * If set to true, will delete the team member
     * @type {boolean}
     * @memberof TeamPatchRequestMembersInner
     */
    'delete'?: boolean;
    /**
     * 
     * @type {Array<Scope>}
     * @memberof TeamPatchRequestMembersInner
     */
    'scopes'?: Array<Scope>;
    /**
     * 
     * @type {TeamMemberRole}
     * @memberof TeamPatchRequestMembersInner
     */
    'role'?: TeamMemberRole;
}


/**
 * 
 * @export
 * @interface TeamZapierToken
 */
export interface TeamZapierToken {
    /**
     * 
     * @type {string}
     * @memberof TeamZapierToken
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof TeamZapierToken
     */
    'expiresAt': string;
}
/**
 * 
 * @export
 * @interface TeamsGet200Response
 */
export interface TeamsGet200Response {
    /**
     * 
     * @type {number}
     * @memberof TeamsGet200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<Team>}
     * @memberof TeamsGet200Response
     */
    'teams': Array<Team>;
}
/**
 * 
 * @export
 * @interface TeamsPatch200Response
 */
export interface TeamsPatch200Response {
    /**
     * 
     * @type {boolean}
     * @memberof TeamsPatch200Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface TokenPost200Response
 */
export interface TokenPost200Response {
    /**
     * 
     * @type {string}
     * @memberof TokenPost200Response
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenPost200Response
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenPost200Response
     */
    'refresh_token_expiry'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenPost200Response
     */
    'was_forced'?: boolean;
}
/**
 * 
 * @export
 * @interface TokenPostResponse
 */
export interface TokenPostResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenPostResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenPostResponse
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenPostResponse
     */
    'refresh_token_expiry'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'disabledAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'fullName': string;
    /**
     * The last used team ID, your refresh token when logging in is generated for this team
     * @type {string}
     * @memberof User
     */
    'lastUsedTeamId'?: string;
    /**
     * Will only contain numbers, no + sign, brackets etc.
     * @type {number}
     * @memberof User
     */
    'phoneNumber': number | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'emailAddress'?: string | null;
    /**
     * 
     * @type {UserCreateMethod}
     * @memberof User
     */
    'createdByMethod'?: UserCreateMethod;
    /**
     * 
     * @type {NotifyModel}
     * @memberof User
     * @deprecated
     */
    'notify': NotifyModel;
    /**
     * 
     * @type {NotificationPreferences}
     * @memberof User
     */
    'notificationPreferences': NotificationPreferences;
    /**
     * The referral code used for sign-up
     * @type {string}
     * @memberof User
     */
    'referralCode'?: string | null;
    /**
     * The signature of the user to use in messages
     * @type {string}
     * @memberof User
     */
    'signature'?: string | null;
    /**
     * 
     * @type {Array<TeamMember>}
     * @memberof User
     */
    'memberships'?: Array<TeamMember>;
    /**
     * 
     * @type {Array<WebPushSubscription>}
     * @memberof User
     */
    'webPushSubscriptions'?: Array<WebPushSubscription>;
    /**
     * The partnership the user has signed in with
     * @type {string}
     * @memberof User
     */
    'partnership'?: string | null;
    /**
     * The variant of the user, chatdaddy or lite
     * @type {string}
     * @memberof User
     */
    'variant'?: UserVariantEnum;
}

export const UserVariantEnum = {
    Chatdaddy: 'chatdaddy',
    Lite: 'lite'
} as const;

export type UserVariantEnum = typeof UserVariantEnum[keyof typeof UserVariantEnum];

/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'fullName': string;
    /**
     * Will only contain numbers, no + sign, brackets etc.
     * @type {number}
     * @memberof UserCreate
     */
    'phoneNumber': number;
    /**
     * SHA256 of the plaintext password pls
     * @type {string}
     * @memberof UserCreate
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'emailAddress'?: string | null;
    /**
     * If the user is a credit customer, then set this field. Only applicable for admin create.
     * @type {string}
     * @memberof UserCreate
     */
    'creditCustomer'?: UserCreateCreditCustomerEnum;
    /**
     * 
     * @type {TeamMetadata}
     * @memberof UserCreate
     */
    'metadata'?: TeamMetadata;
    /**
     * 
     * @type {NotifyModel}
     * @memberof UserCreate
     * @deprecated
     */
    'notify'?: NotifyModel;
    /**
     * 
     * @type {NotificationPreferences}
     * @memberof UserCreate
     */
    'notificationPreferences'?: NotificationPreferences;
    /**
     * Sign up with a referral code
     * @type {string}
     * @memberof UserCreate
     */
    'referralCode'?: string;
    /**
     * Id of the invite link to use
     * @type {string}
     * @memberof UserCreate
     */
    'inviteLinkId'?: string;
    /**
     * The ISO country code of the team
     * @type {string}
     * @memberof UserCreate
     */
    'region'?: string;
    /**
     * The variant of the user to create. chatdaddy or lite
     * @type {string}
     * @memberof UserCreate
     */
    'variant'?: UserCreateVariantEnum;
}

export const UserCreateCreditCustomerEnum = {
    Production: 'production',
    TestMode: 'test_mode'
} as const;

export type UserCreateCreditCustomerEnum = typeof UserCreateCreditCustomerEnum[keyof typeof UserCreateCreditCustomerEnum];
export const UserCreateVariantEnum = {
    Chatdaddy: 'chatdaddy',
    Lite: 'lite'
} as const;

export type UserCreateVariantEnum = typeof UserCreateVariantEnum[keyof typeof UserCreateVariantEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const UserCreateMethod = {
    AdminPanel: 'admin-panel',
    Otp: 'otp',
    Boutir: 'boutir',
    InstantReg: 'instant-reg',
    Firebase: 'firebase',
    TeamMember: 'team-member'
} as const;

export type UserCreateMethod = typeof UserCreateMethod[keyof typeof UserCreateMethod];


/**
 * 
 * @export
 * @interface UserPatch
 */
export interface UserPatch {
    /**
     * 
     * @type {string}
     * @memberof UserPatch
     */
    'fullName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPatch
     */
    'emailAddress'?: string | null;
    /**
     * 
     * @type {NotifyModel}
     * @memberof UserPatch
     * @deprecated
     */
    'notify'?: NotifyModel;
    /**
     * 
     * @type {NotificationPreferences}
     * @memberof UserPatch
     */
    'notificationPreferences'?: NotificationPreferences;
    /**
     * Phone number. Only admin access can modify or specify OTP
     * @type {number}
     * @memberof UserPatch
     */
    'phoneNumber'?: number;
    /**
     * OTP to change password/phone number
     * @type {number}
     * @memberof UserPatch
     */
    'otp'?: number;
    /**
     * plaintext/base64Sha256 of the password, depending on the passwordEncoding
     * @type {string}
     * @memberof UserPatch
     */
    'password'?: string;
    /**
     * 
     * @type {PasswordEncoding}
     * @memberof UserPatch
     */
    'passwordEncoding'?: PasswordEncoding;
    /**
     * Logs out the user from all devices. If the user is logged in on the device, the user will be logged out.
     * @type {boolean}
     * @memberof UserPatch
     */
    'logout'?: boolean;
    /**
     * A signature of the user to be used at the end of the message
     * @type {string}
     * @memberof UserPatch
     */
    'signature'?: string;
    /**
     * 
     * @type {Array<WebPushSubscription>}
     * @memberof UserPatch
     */
    'webPushSubscriptions'?: Array<WebPushSubscription>;
    /**
     * add a user to a partnership manually
     * @type {string}
     * @memberof UserPatch
     */
    'partnership'?: string | null;
    /**
     * If the user should be made a credit customer. Once set, it cannot be unset.
     * @type {string}
     * @memberof UserPatch
     */
    'creditCustomer'?: UserPatchCreditCustomerEnum;
}

export const UserPatchCreditCustomerEnum = {
    Production: 'production'
} as const;

export type UserPatchCreditCustomerEnum = typeof UserPatchCreditCustomerEnum[keyof typeof UserPatchCreditCustomerEnum];

/**
 * 
 * @export
 * @interface UsersGet200Response
 */
export interface UsersGet200Response {
    /**
     * 
     * @type {number}
     * @memberof UsersGet200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof UsersGet200Response
     */
    'users': Array<User>;
}
/**
 * 
 * @export
 * @interface UsersPhoneNumberPatchRequest
 */
export interface UsersPhoneNumberPatchRequest {
    /**
     * 
     * @type {number}
     * @memberof UsersPhoneNumberPatchRequest
     */
    'phoneNumber': number;
    /**
     * 
     * @type {string}
     * @memberof UsersPhoneNumberPatchRequest
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface VerifyEmail200Response
 */
export interface VerifyEmail200Response {
    /**
     * 
     * @type {boolean}
     * @memberof VerifyEmail200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface VerifyEmailRequest
 */
export interface VerifyEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailRequest
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface WebPushNotification
 */
export interface WebPushNotification {
    /**
     * 
     * @type {string}
     * @memberof WebPushNotification
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof WebPushNotification
     */
    'text': string;
    /**
     * When true, the notification is only shown if the user is online
     * @type {boolean}
     * @memberof WebPushNotification
     */
    'onlineOnly'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WebPushNotification
     */
    'teamId': string;
    /**
     * The path to open when the notification is clicked
     * @type {string}
     * @memberof WebPushNotification
     */
    'path'?: string;
    /**
     * The image to show in the notification
     * @type {string}
     * @memberof WebPushNotification
     */
    'imgUrl'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebPushNotification
     */
    'context'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface WebPushSubscription
 */
export interface WebPushSubscription {
    /**
     * 
     * @type {string}
     * @memberof WebPushSubscription
     */
    'endpoint': string;
    /**
     * 
     * @type {string}
     * @memberof WebPushSubscription
     */
    'authKey': string;
    /**
     * 
     * @type {string}
     * @memberof WebPushSubscription
     */
    'p256dhKey': string;
}
/**
 * 
 * @export
 * @interface WidgetButtonParams
 */
export interface WidgetButtonParams {
    /**
     * 
     * @type {string}
     * @memberof WidgetButtonParams
     */
    'buttonIcon': WidgetButtonParamsButtonIconEnum;
    /**
     * 
     * @type {string}
     * @memberof WidgetButtonParams
     */
    'buttonText': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetButtonParams
     */
    'buttonBackgroundColor': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetButtonParams
     */
    'buttonTextAndIconColor': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetButtonParams
     */
    'buttonPosition': WidgetButtonParamsButtonPositionEnum;
}

export const WidgetButtonParamsButtonIconEnum = {
    Wa: 'wa',
    Headset: 'headset',
    Message: 'message',
    ChatBubble: 'chatBubble'
} as const;

export type WidgetButtonParamsButtonIconEnum = typeof WidgetButtonParamsButtonIconEnum[keyof typeof WidgetButtonParamsButtonIconEnum];
export const WidgetButtonParamsButtonPositionEnum = {
    Left: 'left',
    Right: 'right'
} as const;

export type WidgetButtonParamsButtonPositionEnum = typeof WidgetButtonParamsButtonPositionEnum[keyof typeof WidgetButtonParamsButtonPositionEnum];

/**
 * 
 * @export
 * @interface WidgetCTAParams
 */
export interface WidgetCTAParams {
    /**
     * 
     * @type {string}
     * @memberof WidgetCTAParams
     */
    'widgetCTAButtonText': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetCTAParams
     */
    'widgetCTAContentColor': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetCTAParams
     */
    'widgetCTABackgroundColor': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetCTAParams
     */
    'CTALink': string;
}
/**
 * 
 * @export
 * @interface WidgetConfig
 */
export interface WidgetConfig {
    /**
     * 
     * @type {WidgetButtonParams}
     * @memberof WidgetConfig
     */
    'widgetButtonParams': WidgetButtonParams;
    /**
     * 
     * @type {WidgetDialogParams}
     * @memberof WidgetConfig
     */
    'widgetDialogParams': WidgetDialogParams;
    /**
     * 
     * @type {WidgetCTAParams}
     * @memberof WidgetConfig
     */
    'widgetCTAParams': WidgetCTAParams;
    /**
     * 
     * @type {string}
     * @memberof WidgetConfig
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetConfig
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetConfig
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetConfig
     */
    'configUrl': string;
}
/**
 * 
 * @export
 * @interface WidgetConfigParams
 */
export interface WidgetConfigParams {
    /**
     * 
     * @type {WidgetButtonParams}
     * @memberof WidgetConfigParams
     */
    'widgetButtonParams': WidgetButtonParams;
    /**
     * 
     * @type {WidgetDialogParams}
     * @memberof WidgetConfigParams
     */
    'widgetDialogParams': WidgetDialogParams;
    /**
     * 
     * @type {WidgetCTAParams}
     * @memberof WidgetConfigParams
     */
    'widgetCTAParams': WidgetCTAParams;
}
/**
 * 
 * @export
 * @interface WidgetDialogParams
 */
export interface WidgetDialogParams {
    /**
     * 
     * @type {string}
     * @memberof WidgetDialogParams
     */
    'widgetBrandName': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetDialogParams
     */
    'widgetHeaderCaption': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetDialogParams
     */
    'widgetBrandIconUrl': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetDialogParams
     */
    'widgetWelcomeMessage': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetDialogParams
     */
    'widgetPrefilledTextMessage': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetDialogParams
     */
    'widgetHeaderContentColor': string;
    /**
     * 
     * @type {string}
     * @memberof WidgetDialogParams
     */
    'widgetHeaderBackgroundColor': string;
}

/**
 * APITokensApi - axios parameter creator
 * @export
 */
export const APITokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an API token
         * @param {Array<string>} tokens 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenDelete: async (tokens: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokens' is not null or undefined
            assertParamExists('apiTokenDelete', 'tokens', tokens)
            const localVarPath = `/api-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (tokens) {
                localVarQueryParameter['tokens'] = tokens;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch API tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate an API token
         * @param {ApiTokenPostRequest} [apiTokenPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenPost: async (apiTokenPostRequest?: ApiTokenPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiTokenPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate an API token
         * @param {ApiTokenValidatePostRequest} [apiTokenValidatePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenValidatePost: async (apiTokenValidatePostRequest?: ApiTokenValidatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-token/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiTokenValidatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APITokensApi - functional programming interface
 * @export
 */
export const APITokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APITokensApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete an API token
         * @param {Array<string>} tokens 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTokenDelete(tokens: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTokenDelete(tokens, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APITokensApi.apiTokenDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch API tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTokenGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTokenGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTokenGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APITokensApi.apiTokenGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate an API token
         * @param {ApiTokenPostRequest} [apiTokenPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTokenPost(apiTokenPostRequest?: ApiTokenPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTokenPost(apiTokenPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APITokensApi.apiTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Validate an API token
         * @param {ApiTokenValidatePostRequest} [apiTokenValidatePostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTokenValidatePost(apiTokenValidatePostRequest?: ApiTokenValidatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JWT>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTokenValidatePost(apiTokenValidatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APITokensApi.apiTokenValidatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * APITokensApi - factory interface
 * @export
 */
export const APITokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APITokensApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete an API token
         * @param {APITokensApiApiTokenDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenDelete(requestParameters: APITokensApiApiTokenDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiTokenDelete(requestParameters.tokens, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch API tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenGet(options?: RawAxiosRequestConfig): AxiosPromise<ApiTokenGet200Response> {
            return localVarFp.apiTokenGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate an API token
         * @param {APITokensApiApiTokenPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenPost(requestParameters: APITokensApiApiTokenPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ApiToken> {
            return localVarFp.apiTokenPost(requestParameters.apiTokenPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate an API token
         * @param {APITokensApiApiTokenValidatePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenValidatePost(requestParameters: APITokensApiApiTokenValidatePostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<JWT> {
            return localVarFp.apiTokenValidatePost(requestParameters.apiTokenValidatePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiTokenDelete operation in APITokensApi.
 * @export
 * @interface APITokensApiApiTokenDeleteRequest
 */
export interface APITokensApiApiTokenDeleteRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof APITokensApiApiTokenDelete
     */
    readonly tokens: Array<string>
}

/**
 * Request parameters for apiTokenPost operation in APITokensApi.
 * @export
 * @interface APITokensApiApiTokenPostRequest
 */
export interface APITokensApiApiTokenPostRequest {
    /**
     * 
     * @type {ApiTokenPostRequest}
     * @memberof APITokensApiApiTokenPost
     */
    readonly apiTokenPostRequest?: ApiTokenPostRequest
}

/**
 * Request parameters for apiTokenValidatePost operation in APITokensApi.
 * @export
 * @interface APITokensApiApiTokenValidatePostRequest
 */
export interface APITokensApiApiTokenValidatePostRequest {
    /**
     * 
     * @type {ApiTokenValidatePostRequest}
     * @memberof APITokensApiApiTokenValidatePost
     */
    readonly apiTokenValidatePostRequest?: ApiTokenValidatePostRequest
}

/**
 * APITokensApi - object-oriented interface
 * @export
 * @class APITokensApi
 * @extends {BaseAPI}
 */
export class APITokensApi extends BaseAPI {
    /**
     * 
     * @summary Delete an API token
     * @param {APITokensApiApiTokenDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APITokensApi
     */
    public apiTokenDelete(requestParameters: APITokensApiApiTokenDeleteRequest, options?: RawAxiosRequestConfig) {
        return APITokensApiFp(this.configuration).apiTokenDelete(requestParameters.tokens, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch API tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APITokensApi
     */
    public apiTokenGet(options?: RawAxiosRequestConfig) {
        return APITokensApiFp(this.configuration).apiTokenGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate an API token
     * @param {APITokensApiApiTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APITokensApi
     */
    public apiTokenPost(requestParameters: APITokensApiApiTokenPostRequest = {}, options?: RawAxiosRequestConfig) {
        return APITokensApiFp(this.configuration).apiTokenPost(requestParameters.apiTokenPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate an API token
     * @param {APITokensApiApiTokenValidatePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APITokensApi
     */
    public apiTokenValidatePost(requestParameters: APITokensApiApiTokenValidatePostRequest = {}, options?: RawAxiosRequestConfig) {
        return APITokensApiFp(this.configuration).apiTokenValidatePost(requestParameters.apiTokenValidatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnnouncementsApi - axios parameter creator
 * @export
 */
export const AnnouncementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates new announcement
         * @param {AnnouncementPatch} [announcementPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementCreate: async (announcementPatch?: AnnouncementPatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(announcementPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes list of announcements
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementDelete: async (ids: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('announcementDelete', 'ids', ids)
            const localVarPath = `/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of announcements
         * @param {number} [count] Number of announcements to fetch
         * @param {string} [before] Announcements to fetch before
         * @param {string} [q] Search by category, title etc.
         * @param {string} [publishedAt] Optional filter to retrieve announcements published on or before a specific date and time. If provided, only announcements published on or before the given timestamp will be returned. 
         * @param {string | null} [expiresAt] Optional filter to retrieve announcements that are valid until a specific date and time. - If set to a specific timestamp, only announcements that expire on or after the given timestamp will be returned. - If set to &#x60;null&#x60;, only announcements with no expiration date will be returned. 
         * @param {string} [partnership] Search by partnership
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementGet: async (count?: number, before?: string, q?: string, publishedAt?: string, expiresAt?: string | null, partnership?: string, returnTotalCount?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (publishedAt !== undefined) {
                localVarQueryParameter['publishedAt'] = (publishedAt as any instanceof Date) ?
                    (publishedAt as any).toISOString() :
                    publishedAt;
            }

            if (expiresAt !== undefined) {
                localVarQueryParameter['expiresAt'] = (expiresAt as any instanceof Date) ?
                    (expiresAt as any).toISOString() :
                    expiresAt;
            }

            if (partnership !== undefined) {
                localVarQueryParameter['partnership'] = partnership;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an announcement
         * @param {string} id 
         * @param {AnnouncementPatch} [announcementPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementPatch: async (id: string, announcementPatch?: AnnouncementPatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('announcementPatch', 'id', id)
            const localVarPath = `/announcements/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(announcementPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnouncementsApi - functional programming interface
 * @export
 */
export const AnnouncementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnouncementsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates new announcement
         * @param {AnnouncementPatch} [announcementPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async announcementCreate(announcementPatch?: AnnouncementPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouncementMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.announcementCreate(announcementPatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnouncementsApi.announcementCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes list of announcements
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async announcementDelete(ids: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.announcementDelete(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnouncementsApi.announcementDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get list of announcements
         * @param {number} [count] Number of announcements to fetch
         * @param {string} [before] Announcements to fetch before
         * @param {string} [q] Search by category, title etc.
         * @param {string} [publishedAt] Optional filter to retrieve announcements published on or before a specific date and time. If provided, only announcements published on or before the given timestamp will be returned. 
         * @param {string | null} [expiresAt] Optional filter to retrieve announcements that are valid until a specific date and time. - If set to a specific timestamp, only announcements that expire on or after the given timestamp will be returned. - If set to &#x60;null&#x60;, only announcements with no expiration date will be returned. 
         * @param {string} [partnership] Search by partnership
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async announcementGet(count?: number, before?: string, q?: string, publishedAt?: string, expiresAt?: string | null, partnership?: string, returnTotalCount?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouncementRetrievalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.announcementGet(count, before, q, publishedAt, expiresAt, partnership, returnTotalCount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnouncementsApi.announcementGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an announcement
         * @param {string} id 
         * @param {AnnouncementPatch} [announcementPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async announcementPatch(id: string, announcementPatch?: AnnouncementPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.announcementPatch(id, announcementPatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnouncementsApi.announcementPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnnouncementsApi - factory interface
 * @export
 */
export const AnnouncementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnouncementsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates new announcement
         * @param {AnnouncementsApiAnnouncementCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementCreate(requestParameters: AnnouncementsApiAnnouncementCreateRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AnnouncementMetadata> {
            return localVarFp.announcementCreate(requestParameters.announcementPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes list of announcements
         * @param {AnnouncementsApiAnnouncementDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementDelete(requestParameters: AnnouncementsApiAnnouncementDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.announcementDelete(requestParameters.ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of announcements
         * @param {AnnouncementsApiAnnouncementGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementGet(requestParameters: AnnouncementsApiAnnouncementGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AnnouncementRetrievalResponse> {
            return localVarFp.announcementGet(requestParameters.count, requestParameters.before, requestParameters.q, requestParameters.publishedAt, requestParameters.expiresAt, requestParameters.partnership, requestParameters.returnTotalCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an announcement
         * @param {AnnouncementsApiAnnouncementPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcementPatch(requestParameters: AnnouncementsApiAnnouncementPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.announcementPatch(requestParameters.id, requestParameters.announcementPatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for announcementCreate operation in AnnouncementsApi.
 * @export
 * @interface AnnouncementsApiAnnouncementCreateRequest
 */
export interface AnnouncementsApiAnnouncementCreateRequest {
    /**
     * 
     * @type {AnnouncementPatch}
     * @memberof AnnouncementsApiAnnouncementCreate
     */
    readonly announcementPatch?: AnnouncementPatch
}

/**
 * Request parameters for announcementDelete operation in AnnouncementsApi.
 * @export
 * @interface AnnouncementsApiAnnouncementDeleteRequest
 */
export interface AnnouncementsApiAnnouncementDeleteRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof AnnouncementsApiAnnouncementDelete
     */
    readonly ids: Array<string>
}

/**
 * Request parameters for announcementGet operation in AnnouncementsApi.
 * @export
 * @interface AnnouncementsApiAnnouncementGetRequest
 */
export interface AnnouncementsApiAnnouncementGetRequest {
    /**
     * Number of announcements to fetch
     * @type {number}
     * @memberof AnnouncementsApiAnnouncementGet
     */
    readonly count?: number

    /**
     * Announcements to fetch before
     * @type {string}
     * @memberof AnnouncementsApiAnnouncementGet
     */
    readonly before?: string

    /**
     * Search by category, title etc.
     * @type {string}
     * @memberof AnnouncementsApiAnnouncementGet
     */
    readonly q?: string

    /**
     * Optional filter to retrieve announcements published on or before a specific date and time. If provided, only announcements published on or before the given timestamp will be returned. 
     * @type {string}
     * @memberof AnnouncementsApiAnnouncementGet
     */
    readonly publishedAt?: string

    /**
     * Optional filter to retrieve announcements that are valid until a specific date and time. - If set to a specific timestamp, only announcements that expire on or after the given timestamp will be returned. - If set to &#x60;null&#x60;, only announcements with no expiration date will be returned. 
     * @type {string}
     * @memberof AnnouncementsApiAnnouncementGet
     */
    readonly expiresAt?: string | null

    /**
     * Search by partnership
     * @type {string}
     * @memberof AnnouncementsApiAnnouncementGet
     */
    readonly partnership?: string

    /**
     * 
     * @type {boolean}
     * @memberof AnnouncementsApiAnnouncementGet
     */
    readonly returnTotalCount?: boolean
}

/**
 * Request parameters for announcementPatch operation in AnnouncementsApi.
 * @export
 * @interface AnnouncementsApiAnnouncementPatchRequest
 */
export interface AnnouncementsApiAnnouncementPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof AnnouncementsApiAnnouncementPatch
     */
    readonly id: string

    /**
     * 
     * @type {AnnouncementPatch}
     * @memberof AnnouncementsApiAnnouncementPatch
     */
    readonly announcementPatch?: AnnouncementPatch
}

/**
 * AnnouncementsApi - object-oriented interface
 * @export
 * @class AnnouncementsApi
 * @extends {BaseAPI}
 */
export class AnnouncementsApi extends BaseAPI {
    /**
     * 
     * @summary Creates new announcement
     * @param {AnnouncementsApiAnnouncementCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public announcementCreate(requestParameters: AnnouncementsApiAnnouncementCreateRequest = {}, options?: RawAxiosRequestConfig) {
        return AnnouncementsApiFp(this.configuration).announcementCreate(requestParameters.announcementPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes list of announcements
     * @param {AnnouncementsApiAnnouncementDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public announcementDelete(requestParameters: AnnouncementsApiAnnouncementDeleteRequest, options?: RawAxiosRequestConfig) {
        return AnnouncementsApiFp(this.configuration).announcementDelete(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of announcements
     * @param {AnnouncementsApiAnnouncementGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public announcementGet(requestParameters: AnnouncementsApiAnnouncementGetRequest = {}, options?: RawAxiosRequestConfig) {
        return AnnouncementsApiFp(this.configuration).announcementGet(requestParameters.count, requestParameters.before, requestParameters.q, requestParameters.publishedAt, requestParameters.expiresAt, requestParameters.partnership, requestParameters.returnTotalCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an announcement
     * @param {AnnouncementsApiAnnouncementPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnouncementsApi
     */
    public announcementPatch(requestParameters: AnnouncementsApiAnnouncementPatchRequest, options?: RawAxiosRequestConfig) {
        return AnnouncementsApiFp(this.configuration).announcementPatch(requestParameters.id, requestParameters.announcementPatch, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InviteLinksApi - axios parameter creator
 * @export
 */
export const InviteLinksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get info about an invite link
         * @param {string} id the invite link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteLinksGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('inviteLinksGet', 'id', id)
            const localVarPath = `/invite-links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To generate an invite link for a specific set of scopes, you must also have the same set of scopes. Eg. you cannot generate a link which gives access to `MESSAGE_SEND` when you don\'t have access to `MESSAGE_SEND` yourself. This is done for obvious security concerns. 
         * @summary Create an invite link for the team
         * @param {EitherRoleOrScopes} [eitherRoleOrScopes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteLinksPost: async (eitherRoleOrScopes?: EitherRoleOrScopes, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invite-links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEAMLINK_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eitherRoleOrScopes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InviteLinksApi - functional programming interface
 * @export
 */
export const InviteLinksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InviteLinksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get info about an invite link
         * @param {string} id the invite link ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteLinksGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteLinksGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InviteLinksApi.inviteLinksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To generate an invite link for a specific set of scopes, you must also have the same set of scopes. Eg. you cannot generate a link which gives access to `MESSAGE_SEND` when you don\'t have access to `MESSAGE_SEND` yourself. This is done for obvious security concerns. 
         * @summary Create an invite link for the team
         * @param {EitherRoleOrScopes} [eitherRoleOrScopes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteLinksPost(eitherRoleOrScopes?: EitherRoleOrScopes, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteLinksPost(eitherRoleOrScopes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InviteLinksApi.inviteLinksPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InviteLinksApi - factory interface
 * @export
 */
export const InviteLinksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InviteLinksApiFp(configuration)
    return {
        /**
         * 
         * @summary Get info about an invite link
         * @param {InviteLinksApiInviteLinksGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteLinksGet(requestParameters: InviteLinksApiInviteLinksGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<InviteLink> {
            return localVarFp.inviteLinksGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * To generate an invite link for a specific set of scopes, you must also have the same set of scopes. Eg. you cannot generate a link which gives access to `MESSAGE_SEND` when you don\'t have access to `MESSAGE_SEND` yourself. This is done for obvious security concerns. 
         * @summary Create an invite link for the team
         * @param {InviteLinksApiInviteLinksPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteLinksPost(requestParameters: InviteLinksApiInviteLinksPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<InviteLink> {
            return localVarFp.inviteLinksPost(requestParameters.eitherRoleOrScopes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for inviteLinksGet operation in InviteLinksApi.
 * @export
 * @interface InviteLinksApiInviteLinksGetRequest
 */
export interface InviteLinksApiInviteLinksGetRequest {
    /**
     * the invite link ID
     * @type {string}
     * @memberof InviteLinksApiInviteLinksGet
     */
    readonly id: string
}

/**
 * Request parameters for inviteLinksPost operation in InviteLinksApi.
 * @export
 * @interface InviteLinksApiInviteLinksPostRequest
 */
export interface InviteLinksApiInviteLinksPostRequest {
    /**
     * 
     * @type {EitherRoleOrScopes}
     * @memberof InviteLinksApiInviteLinksPost
     */
    readonly eitherRoleOrScopes?: EitherRoleOrScopes
}

/**
 * InviteLinksApi - object-oriented interface
 * @export
 * @class InviteLinksApi
 * @extends {BaseAPI}
 */
export class InviteLinksApi extends BaseAPI {
    /**
     * 
     * @summary Get info about an invite link
     * @param {InviteLinksApiInviteLinksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteLinksApi
     */
    public inviteLinksGet(requestParameters: InviteLinksApiInviteLinksGetRequest, options?: RawAxiosRequestConfig) {
        return InviteLinksApiFp(this.configuration).inviteLinksGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To generate an invite link for a specific set of scopes, you must also have the same set of scopes. Eg. you cannot generate a link which gives access to `MESSAGE_SEND` when you don\'t have access to `MESSAGE_SEND` yourself. This is done for obvious security concerns. 
     * @summary Create an invite link for the team
     * @param {InviteLinksApiInviteLinksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteLinksApi
     */
    public inviteLinksPost(requestParameters: InviteLinksApiInviteLinksPostRequest = {}, options?: RawAxiosRequestConfig) {
        return InviteLinksApiFp(this.configuration).inviteLinksPost(requestParameters.eitherRoleOrScopes, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Send a notification to a team member
         * @param {string} userId 
         * @param {Array<NotifyTeamMemberDestinationsEnum>} [destinations] The destinations to send the notification to
         * @param {NotifyRequestWithContent} [notifyRequestWithContent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyTeamMember: async (userId: string, destinations?: Array<NotifyTeamMemberDestinationsEnum>, notifyRequestWithContent?: NotifyRequestWithContent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('notifyTeamMember', 'userId', userId)
            const localVarPath = `/notify/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["MESSAGES_SEND_TO_ALL"], configuration)

            if (destinations) {
                localVarQueryParameter['destinations'] = destinations;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notifyRequestWithContent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Send a notification to a team member
         * @param {string} userId 
         * @param {Array<NotifyTeamMemberDestinationsEnum>} [destinations] The destinations to send the notification to
         * @param {NotifyRequestWithContent} [notifyRequestWithContent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyTeamMember(userId: string, destinations?: Array<NotifyTeamMemberDestinationsEnum>, notifyRequestWithContent?: NotifyRequestWithContent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyTeamMember(userId, destinations, notifyRequestWithContent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notifyTeamMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Send a notification to a team member
         * @param {NotificationsApiNotifyTeamMemberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyTeamMember(requestParameters: NotificationsApiNotifyTeamMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.notifyTeamMember(requestParameters.userId, requestParameters.destinations, requestParameters.notifyRequestWithContent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for notifyTeamMember operation in NotificationsApi.
 * @export
 * @interface NotificationsApiNotifyTeamMemberRequest
 */
export interface NotificationsApiNotifyTeamMemberRequest {
    /**
     * 
     * @type {string}
     * @memberof NotificationsApiNotifyTeamMember
     */
    readonly userId: string

    /**
     * The destinations to send the notification to
     * @type {Array<'email' | 'push'>}
     * @memberof NotificationsApiNotifyTeamMember
     */
    readonly destinations?: Array<NotifyTeamMemberDestinationsEnum>

    /**
     * 
     * @type {NotifyRequestWithContent}
     * @memberof NotificationsApiNotifyTeamMember
     */
    readonly notifyRequestWithContent?: NotifyRequestWithContent
}

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @summary Send a notification to a team member
     * @param {NotificationsApiNotifyTeamMemberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notifyTeamMember(requestParameters: NotificationsApiNotifyTeamMemberRequest, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notifyTeamMember(requestParameters.userId, requestParameters.destinations, requestParameters.notifyRequestWithContent, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const NotifyTeamMemberDestinationsEnum = {
    Email: 'email',
    Push: 'push'
} as const;
export type NotifyTeamMemberDestinationsEnum = typeof NotifyTeamMemberDestinationsEnum[keyof typeof NotifyTeamMemberDestinationsEnum];


/**
 * OAuthApi - axios parameter creator
 * @export
 */
export const OAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If the token is not specified, all tokens of the user are revoked
         * @summary Revoke refresh tokens
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDelete: async (token?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TOKENS_DELETE"], configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns in descending order of most recently used
         * @summary Fetch list of tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TOKENS_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a new access token, and optionally a refresh token. The refresh token can then be used to generate a new access token when the current one expires.  The token can be generated either via a phone number/password combo or via a refresh token. 
         * @summary Generate a new token
         * @param {AuthRequest} [authRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost: async (authRequest?: AuthRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login via an external partner
         * @param {ExternalTokenRequest} [externalTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPostExternal: async (externalTokenRequest?: ExternalTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token/external`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(externalTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthApi - functional programming interface
 * @export
 */
export const OAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * If the token is not specified, all tokens of the user are revoked
         * @summary Revoke refresh tokens
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenDelete(token?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenDelete(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.tokenDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns in descending order of most recently used
         * @summary Fetch list of tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefreshToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.tokenGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates a new access token, and optionally a refresh token. The refresh token can then be used to generate a new access token when the current one expires.  The token can be generated either via a phone number/password combo or via a refresh token. 
         * @summary Generate a new token
         * @param {AuthRequest} [authRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenPost(authRequest?: AuthRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenPost(authRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.tokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login via an external partner
         * @param {ExternalTokenRequest} [externalTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenPostExternal(externalTokenRequest?: ExternalTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalTokenPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenPostExternal(externalTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.tokenPostExternal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OAuthApi - factory interface
 * @export
 */
export const OAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthApiFp(configuration)
    return {
        /**
         * If the token is not specified, all tokens of the user are revoked
         * @summary Revoke refresh tokens
         * @param {OAuthApiTokenDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDelete(requestParameters: OAuthApiTokenDeleteRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tokenDelete(requestParameters.token, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns in descending order of most recently used
         * @summary Fetch list of tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<RefreshToken>> {
            return localVarFp.tokenGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a new access token, and optionally a refresh token. The refresh token can then be used to generate a new access token when the current one expires.  The token can be generated either via a phone number/password combo or via a refresh token. 
         * @summary Generate a new token
         * @param {OAuthApiTokenPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost(requestParameters: OAuthApiTokenPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<TokenPost200Response> {
            return localVarFp.tokenPost(requestParameters.authRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login via an external partner
         * @param {OAuthApiTokenPostExternalRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPostExternal(requestParameters: OAuthApiTokenPostExternalRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ExternalTokenPostResponse> {
            return localVarFp.tokenPostExternal(requestParameters.externalTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for tokenDelete operation in OAuthApi.
 * @export
 * @interface OAuthApiTokenDeleteRequest
 */
export interface OAuthApiTokenDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof OAuthApiTokenDelete
     */
    readonly token?: string
}

/**
 * Request parameters for tokenPost operation in OAuthApi.
 * @export
 * @interface OAuthApiTokenPostRequest
 */
export interface OAuthApiTokenPostRequest {
    /**
     * 
     * @type {AuthRequest}
     * @memberof OAuthApiTokenPost
     */
    readonly authRequest?: AuthRequest
}

/**
 * Request parameters for tokenPostExternal operation in OAuthApi.
 * @export
 * @interface OAuthApiTokenPostExternalRequest
 */
export interface OAuthApiTokenPostExternalRequest {
    /**
     * 
     * @type {ExternalTokenRequest}
     * @memberof OAuthApiTokenPostExternal
     */
    readonly externalTokenRequest?: ExternalTokenRequest
}

/**
 * OAuthApi - object-oriented interface
 * @export
 * @class OAuthApi
 * @extends {BaseAPI}
 */
export class OAuthApi extends BaseAPI {
    /**
     * If the token is not specified, all tokens of the user are revoked
     * @summary Revoke refresh tokens
     * @param {OAuthApiTokenDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public tokenDelete(requestParameters: OAuthApiTokenDeleteRequest = {}, options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).tokenDelete(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns in descending order of most recently used
     * @summary Fetch list of tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public tokenGet(options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).tokenGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a new access token, and optionally a refresh token. The refresh token can then be used to generate a new access token when the current one expires.  The token can be generated either via a phone number/password combo or via a refresh token. 
     * @summary Generate a new token
     * @param {OAuthApiTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public tokenPost(requestParameters: OAuthApiTokenPostRequest = {}, options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).tokenPost(requestParameters.authRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login via an external partner
     * @param {OAuthApiTokenPostExternalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public tokenPostExternal(requestParameters: OAuthApiTokenPostExternalRequest = {}, options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).tokenPostExternal(requestParameters.externalTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OTPApi - axios parameter creator
 * @export
 */
export const OTPApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sends an OTP to user input email address for verification purposes.
         * @summary Send email OTP
         * @param {EmailOtpRequest} [emailOtpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailOtpPost: async (emailOtpRequest?: EmailOtpRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/email-otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailOtpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an OTP for the given phone number. Once generated, the OTP can be used to authenticate the user for specific APIs, i.e. signup & forget password.  A captcha token is required to generate an OTP, available only from the frontend 
         * @summary Generate an OTP
         * @param {OtpPostChannelEnum} [channel] 
         * @param {OtpPostRequest} [otpPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        otpPost: async (channel?: OtpPostChannelEnum, otpPostRequest?: OtpPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(otpPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies the OTP sent to the user\'s email address.
         * @summary Verify email OTP
         * @param {VerifyEmailRequest} [verifyEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail: async (verifyEmailRequest?: VerifyEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/email-otp-verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OTPApi - functional programming interface
 * @export
 */
export const OTPApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OTPApiAxiosParamCreator(configuration)
    return {
        /**
         * Sends an OTP to user input email address for verification purposes.
         * @summary Send email OTP
         * @param {EmailOtpRequest} [emailOtpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailOtpPost(emailOtpRequest?: EmailOtpRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailOtpPost(emailOtpRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OTPApi.emailOtpPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates an OTP for the given phone number. Once generated, the OTP can be used to authenticate the user for specific APIs, i.e. signup & forget password.  A captcha token is required to generate an OTP, available only from the frontend 
         * @summary Generate an OTP
         * @param {OtpPostChannelEnum} [channel] 
         * @param {OtpPostRequest} [otpPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async otpPost(channel?: OtpPostChannelEnum, otpPostRequest?: OtpPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OTP>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.otpPost(channel, otpPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OTPApi.otpPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies the OTP sent to the user\'s email address.
         * @summary Verify email OTP
         * @param {VerifyEmailRequest} [verifyEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmail(verifyEmailRequest?: VerifyEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyEmail200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmail(verifyEmailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OTPApi.verifyEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OTPApi - factory interface
 * @export
 */
export const OTPApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OTPApiFp(configuration)
    return {
        /**
         * Sends an OTP to user input email address for verification purposes.
         * @summary Send email OTP
         * @param {OTPApiEmailOtpPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailOtpPost(requestParameters: OTPApiEmailOtpPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.emailOtpPost(requestParameters.emailOtpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an OTP for the given phone number. Once generated, the OTP can be used to authenticate the user for specific APIs, i.e. signup & forget password.  A captcha token is required to generate an OTP, available only from the frontend 
         * @summary Generate an OTP
         * @param {OTPApiOtpPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        otpPost(requestParameters: OTPApiOtpPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<OTP> {
            return localVarFp.otpPost(requestParameters.channel, requestParameters.otpPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies the OTP sent to the user\'s email address.
         * @summary Verify email OTP
         * @param {OTPApiVerifyEmailRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(requestParameters: OTPApiVerifyEmailRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<VerifyEmail200Response> {
            return localVarFp.verifyEmail(requestParameters.verifyEmailRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for emailOtpPost operation in OTPApi.
 * @export
 * @interface OTPApiEmailOtpPostRequest
 */
export interface OTPApiEmailOtpPostRequest {
    /**
     * 
     * @type {EmailOtpRequest}
     * @memberof OTPApiEmailOtpPost
     */
    readonly emailOtpRequest?: EmailOtpRequest
}

/**
 * Request parameters for otpPost operation in OTPApi.
 * @export
 * @interface OTPApiOtpPostRequest
 */
export interface OTPApiOtpPostRequest {
    /**
     * 
     * @type {'whatsapp'}
     * @memberof OTPApiOtpPost
     */
    readonly channel?: OtpPostChannelEnum

    /**
     * 
     * @type {OtpPostRequest}
     * @memberof OTPApiOtpPost
     */
    readonly otpPostRequest?: OtpPostRequest
}

/**
 * Request parameters for verifyEmail operation in OTPApi.
 * @export
 * @interface OTPApiVerifyEmailRequest
 */
export interface OTPApiVerifyEmailRequest {
    /**
     * 
     * @type {VerifyEmailRequest}
     * @memberof OTPApiVerifyEmail
     */
    readonly verifyEmailRequest?: VerifyEmailRequest
}

/**
 * OTPApi - object-oriented interface
 * @export
 * @class OTPApi
 * @extends {BaseAPI}
 */
export class OTPApi extends BaseAPI {
    /**
     * Sends an OTP to user input email address for verification purposes.
     * @summary Send email OTP
     * @param {OTPApiEmailOtpPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OTPApi
     */
    public emailOtpPost(requestParameters: OTPApiEmailOtpPostRequest = {}, options?: RawAxiosRequestConfig) {
        return OTPApiFp(this.configuration).emailOtpPost(requestParameters.emailOtpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an OTP for the given phone number. Once generated, the OTP can be used to authenticate the user for specific APIs, i.e. signup & forget password.  A captcha token is required to generate an OTP, available only from the frontend 
     * @summary Generate an OTP
     * @param {OTPApiOtpPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OTPApi
     */
    public otpPost(requestParameters: OTPApiOtpPostRequest = {}, options?: RawAxiosRequestConfig) {
        return OTPApiFp(this.configuration).otpPost(requestParameters.channel, requestParameters.otpPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies the OTP sent to the user\'s email address.
     * @summary Verify email OTP
     * @param {OTPApiVerifyEmailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OTPApi
     */
    public verifyEmail(requestParameters: OTPApiVerifyEmailRequest = {}, options?: RawAxiosRequestConfig) {
        return OTPApiFp(this.configuration).verifyEmail(requestParameters.verifyEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const OtpPostChannelEnum = {
    Whatsapp: 'whatsapp'
} as const;
export type OtpPostChannelEnum = typeof OtpPostChannelEnum[keyof typeof OtpPostChannelEnum];


/**
 * PinnedFiltersApi - axios parameter creator
 * @export
 */
export const PinnedFiltersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a pinned filter
         * @param {string} name name of filter to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboxFiltersDelete: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('inboxFiltersDelete', 'name', name)
            const localVarPath = `/inbox-filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read pinned filters created by a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboxFiltersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/inbox-filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new pinned filter
         * @param {InboxFilterData} [inboxFilterData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboxFiltersPost: async (inboxFilterData?: InboxFilterData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/inbox-filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inboxFilterData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rename a pinned filter
         * @param {string} nameToUpdate name of filter to update
         * @param {InboxFilterName} [inboxFilterName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboxFiltersUpdate: async (nameToUpdate: string, inboxFilterName?: InboxFilterName, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nameToUpdate' is not null or undefined
            assertParamExists('inboxFiltersUpdate', 'nameToUpdate', nameToUpdate)
            const localVarPath = `/inbox-filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (nameToUpdate !== undefined) {
                localVarQueryParameter['nameToUpdate'] = nameToUpdate;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inboxFilterName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PinnedFiltersApi - functional programming interface
 * @export
 */
export const PinnedFiltersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PinnedFiltersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a pinned filter
         * @param {string} name name of filter to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inboxFiltersDelete(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inboxFiltersDelete(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PinnedFiltersApi.inboxFiltersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Read pinned filters created by a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inboxFiltersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InboxFilterData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inboxFiltersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PinnedFiltersApi.inboxFiltersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create new pinned filter
         * @param {InboxFilterData} [inboxFilterData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inboxFiltersPost(inboxFilterData?: InboxFilterData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inboxFiltersPost(inboxFilterData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PinnedFiltersApi.inboxFiltersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Rename a pinned filter
         * @param {string} nameToUpdate name of filter to update
         * @param {InboxFilterName} [inboxFilterName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inboxFiltersUpdate(nameToUpdate: string, inboxFilterName?: InboxFilterName, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inboxFiltersUpdate(nameToUpdate, inboxFilterName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PinnedFiltersApi.inboxFiltersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PinnedFiltersApi - factory interface
 * @export
 */
export const PinnedFiltersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PinnedFiltersApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a pinned filter
         * @param {PinnedFiltersApiInboxFiltersDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboxFiltersDelete(requestParameters: PinnedFiltersApiInboxFiltersDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.inboxFiltersDelete(requestParameters.name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read pinned filters created by a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboxFiltersGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<InboxFilterData>> {
            return localVarFp.inboxFiltersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new pinned filter
         * @param {PinnedFiltersApiInboxFiltersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboxFiltersPost(requestParameters: PinnedFiltersApiInboxFiltersPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.inboxFiltersPost(requestParameters.inboxFilterData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rename a pinned filter
         * @param {PinnedFiltersApiInboxFiltersUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inboxFiltersUpdate(requestParameters: PinnedFiltersApiInboxFiltersUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.inboxFiltersUpdate(requestParameters.nameToUpdate, requestParameters.inboxFilterName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for inboxFiltersDelete operation in PinnedFiltersApi.
 * @export
 * @interface PinnedFiltersApiInboxFiltersDeleteRequest
 */
export interface PinnedFiltersApiInboxFiltersDeleteRequest {
    /**
     * name of filter to delete
     * @type {string}
     * @memberof PinnedFiltersApiInboxFiltersDelete
     */
    readonly name: string
}

/**
 * Request parameters for inboxFiltersPost operation in PinnedFiltersApi.
 * @export
 * @interface PinnedFiltersApiInboxFiltersPostRequest
 */
export interface PinnedFiltersApiInboxFiltersPostRequest {
    /**
     * 
     * @type {InboxFilterData}
     * @memberof PinnedFiltersApiInboxFiltersPost
     */
    readonly inboxFilterData?: InboxFilterData
}

/**
 * Request parameters for inboxFiltersUpdate operation in PinnedFiltersApi.
 * @export
 * @interface PinnedFiltersApiInboxFiltersUpdateRequest
 */
export interface PinnedFiltersApiInboxFiltersUpdateRequest {
    /**
     * name of filter to update
     * @type {string}
     * @memberof PinnedFiltersApiInboxFiltersUpdate
     */
    readonly nameToUpdate: string

    /**
     * 
     * @type {InboxFilterName}
     * @memberof PinnedFiltersApiInboxFiltersUpdate
     */
    readonly inboxFilterName?: InboxFilterName
}

/**
 * PinnedFiltersApi - object-oriented interface
 * @export
 * @class PinnedFiltersApi
 * @extends {BaseAPI}
 */
export class PinnedFiltersApi extends BaseAPI {
    /**
     * 
     * @summary Delete a pinned filter
     * @param {PinnedFiltersApiInboxFiltersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinnedFiltersApi
     */
    public inboxFiltersDelete(requestParameters: PinnedFiltersApiInboxFiltersDeleteRequest, options?: RawAxiosRequestConfig) {
        return PinnedFiltersApiFp(this.configuration).inboxFiltersDelete(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read pinned filters created by a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinnedFiltersApi
     */
    public inboxFiltersGet(options?: RawAxiosRequestConfig) {
        return PinnedFiltersApiFp(this.configuration).inboxFiltersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new pinned filter
     * @param {PinnedFiltersApiInboxFiltersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinnedFiltersApi
     */
    public inboxFiltersPost(requestParameters: PinnedFiltersApiInboxFiltersPostRequest = {}, options?: RawAxiosRequestConfig) {
        return PinnedFiltersApiFp(this.configuration).inboxFiltersPost(requestParameters.inboxFilterData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rename a pinned filter
     * @param {PinnedFiltersApiInboxFiltersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinnedFiltersApi
     */
    public inboxFiltersUpdate(requestParameters: PinnedFiltersApiInboxFiltersUpdateRequest, options?: RawAxiosRequestConfig) {
        return PinnedFiltersApiFp(this.configuration).inboxFiltersUpdate(requestParameters.nameToUpdate, requestParameters.inboxFilterName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubUserApi - axios parameter creator
 * @export
 */
export const SubUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a sub user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subUserDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subUserDelete', 'id', id)
            const localVarPath = `/sub-user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEAMMEMBERS_UPDATE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout a sub user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subUserLogout: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subUserLogout', 'id', id)
            const localVarPath = `/sub-user/{id}/logout`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["LOGOUT_SUB_USER"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a sub user
         * @param {string} id 
         * @param {ResetPassword} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subUserPatch: async (id: string, resetPassword?: ResetPassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subUserPatch', 'id', id)
            const localVarPath = `/sub-user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEAMMEMBERS_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a sub user
         * @param {SubUserCreate} [subUserCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subUserPost: async (subUserCreate?: SubUserCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sub-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["CREATE_SUB_USER"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subUserCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubUserApi - functional programming interface
 * @export
 */
export const SubUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubUserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a sub user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subUserDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subUserDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubUserApi.subUserDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout a sub user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subUserLogout(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subUserLogout(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubUserApi.subUserLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a sub user
         * @param {string} id 
         * @param {ResetPassword} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subUserPatch(id: string, resetPassword?: ResetPassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subUserPatch(id, resetPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubUserApi.subUserPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a sub user
         * @param {SubUserCreate} [subUserCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subUserPost(subUserCreate?: SubUserCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subUserPost(subUserCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubUserApi.subUserPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubUserApi - factory interface
 * @export
 */
export const SubUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubUserApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a sub user
         * @param {SubUserApiSubUserDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subUserDelete(requestParameters: SubUserApiSubUserDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.subUserDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout a sub user
         * @param {SubUserApiSubUserLogoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subUserLogout(requestParameters: SubUserApiSubUserLogoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.subUserLogout(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a sub user
         * @param {SubUserApiSubUserPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subUserPatch(requestParameters: SubUserApiSubUserPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.subUserPatch(requestParameters.id, requestParameters.resetPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a sub user
         * @param {SubUserApiSubUserPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subUserPost(requestParameters: SubUserApiSubUserPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.subUserPost(requestParameters.subUserCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for subUserDelete operation in SubUserApi.
 * @export
 * @interface SubUserApiSubUserDeleteRequest
 */
export interface SubUserApiSubUserDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof SubUserApiSubUserDelete
     */
    readonly id: string
}

/**
 * Request parameters for subUserLogout operation in SubUserApi.
 * @export
 * @interface SubUserApiSubUserLogoutRequest
 */
export interface SubUserApiSubUserLogoutRequest {
    /**
     * 
     * @type {string}
     * @memberof SubUserApiSubUserLogout
     */
    readonly id: string
}

/**
 * Request parameters for subUserPatch operation in SubUserApi.
 * @export
 * @interface SubUserApiSubUserPatchRequest
 */
export interface SubUserApiSubUserPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof SubUserApiSubUserPatch
     */
    readonly id: string

    /**
     * 
     * @type {ResetPassword}
     * @memberof SubUserApiSubUserPatch
     */
    readonly resetPassword?: ResetPassword
}

/**
 * Request parameters for subUserPost operation in SubUserApi.
 * @export
 * @interface SubUserApiSubUserPostRequest
 */
export interface SubUserApiSubUserPostRequest {
    /**
     * 
     * @type {SubUserCreate}
     * @memberof SubUserApiSubUserPost
     */
    readonly subUserCreate?: SubUserCreate
}

/**
 * SubUserApi - object-oriented interface
 * @export
 * @class SubUserApi
 * @extends {BaseAPI}
 */
export class SubUserApi extends BaseAPI {
    /**
     * 
     * @summary Delete a sub user
     * @param {SubUserApiSubUserDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubUserApi
     */
    public subUserDelete(requestParameters: SubUserApiSubUserDeleteRequest, options?: RawAxiosRequestConfig) {
        return SubUserApiFp(this.configuration).subUserDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout a sub user
     * @param {SubUserApiSubUserLogoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubUserApi
     */
    public subUserLogout(requestParameters: SubUserApiSubUserLogoutRequest, options?: RawAxiosRequestConfig) {
        return SubUserApiFp(this.configuration).subUserLogout(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a sub user
     * @param {SubUserApiSubUserPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubUserApi
     */
    public subUserPatch(requestParameters: SubUserApiSubUserPatchRequest, options?: RawAxiosRequestConfig) {
        return SubUserApiFp(this.configuration).subUserPatch(requestParameters.id, requestParameters.resetPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a sub user
     * @param {SubUserApiSubUserPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubUserApi
     */
    public subUserPost(requestParameters: SubUserApiSubUserPostRequest = {}, options?: RawAxiosRequestConfig) {
        return SubUserApiFp(this.configuration).subUserPost(requestParameters.subUserCreate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamsApi - axios parameter creator
 * @export
 */
export const TeamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch partner admin teamIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerAdminGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/teams/partner-admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upgrade the team to \'partner\' if partner is specified, else, downgrade partner status
         * @param {string} teamId the teamId of the team to be upgraded/downgraded
         * @param {PartnerTeamPatchRequest} [partnerTeamPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTeamPatch: async (teamId: string, partnerTeamPatchRequest?: PartnerTeamPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('partnerTeamPatch', 'teamId', teamId)
            const localVarPath = `/teams/partner-team-status/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partnerTeamPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark a team as having completed an onboarding step
         * @param {OnboardingStepID} step the onboarding step to mark as completed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsCompletedOnboardingStepPost: async (step: OnboardingStepID, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'step' is not null or undefined
            assertParamExists('teamsCompletedOnboardingStepPost', 'step', step)
            const localVarPath = `/teams/completed-onboarding-step/{step}`
                .replace(`{${"step"}}`, encodeURIComponent(String(step)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch teams you have access to
         * @param {string} [q] Search by name, ID, invite code, etc.
         * @param {string} [partnership] Search by partnership
         * @param {number} [onboardingScoreMin] The minimum onboarding score of the teams to return
         * @param {number} [onboardingScoreMax] The maximum onboarding score of the teams to return
         * @param {string} [createdAfter] Teams after a given date-time
         * @param {Array<OnboardingStepID>} [completedSteps] Teams that have completed the given Steps
         * @param {Array<string>} [id] Fetch specific teams by ID
         * @param {string} [userId] teams that contain this user ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeTeamMembers] Should include the team members. Will only return members for which you have the &#x60;TEAMMEMBERS_READ&#x60; scope
         * @param {boolean} [includeInviteLinks] Should include the invite links.  Will only return invite links for which you have the &#x60;TEAMLINKS_READ&#x60; scope
         * @param {boolean} [includeTotal] include the count of the total teams
         * @param {boolean} [includeCreator] include the creator\&#39;s data in the API result
         * @param {string} [partner] string to identify user with a partner
         * @param {boolean} [returnOnboardingScore] return the onboarding score for the team
         * @param {boolean} [isCreditSystemCustomer] If true, only return teams that are credit system customers. If false, only return teams that are not credit system customers. A team is only considered a credit system customer if they have a \&quot;creditCustomerId\&quot; set.
         * @param {TeamsGetVariantEnum} [variant] The variant of the team to return. lite or chatdaddy. If not specified, returns chatdaddy teams only. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsGet: async (q?: string, partnership?: string, onboardingScoreMin?: number, onboardingScoreMax?: number, createdAfter?: string, completedSteps?: Array<OnboardingStepID>, id?: Array<string>, userId?: string, count?: number, page?: number, includeTeamMembers?: boolean, includeInviteLinks?: boolean, includeTotal?: boolean, includeCreator?: boolean, partner?: string, returnOnboardingScore?: boolean, isCreditSystemCustomer?: boolean, variant?: TeamsGetVariantEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (partnership !== undefined) {
                localVarQueryParameter['partnership'] = partnership;
            }

            if (onboardingScoreMin !== undefined) {
                localVarQueryParameter['onboardingScoreMin'] = onboardingScoreMin;
            }

            if (onboardingScoreMax !== undefined) {
                localVarQueryParameter['onboardingScoreMax'] = onboardingScoreMax;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['createdAfter'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (completedSteps) {
                localVarQueryParameter['completedSteps'] = completedSteps;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includeTeamMembers !== undefined) {
                localVarQueryParameter['includeTeamMembers'] = includeTeamMembers;
            }

            if (includeInviteLinks !== undefined) {
                localVarQueryParameter['includeInviteLinks'] = includeInviteLinks;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['includeTotal'] = includeTotal;
            }

            if (includeCreator !== undefined) {
                localVarQueryParameter['includeCreator'] = includeCreator;
            }

            if (partner !== undefined) {
                localVarQueryParameter['partner'] = partner;
            }

            if (returnOnboardingScore !== undefined) {
                localVarQueryParameter['returnOnboardingScore'] = returnOnboardingScore;
            }

            if (isCreditSystemCustomer !== undefined) {
                localVarQueryParameter['isCreditSystemCustomer'] = isCreditSystemCustomer;
            }

            if (variant !== undefined) {
                localVarQueryParameter['variant'] = variant;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join a team
         * @param {string} id inviteLink ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsJoinInvite: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teamsJoinInvite', 'id', id)
            const localVarPath = `/teams/join`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leave a team
         * @param {string} teamId the teamId of the team to leave
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsLeave: async (teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamsLeave', 'teamId', teamId)
            const localVarPath = `/teams/leave/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * - If you want to update/delete members -- ensure you have the `TEAMMEMBERS_UPDATE` scope - If you want to delete invite links -- ensure you have the `TEAMLINKS_UPDATE` scope - Also you cannot delete/update yourself in the team. If you attempt to do so, a 400 will be returned - If scopes and role are both specified, scopes will be ignored 
         * @summary Update the team the access token is for
         * @param {TeamPatchRequest} [teamPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsPatch: async (teamPatchRequest?: TeamPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["TEAM_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 * @export
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch partner admin teamIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerAdminGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerAdminGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerAdminGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.partnerAdminGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upgrade the team to \'partner\' if partner is specified, else, downgrade partner status
         * @param {string} teamId the teamId of the team to be upgraded/downgraded
         * @param {PartnerTeamPatchRequest} [partnerTeamPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partnerTeamPatch(teamId: string, partnerTeamPatchRequest?: PartnerTeamPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamsPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partnerTeamPatch(teamId, partnerTeamPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.partnerTeamPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Mark a team as having completed an onboarding step
         * @param {OnboardingStepID} step the onboarding step to mark as completed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsCompletedOnboardingStepPost(step: OnboardingStepID, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamsPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsCompletedOnboardingStepPost(step, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.teamsCompletedOnboardingStepPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch teams you have access to
         * @param {string} [q] Search by name, ID, invite code, etc.
         * @param {string} [partnership] Search by partnership
         * @param {number} [onboardingScoreMin] The minimum onboarding score of the teams to return
         * @param {number} [onboardingScoreMax] The maximum onboarding score of the teams to return
         * @param {string} [createdAfter] Teams after a given date-time
         * @param {Array<OnboardingStepID>} [completedSteps] Teams that have completed the given Steps
         * @param {Array<string>} [id] Fetch specific teams by ID
         * @param {string} [userId] teams that contain this user ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeTeamMembers] Should include the team members. Will only return members for which you have the &#x60;TEAMMEMBERS_READ&#x60; scope
         * @param {boolean} [includeInviteLinks] Should include the invite links.  Will only return invite links for which you have the &#x60;TEAMLINKS_READ&#x60; scope
         * @param {boolean} [includeTotal] include the count of the total teams
         * @param {boolean} [includeCreator] include the creator\&#39;s data in the API result
         * @param {string} [partner] string to identify user with a partner
         * @param {boolean} [returnOnboardingScore] return the onboarding score for the team
         * @param {boolean} [isCreditSystemCustomer] If true, only return teams that are credit system customers. If false, only return teams that are not credit system customers. A team is only considered a credit system customer if they have a \&quot;creditCustomerId\&quot; set.
         * @param {TeamsGetVariantEnum} [variant] The variant of the team to return. lite or chatdaddy. If not specified, returns chatdaddy teams only. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsGet(q?: string, partnership?: string, onboardingScoreMin?: number, onboardingScoreMax?: number, createdAfter?: string, completedSteps?: Array<OnboardingStepID>, id?: Array<string>, userId?: string, count?: number, page?: number, includeTeamMembers?: boolean, includeInviteLinks?: boolean, includeTotal?: boolean, includeCreator?: boolean, partner?: string, returnOnboardingScore?: boolean, isCreditSystemCustomer?: boolean, variant?: TeamsGetVariantEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsGet(q, partnership, onboardingScoreMin, onboardingScoreMax, createdAfter, completedSteps, id, userId, count, page, includeTeamMembers, includeInviteLinks, includeTotal, includeCreator, partner, returnOnboardingScore, isCreditSystemCustomer, variant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.teamsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Join a team
         * @param {string} id inviteLink ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsJoinInvite(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsJoinInvite(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.teamsJoinInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Leave a team
         * @param {string} teamId the teamId of the team to leave
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsLeave(teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsLeave(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.teamsLeave']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * - If you want to update/delete members -- ensure you have the `TEAMMEMBERS_UPDATE` scope - If you want to delete invite links -- ensure you have the `TEAMLINKS_UPDATE` scope - Also you cannot delete/update yourself in the team. If you attempt to do so, a 400 will be returned - If scopes and role are both specified, scopes will be ignored 
         * @summary Update the team the access token is for
         * @param {TeamPatchRequest} [teamPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsPatch(teamPatchRequest?: TeamPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamsPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsPatch(teamPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.teamsPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamsApi - factory interface
 * @export
 */
export const TeamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamsApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch partner admin teamIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerAdminGet(options?: RawAxiosRequestConfig): AxiosPromise<PartnerAdminGet200Response> {
            return localVarFp.partnerAdminGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upgrade the team to \'partner\' if partner is specified, else, downgrade partner status
         * @param {TeamsApiPartnerTeamPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partnerTeamPatch(requestParameters: TeamsApiPartnerTeamPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<TeamsPatch200Response> {
            return localVarFp.partnerTeamPatch(requestParameters.teamId, requestParameters.partnerTeamPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark a team as having completed an onboarding step
         * @param {TeamsApiTeamsCompletedOnboardingStepPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsCompletedOnboardingStepPost(requestParameters: TeamsApiTeamsCompletedOnboardingStepPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TeamsPatch200Response> {
            return localVarFp.teamsCompletedOnboardingStepPost(requestParameters.step, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch teams you have access to
         * @param {TeamsApiTeamsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsGet(requestParameters: TeamsApiTeamsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<TeamsGet200Response> {
            return localVarFp.teamsGet(requestParameters.q, requestParameters.partnership, requestParameters.onboardingScoreMin, requestParameters.onboardingScoreMax, requestParameters.createdAfter, requestParameters.completedSteps, requestParameters.id, requestParameters.userId, requestParameters.count, requestParameters.page, requestParameters.includeTeamMembers, requestParameters.includeInviteLinks, requestParameters.includeTotal, requestParameters.includeCreator, requestParameters.partner, requestParameters.returnOnboardingScore, requestParameters.isCreditSystemCustomer, requestParameters.variant, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join a team
         * @param {TeamsApiTeamsJoinInviteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsJoinInvite(requestParameters: TeamsApiTeamsJoinInviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.teamsJoinInvite(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Leave a team
         * @param {TeamsApiTeamsLeaveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsLeave(requestParameters: TeamsApiTeamsLeaveRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.teamsLeave(requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * - If you want to update/delete members -- ensure you have the `TEAMMEMBERS_UPDATE` scope - If you want to delete invite links -- ensure you have the `TEAMLINKS_UPDATE` scope - Also you cannot delete/update yourself in the team. If you attempt to do so, a 400 will be returned - If scopes and role are both specified, scopes will be ignored 
         * @summary Update the team the access token is for
         * @param {TeamsApiTeamsPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsPatch(requestParameters: TeamsApiTeamsPatchRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<TeamsPatch200Response> {
            return localVarFp.teamsPatch(requestParameters.teamPatchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for partnerTeamPatch operation in TeamsApi.
 * @export
 * @interface TeamsApiPartnerTeamPatchRequest
 */
export interface TeamsApiPartnerTeamPatchRequest {
    /**
     * the teamId of the team to be upgraded/downgraded
     * @type {string}
     * @memberof TeamsApiPartnerTeamPatch
     */
    readonly teamId: string

    /**
     * 
     * @type {PartnerTeamPatchRequest}
     * @memberof TeamsApiPartnerTeamPatch
     */
    readonly partnerTeamPatchRequest?: PartnerTeamPatchRequest
}

/**
 * Request parameters for teamsCompletedOnboardingStepPost operation in TeamsApi.
 * @export
 * @interface TeamsApiTeamsCompletedOnboardingStepPostRequest
 */
export interface TeamsApiTeamsCompletedOnboardingStepPostRequest {
    /**
     * the onboarding step to mark as completed
     * @type {OnboardingStepID}
     * @memberof TeamsApiTeamsCompletedOnboardingStepPost
     */
    readonly step: OnboardingStepID
}

/**
 * Request parameters for teamsGet operation in TeamsApi.
 * @export
 * @interface TeamsApiTeamsGetRequest
 */
export interface TeamsApiTeamsGetRequest {
    /**
     * Search by name, ID, invite code, etc.
     * @type {string}
     * @memberof TeamsApiTeamsGet
     */
    readonly q?: string

    /**
     * Search by partnership
     * @type {string}
     * @memberof TeamsApiTeamsGet
     */
    readonly partnership?: string

    /**
     * The minimum onboarding score of the teams to return
     * @type {number}
     * @memberof TeamsApiTeamsGet
     */
    readonly onboardingScoreMin?: number

    /**
     * The maximum onboarding score of the teams to return
     * @type {number}
     * @memberof TeamsApiTeamsGet
     */
    readonly onboardingScoreMax?: number

    /**
     * Teams after a given date-time
     * @type {string}
     * @memberof TeamsApiTeamsGet
     */
    readonly createdAfter?: string

    /**
     * Teams that have completed the given Steps
     * @type {Array<OnboardingStepID>}
     * @memberof TeamsApiTeamsGet
     */
    readonly completedSteps?: Array<OnboardingStepID>

    /**
     * Fetch specific teams by ID
     * @type {Array<string>}
     * @memberof TeamsApiTeamsGet
     */
    readonly id?: Array<string>

    /**
     * teams that contain this user ID
     * @type {string}
     * @memberof TeamsApiTeamsGet
     */
    readonly userId?: string

    /**
     * The numbers of items to return
     * @type {number}
     * @memberof TeamsApiTeamsGet
     */
    readonly count?: number

    /**
     * The page number
     * @type {number}
     * @memberof TeamsApiTeamsGet
     */
    readonly page?: number

    /**
     * Should include the team members. Will only return members for which you have the &#x60;TEAMMEMBERS_READ&#x60; scope
     * @type {boolean}
     * @memberof TeamsApiTeamsGet
     */
    readonly includeTeamMembers?: boolean

    /**
     * Should include the invite links.  Will only return invite links for which you have the &#x60;TEAMLINKS_READ&#x60; scope
     * @type {boolean}
     * @memberof TeamsApiTeamsGet
     */
    readonly includeInviteLinks?: boolean

    /**
     * include the count of the total teams
     * @type {boolean}
     * @memberof TeamsApiTeamsGet
     */
    readonly includeTotal?: boolean

    /**
     * include the creator\&#39;s data in the API result
     * @type {boolean}
     * @memberof TeamsApiTeamsGet
     */
    readonly includeCreator?: boolean

    /**
     * string to identify user with a partner
     * @type {string}
     * @memberof TeamsApiTeamsGet
     */
    readonly partner?: string

    /**
     * return the onboarding score for the team
     * @type {boolean}
     * @memberof TeamsApiTeamsGet
     */
    readonly returnOnboardingScore?: boolean

    /**
     * If true, only return teams that are credit system customers. If false, only return teams that are not credit system customers. A team is only considered a credit system customer if they have a \&quot;creditCustomerId\&quot; set.
     * @type {boolean}
     * @memberof TeamsApiTeamsGet
     */
    readonly isCreditSystemCustomer?: boolean

    /**
     * The variant of the team to return. lite or chatdaddy. If not specified, returns chatdaddy teams only. 
     * @type {'chatdaddy' | 'lite'}
     * @memberof TeamsApiTeamsGet
     */
    readonly variant?: TeamsGetVariantEnum
}

/**
 * Request parameters for teamsJoinInvite operation in TeamsApi.
 * @export
 * @interface TeamsApiTeamsJoinInviteRequest
 */
export interface TeamsApiTeamsJoinInviteRequest {
    /**
     * inviteLink ID
     * @type {string}
     * @memberof TeamsApiTeamsJoinInvite
     */
    readonly id: string
}

/**
 * Request parameters for teamsLeave operation in TeamsApi.
 * @export
 * @interface TeamsApiTeamsLeaveRequest
 */
export interface TeamsApiTeamsLeaveRequest {
    /**
     * the teamId of the team to leave
     * @type {string}
     * @memberof TeamsApiTeamsLeave
     */
    readonly teamId: string
}

/**
 * Request parameters for teamsPatch operation in TeamsApi.
 * @export
 * @interface TeamsApiTeamsPatchRequest
 */
export interface TeamsApiTeamsPatchRequest {
    /**
     * 
     * @type {TeamPatchRequest}
     * @memberof TeamsApiTeamsPatch
     */
    readonly teamPatchRequest?: TeamPatchRequest
}

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI {
    /**
     * 
     * @summary Fetch partner admin teamIds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public partnerAdminGet(options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).partnerAdminGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upgrade the team to \'partner\' if partner is specified, else, downgrade partner status
     * @param {TeamsApiPartnerTeamPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public partnerTeamPatch(requestParameters: TeamsApiPartnerTeamPatchRequest, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).partnerTeamPatch(requestParameters.teamId, requestParameters.partnerTeamPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark a team as having completed an onboarding step
     * @param {TeamsApiTeamsCompletedOnboardingStepPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsCompletedOnboardingStepPost(requestParameters: TeamsApiTeamsCompletedOnboardingStepPostRequest, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsCompletedOnboardingStepPost(requestParameters.step, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch teams you have access to
     * @param {TeamsApiTeamsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsGet(requestParameters: TeamsApiTeamsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsGet(requestParameters.q, requestParameters.partnership, requestParameters.onboardingScoreMin, requestParameters.onboardingScoreMax, requestParameters.createdAfter, requestParameters.completedSteps, requestParameters.id, requestParameters.userId, requestParameters.count, requestParameters.page, requestParameters.includeTeamMembers, requestParameters.includeInviteLinks, requestParameters.includeTotal, requestParameters.includeCreator, requestParameters.partner, requestParameters.returnOnboardingScore, requestParameters.isCreditSystemCustomer, requestParameters.variant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join a team
     * @param {TeamsApiTeamsJoinInviteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsJoinInvite(requestParameters: TeamsApiTeamsJoinInviteRequest, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsJoinInvite(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Leave a team
     * @param {TeamsApiTeamsLeaveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsLeave(requestParameters: TeamsApiTeamsLeaveRequest, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsLeave(requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * - If you want to update/delete members -- ensure you have the `TEAMMEMBERS_UPDATE` scope - If you want to delete invite links -- ensure you have the `TEAMLINKS_UPDATE` scope - Also you cannot delete/update yourself in the team. If you attempt to do so, a 400 will be returned - If scopes and role are both specified, scopes will be ignored 
     * @summary Update the team the access token is for
     * @param {TeamsApiTeamsPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsPatch(requestParameters: TeamsApiTeamsPatchRequest = {}, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamsPatch(requestParameters.teamPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const TeamsGetVariantEnum = {
    Chatdaddy: 'chatdaddy',
    Lite: 'lite'
} as const;
export type TeamsGetVariantEnum = typeof TeamsGetVariantEnum[keyof typeof TeamsGetVariantEnum];


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get total user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the user specified
         * @summary Delete a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersDelete', 'id', id)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch users you have access to
         * @param {string} [q] Search by name, ID, email, phone etc.
         * @param {string} [partnership] Search by partnership
         * @param {Array<string>} [id] Fetch specific users by ID
         * @param {Array<string>} [originalTeamId] Fetch specific users by original team ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeMemberships] Should include the user\&#39;s memberships
         * @param {boolean} [includeTotal] should return total count of accessible users
         * @param {Array<string>} [other] other internal query options
         * @param {UsersGetVariantEnum} [variant] The variant of the user to return. lite or chatdaddy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (q?: string, partnership?: string, id?: Array<string>, originalTeamId?: Array<string>, count?: number, page?: number, includeMemberships?: boolean, includeTotal?: boolean, other?: Array<string>, variant?: UsersGetVariantEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (partnership !== undefined) {
                localVarQueryParameter['partnership'] = partnership;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (originalTeamId) {
                localVarQueryParameter['originalTeamId'] = originalTeamId;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (includeMemberships !== undefined) {
                localVarQueryParameter['includeMemberships'] = includeMemberships;
            }

            if (includeTotal !== undefined) {
                localVarQueryParameter['includeTotal'] = includeTotal;
            }

            if (other) {
                localVarQueryParameter['other'] = other;
            }

            if (variant !== undefined) {
                localVarQueryParameter['variant'] = variant;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset user password
         * @param {ResetPassword} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPasswordPatch: async (resetPassword?: ResetPassword, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication otp required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the user in the access token
         * @param {string} [userId] Change the password of this user ID
         * @param {UserPatch} [userPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPatch: async (userId?: string, userPatch?: UserPatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["USERS_PATCH"], configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates users Phonenumber
         * @param {UsersPhoneNumberPatchRequest} [usersPhoneNumberPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPhoneNumberPatch: async (usersPhoneNumberPatchRequest?: UsersPhoneNumberPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/phonenumber`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication otp required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersPhoneNumberPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new user
         * @param {UserCreate} [userCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: async (userCreate?: UserCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication otp required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get total user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsersCount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the user specified
         * @summary Delete a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch users you have access to
         * @param {string} [q] Search by name, ID, email, phone etc.
         * @param {string} [partnership] Search by partnership
         * @param {Array<string>} [id] Fetch specific users by ID
         * @param {Array<string>} [originalTeamId] Fetch specific users by original team ID
         * @param {number} [count] The numbers of items to return
         * @param {number} [page] The page number
         * @param {boolean} [includeMemberships] Should include the user\&#39;s memberships
         * @param {boolean} [includeTotal] should return total count of accessible users
         * @param {Array<string>} [other] other internal query options
         * @param {UsersGetVariantEnum} [variant] The variant of the user to return. lite or chatdaddy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(q?: string, partnership?: string, id?: Array<string>, originalTeamId?: Array<string>, count?: number, page?: number, includeMemberships?: boolean, includeTotal?: boolean, other?: Array<string>, variant?: UsersGetVariantEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(q, partnership, id, originalTeamId, count, page, includeMemberships, includeTotal, other, variant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset user password
         * @param {ResetPassword} [resetPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPasswordPatch(resetPassword?: ResetPassword, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPasswordPatch(resetPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersPasswordPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the user in the access token
         * @param {string} [userId] Change the password of this user ID
         * @param {UserPatch} [userPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPatch(userId?: string, userPatch?: UserPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPatch(userId, userPatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates users Phonenumber
         * @param {UsersPhoneNumberPatchRequest} [usersPhoneNumberPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPhoneNumberPatch(usersPhoneNumberPatchRequest?: UsersPhoneNumberPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPhoneNumberPatch(usersPhoneNumberPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersPhoneNumberPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new user
         * @param {UserCreate} [userCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPost(userCreate?: UserCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(userCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get total user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersCount(options?: RawAxiosRequestConfig): AxiosPromise<GetUsersCount200Response> {
            return localVarFp.getUsersCount(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the user specified
         * @summary Delete a user
         * @param {UsersApiUsersDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDelete(requestParameters: UsersApiUsersDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch users you have access to
         * @param {UsersApiUsersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(requestParameters: UsersApiUsersGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UsersGet200Response> {
            return localVarFp.usersGet(requestParameters.q, requestParameters.partnership, requestParameters.id, requestParameters.originalTeamId, requestParameters.count, requestParameters.page, requestParameters.includeMemberships, requestParameters.includeTotal, requestParameters.other, requestParameters.variant, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset user password
         * @param {UsersApiUsersPasswordPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPasswordPatch(requestParameters: UsersApiUsersPasswordPatchRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersPasswordPatch(requestParameters.resetPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the user in the access token
         * @param {UsersApiUsersPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPatch(requestParameters: UsersApiUsersPatchRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersPatch(requestParameters.userId, requestParameters.userPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates users Phonenumber
         * @param {UsersApiUsersPhoneNumberPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPhoneNumberPatch(requestParameters: UsersApiUsersPhoneNumberPatchRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersPhoneNumberPatch(requestParameters.usersPhoneNumberPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new user
         * @param {UsersApiUsersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(requestParameters: UsersApiUsersPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersPost(requestParameters.userCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for usersDelete operation in UsersApi.
 * @export
 * @interface UsersApiUsersDeleteRequest
 */
export interface UsersApiUsersDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersDelete
     */
    readonly id: string
}

/**
 * Request parameters for usersGet operation in UsersApi.
 * @export
 * @interface UsersApiUsersGetRequest
 */
export interface UsersApiUsersGetRequest {
    /**
     * Search by name, ID, email, phone etc.
     * @type {string}
     * @memberof UsersApiUsersGet
     */
    readonly q?: string

    /**
     * Search by partnership
     * @type {string}
     * @memberof UsersApiUsersGet
     */
    readonly partnership?: string

    /**
     * Fetch specific users by ID
     * @type {Array<string>}
     * @memberof UsersApiUsersGet
     */
    readonly id?: Array<string>

    /**
     * Fetch specific users by original team ID
     * @type {Array<string>}
     * @memberof UsersApiUsersGet
     */
    readonly originalTeamId?: Array<string>

    /**
     * The numbers of items to return
     * @type {number}
     * @memberof UsersApiUsersGet
     */
    readonly count?: number

    /**
     * The page number
     * @type {number}
     * @memberof UsersApiUsersGet
     */
    readonly page?: number

    /**
     * Should include the user\&#39;s memberships
     * @type {boolean}
     * @memberof UsersApiUsersGet
     */
    readonly includeMemberships?: boolean

    /**
     * should return total count of accessible users
     * @type {boolean}
     * @memberof UsersApiUsersGet
     */
    readonly includeTotal?: boolean

    /**
     * other internal query options
     * @type {Array<string>}
     * @memberof UsersApiUsersGet
     */
    readonly other?: Array<string>

    /**
     * The variant of the user to return. lite or chatdaddy 
     * @type {'chatdaddy' | 'lite'}
     * @memberof UsersApiUsersGet
     */
    readonly variant?: UsersGetVariantEnum
}

/**
 * Request parameters for usersPasswordPatch operation in UsersApi.
 * @export
 * @interface UsersApiUsersPasswordPatchRequest
 */
export interface UsersApiUsersPasswordPatchRequest {
    /**
     * 
     * @type {ResetPassword}
     * @memberof UsersApiUsersPasswordPatch
     */
    readonly resetPassword?: ResetPassword
}

/**
 * Request parameters for usersPatch operation in UsersApi.
 * @export
 * @interface UsersApiUsersPatchRequest
 */
export interface UsersApiUsersPatchRequest {
    /**
     * Change the password of this user ID
     * @type {string}
     * @memberof UsersApiUsersPatch
     */
    readonly userId?: string

    /**
     * 
     * @type {UserPatch}
     * @memberof UsersApiUsersPatch
     */
    readonly userPatch?: UserPatch
}

/**
 * Request parameters for usersPhoneNumberPatch operation in UsersApi.
 * @export
 * @interface UsersApiUsersPhoneNumberPatchRequest
 */
export interface UsersApiUsersPhoneNumberPatchRequest {
    /**
     * 
     * @type {UsersPhoneNumberPatchRequest}
     * @memberof UsersApiUsersPhoneNumberPatch
     */
    readonly usersPhoneNumberPatchRequest?: UsersPhoneNumberPatchRequest
}

/**
 * Request parameters for usersPost operation in UsersApi.
 * @export
 * @interface UsersApiUsersPostRequest
 */
export interface UsersApiUsersPostRequest {
    /**
     * 
     * @type {UserCreate}
     * @memberof UsersApiUsersPost
     */
    readonly userCreate?: UserCreate
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Get total user count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersCount(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the user specified
     * @summary Delete a user
     * @param {UsersApiUsersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDelete(requestParameters: UsersApiUsersDeleteRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch users you have access to
     * @param {UsersApiUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGet(requestParameters: UsersApiUsersGetRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersGet(requestParameters.q, requestParameters.partnership, requestParameters.id, requestParameters.originalTeamId, requestParameters.count, requestParameters.page, requestParameters.includeMemberships, requestParameters.includeTotal, requestParameters.other, requestParameters.variant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset user password
     * @param {UsersApiUsersPasswordPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPasswordPatch(requestParameters: UsersApiUsersPasswordPatchRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPasswordPatch(requestParameters.resetPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the user in the access token
     * @param {UsersApiUsersPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPatch(requestParameters: UsersApiUsersPatchRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPatch(requestParameters.userId, requestParameters.userPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates users Phonenumber
     * @param {UsersApiUsersPhoneNumberPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPhoneNumberPatch(requestParameters: UsersApiUsersPhoneNumberPatchRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPhoneNumberPatch(requestParameters.usersPhoneNumberPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new user
     * @param {UsersApiUsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPost(requestParameters: UsersApiUsersPostRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPost(requestParameters.userCreate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UsersGetVariantEnum = {
    Chatdaddy: 'chatdaddy',
    Lite: 'lite'
} as const;
export type UsersGetVariantEnum = typeof UsersGetVariantEnum[keyof typeof UsersGetVariantEnum];


/**
 * WidgetConfigApi - axios parameter creator
 * @export
 */
export const WidgetConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get widget config for a team id
         * @param {string} teamId teamId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        widgetGet: async (teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('widgetGet', 'teamId', teamId)
            const localVarPath = `/widget/{teamId}`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OptionalWidgetConfigParams} [optionalWidgetConfigParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        widgetPatch: async (optionalWidgetConfigParams?: OptionalWidgetConfigParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/widget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["WIDGET_EDIT"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(optionalWidgetConfigParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create widget config
         * @param {WidgetConfigParams} [widgetConfigParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        widgetPost: async (widgetConfigParams?: WidgetConfigParams, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/widget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["WIDGET_EDIT"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(widgetConfigParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WidgetConfigApi - functional programming interface
 * @export
 */
export const WidgetConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WidgetConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get widget config for a team id
         * @param {string} teamId teamId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async widgetGet(teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WidgetConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.widgetGet(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WidgetConfigApi.widgetGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {OptionalWidgetConfigParams} [optionalWidgetConfigParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async widgetPatch(optionalWidgetConfigParams?: OptionalWidgetConfigParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamsPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.widgetPatch(optionalWidgetConfigParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WidgetConfigApi.widgetPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create widget config
         * @param {WidgetConfigParams} [widgetConfigParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async widgetPost(widgetConfigParams?: WidgetConfigParams, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WidgetConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.widgetPost(widgetConfigParams, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WidgetConfigApi.widgetPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WidgetConfigApi - factory interface
 * @export
 */
export const WidgetConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WidgetConfigApiFp(configuration)
    return {
        /**
         * 
         * @summary Get widget config for a team id
         * @param {WidgetConfigApiWidgetGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        widgetGet(requestParameters: WidgetConfigApiWidgetGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<WidgetConfig> {
            return localVarFp.widgetGet(requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WidgetConfigApiWidgetPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        widgetPatch(requestParameters: WidgetConfigApiWidgetPatchRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<TeamsPatch200Response> {
            return localVarFp.widgetPatch(requestParameters.optionalWidgetConfigParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create widget config
         * @param {WidgetConfigApiWidgetPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        widgetPost(requestParameters: WidgetConfigApiWidgetPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<WidgetConfig> {
            return localVarFp.widgetPost(requestParameters.widgetConfigParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for widgetGet operation in WidgetConfigApi.
 * @export
 * @interface WidgetConfigApiWidgetGetRequest
 */
export interface WidgetConfigApiWidgetGetRequest {
    /**
     * teamId
     * @type {string}
     * @memberof WidgetConfigApiWidgetGet
     */
    readonly teamId: string
}

/**
 * Request parameters for widgetPatch operation in WidgetConfigApi.
 * @export
 * @interface WidgetConfigApiWidgetPatchRequest
 */
export interface WidgetConfigApiWidgetPatchRequest {
    /**
     * 
     * @type {OptionalWidgetConfigParams}
     * @memberof WidgetConfigApiWidgetPatch
     */
    readonly optionalWidgetConfigParams?: OptionalWidgetConfigParams
}

/**
 * Request parameters for widgetPost operation in WidgetConfigApi.
 * @export
 * @interface WidgetConfigApiWidgetPostRequest
 */
export interface WidgetConfigApiWidgetPostRequest {
    /**
     * 
     * @type {WidgetConfigParams}
     * @memberof WidgetConfigApiWidgetPost
     */
    readonly widgetConfigParams?: WidgetConfigParams
}

/**
 * WidgetConfigApi - object-oriented interface
 * @export
 * @class WidgetConfigApi
 * @extends {BaseAPI}
 */
export class WidgetConfigApi extends BaseAPI {
    /**
     * 
     * @summary Get widget config for a team id
     * @param {WidgetConfigApiWidgetGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetConfigApi
     */
    public widgetGet(requestParameters: WidgetConfigApiWidgetGetRequest, options?: RawAxiosRequestConfig) {
        return WidgetConfigApiFp(this.configuration).widgetGet(requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WidgetConfigApiWidgetPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetConfigApi
     */
    public widgetPatch(requestParameters: WidgetConfigApiWidgetPatchRequest = {}, options?: RawAxiosRequestConfig) {
        return WidgetConfigApiFp(this.configuration).widgetPatch(requestParameters.optionalWidgetConfigParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create widget config
     * @param {WidgetConfigApiWidgetPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetConfigApi
     */
    public widgetPost(requestParameters: WidgetConfigApiWidgetPostRequest = {}, options?: RawAxiosRequestConfig) {
        return WidgetConfigApiFp(this.configuration).widgetPost(requestParameters.widgetConfigParams, options).then((request) => request(this.axios, this.basePath));
    }
}



