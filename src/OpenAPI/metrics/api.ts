const BASE_PATH = "https://api.chatdaddy.tech/metrics".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy Metrics Service
 * Query aggregate metrics
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from '../base';

/**
 * @type AdminDashboardFilter
 * @export
 */
export type AdminDashboardFilter = AdminDashboardMatchFilter | AdminDashboardRangeFilter;

/**
 * @type AdminDashboardFilterItems
 * @export
 */
export type AdminDashboardFilterItems = AdminDashboardFilter | Array<AdminDashboardFilter>;

/**
 * 
 * @export
 * @interface AdminDashboardMatchFilter
 */
export interface AdminDashboardMatchFilter {
    /**
     * 
     * @type {string}
     * @memberof AdminDashboardMatchFilter
     */
    'field': string;
    /**
     * 
     * @type {AdminDashboardMatchFilterValue}
     * @memberof AdminDashboardMatchFilter
     */
    'value': AdminDashboardMatchFilterValue;
}
/**
 * @type AdminDashboardMatchFilterValue
 * @export
 */
export type AdminDashboardMatchFilterValue = Array<string> | string;

/**
 * 
 * @export
 * @interface AdminDashboardRangeFilter
 */
export interface AdminDashboardRangeFilter {
    /**
     * 
     * @type {string}
     * @memberof AdminDashboardRangeFilter
     */
    'field': string;
    /**
     * 
     * @type {NumericalRange}
     * @memberof AdminDashboardRangeFilter
     */
    'range': NumericalRange;
}
/**
 * 
 * @export
 * @interface AdminDashboardResponse
 */
export interface AdminDashboardResponse {
    /**
     * 
     * @type {Array<TeamData>}
     * @memberof AdminDashboardResponse
     */
    'items': Array<TeamData>;
    /**
     * 
     * @type {string}
     * @memberof AdminDashboardResponse
     */
    'nextCursor'?: string;
    /**
     * Total number of items
     * @type {number}
     * @memberof AdminDashboardResponse
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface AdminDashboardSort
 */
export interface AdminDashboardSort {
    /**
     * 
     * @type {string}
     * @memberof AdminDashboardSort
     */
    'field': string;
    /**
     * 
     * @type {string}
     * @memberof AdminDashboardSort
     */
    'order': AdminDashboardSortOrderEnum;
}

export const AdminDashboardSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type AdminDashboardSortOrderEnum = typeof AdminDashboardSortOrderEnum[keyof typeof AdminDashboardSortOrderEnum];

/**
 * 
 * @export
 * @interface AgentMetrics
 */
export interface AgentMetrics {
    /**
     * Unique identifier for the agent
     * @type {string}
     * @memberof AgentMetrics
     */
    'agentId': string;
    /**
     * Display name of the agent
     * @type {string}
     * @memberof AgentMetrics
     */
    'agentName': string;
    /**
     * Current online status of the agent
     * @type {string}
     * @memberof AgentMetrics
     */
    'status': AgentMetricsStatusEnum;
    /**
     * Total number of chats handled in the period
     * @type {number}
     * @memberof AgentMetrics
     */
    'chatsHandled': number;
    /**
     * Average handle time in seconds
     * @type {number}
     * @memberof AgentMetrics
     */
    'avgHandleTime': number;
    /**
     * Customer satisfaction score as percentage (0-100)
     * @type {number}
     * @memberof AgentMetrics
     */
    'csat': number;
    /**
     * Percentage of chats not responded to within 12 hours
     * @type {number}
     * @memberof AgentMetrics
     */
    'missedChats': number;
    /**
     * Percentage of chats responded to within 12 hours
     * @type {number}
     * @memberof AgentMetrics
     */
    'responseRate12Hr': number;
    /**
     * Percentage of chats responded to within 10 minutes
     * @type {number}
     * @memberof AgentMetrics
     */
    'responseRate10Min': number;
    /**
     * Average first response time in seconds
     * @type {number}
     * @memberof AgentMetrics
     */
    'avgResponseTime': number;
    /**
     * 
     * @type {AgentMetricsTrend}
     * @memberof AgentMetrics
     */
    'trend': AgentMetricsTrend;
}

export const AgentMetricsStatusEnum = {
    Online: 'online',
    Offline: 'offline'
} as const;

export type AgentMetricsStatusEnum = typeof AgentMetricsStatusEnum[keyof typeof AgentMetricsStatusEnum];

/**
 * Period-over-period trend indicators
 * @export
 * @interface AgentMetricsTrend
 */
export interface AgentMetricsTrend {
    /**
     * Percentage change in chats handled
     * @type {number}
     * @memberof AgentMetricsTrend
     */
    'chatsHandled': number;
    /**
     * Percentage change in average handle time
     * @type {number}
     * @memberof AgentMetricsTrend
     */
    'avgHandleTime': number;
    /**
     * Percentage change in CSAT score
     * @type {number}
     * @memberof AgentMetricsTrend
     */
    'csat': number;
}
/**
 * 
 * @export
 * @interface AgentPerformanceResponse
 */
export interface AgentPerformanceResponse {
    /**
     * 
     * @type {Array<AgentMetrics>}
     * @memberof AgentPerformanceResponse
     */
    'items': Array<AgentMetrics>;
    /**
     * Total number of agents
     * @type {number}
     * @memberof AgentPerformanceResponse
     */
    'total': number;
    /**
     * 
     * @type {string}
     * @memberof AgentPerformanceResponse
     */
    'period': AgentPerformanceResponsePeriodEnum;
    /**
     * 
     * @type {AgentPerformanceResponseDateRange}
     * @memberof AgentPerformanceResponse
     */
    'dateRange': AgentPerformanceResponseDateRange;
}

export const AgentPerformanceResponsePeriodEnum = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;

export type AgentPerformanceResponsePeriodEnum = typeof AgentPerformanceResponsePeriodEnum[keyof typeof AgentPerformanceResponsePeriodEnum];

/**
 * 
 * @export
 * @interface AgentPerformanceResponseDateRange
 */
export interface AgentPerformanceResponseDateRange {
    /**
     * 
     * @type {string}
     * @memberof AgentPerformanceResponseDateRange
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof AgentPerformanceResponseDateRange
     */
    'end': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Aggregate = {
    Day: 'day',
    Week: 'week',
    Month: 'month'
} as const;

export type Aggregate = typeof Aggregate[keyof typeof Aggregate];


/**
 * @type AggregateTeamDataValue
 * @export
 */
export type AggregateTeamDataValue = BooleanValueObject | StringValueObject | ValueObject | { [key: string]: ValueObject; };

/**
 * Describe an array
 * @export
 * @interface ArrayPropertyDescriptor
 */
interface ArrayPropertyDescriptor {
    /**
     * 
     * @type {string}
     * @memberof ArrayPropertyDescriptor
     */
    'type': ArrayPropertyDescriptorTypeEnum;
    /**
     * 
     * @type {DataPropertyDescriptor}
     * @memberof ArrayPropertyDescriptor
     */
    'items': DataPropertyDescriptor;
}

const ArrayPropertyDescriptorTypeEnum = {
    Array: 'array'
} as const;

type ArrayPropertyDescriptorTypeEnum = typeof ArrayPropertyDescriptorTypeEnum[keyof typeof ArrayPropertyDescriptorTypeEnum];

/**
 * 
 * @export
 * @interface BenchmarkValues
 */
export interface BenchmarkValues {
    /**
     * 
     * @type {ValueObject}
     * @memberof BenchmarkValues
     */
    'low': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof BenchmarkValues
     */
    'medium': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof BenchmarkValues
     */
    'high': ValueObject;
}
/**
 * 
 * @export
 * @interface Benchmarks
 */
export interface Benchmarks {
    /**
     * 
     * @type {{ [key: string]: BenchmarkValues; }}
     * @memberof Benchmarks
     */
    'benchmarks': { [key: string]: BenchmarkValues; };
}
/**
 * 
 * @export
 * @interface BooleanValueObject
 */
export interface BooleanValueObject {
    /**
     * 
     * @type {boolean}
     * @memberof BooleanValueObject
     */
    'value': boolean;
}
/**
 * 
 * @export
 * @interface ConditionalPropertyOption
 */
interface ConditionalPropertyOption {
    /**
     * Stringified value of the option.
     * @type {string}
     * @memberof ConditionalPropertyOption
     */
    'valueStr': string;
    /**
     * 
     * @type {string}
     * @memberof ConditionalPropertyOption
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface DashboardCreate
 */
export interface DashboardCreate {
    /**
     * 
     * @type {string}
     * @memberof DashboardCreate
     */
    'name': string;
    /**
     * 
     * @type {DashboardSchema}
     * @memberof DashboardCreate
     */
    'schema'?: DashboardSchema;
    /**
     * 
     * @type {DashboardMetadataPermissions}
     * @memberof DashboardCreate
     */
    'permissions'?: DashboardMetadataPermissions;
}
/**
 * 
 * @export
 * @interface DashboardData
 */
export interface DashboardData {
    /**
     * 
     * @type {string}
     * @memberof DashboardData
     */
    'id': string;
    /**
     * 
     * @type {Array<MetricsResult>}
     * @memberof DashboardData
     */
    'dataV2': Array<MetricsResult>;
}
/**
 * 
 * @export
 * @interface DashboardLayoutSchema
 */
export interface DashboardLayoutSchema {
    /**
     * 
     * @type {Array<LayoutSchema>}
     * @memberof DashboardLayoutSchema
     */
    'xl': Array<LayoutSchema>;
    /**
     * 
     * @type {Array<LayoutSchema>}
     * @memberof DashboardLayoutSchema
     */
    'lg': Array<LayoutSchema>;
    /**
     * 
     * @type {Array<LayoutSchema>}
     * @memberof DashboardLayoutSchema
     */
    'md': Array<LayoutSchema>;
    /**
     * 
     * @type {Array<LayoutSchema>}
     * @memberof DashboardLayoutSchema
     */
    'sm': Array<LayoutSchema>;
}
/**
 * 
 * @export
 * @interface DashboardMetadata
 */
export interface DashboardMetadata {
    /**
     * 
     * @type {string}
     * @memberof DashboardMetadata
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DashboardMetadata
     */
    'name': string;
    /**
     * Unique identifier for a user
     * @type {string}
     * @memberof DashboardMetadata
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof DashboardMetadata
     */
    'teamId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DashboardMetadata
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DashboardMetadata
     */
    'updatedAt': string;
    /**
     * 
     * @type {DashboardSchema}
     * @memberof DashboardMetadata
     */
    'schema': DashboardSchema;
    /**
     * 
     * @type {DashboardMetadataPermissions}
     * @memberof DashboardMetadata
     */
    'permissions'?: DashboardMetadataPermissions;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DashboardMetadataAccess = {
    Lvl1View: 'lvl1_view',
    Lvl2Edit: 'lvl2_edit'
} as const;

export type DashboardMetadataAccess = typeof DashboardMetadataAccess[keyof typeof DashboardMetadataAccess];


/**
 * 
 * @export
 * @interface DashboardMetadataPermissionItem
 */
export interface DashboardMetadataPermissionItem {
    /**
     * 
     * @type {string}
     * @memberof DashboardMetadataPermissionItem
     */
    'id': string;
    /**
     * 
     * @type {DashboardMetadataAccess}
     * @memberof DashboardMetadataPermissionItem
     */
    'access': DashboardMetadataAccess;
}


/**
 * 
 * @export
 * @interface DashboardMetadataPermissions
 */
export interface DashboardMetadataPermissions {
    /**
     * 
     * @type {NullableDashboardMetadataAccess}
     * @memberof DashboardMetadataPermissions
     */
    'allMembers'?: NullableDashboardMetadataAccess | null;
    /**
     * 
     * @type {Array<DashboardMetadataPermissionItem>}
     * @memberof DashboardMetadataPermissions
     */
    'users'?: Array<DashboardMetadataPermissionItem>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const DashboardPeriod = {
    MonthToDate: 'month-to-date',
    QuarterToDate: 'quarter-to-date',
    YearToDate: 'year-to-date',
    Last4Weeks: 'last-4-weeks',
    Last12Weeks: 'last-12-weeks',
    Last12Months: 'last-12-months',
    Custom: 'custom'
} as const;

export type DashboardPeriod = typeof DashboardPeriod[keyof typeof DashboardPeriod];


/**
 * 
 * @export
 * @interface DashboardSchema
 */
export interface DashboardSchema {
    /**
     * 
     * @type {string}
     * @memberof DashboardSchema
     */
    'version': DashboardSchemaVersionEnum;
    /**
     * 
     * @type {Array<DashboardSchemaItemsInner>}
     * @memberof DashboardSchema
     */
    'items': Array<DashboardSchemaItemsInner>;
    /**
     * 
     * @type {DashboardLayoutSchema}
     * @memberof DashboardSchema
     */
    'layout'?: DashboardLayoutSchema;
}

export const DashboardSchemaVersionEnum = {
    2: '2'
} as const;

export type DashboardSchemaVersionEnum = typeof DashboardSchemaVersionEnum[keyof typeof DashboardSchemaVersionEnum];

/**
 * 
 * @export
 * @interface DashboardSchemaItem
 */
export interface DashboardSchemaItem {
    /**
     * 
     * @type {string}
     * @memberof DashboardSchemaItem
     */
    'id': string;
    /**
     * 
     * @type {DashboardVisualizationType}
     * @memberof DashboardSchemaItem
     */
    'visualizationType': DashboardVisualizationType;
    /**
     * 
     * @type {string}
     * @memberof DashboardSchemaItem
     */
    'metricId': string;
    /**
     * 
     * @type {string}
     * @memberof DashboardSchemaItem
     */
    'name': string;
    /**
     * 
     * @type {MetricType}
     * @memberof DashboardSchemaItem
     */
    'type'?: MetricType;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DashboardSchemaItem
     */
    'filter'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof DashboardSchemaItem
     */
    'breakdown'?: string;
    /**
     * Hide the default value in the breakdown.
     * @type {boolean}
     * @memberof DashboardSchemaItem
     */
    'hideDefaultInBreakdown'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardSchemaItem
     */
    'includePreviousPeriod'?: boolean;
}


/**
 * @type DashboardSchemaItemsInner
 * @export
 */
export type DashboardSchemaItemsInner = DashboardSchemaItem | TextSchemaItem;

/**
 * 
 * @export
 * @interface DashboardUpdate
 */
interface DashboardUpdate {
    /**
     * 
     * @type {string}
     * @memberof DashboardUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {DashboardSchema}
     * @memberof DashboardUpdate
     */
    'schema'?: DashboardSchema;
    /**
     * 
     * @type {DashboardMetadataPermissions}
     * @memberof DashboardUpdate
     */
    'permissions'?: DashboardMetadataPermissions;
    /**
     * 
     * @type {DashboardLayoutSchema}
     * @memberof DashboardUpdate
     */
    'layout'?: DashboardLayoutSchema;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DashboardVisualizationType = {
    Histogram: 'histogram',
    PieChart: 'pie-chart',
    Table: 'table',
    Snapshot: 'snapshot',
    SimpleSnapshot: 'simple-snapshot'
} as const;

export type DashboardVisualizationType = typeof DashboardVisualizationType[keyof typeof DashboardVisualizationType];


/**
 * 
 * @export
 * @interface DashboardWithData
 */
export interface DashboardWithData {
    /**
     * 
     * @type {string}
     * @memberof DashboardWithData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DashboardWithData
     */
    'name': string;
    /**
     * Unique identifier for a user
     * @type {string}
     * @memberof DashboardWithData
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof DashboardWithData
     */
    'teamId': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DashboardWithData
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DashboardWithData
     */
    'updatedAt': string;
    /**
     * 
     * @type {DashboardSchema}
     * @memberof DashboardWithData
     */
    'schema': DashboardSchema;
    /**
     * 
     * @type {DashboardMetadataPermissions}
     * @memberof DashboardWithData
     */
    'permissions'?: DashboardMetadataPermissions;
    /**
     * 
     * @type {Array<MetricsResult>}
     * @memberof DashboardWithData
     */
    'dataV2': Array<MetricsResult>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DataAggregateType = {
    Avg: 'avg',
    Sum: 'sum'
} as const;

export type DataAggregateType = typeof DataAggregateType[keyof typeof DataAggregateType];


/**
 * Description of a property
 * @export
 * @interface DataProperty
 */
type DataProperty = DataPropertyDescriptor & PropertyMetadata
/**
 * @type DataPropertyDescriptor
 * @export
 */
type DataPropertyDescriptor = SimplePropertyDescriptor | ArrayPropertyDescriptor | MapPropertyDescriptor | OAuthPropertyDescriptor;

/**
 * 
 * @export
 * @interface DateRange
 */
export interface DateRange {
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DateRange
     */
    'start': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof DateRange
     */
    'end': string;
}
/**
 * 
 * @export
 * @interface DefaultMetricConfigInner
 */
export interface DefaultMetricConfigInner {
    /**
     * 
     * @type {string}
     * @memberof DefaultMetricConfigInner
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof DefaultMetricConfigInner
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<DashboardSchemaItemsInner>}
     * @memberof DefaultMetricConfigInner
     */
    'items': Array<DashboardSchemaItemsInner>;
}
/**
 * 
 * @export
 * @interface DisplayIcon
 */
interface DisplayIcon {
    /**
     * Material symbol name
     * @type {string}
     * @memberof DisplayIcon
     */
    'name': string;
    /**
     * Color name, hex code or theme color
     * @type {string}
     * @memberof DisplayIcon
     */
    'color'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FlagState = {
    Growth: 'growth',
    Decline: 'decline',
    Inactive: 'inactive'
} as const;

export type FlagState = typeof FlagState[keyof typeof FlagState];


/**
 * 
 * @export
 * @interface GetDashboardBySchemaRequest
 */
export interface GetDashboardBySchemaRequest {
    /**
     * 
     * @type {DashboardSchema}
     * @memberof GetDashboardBySchemaRequest
     */
    'schema': DashboardSchema;
}
/**
 * 
 * @export
 * @interface GetDashboardMetadatas200Response
 */
export interface GetDashboardMetadatas200Response {
    /**
     * 
     * @type {Array<DashboardMetadata>}
     * @memberof GetDashboardMetadatas200Response
     */
    'items': Array<DashboardMetadata>;
}
/**
 * 
 * @export
 * @interface GetInitData200Response
 */
export interface GetInitData200Response {
    /**
     * 
     * @type {DashboardMetadata}
     * @memberof GetInitData200Response
     */
    'adminDashboard'?: DashboardMetadata;
    /**
     * 
     * @type {Array<DashboardMetadata>}
     * @memberof GetInitData200Response
     */
    'dashboards': Array<DashboardMetadata>;
    /**
     * 
     * @type {Array<MetricConfig>}
     * @memberof GetInitData200Response
     */
    'configs': Array<MetricConfig>;
    /**
     * 
     * @type {DashboardData}
     * @memberof GetInitData200Response
     */
    'data': DashboardData;
    /**
     * Present if the data being fetched is for the default dashboard. 
     * @type {DashboardMetadata}
     * @memberof GetInitData200Response
     */
    'defaultDashboard'?: DashboardMetadata;
    /**
     * 
     * @type {Array<DefaultMetricConfigInner>}
     * @memberof GetInitData200Response
     */
    'defaultSchema'?: Array<DefaultMetricConfigInner>;
}
/**
 * 
 * @export
 * @interface LayoutSchema
 */
export interface LayoutSchema {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof LayoutSchema
     */
    'i': string;
    /**
     * 
     * @type {number}
     * @memberof LayoutSchema
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof LayoutSchema
     */
    'y': number;
    /**
     * 
     * @type {number}
     * @memberof LayoutSchema
     */
    'w': number;
    /**
     * 
     * @type {number}
     * @memberof LayoutSchema
     */
    'h': number;
}
/**
 * Describe a map
 * @export
 * @interface MapPropertyDescriptor
 */
interface MapPropertyDescriptor {
    /**
     * 
     * @type {string}
     * @memberof MapPropertyDescriptor
     */
    'type': MapPropertyDescriptorTypeEnum;
    /**
     * 
     * @type {Array<DataProperty>}
     * @memberof MapPropertyDescriptor
     */
    'properties': Array<DataProperty>;
    /**
     * 
     * @type {DataPropertyDescriptor}
     * @memberof MapPropertyDescriptor
     */
    'additionalProperties'?: DataPropertyDescriptor;
}

const MapPropertyDescriptorTypeEnum = {
    Map: 'map'
} as const;

type MapPropertyDescriptorTypeEnum = typeof MapPropertyDescriptorTypeEnum[keyof typeof MapPropertyDescriptorTypeEnum];

/**
 * 
 * @export
 * @interface Metric
 */
export interface Metric {
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    'value': number;
    /**
     * Number of data points in this metric. Only present for when the value is not a count 
     * @type {number}
     * @memberof Metric
     */
    'count'?: number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Metric
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MetricCategory = {
    Message: 'message',
    ChatContact: 'chat-contact',
    Metadata: 'metadata',
    CreditTransactionRecord: 'credit-transaction-record',
    TeamData: 'team-data'
} as const;

export type MetricCategory = typeof MetricCategory[keyof typeof MetricCategory];


/**
 * 
 * @export
 * @interface MetricConfig
 */
export interface MetricConfig {
    /**
     * 
     * @type {string}
     * @memberof MetricConfig
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricConfig
     */
    'defaultName': string;
    /**
     * 
     * @type {MetricType}
     * @memberof MetricConfig
     */
    'type'?: MetricType;
    /**
     * 
     * @type {string}
     * @memberof MetricConfig
     */
    'valueFormat'?: MetricConfigValueFormatEnum;
    /**
     * 
     * @type {DataAggregateType}
     * @memberof MetricConfig
     */
    'aggregationType'?: DataAggregateType;
    /**
     * Whether an increase in the metric is good or bad.
     * @type {boolean}
     * @memberof MetricConfig
     */
    'isIncreaseGood'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MetricConfig
     */
    'description'?: string;
    /**
     * 
     * @type {Array<MetricConfigProperty>}
     * @memberof MetricConfig
     */
    'properties': Array<MetricConfigProperty>;
    /**
     * 
     * @type {Array<DashboardVisualizationType>}
     * @memberof MetricConfig
     */
    'disallowedVisualisations'?: Array<DashboardVisualizationType>;
}

export const MetricConfigValueFormatEnum = {
    Count: 'count',
    DurationSeconds: 'durationSeconds',
    Percentage: 'percentage'
} as const;

export type MetricConfigValueFormatEnum = typeof MetricConfigValueFormatEnum[keyof typeof MetricConfigValueFormatEnum];

/**
 * 
 * @export
 * @interface MetricConfigProperty
 */
export type MetricConfigProperty = DataProperty & {
    /**
     * Title to show when the value is none. Use \"{{appName}}\" to refer to the app name. 
     * @type {string}
     * @memberof MetricConfigProperty
     */
    'noneValueTitle'?: string;
    /**
     * 
     * @type {MetricConfigPropertyAllOfElasticConfig}
     * @memberof MetricConfigProperty
     */
    'elasticConfig'?: MetricConfigPropertyAllOfElasticConfig;
}


/**
 * 
 * @export
 * @interface MetricConfigPropertyAllOfElasticConfig
 */
export interface MetricConfigPropertyAllOfElasticConfig {
    /**
     * The path to the nested field. If true, the metric will be nested in the query. 
     * @type {string}
     * @memberof MetricConfigPropertyAllOfElasticConfig
     */
    'nestedPath'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MetricType = {
    ChatsPerformance: 'chats-performance',
    MarketingPerformance: 'marketing-performance',
    AgentPerformance: 'agent-performance',
    SalesPerformance: 'sales-performance'
} as const;

export type MetricType = typeof MetricType[keyof typeof MetricType];


/**
 * @type MetricsResult
 * @export
 */
export type MetricsResult = MetricsResultHistogram | MetricsResultTotal;

/**
 * 
 * @export
 * @interface MetricsResultHistogram
 */
export interface MetricsResultHistogram {
    /**
     * 
     * @type {string}
     * @memberof MetricsResultHistogram
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsResultHistogram
     */
    'visualizationType': MetricsResultHistogramVisualizationTypeEnum;
    /**
     * 
     * @type {MetricType}
     * @memberof MetricsResultHistogram
     */
    'metricType'?: MetricType;
    /**
     * 
     * @type {{ [key: string]: Array<Metric>; }}
     * @memberof MetricsResultHistogram
     */
    'lines': { [key: string]: Array<Metric>; };
    /**
     * 
     * @type {{ [key: string]: Array<Metric>; }}
     * @memberof MetricsResultHistogram
     */
    'previousPeriodLines'?: { [key: string]: Array<Metric>; };
}

export const MetricsResultHistogramVisualizationTypeEnum = {
    Histogram: 'histogram'
} as const;

export type MetricsResultHistogramVisualizationTypeEnum = typeof MetricsResultHistogramVisualizationTypeEnum[keyof typeof MetricsResultHistogramVisualizationTypeEnum];

/**
 * 
 * @export
 * @interface MetricsResultTotal
 */
export interface MetricsResultTotal {
    /**
     * 
     * @type {string}
     * @memberof MetricsResultTotal
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MetricsResultTotal
     */
    'visualizationType': MetricsResultTotalVisualizationTypeEnum;
    /**
     * 
     * @type {MetricType}
     * @memberof MetricsResultTotal
     */
    'metricType'?: MetricType;
    /**
     * 
     * @type {{ [key: string]: ValueObject; }}
     * @memberof MetricsResultTotal
     */
    'values': { [key: string]: ValueObject; };
    /**
     * 
     * @type {{ [key: string]: ValueObject; }}
     * @memberof MetricsResultTotal
     */
    'previousPeriodValues'?: { [key: string]: ValueObject; };
}

export const MetricsResultTotalVisualizationTypeEnum = {
    Total: 'total'
} as const;

export type MetricsResultTotalVisualizationTypeEnum = typeof MetricsResultTotalVisualizationTypeEnum[keyof typeof MetricsResultTotalVisualizationTypeEnum];

/**
 * 
 * @export
 * @interface MigrateDashboardToV2200Response
 */
export interface MigrateDashboardToV2200Response {
    /**
     * Number of dashboards deleted
     * @type {number}
     * @memberof MigrateDashboardToV2200Response
     */
    'deletedCount': number;
    /**
     * 
     * @type {DashboardMetadata}
     * @memberof MigrateDashboardToV2200Response
     */
    'dashboard': DashboardMetadata;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NullableDashboardMetadataAccess = {
    Lvl1View: 'lvl1_view',
    Lvl2Edit: 'lvl2_edit'
} as const;

export type NullableDashboardMetadataAccess = typeof NullableDashboardMetadataAccess[keyof typeof NullableDashboardMetadataAccess];


/**
 * 
 * @export
 * @interface NumericalRange
 */
export interface NumericalRange {
    /**
     * 
     * @type {number}
     * @memberof NumericalRange
     */
    'start'?: number;
    /**
     * 
     * @type {number}
     * @memberof NumericalRange
     */
    'end'?: number;
}
/**
 * describe OAuth input for access tokens
 * @export
 * @interface OAuthPropertyDescriptor
 */
interface OAuthPropertyDescriptor {
    /**
     * 
     * @type {string}
     * @memberof OAuthPropertyDescriptor
     */
    'type': OAuthPropertyDescriptorTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OAuthPropertyDescriptor
     */
    'url'?: string;
}

const OAuthPropertyDescriptorTypeEnum = {
    Oauth: 'oauth'
} as const;

type OAuthPropertyDescriptorTypeEnum = typeof OAuthPropertyDescriptorTypeEnum[keyof typeof OAuthPropertyDescriptorTypeEnum];

/**
 * 
 * @export
 * @interface PropertyMetadata
 */
interface PropertyMetadata {
    /**
     * 
     * @type {string}
     * @memberof PropertyMetadata
     */
    'propertyPath': string;
    /**
     * 
     * @type {string}
     * @memberof PropertyMetadata
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof PropertyMetadata
     */
    'description'?: string;
    /**
     * 
     * @type {DisplayIcon}
     * @memberof PropertyMetadata
     */
    'icon'?: DisplayIcon;
    /**
     * Is the property always expected to be present.
     * @type {boolean}
     * @memberof PropertyMetadata
     */
    'required'?: boolean;
}
/**
 * Simple string/number/boolean type
 * @export
 * @interface SimplePropertyDescriptor
 */
interface SimplePropertyDescriptor {
    /**
     * 
     * @type {SimplePropertyType}
     * @memberof SimplePropertyDescriptor
     */
    'type': SimplePropertyType;
    /**
     * 
     * @type {Array<ConditionalPropertyOption>}
     * @memberof SimplePropertyDescriptor
     */
    'options'?: Array<ConditionalPropertyOption>;
    /**
     * Format of the property.  Only valid for string type. For example, \'date-time\' for timestamp properties
     * @type {string}
     * @memberof SimplePropertyDescriptor
     */
    'format'?: string;
    /**
     * Minimum number of stages required in the board for the condition to be valid. Only valid for \"board\" type
     * @type {number}
     * @memberof SimplePropertyDescriptor
     */
    'minimumStages'?: number;
}


/**
 * Type of property. - string, number, boolean: Simple property type - timestamp: timestamp string in ISO format - timezone: timezone in offset format - time: time in 24 hour format - channel, tag, team_member, chat, board_stage, board, ticket, custom_field_select, knowledge_base:     Reference to another object by ID - custom_field: Object of type { name: string, value: string } - duration: integer representing seconds - credit_consumption_type: all credit consumption types - delay: object containing bot delay details - post: ID of a post on the platform (eg. messenger, instagram) - next_action: ActionTarget object containing next action details - data_property_map: MapPropertyDescriptor object 
 * @export
 * @enum {string}
 */

const SimplePropertyType = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean',
    Channel: 'channel',
    Tag: 'tag',
    CustomField: 'custom_field',
    Timestamp: 'timestamp',
    CountryCode: 'country_code',
    TeamMember: 'team_member',
    Chat: 'chat',
    BoardStage: 'board_stage',
    Duration: 'duration',
    Ticket: 'ticket',
    Board: 'board',
    Oauth: 'oauth',
    Timezone: 'timezone',
    Time: 'time',
    CreditConsumptionType: 'credit_consumption_type',
    CustomFieldSelect: 'custom_field_select',
    Delay: 'delay',
    Post: 'post',
    KnowledgeBase: 'knowledge_base',
    NextAction: 'next_action',
    DataPropertyMap: 'data_property_map'
} as const;

type SimplePropertyType = typeof SimplePropertyType[keyof typeof SimplePropertyType];


/**
 * 
 * @export
 * @interface StringValueObject
 */
export interface StringValueObject {
    /**
     * 
     * @type {string}
     * @memberof StringValueObject
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface TeamData
 */
export interface TeamData {
    /**
     * 
     * @type {string}
     * @memberof TeamData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TeamData
     */
    'name'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TeamData
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof TeamData
     */
    'industry': string;
    /**
     * 
     * @type {string}
     * @memberof TeamData
     */
    'region': string;
    /**
     * 
     * @type {TeamDataData}
     * @memberof TeamData
     */
    'data': TeamDataData;
}
/**
 * 
 * @export
 * @interface TeamDataData
 */
export interface TeamDataData {
    /**
     * 
     * @type {{ [key: string]: AggregateTeamDataValue; }}
     * @memberof TeamDataData
     */
    'static'?: { [key: string]: AggregateTeamDataValue; };
    /**
     * 
     * @type {{ [key: string]: AggregateTeamDataValue; }}
     * @memberof TeamDataData
     */
    'last4Weeks'?: { [key: string]: AggregateTeamDataValue; };
    /**
     * 
     * @type {{ [key: string]: AggregateTeamDataValue; }}
     * @memberof TeamDataData
     */
    'last12Weeks'?: { [key: string]: AggregateTeamDataValue; };
    /**
     * 
     * @type {{ [key: string]: AggregateTeamDataValue; }}
     * @memberof TeamDataData
     */
    'last12Months'?: { [key: string]: AggregateTeamDataValue; };
}
/**
 * 
 * @export
 * @interface TextSchemaItem
 */
export interface TextSchemaItem {
    /**
     * 
     * @type {string}
     * @memberof TextSchemaItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TextSchemaItem
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ValueObject
 */
export interface ValueObject {
    /**
     * 
     * @type {number}
     * @memberof ValueObject
     */
    'value': number;
    /**
     * Number of data points in this metric. Only present for when the value is not a count 
     * @type {number}
     * @memberof ValueObject
     */
    'count'?: number;
}

/**
 * AgentApi - axios parameter creator
 * @export
 */
export const AgentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns detailed performance metrics for all agents in a team including chats handled, response times, CSAT, and trends
         * @summary Get individual agent performance metrics
         * @param {GetAgentPerformancePeriodEnum} [period] Time period for metrics calculation
         * @param {string} [startDate] Custom start date (ISO 8601 format). Must be used with endDate
         * @param {string} [endDate] Custom end date (ISO 8601 format). Must be used with startDate
         * @param {string} [teamId] Filter by specific team ID. Defaults to user\&#39;s team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPerformance: async (period?: GetAgentPerformancePeriodEnum, startDate?: string, endDate?: string, teamId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/agent/performance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentApi - functional programming interface
 * @export
 */
export const AgentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AgentApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns detailed performance metrics for all agents in a team including chats handled, response times, CSAT, and trends
         * @summary Get individual agent performance metrics
         * @param {GetAgentPerformancePeriodEnum} [period] Time period for metrics calculation
         * @param {string} [startDate] Custom start date (ISO 8601 format). Must be used with endDate
         * @param {string} [endDate] Custom end date (ISO 8601 format). Must be used with startDate
         * @param {string} [teamId] Filter by specific team ID. Defaults to user\&#39;s team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgentPerformance(period?: GetAgentPerformancePeriodEnum, startDate?: string, endDate?: string, teamId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentPerformanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgentPerformance(period, startDate, endDate, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentApi.getAgentPerformance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AgentApi - factory interface
 * @export
 */
export const AgentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AgentApiFp(configuration)
    return {
        /**
         * Returns detailed performance metrics for all agents in a team including chats handled, response times, CSAT, and trends
         * @summary Get individual agent performance metrics
         * @param {AgentApiGetAgentPerformanceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentPerformance(requestParameters: AgentApiGetAgentPerformanceRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AgentPerformanceResponse> {
            return localVarFp.getAgentPerformance(requestParameters.period, requestParameters.startDate, requestParameters.endDate, requestParameters.teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAgentPerformance operation in AgentApi.
 * @export
 * @interface AgentApiGetAgentPerformanceRequest
 */
export interface AgentApiGetAgentPerformanceRequest {
    /**
     * Time period for metrics calculation
     * @type {'daily' | 'weekly' | 'monthly'}
     * @memberof AgentApiGetAgentPerformance
     */
    readonly period?: GetAgentPerformancePeriodEnum

    /**
     * Custom start date (ISO 8601 format). Must be used with endDate
     * @type {string}
     * @memberof AgentApiGetAgentPerformance
     */
    readonly startDate?: string

    /**
     * Custom end date (ISO 8601 format). Must be used with startDate
     * @type {string}
     * @memberof AgentApiGetAgentPerformance
     */
    readonly endDate?: string

    /**
     * Filter by specific team ID. Defaults to user\&#39;s team
     * @type {string}
     * @memberof AgentApiGetAgentPerformance
     */
    readonly teamId?: string
}

/**
 * AgentApi - object-oriented interface
 * @export
 * @class AgentApi
 * @extends {BaseAPI}
 */
export class AgentApi extends BaseAPI {
    /**
     * Returns detailed performance metrics for all agents in a team including chats handled, response times, CSAT, and trends
     * @summary Get individual agent performance metrics
     * @param {AgentApiGetAgentPerformanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    public getAgentPerformance(requestParameters: AgentApiGetAgentPerformanceRequest = {}, options?: RawAxiosRequestConfig) {
        return AgentApiFp(this.configuration).getAgentPerformance(requestParameters.period, requestParameters.startDate, requestParameters.endDate, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAgentPerformancePeriodEnum = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;
export type GetAgentPerformancePeriodEnum = typeof GetAgentPerformancePeriodEnum[keyof typeof GetAgentPerformancePeriodEnum];


/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new dashboard metadata
         * @param {CreateDashboardMetadataVersionEnum} [version] Which version of the schema to use.
         * @param {DashboardCreate} [dashboardCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboardMetadata: async (version?: CreateDashboardMetadataVersionEnum, dashboardCreate?: DashboardCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/metadatas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["DASHBOARD_CREATE"], configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dashboardCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a dashboard metadata
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardMetadata: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDashboardMetadata', 'id', id)
            const localVarPath = `/dashboard/metadatas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["DASHBOARD_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get admin dashboards
         * @param {GetAdminDashboardsPeriodEnum} period 
         * @param {Array<string>} [teamIds] Fetch specific teams by ID
         * @param {number} [count] Number of items to fetch.
         * @param {string} [cursor] Cursor to fetch the next page of dashboards.
         * @param {boolean} [returnTotal] Whether to return the total number of dashboards.
         * @param {AdminDashboardSort} [sort] Sort the dashboards by a field.
         * @param {AdminDashboardFilterItems} [filters] Filters to apply to the dashboards.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminDashboards: async (period: GetAdminDashboardsPeriodEnum, teamIds?: Array<string>, count?: number, cursor?: string, returnTotal?: boolean, sort?: AdminDashboardSort, filters?: AdminDashboardFilterItems, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getAdminDashboards', 'period', period)
            const localVarPath = `/dashboard/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS", "PARTNER_ADMIN_PANEL_ACCESS"], configuration)

            if (teamIds) {
                localVarQueryParameter['teamIds'] = teamIds;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (returnTotal !== undefined) {
                localVarQueryParameter['returnTotal'] = returnTotal;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get benchmarks
         * @param {DashboardPeriod} [period] 
         * @param {AdminDashboardFilterItems} [filters] Filters to apply to the dashboards.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenchmarks: async (period?: DashboardPeriod, filters?: AdminDashboardFilterItems, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/benchmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["ADMIN_PANEL_ACCESS"], configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dashboard data
         * @param {DashboardPeriod} period 
         * @param {Aggregate} aggregate Timeframe to aggregate the data in.
         * @param {string} [id] Dashboard ID to fetch data for. If not provided, the default dashboard will be returned.
         * @param {string} [timezoneOffset] Timezone offset to query the data in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard: async (period: DashboardPeriod, aggregate: Aggregate, id?: string, timezoneOffset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getDashboard', 'period', period)
            // verify required parameter 'aggregate' is not null or undefined
            assertParamExists('getDashboard', 'aggregate', aggregate)
            const localVarPath = `/dashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["METRICS_GET"], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (timezoneOffset !== undefined) {
                localVarQueryParameter['timezoneOffset'] = timezoneOffset;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dashboard data by schema
         * @param {DashboardPeriod} period 
         * @param {Aggregate} aggregate Timeframe to aggregate the data in.
         * @param {DateRange} [customDateRange] Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
         * @param {string} [timezoneOffset] Timezone offset to query the data in.
         * @param {string} [teamId] Team ID to fetch data for.
         * @param {MetricType} [type] Filter metrics by performance type.
         * @param {GetDashboardBySchemaRequest} [getDashboardBySchemaRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardBySchema: async (period: DashboardPeriod, aggregate: Aggregate, customDateRange?: DateRange, timezoneOffset?: string, teamId?: string, type?: MetricType, getDashboardBySchemaRequest?: GetDashboardBySchemaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getDashboardBySchema', 'period', period)
            // verify required parameter 'aggregate' is not null or undefined
            assertParamExists('getDashboardBySchema', 'aggregate', aggregate)
            const localVarPath = `/dashboard/get-by-schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["METRICS_GET"], configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (customDateRange !== undefined) {
                localVarQueryParameter['customDateRange'] = customDateRange;
            }

            if (timezoneOffset !== undefined) {
                localVarQueryParameter['timezoneOffset'] = timezoneOffset;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getDashboardBySchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dashboard metadatas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardMetadatas: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/metadatas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["METRICS_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get initial data
         * @param {DashboardPeriod} period 
         * @param {Aggregate} aggregate Timeframe to aggregate the data in.
         * @param {string} [id] Dashboard ID to fetch data for. If not provided, the default dashboard will be returned.
         * @param {DateRange} [customDateRange] Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
         * @param {string} [timezoneOffset] Timezone offset to query the data in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInitData: async (period: DashboardPeriod, aggregate: Aggregate, id?: string, customDateRange?: DateRange, timezoneOffset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getInitData', 'period', period)
            // verify required parameter 'aggregate' is not null or undefined
            assertParamExists('getInitData', 'aggregate', aggregate)
            const localVarPath = `/initData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["METRICS_GET"], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (customDateRange !== undefined) {
                localVarQueryParameter['customDateRange'] = customDateRange;
            }

            if (timezoneOffset !== undefined) {
                localVarQueryParameter['timezoneOffset'] = timezoneOffset;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a dashboard metadata
         * @param {string} id 
         * @param {DashboardUpdate} [dashboardUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboardMetadata: async (id: string, dashboardUpdate?: DashboardUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDashboardMetadata', 'id', id)
            const localVarPath = `/dashboard/metadatas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["METRICS_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dashboardUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new dashboard metadata
         * @param {CreateDashboardMetadataVersionEnum} [version] Which version of the schema to use.
         * @param {DashboardCreate} [dashboardCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDashboardMetadata(version?: CreateDashboardMetadataVersionEnum, dashboardCreate?: DashboardCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDashboardMetadata(version, dashboardCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.createDashboardMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a dashboard metadata
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDashboardMetadata(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDashboardMetadata(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.deleteDashboardMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get admin dashboards
         * @param {GetAdminDashboardsPeriodEnum} period 
         * @param {Array<string>} [teamIds] Fetch specific teams by ID
         * @param {number} [count] Number of items to fetch.
         * @param {string} [cursor] Cursor to fetch the next page of dashboards.
         * @param {boolean} [returnTotal] Whether to return the total number of dashboards.
         * @param {AdminDashboardSort} [sort] Sort the dashboards by a field.
         * @param {AdminDashboardFilterItems} [filters] Filters to apply to the dashboards.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdminDashboards(period: GetAdminDashboardsPeriodEnum, teamIds?: Array<string>, count?: number, cursor?: string, returnTotal?: boolean, sort?: AdminDashboardSort, filters?: AdminDashboardFilterItems, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminDashboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdminDashboards(period, teamIds, count, cursor, returnTotal, sort, filters, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getAdminDashboards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get benchmarks
         * @param {DashboardPeriod} [period] 
         * @param {AdminDashboardFilterItems} [filters] Filters to apply to the dashboards.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenchmarks(period?: DashboardPeriod, filters?: AdminDashboardFilterItems, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Benchmarks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenchmarks(period, filters, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getBenchmarks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get dashboard data
         * @param {DashboardPeriod} period 
         * @param {Aggregate} aggregate Timeframe to aggregate the data in.
         * @param {string} [id] Dashboard ID to fetch data for. If not provided, the default dashboard will be returned.
         * @param {string} [timezoneOffset] Timezone offset to query the data in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboard(period: DashboardPeriod, aggregate: Aggregate, id?: string, timezoneOffset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardWithData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboard(period, aggregate, id, timezoneOffset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getDashboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get dashboard data by schema
         * @param {DashboardPeriod} period 
         * @param {Aggregate} aggregate Timeframe to aggregate the data in.
         * @param {DateRange} [customDateRange] Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
         * @param {string} [timezoneOffset] Timezone offset to query the data in.
         * @param {string} [teamId] Team ID to fetch data for.
         * @param {MetricType} [type] Filter metrics by performance type.
         * @param {GetDashboardBySchemaRequest} [getDashboardBySchemaRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardBySchema(period: DashboardPeriod, aggregate: Aggregate, customDateRange?: DateRange, timezoneOffset?: string, teamId?: string, type?: MetricType, getDashboardBySchemaRequest?: GetDashboardBySchemaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardBySchema(period, aggregate, customDateRange, timezoneOffset, teamId, type, getDashboardBySchemaRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getDashboardBySchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get dashboard metadatas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardMetadatas(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDashboardMetadatas200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardMetadatas(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getDashboardMetadatas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get initial data
         * @param {DashboardPeriod} period 
         * @param {Aggregate} aggregate Timeframe to aggregate the data in.
         * @param {string} [id] Dashboard ID to fetch data for. If not provided, the default dashboard will be returned.
         * @param {DateRange} [customDateRange] Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
         * @param {string} [timezoneOffset] Timezone offset to query the data in.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInitData(period: DashboardPeriod, aggregate: Aggregate, id?: string, customDateRange?: DateRange, timezoneOffset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInitData200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInitData(period, aggregate, id, customDateRange, timezoneOffset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getInitData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a dashboard metadata
         * @param {string} id 
         * @param {DashboardUpdate} [dashboardUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDashboardMetadata(id: string, dashboardUpdate?: DashboardUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDashboardMetadata(id, dashboardUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.updateDashboardMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new dashboard metadata
         * @param {DashboardApiCreateDashboardMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboardMetadata(requestParameters: DashboardApiCreateDashboardMetadataRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<DashboardMetadata> {
            return localVarFp.createDashboardMetadata(requestParameters.version, requestParameters.dashboardCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a dashboard metadata
         * @param {DashboardApiDeleteDashboardMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardMetadata(requestParameters: DashboardApiDeleteDashboardMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDashboardMetadata(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get admin dashboards
         * @param {DashboardApiGetAdminDashboardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminDashboards(requestParameters: DashboardApiGetAdminDashboardsRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminDashboardResponse> {
            return localVarFp.getAdminDashboards(requestParameters.period, requestParameters.teamIds, requestParameters.count, requestParameters.cursor, requestParameters.returnTotal, requestParameters.sort, requestParameters.filters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get benchmarks
         * @param {DashboardApiGetBenchmarksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenchmarks(requestParameters: DashboardApiGetBenchmarksRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Benchmarks> {
            return localVarFp.getBenchmarks(requestParameters.period, requestParameters.filters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get dashboard data
         * @param {DashboardApiGetDashboardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard(requestParameters: DashboardApiGetDashboardRequest, options?: RawAxiosRequestConfig): AxiosPromise<DashboardWithData> {
            return localVarFp.getDashboard(requestParameters.period, requestParameters.aggregate, requestParameters.id, requestParameters.timezoneOffset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get dashboard data by schema
         * @param {DashboardApiGetDashboardBySchemaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardBySchema(requestParameters: DashboardApiGetDashboardBySchemaRequest, options?: RawAxiosRequestConfig): AxiosPromise<DashboardData> {
            return localVarFp.getDashboardBySchema(requestParameters.period, requestParameters.aggregate, requestParameters.customDateRange, requestParameters.timezoneOffset, requestParameters.teamId, requestParameters.type, requestParameters.getDashboardBySchemaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get dashboard metadatas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardMetadatas(options?: RawAxiosRequestConfig): AxiosPromise<GetDashboardMetadatas200Response> {
            return localVarFp.getDashboardMetadatas(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get initial data
         * @param {DashboardApiGetInitDataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInitData(requestParameters: DashboardApiGetInitDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetInitData200Response> {
            return localVarFp.getInitData(requestParameters.period, requestParameters.aggregate, requestParameters.id, requestParameters.customDateRange, requestParameters.timezoneOffset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a dashboard metadata
         * @param {DashboardApiUpdateDashboardMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboardMetadata(requestParameters: DashboardApiUpdateDashboardMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDashboardMetadata(requestParameters.id, requestParameters.dashboardUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createDashboardMetadata operation in DashboardApi.
 * @export
 * @interface DashboardApiCreateDashboardMetadataRequest
 */
export interface DashboardApiCreateDashboardMetadataRequest {
    /**
     * Which version of the schema to use.
     * @type {'1' | '2'}
     * @memberof DashboardApiCreateDashboardMetadata
     */
    readonly version?: CreateDashboardMetadataVersionEnum

    /**
     * 
     * @type {DashboardCreate}
     * @memberof DashboardApiCreateDashboardMetadata
     */
    readonly dashboardCreate?: DashboardCreate
}

/**
 * Request parameters for deleteDashboardMetadata operation in DashboardApi.
 * @export
 * @interface DashboardApiDeleteDashboardMetadataRequest
 */
export interface DashboardApiDeleteDashboardMetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof DashboardApiDeleteDashboardMetadata
     */
    readonly id: string
}

/**
 * Request parameters for getAdminDashboards operation in DashboardApi.
 * @export
 * @interface DashboardApiGetAdminDashboardsRequest
 */
export interface DashboardApiGetAdminDashboardsRequest {
    /**
     * 
     * @type {'last-4-weeks' | 'last-12-weeks' | 'last-12-months'}
     * @memberof DashboardApiGetAdminDashboards
     */
    readonly period: GetAdminDashboardsPeriodEnum

    /**
     * Fetch specific teams by ID
     * @type {Array<string>}
     * @memberof DashboardApiGetAdminDashboards
     */
    readonly teamIds?: Array<string>

    /**
     * Number of items to fetch.
     * @type {number}
     * @memberof DashboardApiGetAdminDashboards
     */
    readonly count?: number

    /**
     * Cursor to fetch the next page of dashboards.
     * @type {string}
     * @memberof DashboardApiGetAdminDashboards
     */
    readonly cursor?: string

    /**
     * Whether to return the total number of dashboards.
     * @type {boolean}
     * @memberof DashboardApiGetAdminDashboards
     */
    readonly returnTotal?: boolean

    /**
     * Sort the dashboards by a field.
     * @type {AdminDashboardSort}
     * @memberof DashboardApiGetAdminDashboards
     */
    readonly sort?: AdminDashboardSort

    /**
     * Filters to apply to the dashboards.
     * @type {AdminDashboardFilterItems}
     * @memberof DashboardApiGetAdminDashboards
     */
    readonly filters?: AdminDashboardFilterItems
}

/**
 * Request parameters for getBenchmarks operation in DashboardApi.
 * @export
 * @interface DashboardApiGetBenchmarksRequest
 */
export interface DashboardApiGetBenchmarksRequest {
    /**
     * 
     * @type {DashboardPeriod}
     * @memberof DashboardApiGetBenchmarks
     */
    readonly period?: DashboardPeriod

    /**
     * Filters to apply to the dashboards.
     * @type {AdminDashboardFilterItems}
     * @memberof DashboardApiGetBenchmarks
     */
    readonly filters?: AdminDashboardFilterItems
}

/**
 * Request parameters for getDashboard operation in DashboardApi.
 * @export
 * @interface DashboardApiGetDashboardRequest
 */
export interface DashboardApiGetDashboardRequest {
    /**
     * 
     * @type {DashboardPeriod}
     * @memberof DashboardApiGetDashboard
     */
    readonly period: DashboardPeriod

    /**
     * Timeframe to aggregate the data in.
     * @type {Aggregate}
     * @memberof DashboardApiGetDashboard
     */
    readonly aggregate: Aggregate

    /**
     * Dashboard ID to fetch data for. If not provided, the default dashboard will be returned.
     * @type {string}
     * @memberof DashboardApiGetDashboard
     */
    readonly id?: string

    /**
     * Timezone offset to query the data in.
     * @type {string}
     * @memberof DashboardApiGetDashboard
     */
    readonly timezoneOffset?: string
}

/**
 * Request parameters for getDashboardBySchema operation in DashboardApi.
 * @export
 * @interface DashboardApiGetDashboardBySchemaRequest
 */
export interface DashboardApiGetDashboardBySchemaRequest {
    /**
     * 
     * @type {DashboardPeriod}
     * @memberof DashboardApiGetDashboardBySchema
     */
    readonly period: DashboardPeriod

    /**
     * Timeframe to aggregate the data in.
     * @type {Aggregate}
     * @memberof DashboardApiGetDashboardBySchema
     */
    readonly aggregate: Aggregate

    /**
     * Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
     * @type {DateRange}
     * @memberof DashboardApiGetDashboardBySchema
     */
    readonly customDateRange?: DateRange

    /**
     * Timezone offset to query the data in.
     * @type {string}
     * @memberof DashboardApiGetDashboardBySchema
     */
    readonly timezoneOffset?: string

    /**
     * Team ID to fetch data for.
     * @type {string}
     * @memberof DashboardApiGetDashboardBySchema
     */
    readonly teamId?: string

    /**
     * Filter metrics by performance type.
     * @type {MetricType}
     * @memberof DashboardApiGetDashboardBySchema
     */
    readonly type?: MetricType

    /**
     * 
     * @type {GetDashboardBySchemaRequest}
     * @memberof DashboardApiGetDashboardBySchema
     */
    readonly getDashboardBySchemaRequest?: GetDashboardBySchemaRequest
}

/**
 * Request parameters for getInitData operation in DashboardApi.
 * @export
 * @interface DashboardApiGetInitDataRequest
 */
export interface DashboardApiGetInitDataRequest {
    /**
     * 
     * @type {DashboardPeriod}
     * @memberof DashboardApiGetInitData
     */
    readonly period: DashboardPeriod

    /**
     * Timeframe to aggregate the data in.
     * @type {Aggregate}
     * @memberof DashboardApiGetInitData
     */
    readonly aggregate: Aggregate

    /**
     * Dashboard ID to fetch data for. If not provided, the default dashboard will be returned.
     * @type {string}
     * @memberof DashboardApiGetInitData
     */
    readonly id?: string

    /**
     * Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
     * @type {DateRange}
     * @memberof DashboardApiGetInitData
     */
    readonly customDateRange?: DateRange

    /**
     * Timezone offset to query the data in.
     * @type {string}
     * @memberof DashboardApiGetInitData
     */
    readonly timezoneOffset?: string
}

/**
 * Request parameters for updateDashboardMetadata operation in DashboardApi.
 * @export
 * @interface DashboardApiUpdateDashboardMetadataRequest
 */
export interface DashboardApiUpdateDashboardMetadataRequest {
    /**
     * 
     * @type {string}
     * @memberof DashboardApiUpdateDashboardMetadata
     */
    readonly id: string

    /**
     * 
     * @type {DashboardUpdate}
     * @memberof DashboardApiUpdateDashboardMetadata
     */
    readonly dashboardUpdate?: DashboardUpdate
}

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI {
    /**
     * 
     * @summary Create a new dashboard metadata
     * @param {DashboardApiCreateDashboardMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public createDashboardMetadata(requestParameters: DashboardApiCreateDashboardMetadataRequest = {}, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).createDashboardMetadata(requestParameters.version, requestParameters.dashboardCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a dashboard metadata
     * @param {DashboardApiDeleteDashboardMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public deleteDashboardMetadata(requestParameters: DashboardApiDeleteDashboardMetadataRequest, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).deleteDashboardMetadata(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get admin dashboards
     * @param {DashboardApiGetAdminDashboardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getAdminDashboards(requestParameters: DashboardApiGetAdminDashboardsRequest, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getAdminDashboards(requestParameters.period, requestParameters.teamIds, requestParameters.count, requestParameters.cursor, requestParameters.returnTotal, requestParameters.sort, requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get benchmarks
     * @param {DashboardApiGetBenchmarksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getBenchmarks(requestParameters: DashboardApiGetBenchmarksRequest = {}, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getBenchmarks(requestParameters.period, requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get dashboard data
     * @param {DashboardApiGetDashboardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDashboard(requestParameters: DashboardApiGetDashboardRequest, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDashboard(requestParameters.period, requestParameters.aggregate, requestParameters.id, requestParameters.timezoneOffset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get dashboard data by schema
     * @param {DashboardApiGetDashboardBySchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDashboardBySchema(requestParameters: DashboardApiGetDashboardBySchemaRequest, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDashboardBySchema(requestParameters.period, requestParameters.aggregate, requestParameters.customDateRange, requestParameters.timezoneOffset, requestParameters.teamId, requestParameters.type, requestParameters.getDashboardBySchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get dashboard metadatas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDashboardMetadatas(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDashboardMetadatas(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get initial data
     * @param {DashboardApiGetInitDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getInitData(requestParameters: DashboardApiGetInitDataRequest, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getInitData(requestParameters.period, requestParameters.aggregate, requestParameters.id, requestParameters.customDateRange, requestParameters.timezoneOffset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a dashboard metadata
     * @param {DashboardApiUpdateDashboardMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public updateDashboardMetadata(requestParameters: DashboardApiUpdateDashboardMetadataRequest, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).updateDashboardMetadata(requestParameters.id, requestParameters.dashboardUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CreateDashboardMetadataVersionEnum = {
    1: '1',
    2: '2'
} as const;
export type CreateDashboardMetadataVersionEnum = typeof CreateDashboardMetadataVersionEnum[keyof typeof CreateDashboardMetadataVersionEnum];
/**
 * @export
 */
export const GetAdminDashboardsPeriodEnum = {
    Last4Weeks: 'last-4-weeks',
    Last12Weeks: 'last-12-weeks',
    Last12Months: 'last-12-months'
} as const;
export type GetAdminDashboardsPeriodEnum = typeof GetAdminDashboardsPeriodEnum[keyof typeof GetAdminDashboardsPeriodEnum];


/**
 * DashboardV2Api - axios parameter creator
 * @export
 */
export const DashboardV2ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get benchmarks V2 with metric type filtering
         * @param {DashboardPeriod} [period] 
         * @param {MetricType} [type] Filter benchmarks by performance type.
         * @param {AdminDashboardFilterItems} [filters] Filters to apply to the dashboards.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenchmarksV2: async (period?: DashboardPeriod, type?: MetricType, filters?: AdminDashboardFilterItems, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/benchmarks/v2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dashboard data by schema with metric type filtering
         * @param {DashboardPeriod} period 
         * @param {Aggregate} aggregate Timeframe to aggregate the data in.
         * @param {DateRange} [customDateRange] Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
         * @param {string} [timezoneOffset] Timezone offset to query the data in.
         * @param {string} [teamId] Team ID to fetch data for.
         * @param {MetricType} [type] Filter metrics by performance type.
         * @param {GetDashboardBySchemaRequest} [getDashboardBySchemaRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardBySchemaV2: async (period: DashboardPeriod, aggregate: Aggregate, customDateRange?: DateRange, timezoneOffset?: string, teamId?: string, type?: MetricType, getDashboardBySchemaRequest?: GetDashboardBySchemaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getDashboardBySchemaV2', 'period', period)
            // verify required parameter 'aggregate' is not null or undefined
            assertParamExists('getDashboardBySchemaV2', 'aggregate', aggregate)
            const localVarPath = `/dashboard/get-by-schema/v2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (customDateRange !== undefined) {
                localVarQueryParameter['customDateRange'] = customDateRange;
            }

            if (timezoneOffset !== undefined) {
                localVarQueryParameter['timezoneOffset'] = timezoneOffset;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getDashboardBySchemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get initial data V2 with metric type filtering
         * @param {DashboardPeriod} period 
         * @param {Aggregate} aggregate Timeframe to aggregate the data in.
         * @param {string} [id] Dashboard ID to fetch data for. If not provided, the default dashboard will be returned.
         * @param {DateRange} [customDateRange] Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
         * @param {string} [timezoneOffset] Timezone offset to query the data in.
         * @param {MetricType} [type] Filter metrics by performance type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInitDataV2: async (period: DashboardPeriod, aggregate: Aggregate, id?: string, customDateRange?: DateRange, timezoneOffset?: string, type?: MetricType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getInitDataV2', 'period', period)
            // verify required parameter 'aggregate' is not null or undefined
            assertParamExists('getInitDataV2', 'aggregate', aggregate)
            const localVarPath = `/initData/v2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (customDateRange !== undefined) {
                localVarQueryParameter['customDateRange'] = customDateRange;
            }

            if (timezoneOffset !== undefined) {
                localVarQueryParameter['timezoneOffset'] = timezoneOffset;
            }

            if (aggregate !== undefined) {
                localVarQueryParameter['aggregate'] = aggregate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all existing dashboards and creates a single V2 dashboard. Does not deduct credits.
         * @summary Migrate team to V2 dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        migrateDashboardToV2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/migrate-to-v2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["DASHBOARD_CREATE", "DASHBOARD_DELETE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardV2Api - functional programming interface
 * @export
 */
export const DashboardV2ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardV2ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get benchmarks V2 with metric type filtering
         * @param {DashboardPeriod} [period] 
         * @param {MetricType} [type] Filter benchmarks by performance type.
         * @param {AdminDashboardFilterItems} [filters] Filters to apply to the dashboards.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBenchmarksV2(period?: DashboardPeriod, type?: MetricType, filters?: AdminDashboardFilterItems, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Benchmarks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBenchmarksV2(period, type, filters, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardV2Api.getBenchmarksV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get dashboard data by schema with metric type filtering
         * @param {DashboardPeriod} period 
         * @param {Aggregate} aggregate Timeframe to aggregate the data in.
         * @param {DateRange} [customDateRange] Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
         * @param {string} [timezoneOffset] Timezone offset to query the data in.
         * @param {string} [teamId] Team ID to fetch data for.
         * @param {MetricType} [type] Filter metrics by performance type.
         * @param {GetDashboardBySchemaRequest} [getDashboardBySchemaRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardBySchemaV2(period: DashboardPeriod, aggregate: Aggregate, customDateRange?: DateRange, timezoneOffset?: string, teamId?: string, type?: MetricType, getDashboardBySchemaRequest?: GetDashboardBySchemaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardBySchemaV2(period, aggregate, customDateRange, timezoneOffset, teamId, type, getDashboardBySchemaRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardV2Api.getDashboardBySchemaV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get initial data V2 with metric type filtering
         * @param {DashboardPeriod} period 
         * @param {Aggregate} aggregate Timeframe to aggregate the data in.
         * @param {string} [id] Dashboard ID to fetch data for. If not provided, the default dashboard will be returned.
         * @param {DateRange} [customDateRange] Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
         * @param {string} [timezoneOffset] Timezone offset to query the data in.
         * @param {MetricType} [type] Filter metrics by performance type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInitDataV2(period: DashboardPeriod, aggregate: Aggregate, id?: string, customDateRange?: DateRange, timezoneOffset?: string, type?: MetricType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInitData200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInitDataV2(period, aggregate, id, customDateRange, timezoneOffset, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardV2Api.getInitDataV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes all existing dashboards and creates a single V2 dashboard. Does not deduct credits.
         * @summary Migrate team to V2 dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async migrateDashboardToV2(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MigrateDashboardToV2200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.migrateDashboardToV2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardV2Api.migrateDashboardToV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardV2Api - factory interface
 * @export
 */
export const DashboardV2ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardV2ApiFp(configuration)
    return {
        /**
         * 
         * @summary Get benchmarks V2 with metric type filtering
         * @param {DashboardV2ApiGetBenchmarksV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBenchmarksV2(requestParameters: DashboardV2ApiGetBenchmarksV2Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Benchmarks> {
            return localVarFp.getBenchmarksV2(requestParameters.period, requestParameters.type, requestParameters.filters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get dashboard data by schema with metric type filtering
         * @param {DashboardV2ApiGetDashboardBySchemaV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardBySchemaV2(requestParameters: DashboardV2ApiGetDashboardBySchemaV2Request, options?: RawAxiosRequestConfig): AxiosPromise<DashboardData> {
            return localVarFp.getDashboardBySchemaV2(requestParameters.period, requestParameters.aggregate, requestParameters.customDateRange, requestParameters.timezoneOffset, requestParameters.teamId, requestParameters.type, requestParameters.getDashboardBySchemaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get initial data V2 with metric type filtering
         * @param {DashboardV2ApiGetInitDataV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInitDataV2(requestParameters: DashboardV2ApiGetInitDataV2Request, options?: RawAxiosRequestConfig): AxiosPromise<GetInitData200Response> {
            return localVarFp.getInitDataV2(requestParameters.period, requestParameters.aggregate, requestParameters.id, requestParameters.customDateRange, requestParameters.timezoneOffset, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all existing dashboards and creates a single V2 dashboard. Does not deduct credits.
         * @summary Migrate team to V2 dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        migrateDashboardToV2(options?: RawAxiosRequestConfig): AxiosPromise<MigrateDashboardToV2200Response> {
            return localVarFp.migrateDashboardToV2(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getBenchmarksV2 operation in DashboardV2Api.
 * @export
 * @interface DashboardV2ApiGetBenchmarksV2Request
 */
export interface DashboardV2ApiGetBenchmarksV2Request {
    /**
     * 
     * @type {DashboardPeriod}
     * @memberof DashboardV2ApiGetBenchmarksV2
     */
    readonly period?: DashboardPeriod

    /**
     * Filter benchmarks by performance type.
     * @type {MetricType}
     * @memberof DashboardV2ApiGetBenchmarksV2
     */
    readonly type?: MetricType

    /**
     * Filters to apply to the dashboards.
     * @type {AdminDashboardFilterItems}
     * @memberof DashboardV2ApiGetBenchmarksV2
     */
    readonly filters?: AdminDashboardFilterItems
}

/**
 * Request parameters for getDashboardBySchemaV2 operation in DashboardV2Api.
 * @export
 * @interface DashboardV2ApiGetDashboardBySchemaV2Request
 */
export interface DashboardV2ApiGetDashboardBySchemaV2Request {
    /**
     * 
     * @type {DashboardPeriod}
     * @memberof DashboardV2ApiGetDashboardBySchemaV2
     */
    readonly period: DashboardPeriod

    /**
     * Timeframe to aggregate the data in.
     * @type {Aggregate}
     * @memberof DashboardV2ApiGetDashboardBySchemaV2
     */
    readonly aggregate: Aggregate

    /**
     * Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
     * @type {DateRange}
     * @memberof DashboardV2ApiGetDashboardBySchemaV2
     */
    readonly customDateRange?: DateRange

    /**
     * Timezone offset to query the data in.
     * @type {string}
     * @memberof DashboardV2ApiGetDashboardBySchemaV2
     */
    readonly timezoneOffset?: string

    /**
     * Team ID to fetch data for.
     * @type {string}
     * @memberof DashboardV2ApiGetDashboardBySchemaV2
     */
    readonly teamId?: string

    /**
     * Filter metrics by performance type.
     * @type {MetricType}
     * @memberof DashboardV2ApiGetDashboardBySchemaV2
     */
    readonly type?: MetricType

    /**
     * 
     * @type {GetDashboardBySchemaRequest}
     * @memberof DashboardV2ApiGetDashboardBySchemaV2
     */
    readonly getDashboardBySchemaRequest?: GetDashboardBySchemaRequest
}

/**
 * Request parameters for getInitDataV2 operation in DashboardV2Api.
 * @export
 * @interface DashboardV2ApiGetInitDataV2Request
 */
export interface DashboardV2ApiGetInitDataV2Request {
    /**
     * 
     * @type {DashboardPeriod}
     * @memberof DashboardV2ApiGetInitDataV2
     */
    readonly period: DashboardPeriod

    /**
     * Timeframe to aggregate the data in.
     * @type {Aggregate}
     * @memberof DashboardV2ApiGetInitDataV2
     */
    readonly aggregate: Aggregate

    /**
     * Dashboard ID to fetch data for. If not provided, the default dashboard will be returned.
     * @type {string}
     * @memberof DashboardV2ApiGetInitDataV2
     */
    readonly id?: string

    /**
     * Custom date range to query the data in. Only required if period is set to \&quot;custom\&quot;
     * @type {DateRange}
     * @memberof DashboardV2ApiGetInitDataV2
     */
    readonly customDateRange?: DateRange

    /**
     * Timezone offset to query the data in.
     * @type {string}
     * @memberof DashboardV2ApiGetInitDataV2
     */
    readonly timezoneOffset?: string

    /**
     * Filter metrics by performance type.
     * @type {MetricType}
     * @memberof DashboardV2ApiGetInitDataV2
     */
    readonly type?: MetricType
}

/**
 * DashboardV2Api - object-oriented interface
 * @export
 * @class DashboardV2Api
 * @extends {BaseAPI}
 */
export class DashboardV2Api extends BaseAPI {
    /**
     * 
     * @summary Get benchmarks V2 with metric type filtering
     * @param {DashboardV2ApiGetBenchmarksV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardV2Api
     */
    public getBenchmarksV2(requestParameters: DashboardV2ApiGetBenchmarksV2Request = {}, options?: RawAxiosRequestConfig) {
        return DashboardV2ApiFp(this.configuration).getBenchmarksV2(requestParameters.period, requestParameters.type, requestParameters.filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get dashboard data by schema with metric type filtering
     * @param {DashboardV2ApiGetDashboardBySchemaV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardV2Api
     */
    public getDashboardBySchemaV2(requestParameters: DashboardV2ApiGetDashboardBySchemaV2Request, options?: RawAxiosRequestConfig) {
        return DashboardV2ApiFp(this.configuration).getDashboardBySchemaV2(requestParameters.period, requestParameters.aggregate, requestParameters.customDateRange, requestParameters.timezoneOffset, requestParameters.teamId, requestParameters.type, requestParameters.getDashboardBySchemaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get initial data V2 with metric type filtering
     * @param {DashboardV2ApiGetInitDataV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardV2Api
     */
    public getInitDataV2(requestParameters: DashboardV2ApiGetInitDataV2Request, options?: RawAxiosRequestConfig) {
        return DashboardV2ApiFp(this.configuration).getInitDataV2(requestParameters.period, requestParameters.aggregate, requestParameters.id, requestParameters.customDateRange, requestParameters.timezoneOffset, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all existing dashboards and creates a single V2 dashboard. Does not deduct credits.
     * @summary Migrate team to V2 dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardV2Api
     */
    public migrateDashboardToV2(options?: RawAxiosRequestConfig) {
        return DashboardV2ApiFp(this.configuration).migrateDashboardToV2(options).then((request) => request(this.axios, this.basePath));
    }
}



