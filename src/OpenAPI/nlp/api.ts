const BASE_PATH = "https://api.chatdaddy.tech/nlp".replace(/\/+$/, "");

/* tslint:disable */
/* eslint-disable */
/**
 * ChatDaddy NLP Service
 * Manage keyword based replies & AI automation
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
import type { RequestArgs } from '../base';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from '../base';

/**
 * 
 * @export
 * @interface AddSourceFile
 */
export interface AddSourceFile {
    /**
     * 
     * @type {string}
     * @memberof AddSourceFile
     */
    'type': AddSourceFileTypeEnum;
    /**
     * URL of the file to add
     * @type {string}
     * @memberof AddSourceFile
     */
    'url': string;
}

export const AddSourceFileTypeEnum = {
    Url: 'url',
    File: 'file'
} as const;

export type AddSourceFileTypeEnum = typeof AddSourceFileTypeEnum[keyof typeof AddSourceFileTypeEnum];

/**
 * @type AddSourceRequest
 * @export
 */
export type AddSourceRequest = AddSourceFile;

/**
 * 
 * @export
 * @interface AiCreditUse
 */
interface AiCreditUse {
    /**
     * 
     * @type {string}
     * @memberof AiCreditUse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AiCreditUse
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof AiCreditUse
     */
    'doneBy': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof AiCreditUse
     */
    'doneAt': string;
    /**
     * 
     * @type {AiCreditUseTranscriptionMetadata}
     * @memberof AiCreditUse
     */
    'transcriptionMetadata'?: AiCreditUseTranscriptionMetadata;
    /**
     * 
     * @type {AiCreditUseMetadata}
     * @memberof AiCreditUse
     */
    'metadata'?: AiCreditUseMetadata;
}
/**
 * 
 * @export
 * @interface AiCreditUseMetadata
 */
export interface AiCreditUseMetadata {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof AiCreditUseMetadata
     */
    'uniqueMessageId'?: string;
}
/**
 * 
 * @export
 * @interface AiCreditUseTranscriptionMetadata
 */
export interface AiCreditUseTranscriptionMetadata {
    /**
     * Duration of the transcription in seconds
     * @type {number}
     * @memberof AiCreditUseTranscriptionMetadata
     */
    'durationS': number;
}
/**
 * 
 * @export
 * @interface AutocompleteCalendarEventRequest
 */
interface AutocompleteCalendarEventRequest {
    /**
     * message to extract calendar event data from
     * @type {string}
     * @memberof AutocompleteCalendarEventRequest
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface AutocompleteInbox200Response
 */
export interface AutocompleteInbox200Response {
    /**
     * Name of the chatbot that generated the suggestions. Will use \"ChatDaddy AI\" if used vanilla GPT
     * @type {string}
     * @memberof AutocompleteInbox200Response
     */
    'chatbotName': string;
    /**
     * ID of the chatbot that generated the suggestions. Empty if used vanilla GPT
     * @type {string}
     * @memberof AutocompleteInbox200Response
     */
    'chatbotId'?: string;
    /**
     * 
     * @type {Array<AutocompleteSuggestion>}
     * @memberof AutocompleteInbox200Response
     */
    'suggestions': Array<AutocompleteSuggestion>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AutocompleteInbox200Response
     */
    'sources'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AutocompleteModifier = {
    Longer: 'longer',
    Shorter: 'shorter',
    Formal: 'formal',
    Friendlier: 'friendlier',
    Apologetic: 'apologetic',
    Assertive: 'assertive',
    Clearer: 'clearer',
    Ask: 'ask'
} as const;

export type AutocompleteModifier = typeof AutocompleteModifier[keyof typeof AutocompleteModifier];


/**
 * 
 * @export
 * @interface AutocompleteModify200Response
 */
export interface AutocompleteModify200Response {
    /**
     * Modified text
     * @type {string}
     * @memberof AutocompleteModify200Response
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface AutocompleteModifyRequest
 */
export interface AutocompleteModifyRequest {
    /**
     * 
     * @type {AutocompleteModifyRequestChat}
     * @memberof AutocompleteModifyRequest
     */
    'chat'?: AutocompleteModifyRequestChat;
    /**
     * Text to be modified
     * @type {string}
     * @memberof AutocompleteModifyRequest
     */
    'text': string;
    /**
     * Language to get response in
     * @type {string}
     * @memberof AutocompleteModifyRequest
     */
    'language'?: string;
}
/**
 * Provide chat as context for the modifier
 * @export
 * @interface AutocompleteModifyRequestChat
 */
export interface AutocompleteModifyRequestChat {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteModifyRequestChat
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof AutocompleteModifyRequestChat
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface AutocompleteSuggestion
 */
export interface AutocompleteSuggestion {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteSuggestion
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface CalendarEvent
 */
interface CalendarEvent {
    /**
     * Title of the event
     * @type {string}
     * @memberof CalendarEvent
     */
    'eventName': string;
    /**
     * Time of the event
     * @type {string}
     * @memberof CalendarEvent
     */
    'time': string;
    /**
     * Date of the event
     * @type {string}
     * @memberof CalendarEvent
     */
    'date': string;
    /**
     * duration of the event
     * @type {string}
     * @memberof CalendarEvent
     */
    'duration': string;
}
/**
 * 
 * @export
 * @interface Chatbot
 */
export interface Chatbot {
    /**
     * Name of the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'name': string;
    /**
     * Fallback message of the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'fallbackMessage': string;
    /**
     * Prompt message of the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'prompt': string;
    /**
     * Name of the member to assign to the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'assignedMember': string | null;
    /**
     * Name of the channel to deploy to the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'deployedAccount': string | null;
    /**
     * Use this chatbot as an AI assistant. Only one chatbot can be used as an AI assistant per team
     * @type {boolean}
     * @memberof Chatbot
     */
    'useAsAiAssistant': boolean;
    /**
     * Whether the chatbot is enabled to send messages to the deployed account
     * @type {boolean}
     * @memberof Chatbot
     */
    'enableAccountDeployment': boolean;
    /**
     * Should generated responses include the source of the data
     * @type {boolean}
     * @memberof Chatbot
     */
    'includeSourceInResponse': boolean;
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'id': string;
    /**
     * 
     * @type {Array<Document>}
     * @memberof Chatbot
     */
    'documents'?: Array<Document>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Chatbot
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Chatbot
     */
    'updatedAt': string;
    /**
     * Current training status of the chatbot
     * @type {string}
     * @memberof Chatbot
     */
    'trainingStatus': ChatbotTrainingStatusEnum;
    /**
     * Progress of training, between 0 and 100
     * @type {number}
     * @memberof Chatbot
     */
    'trainingProgress'?: number;
    /**
     * 
     * @type {Array<Job>}
     * @memberof Chatbot
     */
    'jobs'?: Array<Job>;
}

export const ChatbotTrainingStatusEnum = {
    Pending: 'pending',
    Running: 'running',
    Finished: 'finished',
    Failed: 'failed',
    Aborted: 'aborted'
} as const;

export type ChatbotTrainingStatusEnum = typeof ChatbotTrainingStatusEnum[keyof typeof ChatbotTrainingStatusEnum];

/**
 * 
 * @export
 * @interface ChatbotMessageRequest
 */
export interface ChatbotMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatbotMessageRequest
     */
    'message': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChatbotMessageRequest
     */
    'conversationHistory': Array<string>;
}
/**
 * 
 * @export
 * @interface ChatbotMessageResponse
 */
export interface ChatbotMessageResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof ChatbotMessageResponse
     */
    'message': Array<string>;
    /**
     * List of sources the bot used to generate the response
     * @type {Array<string>}
     * @memberof ChatbotMessageResponse
     */
    'sources': Array<string>;
    /**
     * Is the response a fallback message
     * @type {boolean}
     * @memberof ChatbotMessageResponse
     */
    'isFallback': boolean;
}
/**
 * 
 * @export
 * @interface ContactToken
 */
interface ContactToken {
    /**
     * ID of the contact
     * @type {string}
     * @memberof ContactToken
     */
    'contactId': string;
    /**
     * Access token for the contact
     * @type {string}
     * @memberof ContactToken
     */
    'accessToken': string;
}
/**
 * 
 * @export
 * @interface CreateChatbotResponse
 */
export interface CreateChatbotResponse {
    /**
     * 
     * @type {Chatbot}
     * @memberof CreateChatbotResponse
     */
    'chatbot': Chatbot;
}
/**
 * Converse via a custom messages
 * @export
 * @interface CustomLlmChatInput
 */
export interface CustomLlmChatInput {
    /**
     * 
     * @type {string}
     * @memberof CustomLlmChatInput
     */
    'type': CustomLlmChatInputTypeEnum;
    /**
     * 
     * @type {Array<LlmMessage>}
     * @memberof CustomLlmChatInput
     */
    'messages': Array<LlmMessage>;
}

export const CustomLlmChatInputTypeEnum = {
    Messages: 'messages'
} as const;

export type CustomLlmChatInputTypeEnum = typeof CustomLlmChatInputTypeEnum[keyof typeof CustomLlmChatInputTypeEnum];

/**
 * 
 * @export
 * @interface DeleteTriggers200Response
 */
export interface DeleteTriggers200Response {
    /**
     * 
     * @type {number}
     * @memberof DeleteTriggers200Response
     */
    'affected'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof DeleteTriggers200Response
     */
    'raw'?: Array<object>;
}
/**
 * 
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * URL of the stored data
     * @type {string}
     * @memberof Document
     */
    'link': string;
    /**
     * ID of the document
     * @type {string}
     * @memberof Document
     */
    'id': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Document
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Document
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Document
     */
    'fileName'?: string | null;
    /**
     * Number of tokens in the document
     * @type {number}
     * @memberof Document
     */
    'tokenCount': number;
}
/**
 * 
 * @export
 * @interface ExecutionFrame
 */
export interface ExecutionFrame {
    /**
     * 
     * @type {string}
     * @memberof ExecutionFrame
     */
    'day'?: ExecutionFrameDayEnum;
    /**
     * 
     * @type {string}
     * @memberof ExecutionFrame
     */
    'startTime': string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionFrame
     */
    'endTime': string;
}

export const ExecutionFrameDayEnum = {
    Monday: 'Monday',
    Tuesday: 'Tuesday',
    Wednesday: 'Wednesday',
    Thursday: 'Thursday',
    Friday: 'Friday',
    Saturday: 'Saturday',
    Sunday: 'Sunday'
} as const;

export type ExecutionFrameDayEnum = typeof ExecutionFrameDayEnum[keyof typeof ExecutionFrameDayEnum];

/**
 * 
 * @export
 * @interface GetChatbotsResponse
 */
export interface GetChatbotsResponse {
    /**
     * 
     * @type {Array<Chatbot>}
     * @memberof GetChatbotsResponse
     */
    'chatbots': Array<Chatbot>;
}
/**
 * 
 * @export
 * @interface GetExecutionRecord200Response
 */
export interface GetExecutionRecord200Response {
    /**
     * 
     * @type {Array<KeywordActionExecutionRecord>}
     * @memberof GetExecutionRecord200Response
     */
    'logs'?: Array<KeywordActionExecutionRecord>;
    /**
     * 
     * @type {number}
     * @memberof GetExecutionRecord200Response
     */
    'nextPageCursor'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetExecutionRecord200Response
     */
    'totalTriggered'?: number;
}
/**
 * 
 * @export
 * @interface GetKnowledgeBases200Response
 */
export interface GetKnowledgeBases200Response {
    /**
     * 
     * @type {Array<KnowledgeBase>}
     * @memberof GetKnowledgeBases200Response
     */
    'items': Array<KnowledgeBase>;
}
/**
 * 
 * @export
 * @interface GetSources200Response
 */
export interface GetSources200Response {
    /**
     * 
     * @type {Array<KnowledgeBaseSource>}
     * @memberof GetSources200Response
     */
    'items': Array<KnowledgeBaseSource>;
}
/**
 * 
 * @export
 * @interface GetTriggers200Response
 */
export interface GetTriggers200Response {
    /**
     * 
     * @type {Array<KeywordBasedAction>}
     * @memberof GetTriggers200Response
     */
    'triggers'?: Array<KeywordBasedAction>;
    /**
     * 
     * @type {number}
     * @memberof GetTriggers200Response
     */
    'nextPageCursor'?: number;
    /**
     * total keywords present with these filters. Only returned if returnTotalCount is true
     * @type {number}
     * @memberof GetTriggers200Response
     */
    'totalCount'?: number;
}
/**
 * Converse via an existing IM chat. The unique identifier for the thread is simply `accountId/id`
 * @export
 * @interface ImLlmChatInput
 */
export interface ImLlmChatInput {
    /**
     * 
     * @type {string}
     * @memberof ImLlmChatInput
     */
    'type': ImLlmChatInputTypeEnum;
    /**
     * Account ID of the chat
     * @type {string}
     * @memberof ImLlmChatInput
     */
    'accountId': string;
    /**
     * ID of the chat
     * @type {string}
     * @memberof ImLlmChatInput
     */
    'id': string;
    /**
     * If no conversation exists with the bot, instructions to start the conversation
     * @type {string}
     * @memberof ImLlmChatInput
     */
    'instructions'?: string;
}

export const ImLlmChatInputTypeEnum = {
    ImChat: 'im-chat'
} as const;

export type ImLlmChatInputTypeEnum = typeof ImLlmChatInputTypeEnum[keyof typeof ImLlmChatInputTypeEnum];

/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'id': string;
    /**
     * 
     * @type {JobType}
     * @memberof Job
     */
    'type': JobType;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'link': string;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'fileName'?: string;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'progress': number;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Job
     */
    'createdAt': string;
    /**
     * 
     * @type {JobStatus}
     * @memberof Job
     */
    'status': JobStatus;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const JobStatus = {
    Pending: 'pending',
    Running: 'running',
    Finished: 'finished',
    Failed: 'failed',
    Aborted: 'aborted'
} as const;

export type JobStatus = typeof JobStatus[keyof typeof JobStatus];


/**
 * - crawl: crawl the URL and extract data - extract: extract data from the URL, expect pdf or docx
 * @export
 * @enum {string}
 */

export const JobType = {
    Crawl: 'crawl',
    Extract: 'extract'
} as const;

export type JobType = typeof JobType[keyof typeof JobType];


/**
 * 
 * @export
 * @interface Keyword
 */
export interface Keyword {
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    'text'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof Keyword
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface KeywordActionCreateRequestObj
 */
export interface KeywordActionCreateRequestObj {
    /**
     * Status of reply service
     * @type {boolean}
     * @memberof KeywordActionCreateRequestObj
     */
    'enabled'?: boolean;
    /**
     * Accounts the keywords will trigger for
     * @type {Array<string>}
     * @memberof KeywordActionCreateRequestObj
     */
    'accountIds'?: Array<string>;
    /**
     * Should typing indicator & read receipt be sent
     * @type {boolean}
     * @memberof KeywordActionCreateRequestObj
     */
    'sendTyping'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof KeywordActionCreateRequestObj
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * Toggles whether the keyword reply will trigger for group chats
     * @type {boolean}
     * @memberof KeywordActionCreateRequestObj
     */
    'enableOnGroupChats'?: boolean;
    /**
     * Only on the first message in a chat
     * @type {boolean}
     * @memberof KeywordActionCreateRequestObj
     */
    'onlyOnFirstMessage'?: boolean;
    /**
     * 
     * @type {TriggerType}
     * @memberof KeywordActionCreateRequestObj
     */
    'triggerType': TriggerType;
    /**
     * Unique triggering keywords
     * @type {Array<Keyword>}
     * @memberof KeywordActionCreateRequestObj
     */
    'keywords': Array<Keyword>;
    /**
     * Flow ids to be triggered
     * @type {Array<string>}
     * @memberof KeywordActionCreateRequestObj
     */
    'flowIds': Array<string>;
    /**
     * Timespan before the keyword can be triggered again, measured in seconds
     * @type {number}
     * @memberof KeywordActionCreateRequestObj
     */
    'delay'?: number;
    /**
     * 
     * @type {Array<ExecutionFrame>}
     * @memberof KeywordActionCreateRequestObj
     */
    'executionFrames'?: Array<ExecutionFrame>;
}


/**
 * 
 * @export
 * @interface KeywordActionEditRequestObj
 */
export interface KeywordActionEditRequestObj {
    /**
     * Keyword Id (auto incrementing)
     * @type {number}
     * @memberof KeywordActionEditRequestObj
     */
    'id': number;
    /**
     * Accounts the keywords will trigger for
     * @type {Array<string>}
     * @memberof KeywordActionEditRequestObj
     */
    'accountIds'?: Array<string>;
    /**
     * Status of reply service
     * @type {boolean}
     * @memberof KeywordActionEditRequestObj
     */
    'enabled'?: boolean;
    /**
     * Should typing indicator & read receipt be sent
     * @type {boolean}
     * @memberof KeywordActionEditRequestObj
     */
    'sendTyping'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof KeywordActionEditRequestObj
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * Only on the first message in a chat
     * @type {boolean}
     * @memberof KeywordActionEditRequestObj
     */
    'onlyOnFirstMessage'?: boolean;
    /**
     * Toggles whether the keyword reply will trigger for group chats
     * @type {boolean}
     * @memberof KeywordActionEditRequestObj
     */
    'enableOnGroupChats'?: boolean;
    /**
     * 
     * @type {TriggerType}
     * @memberof KeywordActionEditRequestObj
     */
    'triggerType'?: TriggerType;
    /**
     * Unique triggering keywords
     * @type {Array<Keyword>}
     * @memberof KeywordActionEditRequestObj
     */
    'keywords'?: Array<Keyword>;
    /**
     * Flow ids to be triggered
     * @type {Array<string>}
     * @memberof KeywordActionEditRequestObj
     */
    'flowIds'?: Array<string>;
    /**
     * Timespan before the keyword can be triggered again, measured in seconds
     * @type {number}
     * @memberof KeywordActionEditRequestObj
     */
    'delay'?: number;
    /**
     * 
     * @type {Array<ExecutionFrame>}
     * @memberof KeywordActionEditRequestObj
     */
    'executionFrames'?: Array<ExecutionFrame>;
}


/**
 * 
 * @export
 * @interface KeywordActionExecutionRecord
 */
export interface KeywordActionExecutionRecord {
    /**
     * Keyword Id (auto incrementing)
     * @type {number}
     * @memberof KeywordActionExecutionRecord
     */
    'id': number;
    /**
     * Triggering chatId (jid)
     * @type {string}
     * @memberof KeywordActionExecutionRecord
     */
    'chatId': string;
    /**
     * Incoming message body
     * @type {string}
     * @memberof KeywordActionExecutionRecord
     */
    'text': string;
    /**
     * FlowId to be triggered
     * @type {string}
     * @memberof KeywordActionExecutionRecord
     */
    'flowId'?: string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof KeywordActionExecutionRecord
     */
    'timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof KeywordActionExecutionRecord
     */
    'messageId': string;
    /**
     * 
     * @type {string}
     * @memberof KeywordActionExecutionRecord
     */
    'accountId'?: string;
}
/**
 * 
 * @export
 * @interface KeywordBasedAction
 */
export interface KeywordBasedAction {
    /**
     * Keyword Id (auto incrementing)
     * @type {number}
     * @memberof KeywordBasedAction
     */
    'id': number;
    /**
     * Team the keyword belongs to
     * @type {string}
     * @memberof KeywordBasedAction
     */
    'teamId': string;
    /**
     * Accounts the keywords will trigger for
     * @type {Array<string>}
     * @memberof KeywordBasedAction
     */
    'accountIds'?: Array<string>;
    /**
     * Status of reply service
     * @type {boolean}
     * @memberof KeywordBasedAction
     */
    'enabled': boolean;
    /**
     * Should typing indicator & read receipt be sent
     * @type {boolean}
     * @memberof KeywordBasedAction
     */
    'sendTyping'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof KeywordBasedAction
     */
    'cancelIfReplyReceived'?: boolean;
    /**
     * Toggles whether the keyword reply will trigger for group chats
     * @type {boolean}
     * @memberof KeywordBasedAction
     */
    'enableOnGroupChats'?: boolean;
    /**
     * Only on the first message in a chat
     * @type {boolean}
     * @memberof KeywordBasedAction
     */
    'onlyOnFirstMessage'?: boolean;
    /**
     * 
     * @type {TriggerType}
     * @memberof KeywordBasedAction
     */
    'triggerType': TriggerType;
    /**
     * Unique triggering keywords
     * @type {Array<Keyword>}
     * @memberof KeywordBasedAction
     */
    'keywords': Array<Keyword>;
    /**
     * Flow ids to be triggered
     * @type {Array<string>}
     * @memberof KeywordBasedAction
     */
    'flowIds'?: Array<string>;
    /**
     * Timespan before the keyword can be triggered again, measured in seconds
     * @type {number}
     * @memberof KeywordBasedAction
     */
    'delay'?: number;
    /**
     * 
     * @type {Array<ExecutionFrame>}
     * @memberof KeywordBasedAction
     */
    'executionFrames'?: Array<ExecutionFrame>;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof KeywordBasedAction
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof KeywordBasedAction
     */
    'updatedAt'?: string;
    /**
     * User who created the keyword
     * @type {string}
     * @memberof KeywordBasedAction
     */
    'createdBy': string;
}


/**
 * 
 * @export
 * @interface KnowledgeBase
 */
export interface KnowledgeBase {
    /**
     * ID of the knowledge base
     * @type {string}
     * @memberof KnowledgeBase
     */
    'id': string;
    /**
     * Name of the knowledge base
     * @type {string}
     * @memberof KnowledgeBase
     */
    'name': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof KnowledgeBase
     */
    'createdAt': string;
    /**
     * User who created the knowledge base
     * @type {string}
     * @memberof KnowledgeBase
     */
    'createdBy': string;
    /**
     * Size of the knowledge base in bytes
     * @type {number}
     * @memberof KnowledgeBase
     */
    'storageSizeBytes': number;
    /**
     * 
     * @type {KnowledgeBaseTestConfig}
     * @memberof KnowledgeBase
     */
    'defaultTestConfig'?: KnowledgeBaseTestConfig;
    /**
     * 
     * @type {Array<KnowledgeBaseSource>}
     * @memberof KnowledgeBase
     */
    'sources': Array<KnowledgeBaseSource>;
}
/**
 * 
 * @export
 * @interface KnowledgeBaseSource
 */
export interface KnowledgeBaseSource {
    /**
     * ID of the source
     * @type {string}
     * @memberof KnowledgeBaseSource
     */
    'id': string;
    /**
     * 
     * @type {KnowledgeBaseSourceData}
     * @memberof KnowledgeBaseSource
     */
    'data': KnowledgeBaseSourceData;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof KnowledgeBaseSource
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseSource
     */
    'createdBy': string;
}
/**
 * @type KnowledgeBaseSourceData
 * @export
 */
export type KnowledgeBaseSourceData = KnowledgeBaseSourceDataFile;

/**
 * 
 * @export
 * @interface KnowledgeBaseSourceDataFile
 */
export interface KnowledgeBaseSourceDataFile {
    /**
     * URL of the uploaded file
     * @type {string}
     * @memberof KnowledgeBaseSourceDataFile
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseSourceDataFile
     */
    'type': KnowledgeBaseSourceDataFileTypeEnum;
    /**
     * Size of the knowledge base in bytes
     * @type {number}
     * @memberof KnowledgeBaseSourceDataFile
     */
    'storageSizeBytes': number;
    /**
     * MIME type of the file
     * @type {string}
     * @memberof KnowledgeBaseSourceDataFile
     */
    'mimetype': string;
    /**
     * ID of the file
     * @type {string}
     * @memberof KnowledgeBaseSourceDataFile
     */
    'fileId': string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseSourceDataFile
     */
    'filename'?: string;
}

export const KnowledgeBaseSourceDataFileTypeEnum = {
    File: 'file',
    Url: 'url'
} as const;

export type KnowledgeBaseSourceDataFileTypeEnum = typeof KnowledgeBaseSourceDataFileTypeEnum[keyof typeof KnowledgeBaseSourceDataFileTypeEnum];

/**
 * 
 * @export
 * @interface KnowledgeBaseTestConfig
 */
export interface KnowledgeBaseTestConfig {
    /**
     * 
     * @type {LlmModel}
     * @memberof KnowledgeBaseTestConfig
     */
    'model'?: LlmModel;
    /**
     * Instructions to start the conversation
     * @type {string}
     * @memberof KnowledgeBaseTestConfig
     */
    'instructions'?: string;
}


/**
 * 
 * @export
 * @interface LlmChat200Response
 */
export interface LlmChat200Response {
    /**
     * 
     * @type {Array<LlmChatOutputItem>}
     * @memberof LlmChat200Response
     */
    'items': Array<LlmChatOutputItem>;
}
/**
 * @type LlmChatInput
 * @export
 */
export type LlmChatInput = CustomLlmChatInput | ImLlmChatInput;

/**
 * @type LlmChatOutputItem
 * @export
 */
export type LlmChatOutputItem = LlmChatOutputText | LlmChatOutputToolRequest;

/**
 * Text response from the chatbot
 * @export
 * @interface LlmChatOutputText
 */
export interface LlmChatOutputText {
    /**
     * 
     * @type {string}
     * @memberof LlmChatOutputText
     */
    'type': LlmChatOutputTextTypeEnum;
    /**
     * Text response from the chatbot
     * @type {string}
     * @memberof LlmChatOutputText
     */
    'text': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LlmChatOutputText
     */
    'sources'?: Array<string>;
}

export const LlmChatOutputTextTypeEnum = {
    Text: 'text'
} as const;

export type LlmChatOutputTextTypeEnum = typeof LlmChatOutputTextTypeEnum[keyof typeof LlmChatOutputTextTypeEnum];

/**
 * Request execution of a tool
 * @export
 * @interface LlmChatOutputToolRequest
 */
export interface LlmChatOutputToolRequest {
    /**
     * 
     * @type {string}
     * @memberof LlmChatOutputToolRequest
     */
    'type': LlmChatOutputToolRequestTypeEnum;
    /**
     * Name of the tool to call
     * @type {string}
     * @memberof LlmChatOutputToolRequest
     */
    'name': string;
    /**
     * ID of the request
     * @type {string}
     * @memberof LlmChatOutputToolRequest
     */
    'id': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof LlmChatOutputToolRequest
     */
    'params': { [key: string]: any; };
}

export const LlmChatOutputToolRequestTypeEnum = {
    Tool: 'tool'
} as const;

export type LlmChatOutputToolRequestTypeEnum = typeof LlmChatOutputToolRequestTypeEnum[keyof typeof LlmChatOutputToolRequestTypeEnum];

/**
 * 
 * @export
 * @interface LlmChatRequest
 */
export interface LlmChatRequest {
    /**
     * Thread ID of the conversation
     * @type {string}
     * @memberof LlmChatRequest
     */
    'id': string;
    /**
     * 
     * @type {LlmChatInput}
     * @memberof LlmChatRequest
     */
    'input': LlmChatInput;
    /**
     * 
     * @type {Array<LlmTool>}
     * @memberof LlmChatRequest
     */
    'tools'?: Array<LlmTool>;
    /**
     * 
     * @type {LlmModel}
     * @memberof LlmChatRequest
     */
    'model'?: LlmModel;
    /**
     * 
     * @type {Array<string>}
     * @memberof LlmChatRequest
     */
    'knowledgeBaseIds'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof LlmChatRequest
     */
    'temperature'?: number;
    /**
     * Clear any existing conversation, and start a new one
     * @type {boolean}
     * @memberof LlmChatRequest
     */
    'clear'?: boolean;
}


/**
 * @type LlmMessage
 * @export
 */
export type LlmMessage = LlmMessageInput | LlmMessageToolOutput;

/**
 * 
 * @export
 * @interface LlmMessageInput
 */
export interface LlmMessageInput {
    /**
     * 
     * @type {string}
     * @memberof LlmMessageInput
     */
    'type': LlmMessageInputTypeEnum;
    /**
     * Text to send to the chatbot
     * @type {string}
     * @memberof LlmMessageInput
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof LlmMessageInput
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof LlmMessageInput
     */
    'fileUrl'?: string;
    /**
     * Role of the sender
     * @type {string}
     * @memberof LlmMessageInput
     */
    'role': LlmMessageInputRoleEnum;
}

export const LlmMessageInputTypeEnum = {
    Input: 'input'
} as const;

export type LlmMessageInputTypeEnum = typeof LlmMessageInputTypeEnum[keyof typeof LlmMessageInputTypeEnum];
export const LlmMessageInputRoleEnum = {
    User: 'user',
    System: 'system',
    Assistant: 'assistant'
} as const;

export type LlmMessageInputRoleEnum = typeof LlmMessageInputRoleEnum[keyof typeof LlmMessageInputRoleEnum];

/**
 * 
 * @export
 * @interface LlmMessageToolOutput
 */
export interface LlmMessageToolOutput {
    /**
     * 
     * @type {string}
     * @memberof LlmMessageToolOutput
     */
    'type': LlmMessageToolOutputTypeEnum;
    /**
     * ID of the tool call being responded to
     * @type {string}
     * @memberof LlmMessageToolOutput
     */
    'id': string;
    /**
     * Output of the tool
     * @type {string}
     * @memberof LlmMessageToolOutput
     */
    'output': string;
}

export const LlmMessageToolOutputTypeEnum = {
    ToolOutput: 'tool-output'
} as const;

export type LlmMessageToolOutputTypeEnum = typeof LlmMessageToolOutputTypeEnum[keyof typeof LlmMessageToolOutputTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const LlmModel = {
    Gpt4oMini: 'gpt-4o-mini',
    Gpt4o: 'gpt-4o'
} as const;

export type LlmModel = typeof LlmModel[keyof typeof LlmModel];


/**
 * 
 * @export
 * @interface LlmTool
 */
export interface LlmTool {
    /**
     * Name of the tool, only supports alphanumeric characters
     * @type {string}
     * @memberof LlmTool
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LlmTool
     */
    'description': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof LlmTool
     */
    'parameters': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface OauthCallback200Response
 */
interface OauthCallback200Response {
    /**
     * 
     * @type {string}
     * @memberof OauthCallback200Response
     */
    'accessToken'?: string;
}
/**
 * 
 * @export
 * @interface StartJobRequest
 */
export interface StartJobRequest {
    /**
     * 
     * @type {string}
     * @memberof StartJobRequest
     */
    'link': string;
    /**
     * 
     * @type {string}
     * @memberof StartJobRequest
     */
    'fileName'?: string;
}
/**
 * 
 * @export
 * @interface StartJobResponse
 */
export interface StartJobResponse {
    /**
     * 
     * @type {Job}
     * @memberof StartJobResponse
     */
    'job': Job;
}
/**
 * 
 * @export
 * @interface TagSuggest200Response
 */
export interface TagSuggest200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof TagSuggest200Response
     */
    'suggestedTagNames'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TrainingStatusResponse
 */
export interface TrainingStatusResponse {
    /**
     * Status of training
     * @type {string}
     * @memberof TrainingStatusResponse
     */
    'status': TrainingStatusResponseStatusEnum;
    /**
     * Progress of training
     * @type {number}
     * @memberof TrainingStatusResponse
     */
    'progress': number;
}

export const TrainingStatusResponseStatusEnum = {
    Idle: 'idle',
    InProgress: 'inProgress',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type TrainingStatusResponseStatusEnum = typeof TrainingStatusResponseStatusEnum[keyof typeof TrainingStatusResponseStatusEnum];

/**
 * 
 * @export
 * @interface TranscribePost200Response
 */
export interface TranscribePost200Response {
    /**
     * 
     * @type {string}
     * @memberof TranscribePost200Response
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface TranscriptionJob
 */
export interface TranscriptionJob {
    /**
     * 
     * @type {string}
     * @memberof TranscriptionJob
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TranscriptionJob
     */
    'status': TranscriptionJobStatusEnum;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TranscriptionJob
     */
    'createdAt': string;
    /**
     * An ISO formatted timestamp
     * @type {string}
     * @memberof TranscriptionJob
     */
    'timesOutAt': string;
    /**
     * Transcription of the audio
     * @type {string}
     * @memberof TranscriptionJob
     */
    'transcription'?: string;
    /**
     * Error message if transcription failed
     * @type {string}
     * @memberof TranscriptionJob
     */
    'error'?: string;
}

export const TranscriptionJobStatusEnum = {
    Pending: 'pending',
    InProgress: 'in-progress',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type TranscriptionJobStatusEnum = typeof TranscriptionJobStatusEnum[keyof typeof TranscriptionJobStatusEnum];

/**
 * 
 * @export
 * @interface TranscriptionRequest
 */
export interface TranscriptionRequest {
    /**
     * 
     * @type {string}
     * @memberof TranscriptionRequest
     */
    'type': TranscriptionRequestTypeEnum;
    /**
     * The URL of the audio to transcribe
     * @type {string}
     * @memberof TranscriptionRequest
     */
    'url': string;
    /**
     * 
     * @type {AiCreditUseMetadata}
     * @memberof TranscriptionRequest
     */
    'metadata'?: AiCreditUseMetadata;
}

export const TranscriptionRequestTypeEnum = {
    Url: 'url'
} as const;

export type TranscriptionRequestTypeEnum = typeof TranscriptionRequestTypeEnum[keyof typeof TranscriptionRequestTypeEnum];

/**
 * Type of trigger
 * @export
 * @enum {string}
 */

export const TriggerType = {
    Contains: 'contains',
    ContainsPhrase: 'containsPhrase',
    StartsWith: 'startsWith',
    KeywordIs: 'keywordIs',
    DefaultReply: 'defaultReply'
} as const;

export type TriggerType = typeof TriggerType[keyof typeof TriggerType];


/**
 * 
 * @export
 * @interface UpdatableChatbotProperties
 */
export interface UpdatableChatbotProperties {
    /**
     * Name of the chatbot
     * @type {string}
     * @memberof UpdatableChatbotProperties
     */
    'name'?: string;
    /**
     * Fallback message of the chatbot
     * @type {string}
     * @memberof UpdatableChatbotProperties
     */
    'fallbackMessage'?: string;
    /**
     * Prompt message of the chatbot
     * @type {string}
     * @memberof UpdatableChatbotProperties
     */
    'prompt'?: string;
    /**
     * Name of the member to assign to the chatbot
     * @type {string}
     * @memberof UpdatableChatbotProperties
     */
    'assignedMember'?: string | null;
    /**
     * Name of the channel to deploy to the chatbot
     * @type {string}
     * @memberof UpdatableChatbotProperties
     */
    'deployedAccount'?: string | null;
    /**
     * Use this chatbot as an AI assistant. Only one chatbot can be used as an AI assistant per team
     * @type {boolean}
     * @memberof UpdatableChatbotProperties
     */
    'useAsAiAssistant'?: boolean;
    /**
     * Whether the chatbot is enabled to send messages to the deployed account
     * @type {boolean}
     * @memberof UpdatableChatbotProperties
     */
    'enableAccountDeployment'?: boolean;
    /**
     * Should generated responses include the source of the data
     * @type {boolean}
     * @memberof UpdatableChatbotProperties
     */
    'includeSourceInResponse'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateChatbotRequest
 */
export interface UpdateChatbotRequest {
    /**
     * Name of the chatbot
     * @type {string}
     * @memberof UpdateChatbotRequest
     */
    'name'?: string;
    /**
     * Fallback message of the chatbot
     * @type {string}
     * @memberof UpdateChatbotRequest
     */
    'fallbackMessage'?: string;
    /**
     * Prompt message of the chatbot
     * @type {string}
     * @memberof UpdateChatbotRequest
     */
    'prompt'?: string;
    /**
     * Name of the member to assign to the chatbot
     * @type {string}
     * @memberof UpdateChatbotRequest
     */
    'assignedMember'?: string | null;
    /**
     * Name of the channel to deploy to the chatbot
     * @type {string}
     * @memberof UpdateChatbotRequest
     */
    'deployedAccount'?: string | null;
    /**
     * Use this chatbot as an AI assistant. Only one chatbot can be used as an AI assistant per team
     * @type {boolean}
     * @memberof UpdateChatbotRequest
     */
    'useAsAiAssistant'?: boolean;
    /**
     * Whether the chatbot is enabled to send messages to the deployed account
     * @type {boolean}
     * @memberof UpdateChatbotRequest
     */
    'enableAccountDeployment'?: boolean;
    /**
     * Should generated responses include the source of the data
     * @type {boolean}
     * @memberof UpdateChatbotRequest
     */
    'includeSourceInResponse'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateChatbotRequest
     */
    'removeDocumentIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpsertKnowledgeBase
 */
export interface UpsertKnowledgeBase {
    /**
     * Name of the knowledge base
     * @type {string}
     * @memberof UpsertKnowledgeBase
     */
    'name'?: string;
    /**
     * 
     * @type {KnowledgeBaseTestConfig}
     * @memberof UpsertKnowledgeBase
     */
    'defaultTestConfig'?: KnowledgeBaseTestConfig;
}

/**
 * AudioTranscriptionApi - axios parameter creator
 * @export
 */
export const AudioTranscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Polls the status of a transcription job
         * @summary Get the status of a transcription job
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribeGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transcribeGet', 'id', id)
            const localVarPath = `/transcribe/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts an audio URL and converts it to text
         * @summary Convert audio URL to text
         * @param {TranscriptionRequest} transcriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribePost: async (transcriptionRequest: TranscriptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transcriptionRequest' is not null or undefined
            assertParamExists('transcribePost', 'transcriptionRequest', transcriptionRequest)
            const localVarPath = `/transcribe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transcriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AudioTranscriptionApi - functional programming interface
 * @export
 */
export const AudioTranscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AudioTranscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Polls the status of a transcription job
         * @summary Get the status of a transcription job
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcribeGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranscriptionJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcribeGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudioTranscriptionApi.transcribeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Accepts an audio URL and converts it to text
         * @summary Convert audio URL to text
         * @param {TranscriptionRequest} transcriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transcribePost(transcriptionRequest: TranscriptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranscribePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transcribePost(transcriptionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudioTranscriptionApi.transcribePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AudioTranscriptionApi - factory interface
 * @export
 */
export const AudioTranscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AudioTranscriptionApiFp(configuration)
    return {
        /**
         * Polls the status of a transcription job
         * @summary Get the status of a transcription job
         * @param {AudioTranscriptionApiTranscribeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribeGet(requestParameters: AudioTranscriptionApiTranscribeGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<TranscriptionJob> {
            return localVarFp.transcribeGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts an audio URL and converts it to text
         * @summary Convert audio URL to text
         * @param {AudioTranscriptionApiTranscribePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transcribePost(requestParameters: AudioTranscriptionApiTranscribePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TranscribePost200Response> {
            return localVarFp.transcribePost(requestParameters.transcriptionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for transcribeGet operation in AudioTranscriptionApi.
 * @export
 * @interface AudioTranscriptionApiTranscribeGetRequest
 */
export interface AudioTranscriptionApiTranscribeGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AudioTranscriptionApiTranscribeGet
     */
    readonly id: string
}

/**
 * Request parameters for transcribePost operation in AudioTranscriptionApi.
 * @export
 * @interface AudioTranscriptionApiTranscribePostRequest
 */
export interface AudioTranscriptionApiTranscribePostRequest {
    /**
     * 
     * @type {TranscriptionRequest}
     * @memberof AudioTranscriptionApiTranscribePost
     */
    readonly transcriptionRequest: TranscriptionRequest
}

/**
 * AudioTranscriptionApi - object-oriented interface
 * @export
 * @class AudioTranscriptionApi
 * @extends {BaseAPI}
 */
export class AudioTranscriptionApi extends BaseAPI {
    /**
     * Polls the status of a transcription job
     * @summary Get the status of a transcription job
     * @param {AudioTranscriptionApiTranscribeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioTranscriptionApi
     */
    public transcribeGet(requestParameters: AudioTranscriptionApiTranscribeGetRequest, options?: RawAxiosRequestConfig) {
        return AudioTranscriptionApiFp(this.configuration).transcribeGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts an audio URL and converts it to text
     * @summary Convert audio URL to text
     * @param {AudioTranscriptionApiTranscribePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioTranscriptionApi
     */
    public transcribePost(requestParameters: AudioTranscriptionApiTranscribePostRequest, options?: RawAxiosRequestConfig) {
        return AudioTranscriptionApiFp(this.configuration).transcribePost(requestParameters.transcriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AutocompleteApi - axios parameter creator
 * @export
 */
export const AutocompleteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Extract calendar event information from message
         * @param {AutocompleteCalendarEventRequest} [autocompleteCalendarEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteCalendarEvent: async (autocompleteCalendarEventRequest?: AutocompleteCalendarEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/autocomplete/calendar-event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autocompleteCalendarEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns autocomplete suggestions for a chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteInbox: async (accountId: string, chatId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('autocompleteInbox', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('autocompleteInbox', 'chatId', chatId)
            const localVarPath = `/autocomplete/inbox/{accountId}/{chatId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply some modification to the given text
         * @param {AutocompleteModifier} modifier 
         * @param {AutocompleteModifyRequest} autocompleteModifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteModify: async (modifier: AutocompleteModifier, autocompleteModifyRequest: AutocompleteModifyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modifier' is not null or undefined
            assertParamExists('autocompleteModify', 'modifier', modifier)
            // verify required parameter 'autocompleteModifyRequest' is not null or undefined
            assertParamExists('autocompleteModify', 'autocompleteModifyRequest', autocompleteModifyRequest)
            const localVarPath = `/autocomplete/modify/{modifier}`
                .replace(`{${"modifier"}}`, encodeURIComponent(String(modifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autocompleteModifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary OAuth callback
         * @param {string} code 
         * @param {string} state 
         * @param {string} [scope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthCallback: async (code: string, state: string, scope?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('oauthCallback', 'code', code)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('oauthCallback', 'state', state)
            const localVarPath = `/oauth/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a suggested tag name
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {boolean} [isCustomField] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagSuggest: async (accountId: string, chatId: string, isCustomField?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('tagSuggest', 'accountId', accountId)
            // verify required parameter 'chatId' is not null or undefined
            assertParamExists('tagSuggest', 'chatId', chatId)
            const localVarPath = `/tag/suggest/{accountId}/{chatId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"chatId"}}`, encodeURIComponent(String(chatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)

            if (isCustomField !== undefined) {
                localVarQueryParameter['isCustomField'] = isCustomField;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutocompleteApi - functional programming interface
 * @export
 */
export const AutocompleteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutocompleteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Extract calendar event information from message
         * @param {AutocompleteCalendarEventRequest} [autocompleteCalendarEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompleteCalendarEvent(autocompleteCalendarEventRequest?: AutocompleteCalendarEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CalendarEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompleteCalendarEvent(autocompleteCalendarEventRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutocompleteApi.autocompleteCalendarEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns autocomplete suggestions for a chat
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompleteInbox(accountId: string, chatId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutocompleteInbox200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompleteInbox(accountId, chatId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutocompleteApi.autocompleteInbox']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Apply some modification to the given text
         * @param {AutocompleteModifier} modifier 
         * @param {AutocompleteModifyRequest} autocompleteModifyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autocompleteModify(modifier: AutocompleteModifier, autocompleteModifyRequest: AutocompleteModifyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutocompleteModify200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autocompleteModify(modifier, autocompleteModifyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutocompleteApi.autocompleteModify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary OAuth callback
         * @param {string} code 
         * @param {string} state 
         * @param {string} [scope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthCallback(code: string, state: string, scope?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OauthCallback200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthCallback(code, state, scope, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutocompleteApi.oauthCallback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a suggested tag name
         * @param {string} accountId 
         * @param {string} chatId 
         * @param {boolean} [isCustomField] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagSuggest(accountId: string, chatId: string, isCustomField?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagSuggest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagSuggest(accountId, chatId, isCustomField, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutocompleteApi.tagSuggest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AutocompleteApi - factory interface
 * @export
 */
export const AutocompleteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutocompleteApiFp(configuration)
    return {
        /**
         * 
         * @summary Extract calendar event information from message
         * @param {AutocompleteApiAutocompleteCalendarEventRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteCalendarEvent(requestParameters: AutocompleteApiAutocompleteCalendarEventRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CalendarEvent> {
            return localVarFp.autocompleteCalendarEvent(requestParameters.autocompleteCalendarEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns autocomplete suggestions for a chat
         * @param {AutocompleteApiAutocompleteInboxRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteInbox(requestParameters: AutocompleteApiAutocompleteInboxRequest, options?: RawAxiosRequestConfig): AxiosPromise<AutocompleteInbox200Response> {
            return localVarFp.autocompleteInbox(requestParameters.accountId, requestParameters.chatId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Apply some modification to the given text
         * @param {AutocompleteApiAutocompleteModifyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autocompleteModify(requestParameters: AutocompleteApiAutocompleteModifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<AutocompleteModify200Response> {
            return localVarFp.autocompleteModify(requestParameters.modifier, requestParameters.autocompleteModifyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary OAuth callback
         * @param {AutocompleteApiOauthCallbackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthCallback(requestParameters: AutocompleteApiOauthCallbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<OauthCallback200Response> {
            return localVarFp.oauthCallback(requestParameters.code, requestParameters.state, requestParameters.scope, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a suggested tag name
         * @param {AutocompleteApiTagSuggestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagSuggest(requestParameters: AutocompleteApiTagSuggestRequest, options?: RawAxiosRequestConfig): AxiosPromise<TagSuggest200Response> {
            return localVarFp.tagSuggest(requestParameters.accountId, requestParameters.chatId, requestParameters.isCustomField, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for autocompleteCalendarEvent operation in AutocompleteApi.
 * @export
 * @interface AutocompleteApiAutocompleteCalendarEventRequest
 */
export interface AutocompleteApiAutocompleteCalendarEventRequest {
    /**
     * 
     * @type {AutocompleteCalendarEventRequest}
     * @memberof AutocompleteApiAutocompleteCalendarEvent
     */
    readonly autocompleteCalendarEventRequest?: AutocompleteCalendarEventRequest
}

/**
 * Request parameters for autocompleteInbox operation in AutocompleteApi.
 * @export
 * @interface AutocompleteApiAutocompleteInboxRequest
 */
export interface AutocompleteApiAutocompleteInboxRequest {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteApiAutocompleteInbox
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof AutocompleteApiAutocompleteInbox
     */
    readonly chatId: string
}

/**
 * Request parameters for autocompleteModify operation in AutocompleteApi.
 * @export
 * @interface AutocompleteApiAutocompleteModifyRequest
 */
export interface AutocompleteApiAutocompleteModifyRequest {
    /**
     * 
     * @type {AutocompleteModifier}
     * @memberof AutocompleteApiAutocompleteModify
     */
    readonly modifier: AutocompleteModifier

    /**
     * 
     * @type {AutocompleteModifyRequest}
     * @memberof AutocompleteApiAutocompleteModify
     */
    readonly autocompleteModifyRequest: AutocompleteModifyRequest
}

/**
 * Request parameters for oauthCallback operation in AutocompleteApi.
 * @export
 * @interface AutocompleteApiOauthCallbackRequest
 */
export interface AutocompleteApiOauthCallbackRequest {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteApiOauthCallback
     */
    readonly code: string

    /**
     * 
     * @type {string}
     * @memberof AutocompleteApiOauthCallback
     */
    readonly state: string

    /**
     * 
     * @type {string}
     * @memberof AutocompleteApiOauthCallback
     */
    readonly scope?: string
}

/**
 * Request parameters for tagSuggest operation in AutocompleteApi.
 * @export
 * @interface AutocompleteApiTagSuggestRequest
 */
export interface AutocompleteApiTagSuggestRequest {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteApiTagSuggest
     */
    readonly accountId: string

    /**
     * 
     * @type {string}
     * @memberof AutocompleteApiTagSuggest
     */
    readonly chatId: string

    /**
     * 
     * @type {boolean}
     * @memberof AutocompleteApiTagSuggest
     */
    readonly isCustomField?: boolean
}

/**
 * AutocompleteApi - object-oriented interface
 * @export
 * @class AutocompleteApi
 * @extends {BaseAPI}
 */
export class AutocompleteApi extends BaseAPI {
    /**
     * 
     * @summary Extract calendar event information from message
     * @param {AutocompleteApiAutocompleteCalendarEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public autocompleteCalendarEvent(requestParameters: AutocompleteApiAutocompleteCalendarEventRequest = {}, options?: RawAxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).autocompleteCalendarEvent(requestParameters.autocompleteCalendarEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns autocomplete suggestions for a chat
     * @param {AutocompleteApiAutocompleteInboxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public autocompleteInbox(requestParameters: AutocompleteApiAutocompleteInboxRequest, options?: RawAxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).autocompleteInbox(requestParameters.accountId, requestParameters.chatId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Apply some modification to the given text
     * @param {AutocompleteApiAutocompleteModifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public autocompleteModify(requestParameters: AutocompleteApiAutocompleteModifyRequest, options?: RawAxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).autocompleteModify(requestParameters.modifier, requestParameters.autocompleteModifyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary OAuth callback
     * @param {AutocompleteApiOauthCallbackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public oauthCallback(requestParameters: AutocompleteApiOauthCallbackRequest, options?: RawAxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).oauthCallback(requestParameters.code, requestParameters.state, requestParameters.scope, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a suggested tag name
     * @param {AutocompleteApiTagSuggestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public tagSuggest(requestParameters: AutocompleteApiTagSuggestRequest, options?: RawAxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).tagSuggest(requestParameters.accountId, requestParameters.chatId, requestParameters.isCustomField, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChatbotApi - axios parameter creator
 * @export
 */
export const ChatbotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Refresh Chatbot data
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatbotRefresh: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('chatbotRefresh', 'id', id)
            const localVarPath = `/chatbot/{id}/refresh`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a chatbot
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBot: async (body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chatbots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a chatbot
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBot: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBot', 'id', id)
            const localVarPath = `/chatbots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user\'s chatbots
         * @param {Array<string>} [id] Find the chatbots with the given ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBots: async (id?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chatbots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)

            if (id) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start an extraction or crawling job
         * @param {string} id ID of the chatbot
         * @param {JobType} type Type of data to be added
         * @param {StartJobRequest} [startJobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobStart: async (id: string, type: JobType, startJobRequest?: StartJobRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobStart', 'id', id)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('jobStart', 'type', type)
            const localVarPath = `/chatbot/{id}/jobs/{type}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startJobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send a message to an LLM
         * @param {LlmChatRequest} llmChatRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        llmChat: async (llmChatRequest: LlmChatRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'llmChatRequest' is not null or undefined
            assertParamExists('llmChat', 'llmChatRequest', llmChatRequest)
            const localVarPath = `/llm-chat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(llmChatRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send message to the chatbot
         * @param {string} id ID of the chatbot
         * @param {ChatbotMessageRequest} [chatbotMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageBot: async (id: string, chatbotMessageRequest?: ChatbotMessageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('messageBot', 'id', id)
            const localVarPath = `/chatbot/{id}/message`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatbotMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start training the chatbot
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainChatbot: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainChatbot', 'id', id)
            const localVarPath = `/chatbot/{id}/train`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update chatbot
         * @param {string} id ID of the chatbot
         * @param {UpdateChatbotRequest} [updateChatbotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBot: async (id: string, updateChatbotRequest?: UpdateChatbotRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBot', 'id', id)
            const localVarPath = `/chatbots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateChatbotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatbotApi - functional programming interface
 * @export
 */
export const ChatbotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatbotApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Refresh Chatbot data
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatbotRefresh(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chatbot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatbotRefresh(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotApi.chatbotRefresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a chatbot
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBot(body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateChatbotResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBot(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotApi.createBot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary delete a chatbot
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBot(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBot(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotApi.deleteBot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user\'s chatbots
         * @param {Array<string>} [id] Find the chatbots with the given ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBots(id?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChatbotsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBots(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotApi.getBots']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Start an extraction or crawling job
         * @param {string} id ID of the chatbot
         * @param {JobType} type Type of data to be added
         * @param {StartJobRequest} [startJobRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobStart(id: string, type: JobType, startJobRequest?: StartJobRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartJobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobStart(id, type, startJobRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotApi.jobStart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send a message to an LLM
         * @param {LlmChatRequest} llmChatRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async llmChat(llmChatRequest: LlmChatRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LlmChat200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.llmChat(llmChatRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotApi.llmChat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send message to the chatbot
         * @param {string} id ID of the chatbot
         * @param {ChatbotMessageRequest} [chatbotMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageBot(id: string, chatbotMessageRequest?: ChatbotMessageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatbotMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messageBot(id, chatbotMessageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotApi.messageBot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Start training the chatbot
         * @param {string} id ID of the chatbot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainChatbot(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainChatbot(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotApi.trainChatbot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update chatbot
         * @param {string} id ID of the chatbot
         * @param {UpdateChatbotRequest} [updateChatbotRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBot(id: string, updateChatbotRequest?: UpdateChatbotRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBot(id, updateChatbotRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatbotApi.updateBot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatbotApi - factory interface
 * @export
 */
export const ChatbotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatbotApiFp(configuration)
    return {
        /**
         * 
         * @summary Refresh Chatbot data
         * @param {ChatbotApiChatbotRefreshRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatbotRefresh(requestParameters: ChatbotApiChatbotRefreshRequest, options?: RawAxiosRequestConfig): AxiosPromise<Chatbot> {
            return localVarFp.chatbotRefresh(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a chatbot
         * @param {ChatbotApiCreateBotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBot(requestParameters: ChatbotApiCreateBotRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CreateChatbotResponse> {
            return localVarFp.createBot(requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete a chatbot
         * @param {ChatbotApiDeleteBotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBot(requestParameters: ChatbotApiDeleteBotRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteBot(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user\'s chatbots
         * @param {ChatbotApiGetBotsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBots(requestParameters: ChatbotApiGetBotsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetChatbotsResponse> {
            return localVarFp.getBots(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start an extraction or crawling job
         * @param {ChatbotApiJobStartRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobStart(requestParameters: ChatbotApiJobStartRequest, options?: RawAxiosRequestConfig): AxiosPromise<StartJobResponse> {
            return localVarFp.jobStart(requestParameters.id, requestParameters.type, requestParameters.startJobRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send a message to an LLM
         * @param {ChatbotApiLlmChatRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        llmChat(requestParameters: ChatbotApiLlmChatRequest, options?: RawAxiosRequestConfig): AxiosPromise<LlmChat200Response> {
            return localVarFp.llmChat(requestParameters.llmChatRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send message to the chatbot
         * @param {ChatbotApiMessageBotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageBot(requestParameters: ChatbotApiMessageBotRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatbotMessageResponse> {
            return localVarFp.messageBot(requestParameters.id, requestParameters.chatbotMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start training the chatbot
         * @param {ChatbotApiTrainChatbotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainChatbot(requestParameters: ChatbotApiTrainChatbotRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.trainChatbot(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update chatbot
         * @param {ChatbotApiUpdateBotRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBot(requestParameters: ChatbotApiUpdateBotRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateBot(requestParameters.id, requestParameters.updateChatbotRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for chatbotRefresh operation in ChatbotApi.
 * @export
 * @interface ChatbotApiChatbotRefreshRequest
 */
export interface ChatbotApiChatbotRefreshRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof ChatbotApiChatbotRefresh
     */
    readonly id: string
}

/**
 * Request parameters for createBot operation in ChatbotApi.
 * @export
 * @interface ChatbotApiCreateBotRequest
 */
export interface ChatbotApiCreateBotRequest {
    /**
     * 
     * @type {object}
     * @memberof ChatbotApiCreateBot
     */
    readonly body?: object
}

/**
 * Request parameters for deleteBot operation in ChatbotApi.
 * @export
 * @interface ChatbotApiDeleteBotRequest
 */
export interface ChatbotApiDeleteBotRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof ChatbotApiDeleteBot
     */
    readonly id: string
}

/**
 * Request parameters for getBots operation in ChatbotApi.
 * @export
 * @interface ChatbotApiGetBotsRequest
 */
export interface ChatbotApiGetBotsRequest {
    /**
     * Find the chatbots with the given ids
     * @type {Array<string>}
     * @memberof ChatbotApiGetBots
     */
    readonly id?: Array<string>
}

/**
 * Request parameters for jobStart operation in ChatbotApi.
 * @export
 * @interface ChatbotApiJobStartRequest
 */
export interface ChatbotApiJobStartRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof ChatbotApiJobStart
     */
    readonly id: string

    /**
     * Type of data to be added
     * @type {JobType}
     * @memberof ChatbotApiJobStart
     */
    readonly type: JobType

    /**
     * 
     * @type {StartJobRequest}
     * @memberof ChatbotApiJobStart
     */
    readonly startJobRequest?: StartJobRequest
}

/**
 * Request parameters for llmChat operation in ChatbotApi.
 * @export
 * @interface ChatbotApiLlmChatRequest
 */
export interface ChatbotApiLlmChatRequest {
    /**
     * 
     * @type {LlmChatRequest}
     * @memberof ChatbotApiLlmChat
     */
    readonly llmChatRequest: LlmChatRequest
}

/**
 * Request parameters for messageBot operation in ChatbotApi.
 * @export
 * @interface ChatbotApiMessageBotRequest
 */
export interface ChatbotApiMessageBotRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof ChatbotApiMessageBot
     */
    readonly id: string

    /**
     * 
     * @type {ChatbotMessageRequest}
     * @memberof ChatbotApiMessageBot
     */
    readonly chatbotMessageRequest?: ChatbotMessageRequest
}

/**
 * Request parameters for trainChatbot operation in ChatbotApi.
 * @export
 * @interface ChatbotApiTrainChatbotRequest
 */
export interface ChatbotApiTrainChatbotRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof ChatbotApiTrainChatbot
     */
    readonly id: string
}

/**
 * Request parameters for updateBot operation in ChatbotApi.
 * @export
 * @interface ChatbotApiUpdateBotRequest
 */
export interface ChatbotApiUpdateBotRequest {
    /**
     * ID of the chatbot
     * @type {string}
     * @memberof ChatbotApiUpdateBot
     */
    readonly id: string

    /**
     * 
     * @type {UpdateChatbotRequest}
     * @memberof ChatbotApiUpdateBot
     */
    readonly updateChatbotRequest?: UpdateChatbotRequest
}

/**
 * ChatbotApi - object-oriented interface
 * @export
 * @class ChatbotApi
 * @extends {BaseAPI}
 */
export class ChatbotApi extends BaseAPI {
    /**
     * 
     * @summary Refresh Chatbot data
     * @param {ChatbotApiChatbotRefreshRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public chatbotRefresh(requestParameters: ChatbotApiChatbotRefreshRequest, options?: RawAxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).chatbotRefresh(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a chatbot
     * @param {ChatbotApiCreateBotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public createBot(requestParameters: ChatbotApiCreateBotRequest = {}, options?: RawAxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).createBot(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete a chatbot
     * @param {ChatbotApiDeleteBotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public deleteBot(requestParameters: ChatbotApiDeleteBotRequest, options?: RawAxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).deleteBot(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user\'s chatbots
     * @param {ChatbotApiGetBotsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public getBots(requestParameters: ChatbotApiGetBotsRequest = {}, options?: RawAxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).getBots(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start an extraction or crawling job
     * @param {ChatbotApiJobStartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public jobStart(requestParameters: ChatbotApiJobStartRequest, options?: RawAxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).jobStart(requestParameters.id, requestParameters.type, requestParameters.startJobRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send a message to an LLM
     * @param {ChatbotApiLlmChatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public llmChat(requestParameters: ChatbotApiLlmChatRequest, options?: RawAxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).llmChat(requestParameters.llmChatRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send message to the chatbot
     * @param {ChatbotApiMessageBotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public messageBot(requestParameters: ChatbotApiMessageBotRequest, options?: RawAxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).messageBot(requestParameters.id, requestParameters.chatbotMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start training the chatbot
     * @param {ChatbotApiTrainChatbotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public trainChatbot(requestParameters: ChatbotApiTrainChatbotRequest, options?: RawAxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).trainChatbot(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update chatbot
     * @param {ChatbotApiUpdateBotRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatbotApi
     */
    public updateBot(requestParameters: ChatbotApiUpdateBotRequest, options?: RawAxiosRequestConfig) {
        return ChatbotApiFp(this.configuration).updateBot(requestParameters.id, requestParameters.updateChatbotRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KeywordsApi - axios parameter creator
 * @export
 */
export const KeywordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new Keyword Based Action
         * @param {Array<KeywordActionCreateRequestObj>} keywordActionCreateRequestObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrigger: async (keywordActionCreateRequestObj: Array<KeywordActionCreateRequestObj>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keywordActionCreateRequestObj' is not null or undefined
            assertParamExists('createTrigger', 'keywordActionCreateRequestObj', keywordActionCreateRequestObj)
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["KEYWORD_CREATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keywordActionCreateRequestObj, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Keyword Based Action
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTriggers: async (ids: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteTriggers', 'ids', ids)
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["KEYWORD_DELETE"], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit Keyword Based Action
         * @param {Array<KeywordActionEditRequestObj>} keywordActionEditRequestObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTrigger: async (keywordActionEditRequestObj: Array<KeywordActionEditRequestObj>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keywordActionEditRequestObj' is not null or undefined
            assertParamExists('editTrigger', 'keywordActionEditRequestObj', keywordActionEditRequestObj)
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["KEYWORD_UPDATE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keywordActionEditRequestObj, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the trigger log of the keyword reply.
         * @param {string} id 
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalTriggered] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionRecord: async (id: string, count?: number, cursor?: string, returnTotalTriggered?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getExecutionRecord', 'id', id)
            const localVarPath = `/log/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["KEYWORD_READ"], configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (returnTotalTriggered !== undefined) {
                localVarQueryParameter['returnTotalTriggered'] = returnTotalTriggered;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query for user\'s Keyword Actions
         * @param {string} [q] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {TriggerType} [triggerType] Query keywords with the specific trigger type
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggers: async (q?: string, count?: number, id?: Array<string>, triggerType?: TriggerType, cursor?: string, returnTotalCount?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["KEYWORD_READ"], configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (triggerType !== undefined) {
                localVarQueryParameter['triggerType'] = triggerType;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (returnTotalCount !== undefined) {
                localVarQueryParameter['returnTotalCount'] = returnTotalCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeywordsApi - functional programming interface
 * @export
 */
export const KeywordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KeywordsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new Keyword Based Action
         * @param {Array<KeywordActionCreateRequestObj>} keywordActionCreateRequestObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTrigger(keywordActionCreateRequestObj: Array<KeywordActionCreateRequestObj>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KeywordBasedAction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrigger(keywordActionCreateRequestObj, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordsApi.createTrigger']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Keyword Based Action
         * @param {Array<string>} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTriggers(ids: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteTriggers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTriggers(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordsApi.deleteTriggers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit Keyword Based Action
         * @param {Array<KeywordActionEditRequestObj>} keywordActionEditRequestObj 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editTrigger(keywordActionEditRequestObj: Array<KeywordActionEditRequestObj>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KeywordBasedAction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editTrigger(keywordActionEditRequestObj, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordsApi.editTrigger']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the trigger log of the keyword reply.
         * @param {string} id 
         * @param {number} [count] 
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalTriggered] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExecutionRecord(id: string, count?: number, cursor?: string, returnTotalTriggered?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetExecutionRecord200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExecutionRecord(id, count, cursor, returnTotalTriggered, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordsApi.getExecutionRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Query for user\'s Keyword Actions
         * @param {string} [q] 
         * @param {number} [count] 
         * @param {Array<string>} [id] 
         * @param {TriggerType} [triggerType] Query keywords with the specific trigger type
         * @param {string} [cursor] 
         * @param {boolean} [returnTotalCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTriggers(q?: string, count?: number, id?: Array<string>, triggerType?: TriggerType, cursor?: string, returnTotalCount?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTriggers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTriggers(q, count, id, triggerType, cursor, returnTotalCount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordsApi.getTriggers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KeywordsApi - factory interface
 * @export
 */
export const KeywordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KeywordsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new Keyword Based Action
         * @param {KeywordsApiCreateTriggerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTrigger(requestParameters: KeywordsApiCreateTriggerRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<KeywordBasedAction>> {
            return localVarFp.createTrigger(requestParameters.keywordActionCreateRequestObj, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Keyword Based Action
         * @param {KeywordsApiDeleteTriggersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTriggers(requestParameters: KeywordsApiDeleteTriggersRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteTriggers200Response> {
            return localVarFp.deleteTriggers(requestParameters.ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit Keyword Based Action
         * @param {KeywordsApiEditTriggerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editTrigger(requestParameters: KeywordsApiEditTriggerRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<KeywordBasedAction>> {
            return localVarFp.editTrigger(requestParameters.keywordActionEditRequestObj, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the trigger log of the keyword reply.
         * @param {KeywordsApiGetExecutionRecordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExecutionRecord(requestParameters: KeywordsApiGetExecutionRecordRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetExecutionRecord200Response> {
            return localVarFp.getExecutionRecord(requestParameters.id, requestParameters.count, requestParameters.cursor, requestParameters.returnTotalTriggered, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query for user\'s Keyword Actions
         * @param {KeywordsApiGetTriggersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTriggers(requestParameters: KeywordsApiGetTriggersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetTriggers200Response> {
            return localVarFp.getTriggers(requestParameters.q, requestParameters.count, requestParameters.id, requestParameters.triggerType, requestParameters.cursor, requestParameters.returnTotalCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createTrigger operation in KeywordsApi.
 * @export
 * @interface KeywordsApiCreateTriggerRequest
 */
export interface KeywordsApiCreateTriggerRequest {
    /**
     * 
     * @type {Array<KeywordActionCreateRequestObj>}
     * @memberof KeywordsApiCreateTrigger
     */
    readonly keywordActionCreateRequestObj: Array<KeywordActionCreateRequestObj>
}

/**
 * Request parameters for deleteTriggers operation in KeywordsApi.
 * @export
 * @interface KeywordsApiDeleteTriggersRequest
 */
export interface KeywordsApiDeleteTriggersRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof KeywordsApiDeleteTriggers
     */
    readonly ids: Array<string>
}

/**
 * Request parameters for editTrigger operation in KeywordsApi.
 * @export
 * @interface KeywordsApiEditTriggerRequest
 */
export interface KeywordsApiEditTriggerRequest {
    /**
     * 
     * @type {Array<KeywordActionEditRequestObj>}
     * @memberof KeywordsApiEditTrigger
     */
    readonly keywordActionEditRequestObj: Array<KeywordActionEditRequestObj>
}

/**
 * Request parameters for getExecutionRecord operation in KeywordsApi.
 * @export
 * @interface KeywordsApiGetExecutionRecordRequest
 */
export interface KeywordsApiGetExecutionRecordRequest {
    /**
     * 
     * @type {string}
     * @memberof KeywordsApiGetExecutionRecord
     */
    readonly id: string

    /**
     * 
     * @type {number}
     * @memberof KeywordsApiGetExecutionRecord
     */
    readonly count?: number

    /**
     * 
     * @type {string}
     * @memberof KeywordsApiGetExecutionRecord
     */
    readonly cursor?: string

    /**
     * 
     * @type {boolean}
     * @memberof KeywordsApiGetExecutionRecord
     */
    readonly returnTotalTriggered?: boolean
}

/**
 * Request parameters for getTriggers operation in KeywordsApi.
 * @export
 * @interface KeywordsApiGetTriggersRequest
 */
export interface KeywordsApiGetTriggersRequest {
    /**
     * 
     * @type {string}
     * @memberof KeywordsApiGetTriggers
     */
    readonly q?: string

    /**
     * 
     * @type {number}
     * @memberof KeywordsApiGetTriggers
     */
    readonly count?: number

    /**
     * 
     * @type {Array<string>}
     * @memberof KeywordsApiGetTriggers
     */
    readonly id?: Array<string>

    /**
     * Query keywords with the specific trigger type
     * @type {TriggerType}
     * @memberof KeywordsApiGetTriggers
     */
    readonly triggerType?: TriggerType

    /**
     * 
     * @type {string}
     * @memberof KeywordsApiGetTriggers
     */
    readonly cursor?: string

    /**
     * 
     * @type {boolean}
     * @memberof KeywordsApiGetTriggers
     */
    readonly returnTotalCount?: boolean
}

/**
 * KeywordsApi - object-oriented interface
 * @export
 * @class KeywordsApi
 * @extends {BaseAPI}
 */
export class KeywordsApi extends BaseAPI {
    /**
     * 
     * @summary Create new Keyword Based Action
     * @param {KeywordsApiCreateTriggerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public createTrigger(requestParameters: KeywordsApiCreateTriggerRequest, options?: RawAxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).createTrigger(requestParameters.keywordActionCreateRequestObj, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Keyword Based Action
     * @param {KeywordsApiDeleteTriggersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public deleteTriggers(requestParameters: KeywordsApiDeleteTriggersRequest, options?: RawAxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).deleteTriggers(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit Keyword Based Action
     * @param {KeywordsApiEditTriggerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public editTrigger(requestParameters: KeywordsApiEditTriggerRequest, options?: RawAxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).editTrigger(requestParameters.keywordActionEditRequestObj, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the trigger log of the keyword reply.
     * @param {KeywordsApiGetExecutionRecordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public getExecutionRecord(requestParameters: KeywordsApiGetExecutionRecordRequest, options?: RawAxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).getExecutionRecord(requestParameters.id, requestParameters.count, requestParameters.cursor, requestParameters.returnTotalTriggered, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query for user\'s Keyword Actions
     * @param {KeywordsApiGetTriggersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public getTriggers(requestParameters: KeywordsApiGetTriggersRequest = {}, options?: RawAxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).getTriggers(requestParameters.q, requestParameters.count, requestParameters.id, requestParameters.triggerType, requestParameters.cursor, requestParameters.returnTotalCount, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KnowledgebaseApi - axios parameter creator
 * @export
 */
export const KnowledgebaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a source to the knowledge base
         * @param {string} id 
         * @param {AddSourceRequest} addSourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSource: async (id: string, addSourceRequest: AddSourceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addSource', 'id', id)
            // verify required parameter 'addSourceRequest' is not null or undefined
            assertParamExists('addSource', 'addSourceRequest', addSourceRequest)
            const localVarPath = `/knowledge-base/{id}/sources`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addSourceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a knowledge base
         * @param {UpsertKnowledgeBase} upsertKnowledgeBase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKnowledgeBase: async (upsertKnowledgeBase: UpsertKnowledgeBase, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upsertKnowledgeBase' is not null or undefined
            assertParamExists('createKnowledgeBase', 'upsertKnowledgeBase', upsertKnowledgeBase)
            const localVarPath = `/knowledge-base`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertKnowledgeBase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a knowledge base
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKnowledgeBase: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteKnowledgeBase', 'id', id)
            const localVarPath = `/knowledge-base/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a source from the knowledge base
         * @param {string} baseId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: async (baseId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseId' is not null or undefined
            assertParamExists('deleteSource', 'baseId', baseId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSource', 'id', id)
            const localVarPath = `/knowledge-base/{baseId}/sources/{id}`
                .replace(`{${"baseId"}}`, encodeURIComponent(String(baseId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all knowledge bases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKnowledgeBases: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/knowledge-base`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all sources in a knowledge base
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSources: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSources', 'id', id)
            const localVarPath = `/knowledge-base/{id}/sources`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the name of a knowledge base
         * @param {string} id 
         * @param {UpsertKnowledgeBase} upsertKnowledgeBase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKnowledgeBase: async (id: string, upsertKnowledgeBase: UpsertKnowledgeBase, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateKnowledgeBase', 'id', id)
            // verify required parameter 'upsertKnowledgeBase' is not null or undefined
            assertParamExists('updateKnowledgeBase', 'upsertKnowledgeBase', upsertKnowledgeBase)
            const localVarPath = `/knowledge-base/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication chatdaddy required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "chatdaddy", ["AUTOCOMPLETE_GET"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertKnowledgeBase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KnowledgebaseApi - functional programming interface
 * @export
 */
export const KnowledgebaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KnowledgebaseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a source to the knowledge base
         * @param {string} id 
         * @param {AddSourceRequest} addSourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSource(id: string, addSourceRequest: AddSourceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KnowledgeBaseSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSource(id, addSourceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgebaseApi.addSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a knowledge base
         * @param {UpsertKnowledgeBase} upsertKnowledgeBase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKnowledgeBase(upsertKnowledgeBase: UpsertKnowledgeBase, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KnowledgeBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKnowledgeBase(upsertKnowledgeBase, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgebaseApi.createKnowledgeBase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a knowledge base
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKnowledgeBase(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKnowledgeBase(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgebaseApi.deleteKnowledgeBase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a source from the knowledge base
         * @param {string} baseId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSource(baseId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSource(baseId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgebaseApi.deleteSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all knowledge bases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKnowledgeBases(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetKnowledgeBases200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKnowledgeBases(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgebaseApi.getKnowledgeBases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all sources in a knowledge base
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSources(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSources200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSources(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgebaseApi.getSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the name of a knowledge base
         * @param {string} id 
         * @param {UpsertKnowledgeBase} upsertKnowledgeBase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKnowledgeBase(id: string, upsertKnowledgeBase: UpsertKnowledgeBase, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKnowledgeBase(id, upsertKnowledgeBase, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgebaseApi.updateKnowledgeBase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KnowledgebaseApi - factory interface
 * @export
 */
export const KnowledgebaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KnowledgebaseApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a source to the knowledge base
         * @param {KnowledgebaseApiAddSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSource(requestParameters: KnowledgebaseApiAddSourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<KnowledgeBaseSource> {
            return localVarFp.addSource(requestParameters.id, requestParameters.addSourceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a knowledge base
         * @param {KnowledgebaseApiCreateKnowledgeBaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKnowledgeBase(requestParameters: KnowledgebaseApiCreateKnowledgeBaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<KnowledgeBase> {
            return localVarFp.createKnowledgeBase(requestParameters.upsertKnowledgeBase, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a knowledge base
         * @param {KnowledgebaseApiDeleteKnowledgeBaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKnowledgeBase(requestParameters: KnowledgebaseApiDeleteKnowledgeBaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteKnowledgeBase(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a source from the knowledge base
         * @param {KnowledgebaseApiDeleteSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(requestParameters: KnowledgebaseApiDeleteSourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSource(requestParameters.baseId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all knowledge bases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKnowledgeBases(options?: RawAxiosRequestConfig): AxiosPromise<GetKnowledgeBases200Response> {
            return localVarFp.getKnowledgeBases(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all sources in a knowledge base
         * @param {KnowledgebaseApiGetSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSources(requestParameters: KnowledgebaseApiGetSourcesRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetSources200Response> {
            return localVarFp.getSources(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the name of a knowledge base
         * @param {KnowledgebaseApiUpdateKnowledgeBaseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKnowledgeBase(requestParameters: KnowledgebaseApiUpdateKnowledgeBaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateKnowledgeBase(requestParameters.id, requestParameters.upsertKnowledgeBase, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addSource operation in KnowledgebaseApi.
 * @export
 * @interface KnowledgebaseApiAddSourceRequest
 */
export interface KnowledgebaseApiAddSourceRequest {
    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiAddSource
     */
    readonly id: string

    /**
     * 
     * @type {AddSourceRequest}
     * @memberof KnowledgebaseApiAddSource
     */
    readonly addSourceRequest: AddSourceRequest
}

/**
 * Request parameters for createKnowledgeBase operation in KnowledgebaseApi.
 * @export
 * @interface KnowledgebaseApiCreateKnowledgeBaseRequest
 */
export interface KnowledgebaseApiCreateKnowledgeBaseRequest {
    /**
     * 
     * @type {UpsertKnowledgeBase}
     * @memberof KnowledgebaseApiCreateKnowledgeBase
     */
    readonly upsertKnowledgeBase: UpsertKnowledgeBase
}

/**
 * Request parameters for deleteKnowledgeBase operation in KnowledgebaseApi.
 * @export
 * @interface KnowledgebaseApiDeleteKnowledgeBaseRequest
 */
export interface KnowledgebaseApiDeleteKnowledgeBaseRequest {
    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiDeleteKnowledgeBase
     */
    readonly id: string
}

/**
 * Request parameters for deleteSource operation in KnowledgebaseApi.
 * @export
 * @interface KnowledgebaseApiDeleteSourceRequest
 */
export interface KnowledgebaseApiDeleteSourceRequest {
    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiDeleteSource
     */
    readonly baseId: string

    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiDeleteSource
     */
    readonly id: string
}

/**
 * Request parameters for getSources operation in KnowledgebaseApi.
 * @export
 * @interface KnowledgebaseApiGetSourcesRequest
 */
export interface KnowledgebaseApiGetSourcesRequest {
    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiGetSources
     */
    readonly id: string
}

/**
 * Request parameters for updateKnowledgeBase operation in KnowledgebaseApi.
 * @export
 * @interface KnowledgebaseApiUpdateKnowledgeBaseRequest
 */
export interface KnowledgebaseApiUpdateKnowledgeBaseRequest {
    /**
     * 
     * @type {string}
     * @memberof KnowledgebaseApiUpdateKnowledgeBase
     */
    readonly id: string

    /**
     * 
     * @type {UpsertKnowledgeBase}
     * @memberof KnowledgebaseApiUpdateKnowledgeBase
     */
    readonly upsertKnowledgeBase: UpsertKnowledgeBase
}

/**
 * KnowledgebaseApi - object-oriented interface
 * @export
 * @class KnowledgebaseApi
 * @extends {BaseAPI}
 */
export class KnowledgebaseApi extends BaseAPI {
    /**
     * 
     * @summary Add a source to the knowledge base
     * @param {KnowledgebaseApiAddSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgebaseApi
     */
    public addSource(requestParameters: KnowledgebaseApiAddSourceRequest, options?: RawAxiosRequestConfig) {
        return KnowledgebaseApiFp(this.configuration).addSource(requestParameters.id, requestParameters.addSourceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a knowledge base
     * @param {KnowledgebaseApiCreateKnowledgeBaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgebaseApi
     */
    public createKnowledgeBase(requestParameters: KnowledgebaseApiCreateKnowledgeBaseRequest, options?: RawAxiosRequestConfig) {
        return KnowledgebaseApiFp(this.configuration).createKnowledgeBase(requestParameters.upsertKnowledgeBase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a knowledge base
     * @param {KnowledgebaseApiDeleteKnowledgeBaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgebaseApi
     */
    public deleteKnowledgeBase(requestParameters: KnowledgebaseApiDeleteKnowledgeBaseRequest, options?: RawAxiosRequestConfig) {
        return KnowledgebaseApiFp(this.configuration).deleteKnowledgeBase(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a source from the knowledge base
     * @param {KnowledgebaseApiDeleteSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgebaseApi
     */
    public deleteSource(requestParameters: KnowledgebaseApiDeleteSourceRequest, options?: RawAxiosRequestConfig) {
        return KnowledgebaseApiFp(this.configuration).deleteSource(requestParameters.baseId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all knowledge bases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgebaseApi
     */
    public getKnowledgeBases(options?: RawAxiosRequestConfig) {
        return KnowledgebaseApiFp(this.configuration).getKnowledgeBases(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all sources in a knowledge base
     * @param {KnowledgebaseApiGetSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgebaseApi
     */
    public getSources(requestParameters: KnowledgebaseApiGetSourcesRequest, options?: RawAxiosRequestConfig) {
        return KnowledgebaseApiFp(this.configuration).getSources(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the name of a knowledge base
     * @param {KnowledgebaseApiUpdateKnowledgeBaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgebaseApi
     */
    public updateKnowledgeBase(requestParameters: KnowledgebaseApiUpdateKnowledgeBaseRequest, options?: RawAxiosRequestConfig) {
        return KnowledgebaseApiFp(this.configuration).updateKnowledgeBase(requestParameters.id, requestParameters.upsertKnowledgeBase, options).then((request) => request(this.axios, this.basePath));
    }
}



